(()=>{var __webpack_modules__={28:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var iterate    = __webpack_require__(8051)\n  , initState  = __webpack_require__(9500)\n  , terminator = __webpack_require__(6276)\n  ;\n\n// Public API\nmodule.exports = serialOrdered;\n// sorting helpers\nmodule.exports.ascending  = ascending;\nmodule.exports.descending = descending;\n\n/**\n * Runs iterator over provided sorted array elements in series\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} sortMethod - custom sort function\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction serialOrdered(list, iterator, sortMethod, callback)\n{\n  var state = initState(list, sortMethod);\n\n  iterate(list, iterator, state, function iteratorHandler(error, result)\n  {\n    if (error)\n    {\n      callback(error, result);\n      return;\n    }\n\n    state.index++;\n\n    // are we there yet?\n    if (state.index < (state['keyedList'] || list).length)\n    {\n      iterate(list, iterator, state, iteratorHandler);\n      return;\n    }\n\n    // done here\n    callback(null, state.results);\n  });\n\n  return terminator.bind(state, callback);\n}\n\n/*\n * -- Sort methods\n */\n\n/**\n * sort helper to sort array elements in ascending order\n *\n * @param   {mixed} a - an item to compare\n * @param   {mixed} b - an item to compare\n * @returns {number} - comparison result\n */\nfunction ascending(a, b)\n{\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\n/**\n * sort helper to sort array elements in descending order\n *\n * @param   {mixed} a - an item to compare\n * @param   {mixed} b - an item to compare\n * @returns {number} - comparison result\n */\nfunction descending(a, b)\n{\n  return -1 * ascending(a, b);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsSUFBa0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsSUFBZ0I7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsSUFBcUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvc2VyaWFsT3JkZXJlZC5qcz9mZTdhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpdGVyYXRlICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0ZS5qcycpXG4gICwgaW5pdFN0YXRlICA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLmpzJylcbiAgLCB0ZXJtaW5hdG9yID0gcmVxdWlyZSgnLi9saWIvdGVybWluYXRvci5qcycpXG4gIDtcblxuLy8gUHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBzZXJpYWxPcmRlcmVkO1xuLy8gc29ydGluZyBoZWxwZXJzXG5tb2R1bGUuZXhwb3J0cy5hc2NlbmRpbmcgID0gYXNjZW5kaW5nO1xubW9kdWxlLmV4cG9ydHMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG5cbi8qKlxuICogUnVucyBpdGVyYXRvciBvdmVyIHByb3ZpZGVkIHNvcnRlZCBhcnJheSBlbGVtZW50cyBpbiBzZXJpZXNcbiAqXG4gKiBAcGFyYW0gICB7YXJyYXl8b2JqZWN0fSBsaXN0IC0gYXJyYXkgb3Igb2JqZWN0IChuYW1lZCBsaXN0KSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBpdGVyYXRvciB0byBydW5cbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gc29ydE1ldGhvZCAtIGN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaW52b2tlZCB3aGVuIGFsbCBlbGVtZW50cyBwcm9jZXNzZWRcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBqb2JzIHRlcm1pbmF0b3JcbiAqL1xuZnVuY3Rpb24gc2VyaWFsT3JkZXJlZChsaXN0LCBpdGVyYXRvciwgc29ydE1ldGhvZCwgY2FsbGJhY2spXG57XG4gIHZhciBzdGF0ZSA9IGluaXRTdGF0ZShsaXN0LCBzb3J0TWV0aG9kKTtcblxuICBpdGVyYXRlKGxpc3QsIGl0ZXJhdG9yLCBzdGF0ZSwgZnVuY3Rpb24gaXRlcmF0b3JIYW5kbGVyKGVycm9yLCByZXN1bHQpXG4gIHtcbiAgICBpZiAoZXJyb3IpXG4gICAge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuaW5kZXgrKztcblxuICAgIC8vIGFyZSB3ZSB0aGVyZSB5ZXQ/XG4gICAgaWYgKHN0YXRlLmluZGV4IDwgKHN0YXRlWydrZXllZExpc3QnXSB8fCBsaXN0KS5sZW5ndGgpXG4gICAge1xuICAgICAgaXRlcmF0ZShsaXN0LCBpdGVyYXRvciwgc3RhdGUsIGl0ZXJhdG9ySGFuZGxlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZG9uZSBoZXJlXG4gICAgY2FsbGJhY2sobnVsbCwgc3RhdGUucmVzdWx0cyk7XG4gIH0pO1xuXG4gIHJldHVybiB0ZXJtaW5hdG9yLmJpbmQoc3RhdGUsIGNhbGxiYWNrKTtcbn1cblxuLypcbiAqIC0tIFNvcnQgbWV0aG9kc1xuICovXG5cbi8qKlxuICogc29ydCBoZWxwZXIgdG8gc29ydCBhcnJheSBlbGVtZW50cyBpbiBhc2NlbmRpbmcgb3JkZXJcbiAqXG4gKiBAcGFyYW0gICB7bWl4ZWR9IGEgLSBhbiBpdGVtIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSAgIHttaXhlZH0gYiAtIGFuIGl0ZW0gdG8gY29tcGFyZVxuICogQHJldHVybnMge251bWJlcn0gLSBjb21wYXJpc29uIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYilcbntcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG4vKipcbiAqIHNvcnQgaGVscGVyIHRvIHNvcnQgYXJyYXkgZWxlbWVudHMgaW4gZGVzY2VuZGluZyBvcmRlclxuICpcbiAqIEBwYXJhbSAgIHttaXhlZH0gYSAtIGFuIGl0ZW0gdG8gY29tcGFyZVxuICogQHBhcmFtICAge21peGVkfSBiIC0gYW4gaXRlbSB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIGNvbXBhcmlzb24gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYilcbntcbiAgcmV0dXJuIC0xICogYXNjZW5kaW5nKGEsIGIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n")},56:n=>{"use strict";n.exports=JSON.parse('{"name":"dotenv","version":"16.5.0","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}')},76:module=>{"use strict";eval("\n\n/** @type {import('./functionCall')} */\nmodule.exports = Function.prototype.call;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVywwQkFBMEI7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQtYXBwbHktaGVscGVycy9mdW5jdGlvbkNhbGwuanM/OTI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2Z1bmN0aW9uQ2FsbCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///76\n")},144:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxJQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcz82MWJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zLCB0aHJvd0Vycm9ycyA9IGZhbHNlKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKCF0aHJvd0Vycm9ycykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhyb3cgZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///144\n")},181:n=>{"use strict";n.exports=require("buffer")},270:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst Range = __webpack_require__(8311)\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcwLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxJQUFtQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsSUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcz9jYTBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IG1pblNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cbm1vZHVsZS5leHBvcnRzID0gbWluU2F0aXNmeWluZ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///270\n")},405:module=>{eval("module.exports = defer;\n\n/**\n * Runs provided function on next iteration of the event loop\n *\n * @param {function} fn - function to run\n */\nfunction defer(fn)\n{\n  var nextTick = typeof setImmediate == 'function'\n    ? setImmediate\n    : (\n      typeof process == 'object' && typeof process.nextTick == 'function'\n      ? process.nextTick\n      : null\n    );\n\n  if (nextTick)\n  {\n    nextTick(fn);\n  }\n  else\n  {\n    setTimeout(fn, 0);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA1LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9saWIvZGVmZXIuanM/OTJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGRlZmVyO1xuXG4vKipcbiAqIFJ1bnMgcHJvdmlkZWQgZnVuY3Rpb24gb24gbmV4dCBpdGVyYXRpb24gb2YgdGhlIGV2ZW50IGxvb3BcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIGZ1bmN0aW9uIHRvIHJ1blxuICovXG5mdW5jdGlvbiBkZWZlcihmbilcbntcbiAgdmFyIG5leHRUaWNrID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PSAnZnVuY3Rpb24nXG4gICAgPyBzZXRJbW1lZGlhdGVcbiAgICA6IChcbiAgICAgIHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvY2Vzcy5uZXh0VGlja1xuICAgICAgOiBudWxsXG4gICAgKTtcblxuICBpZiAobmV4dFRpY2spXG4gIHtcbiAgICBuZXh0VGljayhmbik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgc2V0VGltZW91dChmbiwgMCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///405\n")},414:module=>{"use strict";eval("\n\n/** @type {import('./round')} */\nmodule.exports = Math.round;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQW1CO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL3JvdW5kLmpzP2MzYWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yb3VuZCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnJvdW5kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n")},453:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar undefined;\n\nvar $Object = __webpack_require__(9612);\n\nvar $Error = __webpack_require__(9383);\nvar $EvalError = __webpack_require__(1237);\nvar $RangeError = __webpack_require__(9290);\nvar $ReferenceError = __webpack_require__(9538);\nvar $SyntaxError = __webpack_require__(8068);\nvar $TypeError = __webpack_require__(9675);\nvar $URIError = __webpack_require__(5345);\n\nvar abs = __webpack_require__(1514);\nvar floor = __webpack_require__(8968);\nvar max = __webpack_require__(6188);\nvar min = __webpack_require__(8002);\nvar pow = __webpack_require__(5880);\nvar round = __webpack_require__(414);\nvar sign = __webpack_require__(3093);\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = __webpack_require__(5795);\nvar $defineProperty = __webpack_require__(655);\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(4039)();\n\nvar getProto = __webpack_require__(3628);\nvar $ObjectGPO = __webpack_require__(1064);\nvar $ReflectGPO = __webpack_require__(8648);\n\nvar $apply = __webpack_require__(1002);\nvar $call = __webpack_require__(76);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': $Object,\n\t'%Object.getOwnPropertyDescriptor%': $gOPD,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\n\t'%Function.prototype.call%': $call,\n\t'%Function.prototype.apply%': $apply,\n\t'%Object.defineProperty%': $defineProperty,\n\t'%Object.getPrototypeOf%': $ObjectGPO,\n\t'%Math.abs%': abs,\n\t'%Math.floor%': floor,\n\t'%Math.max%': max,\n\t'%Math.min%': min,\n\t'%Math.pow%': pow,\n\t'%Math.round%': round,\n\t'%Math.sign%': sign,\n\t'%Reflect.getPrototypeOf%': $ReflectGPO\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(6743);\nvar hasOwn = __webpack_require__(9957);\nvar $concat = bind.call($call, Array.prototype.concat);\nvar $spliceApply = bind.call($apply, Array.prototype.splice);\nvar $replace = bind.call($call, String.prototype.replace);\nvar $strSlice = bind.call($call, String.prototype.slice);\nvar $exec = bind.call($call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxJQUFpQjs7QUFFdkMsYUFBYSxtQkFBTyxDQUFDLElBQVc7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsSUFBZ0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsSUFBaUI7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsSUFBZTtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyxJQUFrQjtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFlOztBQUV2QyxVQUFVLG1CQUFPLENBQUMsSUFBcUI7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLElBQXVCO0FBQzNDLFVBQVUsbUJBQU8sQ0FBQyxJQUFxQjtBQUN2QyxVQUFVLG1CQUFPLENBQUMsSUFBcUI7QUFDdkMsVUFBVSxtQkFBTyxDQUFDLElBQXFCO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQyxHQUF1QjtBQUMzQyxXQUFXLG1CQUFPLENBQUMsSUFBc0I7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4Q0FBOEM7QUFDaEYsR0FBRztBQUNIOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxJQUFNO0FBQzFCLHNCQUFzQixtQkFBTyxDQUFDLEdBQW9COztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLElBQWE7O0FBRXRDLGVBQWUsbUJBQU8sQ0FBQyxJQUFXO0FBQ2xDLGlCQUFpQixtQkFBTyxDQUFDLElBQWlDO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLElBQWtDOztBQUU1RCxhQUFhLG1CQUFPLENBQUMsSUFBdUM7QUFDNUQsWUFBWSxtQkFBTyxDQUFDLEVBQXNDOztBQUUxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxHQUFHO0FBQ0gsZ0RBQWdEO0FBQ2hELEdBQUc7QUFDSCxzREFBc0Q7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLElBQWU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLElBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzPzAwY2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJ2VzLW9iamVjdC1hdG9tcycpO1xuXG52YXIgJEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzJyk7XG52YXIgJEV2YWxFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9ldmFsJyk7XG52YXIgJFJhbmdlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmFuZ2UnKTtcbnZhciAkUmVmZXJlbmNlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvcmVmJyk7XG52YXIgJFN5bnRheEVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3N5bnRheCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRVUklFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy91cmknKTtcblxudmFyIGFicyA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9hYnMnKTtcbnZhciBmbG9vciA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9mbG9vcicpO1xudmFyIG1heCA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9tYXgnKTtcbnZhciBtaW4gPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvbWluJyk7XG52YXIgcG93ID0gcmVxdWlyZSgnbWF0aC1pbnRyaW5zaWNzL3BvdycpO1xudmFyIHJvdW5kID0gcmVxdWlyZSgnbWF0aC1pbnRyaW5zaWNzL3JvdW5kJyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9zaWduJyk7XG5cbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnZXMtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gcmVxdWlyZSgnZ2V0LXByb3RvJyk7XG52YXIgJE9iamVjdEdQTyA9IHJlcXVpcmUoJ2dldC1wcm90by9PYmplY3QuZ2V0UHJvdG90eXBlT2YnKTtcbnZhciAkUmVmbGVjdEdQTyA9IHJlcXVpcmUoJ2dldC1wcm90by9SZWZsZWN0LmdldFByb3RvdHlwZU9mJyk7XG5cbnZhciAkYXBwbHkgPSByZXF1aXJlKCdjYWxsLWJpbmQtYXBwbHktaGVscGVycy9mdW5jdGlvbkFwcGx5Jyk7XG52YXIgJGNhbGwgPSByZXF1aXJlKCdjYWxsLWJpbmQtYXBwbHktaGVscGVycy9mdW5jdGlvbkNhbGwnKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogJEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6ICRFdmFsRXJyb3IsXG5cdCclRmxvYXQxNkFycmF5JSc6IHR5cGVvZiBGbG9hdDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQxNkFycmF5LFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6ICRPYmplY3QsXG5cdCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnOiAkZ09QRCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6ICRSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6ICRSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogJFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0LFxuXG5cdCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJzogJGNhbGwsXG5cdCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JSc6ICRhcHBseSxcblx0JyVPYmplY3QuZGVmaW5lUHJvcGVydHklJzogJGRlZmluZVByb3BlcnR5LFxuXHQnJU9iamVjdC5nZXRQcm90b3R5cGVPZiUnOiAkT2JqZWN0R1BPLFxuXHQnJU1hdGguYWJzJSc6IGFicyxcblx0JyVNYXRoLmZsb29yJSc6IGZsb29yLFxuXHQnJU1hdGgubWF4JSc6IG1heCxcblx0JyVNYXRoLm1pbiUnOiBtaW4sXG5cdCclTWF0aC5wb3clJzogcG93LFxuXHQnJU1hdGgucm91bmQlJzogcm91bmQsXG5cdCclTWF0aC5zaWduJSc6IHNpZ24sXG5cdCclUmVmbGVjdC5nZXRQcm90b3R5cGVPZiUnOiAkUmVmbGVjdEdQT1xufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzb3duJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbCgkY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKCRhcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoJGNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKCRjYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbCgkY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///453\n")},560:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYwLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxJQUFtQjtBQUMxQztBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzP2YwNmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+XG4gIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///560\n")},655:module=>{"use strict";eval("\n\n/** @type {import('.')} */\nvar $defineProperty = Object.defineProperty || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxVQUFVO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VzLWRlZmluZS1wcm9wZXJ0eS9pbmRleC5qcz83MWM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///655\n")},737:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var CombinedStream = __webpack_require__(801);\nvar util = __webpack_require__(9023);\nvar path = __webpack_require__(6928);\nvar http = __webpack_require__(8611);\nvar https = __webpack_require__(5692);\nvar parseUrl = (__webpack_require__(7016).parse);\nvar fs = __webpack_require__(9896);\nvar Stream = (__webpack_require__(2203).Stream);\nvar mime = __webpack_require__(6049);\nvar asynckit = __webpack_require__(1873);\nvar setToStringTag = __webpack_require__(9605);\nvar populate = __webpack_require__(1362);\n\n// Public API\nmodule.exports = FormData;\n\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */\nfunction FormData(options) {\n  if (!(this instanceof FormData)) {\n    return new FormData(options);\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._valuesToMeasure = [];\n\n  CombinedStream.call(this);\n\n  options = options || {};\n  for (var option in options) {\n    this[option] = options[option];\n  }\n}\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function(field, value, options) {\n\n  options = options || {};\n\n  // allow filename as single option\n  if (typeof options == 'string') {\n    options = {filename: options};\n  }\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value == 'number') {\n    value = '' + value;\n  }\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (Array.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function(header, value, options) {\n  var valueLength = 0;\n\n  // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength +=\n    Buffer.byteLength(header) +\n    FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response or not a stream\n  if (!value || ( !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) && !(value instanceof Stream))) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength) {\n    this._valuesToMeasure.push(value);\n  }\n};\n\nFormData.prototype._lengthRetriever = function(value, callback) {\n  if (Object.prototype.hasOwnProperty.call(value, 'fd')) {\n\n    // take read range into a account\n    // `end` = Infinity > read file till the end\n    //\n    // TODO: Looks like there is bug in Node fs.createReadStream\n    // it doesn't respect `end` options without `start` options\n    // Fix it when node fixes it.\n    // https://github.com/joyent/node/issues/7819\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n\n      // when end specified\n      // no need to calculate range\n      // inclusive, starts with 0\n      callback(null, value.end + 1 - (value.start ? value.start : 0));\n\n    // not that fast snoopy\n    } else {\n      // still need to fetch file size from fs\n      fs.stat(value.path, function(err, stat) {\n\n        var fileSize;\n\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // update final size based on the range options\n        fileSize = stat.size - (value.start ? value.start : 0);\n        callback(null, fileSize);\n      });\n    }\n\n  // or http response\n  } else if (Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {\n    callback(null, +value.headers['content-length']);\n\n  // or request stream http://github.com/mikeal/request\n  } else if (Object.prototype.hasOwnProperty.call(value, 'httpModule')) {\n    // wait till response come back\n    value.on('response', function(response) {\n      value.pause();\n      callback(null, +response.headers['content-length']);\n    });\n    value.resume();\n\n  // something else\n  } else {\n    callback('Unknown stream');\n  }\n};\n\nFormData.prototype._multiPartHeader = function(field, value, options) {\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (typeof options.header == 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers  = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  };\n\n  // allow custom headers.\n  if (typeof options.header == 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n  for (var prop in headers) {\n    if (Object.prototype.hasOwnProperty.call(headers, prop)) {\n      header = headers[prop];\n\n      // skip nullish headers.\n      if (header == null) {\n        continue;\n      }\n\n      // convert all headers to arrays.\n      if (!Array.isArray(header)) {\n        header = [header];\n      }\n\n      // add non-empty headers.\n      if (header.length) {\n        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n      }\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function(value, options) {\n\n  var filename\n    , contentDisposition\n    ;\n\n  if (typeof options.filepath === 'string') {\n    // custom filepath for relative paths\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\n  } else if (options.filename || value.name || value.path) {\n    // custom filename take precedence\n    // formidable and the browser add a name property\n    // fs- and request- streams have path property\n    filename = path.basename(options.filename || value.name || value.path);\n  } else if (value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {\n    // or try http response\n    filename = path.basename(value.client._httpMessage.path || '');\n  }\n\n  if (filename) {\n    contentDisposition = 'filename=\"' + filename + '\"';\n  }\n\n  return contentDisposition;\n};\n\nFormData.prototype._getContentType = function(value, options) {\n\n  // use custom content-type above all\n  var contentType = options.contentType;\n\n  // or try `name` from formidable, browser\n  if (!contentType && value.name) {\n    contentType = mime.lookup(value.name);\n  }\n\n  // or try `path` from fs-, request- streams\n  if (!contentType && value.path) {\n    contentType = mime.lookup(value.path);\n  }\n\n  // or if it's http-reponse\n  if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {\n    contentType = value.headers['content-type'];\n  }\n\n  // or guess it from the filepath or filename\n  if (!contentType && (options.filepath || options.filename)) {\n    contentType = mime.lookup(options.filepath || options.filename);\n  }\n\n  // fallback to the default content type if `value` is not simple value\n  if (!contentType && typeof value == 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function() {\n  return function(next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = (this._streams.length === 0);\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function() {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function(userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) {\n    if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.setBoundary = function(boundary) {\n  this._boundary = boundary;\n};\n\nFormData.prototype.getBoundary = function() {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype.getBuffer = function() {\n  var dataBuffer = new Buffer.alloc(0);\n  var boundary = this.getBoundary();\n\n  // Create the form content. Add Line breaks to the end of data.\n  for (var i = 0, len = this._streams.length; i < len; i++) {\n    if (typeof this._streams[i] !== 'function') {\n\n      // Add content to the buffer.\n      if(Buffer.isBuffer(this._streams[i])) {\n        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);\n      }else {\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);\n      }\n\n      // Add break after content.\n      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );\n      }\n    }\n  }\n\n  // Add the footer and return the Buffer object.\n  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );\n};\n\nFormData.prototype._generateBoundary = function() {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/form-data/form-data/issues/40\n  if (!this.hasKnownLength()) {\n    // Some async length retrievers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function() {\n  var hasKnownLength = true;\n\n  if (this._valuesToMeasure.length) {\n    hasKnownLength = false;\n  }\n\n  return hasKnownLength;\n};\n\nFormData.prototype.getLength = function(cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._valuesToMeasure.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function(length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function(params, cb) {\n  var request\n    , options\n    , defaults = {method: 'post'}\n    ;\n\n  // parse provided url if it's string\n  // or treat it as options object\n  if (typeof params == 'string') {\n\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname,\n      protocol: params.protocol\n    }, defaults);\n\n  // use custom params\n  } else {\n\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (options.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function(err, length) {\n    if (err && err !== 'Unknown stream') {\n      this._error(err);\n      return;\n    }\n\n    // add content length\n    if (length) {\n      request.setHeader('Content-Length', length);\n    }\n\n    this.pipe(request);\n    if (cb) {\n      var onResponse;\n\n      var callback = function (error, responce) {\n        request.removeListener('error', callback);\n        request.removeListener('response', onResponse);\n\n        return cb.call(this, error, responce);\n      };\n\n      onResponse = callback.bind(this, null);\n\n      request.on('error', callback);\n      request.on('response', onResponse);\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function(err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n\nFormData.prototype.toString = function () {\n  return '[object FormData]';\n};\nsetToStringTag(FormData, 'FormData');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM3LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLEdBQWlCO0FBQzlDLFdBQVcsbUJBQU8sQ0FBQyxJQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxJQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxJQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxJQUFPO0FBQzNCLGVBQWUsaUNBQW9CO0FBQ25DLFNBQVMsbUJBQU8sQ0FBQyxJQUFJO0FBQ3JCLGFBQWEsa0NBQXdCO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyxJQUFZO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxJQUFVO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLElBQW9CO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxJQUFlOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanM/MmIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tYmluZWRTdHJlYW0gPSByZXF1aXJlKCdjb21iaW5lZC1zdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgcGFyc2VVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG52YXIgYXN5bmNraXQgPSByZXF1aXJlKCdhc3luY2tpdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnZXMtc2V0LXRvc3RyaW5ndGFnJyk7XG52YXIgcG9wdWxhdGUgPSByZXF1aXJlKCcuL3BvcHVsYXRlLmpzJyk7XG5cbi8vIFB1YmxpYyBBUElcbm1vZHVsZS5leHBvcnRzID0gRm9ybURhdGE7XG5cbi8vIG1ha2UgaXQgYSBTdHJlYW1cbnV0aWwuaW5oZXJpdHMoRm9ybURhdGEsIENvbWJpbmVkU3RyZWFtKTtcblxuLyoqXG4gKiBDcmVhdGUgcmVhZGFibGUgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgc3RyZWFtcy5cbiAqIENhbiBiZSB1c2VkIHRvIHN1Ym1pdCBmb3Jtc1xuICogYW5kIGZpbGUgdXBsb2FkcyB0byBvdGhlciB3ZWIgYXBwbGljYXRpb25zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQcm9wZXJ0aWVzIHRvIGJlIGFkZGVkL292ZXJyaWRlbiBmb3IgRm9ybURhdGEgYW5kIENvbWJpbmVkU3RyZWFtXG4gKi9cbmZ1bmN0aW9uIEZvcm1EYXRhKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZvcm1EYXRhKSkge1xuICAgIHJldHVybiBuZXcgRm9ybURhdGEob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl9vdmVyaGVhZExlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlTGVuZ3RoID0gMDtcbiAgdGhpcy5fdmFsdWVzVG9NZWFzdXJlID0gW107XG5cbiAgQ29tYmluZWRTdHJlYW0uY2FsbCh0aGlzKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gIH1cbn1cblxuRm9ybURhdGEuTElORV9CUkVBSyA9ICdcXHJcXG4nO1xuRm9ybURhdGEuREVGQVVMVF9DT05URU5UX1RZUEUgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblxuRm9ybURhdGEucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGFsbG93IGZpbGVuYW1lIGFzIHNpbmdsZSBvcHRpb25cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtmaWxlbmFtZTogb3B0aW9uc307XG4gIH1cblxuICB2YXIgYXBwZW5kID0gQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmFwcGVuZC5iaW5kKHRoaXMpO1xuXG4gIC8vIGFsbCB0aGF0IHN0cmVhbXkgYnVzaW5lc3MgY2FuJ3QgaGFuZGxlIG51bWJlcnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZWxpeGdlL25vZGUtZm9ybS1kYXRhL2lzc3Vlcy8zOFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBQbGVhc2UgY29udmVydCB5b3VyIGFycmF5IGludG8gc3RyaW5nXG4gICAgLy8gdGhlIHdheSB3ZWIgc2VydmVyIGV4cGVjdHMgaXRcbiAgICB0aGlzLl9lcnJvcihuZXcgRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZC4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlYWRlciA9IHRoaXMuX211bHRpUGFydEhlYWRlcihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgZm9vdGVyID0gdGhpcy5fbXVsdGlQYXJ0Rm9vdGVyKCk7XG5cbiAgYXBwZW5kKGhlYWRlcik7XG4gIGFwcGVuZCh2YWx1ZSk7XG4gIGFwcGVuZChmb290ZXIpO1xuXG4gIC8vIHBhc3MgYWxvbmcgb3B0aW9ucy5rbm93bkxlbmd0aFxuICB0aGlzLl90cmFja0xlbmd0aChoZWFkZXIsIHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fdHJhY2tMZW5ndGggPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB2YWx1ZUxlbmd0aCA9IDA7XG5cbiAgLy8gdXNlZCB3LyBnZXRMZW5ndGhTeW5jKCksIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxuICAvLyBlLmcuIGZvciBzdHJlYW1pbmcgZGlyZWN0bHkgZnJvbSBhIHJlbW90ZSBzZXJ2ZXIsXG4gIC8vIHcvIGEga25vd24gZmlsZSBhIHNpemUsIGFuZCBub3Qgd2FudGluZyB0byB3YWl0IGZvclxuICAvLyBpbmNvbWluZyBmaWxlIHRvIGZpbmlzaCB0byBnZXQgaXRzIHNpemUuXG4gIGlmIChvcHRpb25zLmtub3duTGVuZ3RoICE9IG51bGwpIHtcbiAgICB2YWx1ZUxlbmd0aCArPSArb3B0aW9ucy5rbm93bkxlbmd0aDtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9XG5cbiAgdGhpcy5fdmFsdWVMZW5ndGggKz0gdmFsdWVMZW5ndGg7XG5cbiAgLy8gQGNoZWNrIHdoeSBhZGQgQ1JMRj8gZG9lcyB0aGlzIGFjY291bnQgZm9yIGN1c3RvbS9tdWx0aXBsZSBDUkxGcz9cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggKz1cbiAgICBCdWZmZXIuYnl0ZUxlbmd0aChoZWFkZXIpICtcbiAgICBGb3JtRGF0YS5MSU5FX0JSRUFLLmxlbmd0aDtcblxuICAvLyBlbXB0eSBvciBlaXRoZXIgZG9lc24ndCBoYXZlIHBhdGggb3Igbm90IGFuIGh0dHAgcmVzcG9uc2Ugb3Igbm90IGEgc3RyZWFtXG4gIGlmICghdmFsdWUgfHwgKCAhdmFsdWUucGF0aCAmJiAhKHZhbHVlLnJlYWRhYmxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2h0dHBWZXJzaW9uJykpICYmICEodmFsdWUgaW5zdGFuY2VvZiBTdHJlYW0pKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG5vIG5lZWQgdG8gYm90aGVyIHdpdGggdGhlIGxlbmd0aFxuICBpZiAoIW9wdGlvbnMua25vd25MZW5ndGgpIHtcbiAgICB0aGlzLl92YWx1ZXNUb01lYXN1cmUucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbGVuZ3RoUmV0cmlldmVyID0gZnVuY3Rpb24odmFsdWUsIGNhbGxiYWNrKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdmZCcpKSB7XG5cbiAgICAvLyB0YWtlIHJlYWQgcmFuZ2UgaW50byBhIGFjY291bnRcbiAgICAvLyBgZW5kYCA9IEluZmluaXR5IOKAkz4gcmVhZCBmaWxlIHRpbGwgdGhlIGVuZFxuICAgIC8vXG4gICAgLy8gVE9ETzogTG9va3MgbGlrZSB0aGVyZSBpcyBidWcgaW4gTm9kZSBmcy5jcmVhdGVSZWFkU3RyZWFtXG4gICAgLy8gaXQgZG9lc24ndCByZXNwZWN0IGBlbmRgIG9wdGlvbnMgd2l0aG91dCBgc3RhcnRgIG9wdGlvbnNcbiAgICAvLyBGaXggaXQgd2hlbiBub2RlIGZpeGVzIGl0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvNzgxOVxuICAgIGlmICh2YWx1ZS5lbmQgIT0gdW5kZWZpbmVkICYmIHZhbHVlLmVuZCAhPSBJbmZpbml0eSAmJiB2YWx1ZS5zdGFydCAhPSB1bmRlZmluZWQpIHtcblxuICAgICAgLy8gd2hlbiBlbmQgc3BlY2lmaWVkXG4gICAgICAvLyBubyBuZWVkIHRvIGNhbGN1bGF0ZSByYW5nZVxuICAgICAgLy8gaW5jbHVzaXZlLCBzdGFydHMgd2l0aCAwXG4gICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZS5lbmQgKyAxIC0gKHZhbHVlLnN0YXJ0ID8gdmFsdWUuc3RhcnQgOiAwKSk7XG5cbiAgICAvLyBub3QgdGhhdCBmYXN0IHNub29weVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGlsbCBuZWVkIHRvIGZldGNoIGZpbGUgc2l6ZSBmcm9tIGZzXG4gICAgICBmcy5zdGF0KHZhbHVlLnBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuXG4gICAgICAgIHZhciBmaWxlU2l6ZTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgZmluYWwgc2l6ZSBiYXNlZCBvbiB0aGUgcmFuZ2Ugb3B0aW9uc1xuICAgICAgICBmaWxlU2l6ZSA9IHN0YXQuc2l6ZSAtICh2YWx1ZS5zdGFydCA/IHZhbHVlLnN0YXJ0IDogMCk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTaXplKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAvLyBvciBodHRwIHJlc3BvbnNlXG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaHR0cFZlcnNpb24nKSkge1xuICAgIGNhbGxiYWNrKG51bGwsICt2YWx1ZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcblxuICAvLyBvciByZXF1ZXN0IHN0cmVhbSBodHRwOi8vZ2l0aHViLmNvbS9taWtlYWwvcmVxdWVzdFxuICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2h0dHBNb2R1bGUnKSkge1xuICAgIC8vIHdhaXQgdGlsbCByZXNwb25zZSBjb21lIGJhY2tcbiAgICB2YWx1ZS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFsdWUucGF1c2UoKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsICtyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcbiAgICB9KTtcbiAgICB2YWx1ZS5yZXN1bWUoKTtcblxuICAvLyBzb21ldGhpbmcgZWxzZVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCdVbmtub3duIHN0cmVhbScpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX211bHRpUGFydEhlYWRlciA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBjdXN0b20gaGVhZGVyIHNwZWNpZmllZCAoYXMgc3RyaW5nKT9cbiAgLy8gaXQgYmVjb21lcyByZXNwb25zaWJsZSBmb3IgYm91bmRhcnlcbiAgLy8gKGUuZy4gdG8gaGFuZGxlIGV4dHJhIENSTEZzIG9uIC5ORVQgc2VydmVycylcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvcHRpb25zLmhlYWRlcjtcbiAgfVxuXG4gIHZhciBjb250ZW50RGlzcG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50RGlzcG9zaXRpb24odmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9nZXRDb250ZW50VHlwZSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgdmFyIGNvbnRlbnRzID0gJyc7XG4gIHZhciBoZWFkZXJzICA9IHtcbiAgICAvLyBhZGQgY3VzdG9tIGRpc3Bvc2l0aW9uIGFzIHRoaXJkIGVsZW1lbnQgb3Iga2VlcCBpdCB0d28gZWxlbWVudHMgaWYgbm90XG4gICAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nOiBbJ2Zvcm0tZGF0YScsICduYW1lPVwiJyArIGZpZWxkICsgJ1wiJ10uY29uY2F0KGNvbnRlbnREaXNwb3NpdGlvbiB8fCBbXSksXG4gICAgLy8gaWYgbm8gY29udGVudCB0eXBlLiBhbGxvdyBpdCB0byBiZSBlbXB0eSBhcnJheVxuICAgICdDb250ZW50LVR5cGUnOiBbXS5jb25jYXQoY29udGVudFR5cGUgfHwgW10pXG4gIH07XG5cbiAgLy8gYWxsb3cgY3VzdG9tIGhlYWRlcnMuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXIgPT0gJ29iamVjdCcpIHtcbiAgICBwb3B1bGF0ZShoZWFkZXJzLCBvcHRpb25zLmhlYWRlcik7XG4gIH1cblxuICB2YXIgaGVhZGVyO1xuICBmb3IgKHZhciBwcm9wIGluIGhlYWRlcnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIHByb3ApKSB7XG4gICAgICBoZWFkZXIgPSBoZWFkZXJzW3Byb3BdO1xuXG4gICAgICAvLyBza2lwIG51bGxpc2ggaGVhZGVycy5cbiAgICAgIGlmIChoZWFkZXIgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29udmVydCBhbGwgaGVhZGVycyB0byBhcnJheXMuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgICBoZWFkZXIgPSBbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIG5vbi1lbXB0eSBoZWFkZXJzLlxuICAgICAgaWYgKGhlYWRlci5sZW5ndGgpIHtcbiAgICAgICAgY29udGVudHMgKz0gcHJvcCArICc6ICcgKyBoZWFkZXIuam9pbignOyAnKSArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyBGb3JtRGF0YS5MSU5FX0JSRUFLICsgY29udGVudHMgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZXRDb250ZW50RGlzcG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuXG4gIHZhciBmaWxlbmFtZVxuICAgICwgY29udGVudERpc3Bvc2l0aW9uXG4gICAgO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5maWxlcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBjdXN0b20gZmlsZXBhdGggZm9yIHJlbGF0aXZlIHBhdGhzXG4gICAgZmlsZW5hbWUgPSBwYXRoLm5vcm1hbGl6ZShvcHRpb25zLmZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5uYW1lIHx8IHZhbHVlLnBhdGgpIHtcbiAgICAvLyBjdXN0b20gZmlsZW5hbWUgdGFrZSBwcmVjZWRlbmNlXG4gICAgLy8gZm9ybWlkYWJsZSBhbmQgdGhlIGJyb3dzZXIgYWRkIGEgbmFtZSBwcm9wZXJ0eVxuICAgIC8vIGZzLSBhbmQgcmVxdWVzdC0gc3RyZWFtcyBoYXZlIHBhdGggcHJvcGVydHlcbiAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5uYW1lIHx8IHZhbHVlLnBhdGgpO1xuICB9IGVsc2UgaWYgKHZhbHVlLnJlYWRhYmxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2h0dHBWZXJzaW9uJykpIHtcbiAgICAvLyBvciB0cnkgaHR0cCByZXNwb25zZVxuICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh2YWx1ZS5jbGllbnQuX2h0dHBNZXNzYWdlLnBhdGggfHwgJycpO1xuICB9XG5cbiAgaWYgKGZpbGVuYW1lKSB7XG4gICAgY29udGVudERpc3Bvc2l0aW9uID0gJ2ZpbGVuYW1lPVwiJyArIGZpbGVuYW1lICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiBjb250ZW50RGlzcG9zaXRpb247XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcblxuICAvLyB1c2UgY3VzdG9tIGNvbnRlbnQtdHlwZSBhYm92ZSBhbGxcbiAgdmFyIGNvbnRlbnRUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZTtcblxuICAvLyBvciB0cnkgYG5hbWVgIGZyb20gZm9ybWlkYWJsZSwgYnJvd3NlclxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLm5hbWUpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKHZhbHVlLm5hbWUpO1xuICB9XG5cbiAgLy8gb3IgdHJ5IGBwYXRoYCBmcm9tIGZzLSwgcmVxdWVzdC0gc3RyZWFtc1xuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLnBhdGgpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKHZhbHVlLnBhdGgpO1xuICB9XG5cbiAgLy8gb3IgaWYgaXQncyBodHRwLXJlcG9uc2VcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5yZWFkYWJsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdodHRwVmVyc2lvbicpKSB7XG4gICAgY29udGVudFR5cGUgPSB2YWx1ZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgfVxuXG4gIC8vIG9yIGd1ZXNzIGl0IGZyb20gdGhlIGZpbGVwYXRoIG9yIGZpbGVuYW1lXG4gIGlmICghY29udGVudFR5cGUgJiYgKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSkpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSk7XG4gIH1cblxuICAvLyBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBjb250ZW50IHR5cGUgaWYgYHZhbHVlYCBpcyBub3Qgc2ltcGxlIHZhbHVlXG4gIGlmICghY29udGVudFR5cGUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgY29udGVudFR5cGUgPSBGb3JtRGF0YS5ERUZBVUxUX0NPTlRFTlRfVFlQRTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50VHlwZTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0Rm9vdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihuZXh0KSB7XG4gICAgdmFyIGZvb3RlciA9IEZvcm1EYXRhLkxJTkVfQlJFQUs7XG5cbiAgICB2YXIgbGFzdFBhcnQgPSAodGhpcy5fc3RyZWFtcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChsYXN0UGFydCkge1xuICAgICAgZm9vdGVyICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpO1xuICAgIH1cblxuICAgIG5leHQoZm9vdGVyKTtcbiAgfS5iaW5kKHRoaXMpO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9sYXN0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyAnLS0nICsgRm9ybURhdGEuTElORV9CUkVBSztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24odXNlckhlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcjtcbiAgdmFyIGZvcm1IZWFkZXJzID0ge1xuICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIHRoaXMuZ2V0Qm91bmRhcnkoKVxuICB9O1xuXG4gIGZvciAoaGVhZGVyIGluIHVzZXJIZWFkZXJzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1c2VySGVhZGVycywgaGVhZGVyKSkge1xuICAgICAgZm9ybUhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gdXNlckhlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybUhlYWRlcnM7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuc2V0Qm91bmRhcnkgPSBmdW5jdGlvbihib3VuZGFyeSkge1xuICB0aGlzLl9ib3VuZGFyeSA9IGJvdW5kYXJ5O1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fYm91bmRhcnkpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZUJvdW5kYXJ5KCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fYm91bmRhcnk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhQnVmZmVyID0gbmV3IEJ1ZmZlci5hbGxvYygwKTtcbiAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5nZXRCb3VuZGFyeSgpO1xuXG4gIC8vIENyZWF0ZSB0aGUgZm9ybSBjb250ZW50LiBBZGQgTGluZSBicmVha3MgdG8gdGhlIGVuZCBvZiBkYXRhLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fc3RyZWFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RyZWFtc1tpXSAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAvLyBBZGQgY29udGVudCB0byB0aGUgYnVmZmVyLlxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHRoaXMuX3N0cmVhbXNbaV0pKSB7XG4gICAgICAgIGRhdGFCdWZmZXIgPSBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgdGhpcy5fc3RyZWFtc1tpXV0pO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKHRoaXMuX3N0cmVhbXNbaV0pXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBicmVhayBhZnRlciBjb250ZW50LlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zdHJlYW1zW2ldICE9PSAnc3RyaW5nJyB8fCB0aGlzLl9zdHJlYW1zW2ldLnN1YnN0cmluZyggMiwgYm91bmRhcnkubGVuZ3RoICsgMiApICE9PSBib3VuZGFyeSkge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKEZvcm1EYXRhLkxJTkVfQlJFQUspXSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCB0aGUgZm9vdGVyIGFuZCByZXR1cm4gdGhlIEJ1ZmZlciBvYmplY3QuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgQnVmZmVyLmZyb20odGhpcy5fbGFzdEJvdW5kYXJ5KCkpXSApO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZW5lcmF0ZUJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgZ2VuZXJhdGVzIGEgNTAgY2hhcmFjdGVyIGJvdW5kYXJ5IHNpbWlsYXIgdG8gdGhvc2UgdXNlZCBieSBGaXJlZm94LlxuICAvLyBUaGV5IGFyZSBvcHRpbWl6ZWQgZm9yIGJveWVyLW1vb3JlIHBhcnNpbmcuXG4gIHZhciBib3VuZGFyeSA9ICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgIGJvdW5kYXJ5ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygxNik7XG4gIH1cblxuICB0aGlzLl9ib3VuZGFyeSA9IGJvdW5kYXJ5O1xufTtcblxuLy8gTm90ZTogZ2V0TGVuZ3RoU3luYyBET0VTTidUIGNhbGN1bGF0ZSBzdHJlYW1zIGxlbmd0aFxuLy8gQXMgd29ya2Fyb3VuZCBvbmUgY2FuIGNhbGN1bGF0ZSBmaWxlIHNpemUgbWFudWFsbHlcbi8vIGFuZCBhZGQgaXQgYXMga25vd25MZW5ndGggb3B0aW9uXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoU3luYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIC8vIERvbid0IGdldCBjb25mdXNlZCwgdGhlcmUgYXJlIDMgXCJpbnRlcm5hbFwiIHN0cmVhbXMgZm9yIGVhY2gga2V5dmFsIHBhaXJcbiAgLy8gc28gaXQgYmFzaWNhbGx5IGNoZWNrcyBpZiB0aGVyZSBpcyBhbnkgdmFsdWUgYWRkZWQgdG8gdGhlIGZvcm1cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzQwXG4gIGlmICghdGhpcy5oYXNLbm93bkxlbmd0aCgpKSB7XG4gICAgLy8gU29tZSBhc3luYyBsZW5ndGggcmV0cmlldmVycyBhcmUgcHJlc2VudFxuICAgIC8vIHRoZXJlZm9yZSBzeW5jaHJvbm91cyBsZW5ndGggY2FsY3VsYXRpb24gaXMgZmFsc2UuXG4gICAgLy8gUGxlYXNlIHVzZSBnZXRMZW5ndGgoY2FsbGJhY2spIHRvIGdldCBwcm9wZXIgbGVuZ3RoXG4gICAgdGhpcy5fZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHByb3BlciBsZW5ndGggaW4gc3luY2hyb25vdXMgd2F5LicpKTtcbiAgfVxuXG4gIHJldHVybiBrbm93bkxlbmd0aDtcbn07XG5cbi8vIFB1YmxpYyBBUEkgdG8gY2hlY2sgaWYgbGVuZ3RoIG9mIGFkZGVkIHZhbHVlcyBpcyBrbm93blxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzE5NlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzI2MlxuRm9ybURhdGEucHJvdG90eXBlLmhhc0tub3duTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYXNLbm93bkxlbmd0aCA9IHRydWU7XG5cbiAgaWYgKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5sZW5ndGgpIHtcbiAgICBoYXNLbm93bkxlbmd0aCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tub3duTGVuZ3RoO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBrbm93bkxlbmd0aCA9IHRoaXMuX292ZXJoZWFkTGVuZ3RoICsgdGhpcy5fdmFsdWVMZW5ndGg7XG5cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCF0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKHRoaXMsIG51bGwsIGtub3duTGVuZ3RoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXN5bmNraXQucGFyYWxsZWwodGhpcy5fdmFsdWVzVG9NZWFzdXJlLCB0aGlzLl9sZW5ndGhSZXRyaWV2ZXIsIGZ1bmN0aW9uKGVyciwgdmFsdWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGtub3duTGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9KTtcblxuICAgIGNiKG51bGwsIGtub3duTGVuZ3RoKTtcbiAgfSk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xuICB2YXIgcmVxdWVzdFxuICAgICwgb3B0aW9uc1xuICAgICwgZGVmYXVsdHMgPSB7bWV0aG9kOiAncG9zdCd9XG4gICAgO1xuXG4gIC8vIHBhcnNlIHByb3ZpZGVkIHVybCBpZiBpdCdzIHN0cmluZ1xuICAvLyBvciB0cmVhdCBpdCBhcyBvcHRpb25zIG9iamVjdFxuICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnc3RyaW5nJykge1xuXG4gICAgcGFyYW1zID0gcGFyc2VVcmwocGFyYW1zKTtcbiAgICBvcHRpb25zID0gcG9wdWxhdGUoe1xuICAgICAgcG9ydDogcGFyYW1zLnBvcnQsXG4gICAgICBwYXRoOiBwYXJhbXMucGF0aG5hbWUsXG4gICAgICBob3N0OiBwYXJhbXMuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbDogcGFyYW1zLnByb3RvY29sXG4gICAgfSwgZGVmYXVsdHMpO1xuXG4gIC8vIHVzZSBjdXN0b20gcGFyYW1zXG4gIH0gZWxzZSB7XG5cbiAgICBvcHRpb25zID0gcG9wdWxhdGUocGFyYW1zLCBkZWZhdWx0cyk7XG4gICAgLy8gaWYgbm8gcG9ydCBwcm92aWRlZCB1c2UgZGVmYXVsdCBvbmVcbiAgICBpZiAoIW9wdGlvbnMucG9ydCkge1xuICAgICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHB1dCB0aGF0IGdvb2QgY29kZSBpbiBnZXRIZWFkZXJzIHRvIHNvbWUgdXNlXG4gIG9wdGlvbnMuaGVhZGVycyA9IHRoaXMuZ2V0SGVhZGVycyhwYXJhbXMuaGVhZGVycyk7XG5cbiAgLy8gaHR0cHMgaWYgc3BlY2lmaWVkLCBmYWxsYmFjayB0byBodHRwIGluIGFueSBvdGhlciBjYXNlXG4gIGlmIChvcHRpb25zLnByb3RvY29sID09ICdodHRwczonKSB7XG4gICAgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGdldCBjb250ZW50IGxlbmd0aCBhbmQgZmlyZSBhd2F5XG4gIHRoaXMuZ2V0TGVuZ3RoKGZ1bmN0aW9uKGVyciwgbGVuZ3RoKSB7XG4gICAgaWYgKGVyciAmJiBlcnIgIT09ICdVbmtub3duIHN0cmVhbScpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIGNvbnRlbnQgbGVuZ3RoXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBpcGUocmVxdWVzdCk7XG4gICAgaWYgKGNiKSB7XG4gICAgICB2YXIgb25SZXNwb25zZTtcblxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yLCByZXNwb25jZSkge1xuICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcblxuICAgICAgICByZXR1cm4gY2IuY2FsbCh0aGlzLCBlcnJvciwgcmVzcG9uY2UpO1xuICAgICAgfTtcblxuICAgICAgb25SZXNwb25zZSA9IGNhbGxiYWNrLmJpbmQodGhpcywgbnVsbCk7XG5cbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICghdGhpcy5lcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnW29iamVjdCBGb3JtRGF0YV0nO1xufTtcbnNldFRvU3RyaW5nVGFnKEZvcm1EYXRhLCAnRm9ybURhdGEnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///737\n")},801:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var util = __webpack_require__(9023);\nvar Stream = (__webpack_require__(2203).Stream);\nvar DelayedStream = __webpack_require__(8069);\n\nmodule.exports = CombinedStream;\nfunction CombinedStream() {\n  this.writable = false;\n  this.readable = true;\n  this.dataSize = 0;\n  this.maxDataSize = 2 * 1024 * 1024;\n  this.pauseStreams = true;\n\n  this._released = false;\n  this._streams = [];\n  this._currentStream = null;\n  this._insideLoop = false;\n  this._pendingNext = false;\n}\nutil.inherits(CombinedStream, Stream);\n\nCombinedStream.create = function(options) {\n  var combinedStream = new this();\n\n  options = options || {};\n  for (var option in options) {\n    combinedStream[option] = options[option];\n  }\n\n  return combinedStream;\n};\n\nCombinedStream.isStreamLike = function(stream) {\n  return (typeof stream !== 'function')\n    && (typeof stream !== 'string')\n    && (typeof stream !== 'boolean')\n    && (typeof stream !== 'number')\n    && (!Buffer.isBuffer(stream));\n};\n\nCombinedStream.prototype.append = function(stream) {\n  var isStreamLike = CombinedStream.isStreamLike(stream);\n\n  if (isStreamLike) {\n    if (!(stream instanceof DelayedStream)) {\n      var newStream = DelayedStream.create(stream, {\n        maxDataSize: Infinity,\n        pauseStream: this.pauseStreams,\n      });\n      stream.on('data', this._checkDataSize.bind(this));\n      stream = newStream;\n    }\n\n    this._handleErrors(stream);\n\n    if (this.pauseStreams) {\n      stream.pause();\n    }\n  }\n\n  this._streams.push(stream);\n  return this;\n};\n\nCombinedStream.prototype.pipe = function(dest, options) {\n  Stream.prototype.pipe.call(this, dest, options);\n  this.resume();\n  return dest;\n};\n\nCombinedStream.prototype._getNext = function() {\n  this._currentStream = null;\n\n  if (this._insideLoop) {\n    this._pendingNext = true;\n    return; // defer call\n  }\n\n  this._insideLoop = true;\n  try {\n    do {\n      this._pendingNext = false;\n      this._realGetNext();\n    } while (this._pendingNext);\n  } finally {\n    this._insideLoop = false;\n  }\n};\n\nCombinedStream.prototype._realGetNext = function() {\n  var stream = this._streams.shift();\n\n\n  if (typeof stream == 'undefined') {\n    this.end();\n    return;\n  }\n\n  if (typeof stream !== 'function') {\n    this._pipeNext(stream);\n    return;\n  }\n\n  var getStream = stream;\n  getStream(function(stream) {\n    var isStreamLike = CombinedStream.isStreamLike(stream);\n    if (isStreamLike) {\n      stream.on('data', this._checkDataSize.bind(this));\n      this._handleErrors(stream);\n    }\n\n    this._pipeNext(stream);\n  }.bind(this));\n};\n\nCombinedStream.prototype._pipeNext = function(stream) {\n  this._currentStream = stream;\n\n  var isStreamLike = CombinedStream.isStreamLike(stream);\n  if (isStreamLike) {\n    stream.on('end', this._getNext.bind(this));\n    stream.pipe(this, {end: false});\n    return;\n  }\n\n  var value = stream;\n  this.write(value);\n  this._getNext();\n};\n\nCombinedStream.prototype._handleErrors = function(stream) {\n  var self = this;\n  stream.on('error', function(err) {\n    self._emitError(err);\n  });\n};\n\nCombinedStream.prototype.write = function(data) {\n  this.emit('data', data);\n};\n\nCombinedStream.prototype.pause = function() {\n  if (!this.pauseStreams) {\n    return;\n  }\n\n  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();\n  this.emit('pause');\n};\n\nCombinedStream.prototype.resume = function() {\n  if (!this._released) {\n    this._released = true;\n    this.writable = true;\n    this._getNext();\n  }\n\n  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();\n  this.emit('resume');\n};\n\nCombinedStream.prototype.end = function() {\n  this._reset();\n  this.emit('end');\n};\n\nCombinedStream.prototype.destroy = function() {\n  this._reset();\n  this.emit('close');\n};\n\nCombinedStream.prototype._reset = function() {\n  this.writable = false;\n  this._streams = [];\n  this._currentStream = null;\n};\n\nCombinedStream.prototype._checkDataSize = function() {\n  this._updateDataSize();\n  if (this.dataSize <= this.maxDataSize) {\n    return;\n  }\n\n  var message =\n    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';\n  this._emitError(new Error(message));\n};\n\nCombinedStream.prototype._updateDataSize = function() {\n  this.dataSize = 0;\n\n  var self = this;\n  this._streams.forEach(function(stream) {\n    if (!stream.dataSize) {\n      return;\n    }\n\n    self.dataSize += stream.dataSize;\n  });\n\n  if (this._currentStream && this._currentStream.dataSize) {\n    this.dataSize += this._currentStream.dataSize;\n  }\n};\n\nCombinedStream.prototype._emitError = function(err) {\n  this._reset();\n  this.emit('error', err);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAxLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxJQUFNO0FBQ3pCLGFBQWEsa0NBQXdCO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLElBQWdCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9jb21iaW5lZC1zdHJlYW0vbGliL2NvbWJpbmVkX3N0cmVhbS5qcz81ZmQwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciBEZWxheWVkU3RyZWFtID0gcmVxdWlyZSgnZGVsYXllZC1zdHJlYW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21iaW5lZFN0cmVhbTtcbmZ1bmN0aW9uIENvbWJpbmVkU3RyZWFtKCkge1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICB0aGlzLmRhdGFTaXplID0gMDtcbiAgdGhpcy5tYXhEYXRhU2l6ZSA9IDIgKiAxMDI0ICogMTAyNDtcbiAgdGhpcy5wYXVzZVN0cmVhbXMgPSB0cnVlO1xuXG4gIHRoaXMuX3JlbGVhc2VkID0gZmFsc2U7XG4gIHRoaXMuX3N0cmVhbXMgPSBbXTtcbiAgdGhpcy5fY3VycmVudFN0cmVhbSA9IG51bGw7XG4gIHRoaXMuX2luc2lkZUxvb3AgPSBmYWxzZTtcbiAgdGhpcy5fcGVuZGluZ05leHQgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoQ29tYmluZWRTdHJlYW0sIFN0cmVhbSk7XG5cbkNvbWJpbmVkU3RyZWFtLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGNvbWJpbmVkU3RyZWFtID0gbmV3IHRoaXMoKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBjb21iaW5lZFN0cmVhbVtvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkU3RyZWFtO1xufTtcblxuQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHJldHVybiAodHlwZW9mIHN0cmVhbSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ3N0cmluZycpXG4gICAgJiYgKHR5cGVvZiBzdHJlYW0gIT09ICdib29sZWFuJylcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ251bWJlcicpXG4gICAgJiYgKCFCdWZmZXIuaXNCdWZmZXIoc3RyZWFtKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBpc1N0cmVhbUxpa2UgPSBDb21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2Uoc3RyZWFtKTtcblxuICBpZiAoaXNTdHJlYW1MaWtlKSB7XG4gICAgaWYgKCEoc3RyZWFtIGluc3RhbmNlb2YgRGVsYXllZFN0cmVhbSkpIHtcbiAgICAgIHZhciBuZXdTdHJlYW0gPSBEZWxheWVkU3RyZWFtLmNyZWF0ZShzdHJlYW0sIHtcbiAgICAgICAgbWF4RGF0YVNpemU6IEluZmluaXR5LFxuICAgICAgICBwYXVzZVN0cmVhbTogdGhpcy5wYXVzZVN0cmVhbXMsXG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbignZGF0YScsIHRoaXMuX2NoZWNrRGF0YVNpemUuYmluZCh0aGlzKSk7XG4gICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlRXJyb3JzKHN0cmVhbSk7XG5cbiAgICBpZiAodGhpcy5wYXVzZVN0cmVhbXMpIHtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3N0cmVhbXMucHVzaChzdHJlYW0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICBTdHJlYW0ucHJvdG90eXBlLnBpcGUuY2FsbCh0aGlzLCBkZXN0LCBvcHRpb25zKTtcbiAgdGhpcy5yZXN1bWUoKTtcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2dldE5leHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3VycmVudFN0cmVhbSA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX2luc2lkZUxvb3ApIHtcbiAgICB0aGlzLl9wZW5kaW5nTmV4dCA9IHRydWU7XG4gICAgcmV0dXJuOyAvLyBkZWZlciBjYWxsXG4gIH1cblxuICB0aGlzLl9pbnNpZGVMb29wID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBkbyB7XG4gICAgICB0aGlzLl9wZW5kaW5nTmV4dCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVhbEdldE5leHQoKTtcbiAgICB9IHdoaWxlICh0aGlzLl9wZW5kaW5nTmV4dCk7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5faW5zaWRlTG9vcCA9IGZhbHNlO1xuICB9XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3JlYWxHZXROZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHJlYW0gPSB0aGlzLl9zdHJlYW1zLnNoaWZ0KCk7XG5cblxuICBpZiAodHlwZW9mIHN0cmVhbSA9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuZW5kKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9waXBlTmV4dChzdHJlYW0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXRTdHJlYW0gPSBzdHJlYW07XG4gIGdldFN0cmVhbShmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgaXNTdHJlYW1MaWtlID0gQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlKHN0cmVhbSk7XG4gICAgaWYgKGlzU3RyZWFtTGlrZSkge1xuICAgICAgc3RyZWFtLm9uKCdkYXRhJywgdGhpcy5fY2hlY2tEYXRhU2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2hhbmRsZUVycm9ycyhzdHJlYW0pO1xuICAgIH1cblxuICAgIHRoaXMuX3BpcGVOZXh0KHN0cmVhbSk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3BpcGVOZXh0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBzdHJlYW07XG5cbiAgdmFyIGlzU3RyZWFtTGlrZSA9IENvbWJpbmVkU3RyZWFtLmlzU3RyZWFtTGlrZShzdHJlYW0pO1xuICBpZiAoaXNTdHJlYW1MaWtlKSB7XG4gICAgc3RyZWFtLm9uKCdlbmQnLCB0aGlzLl9nZXROZXh0LmJpbmQodGhpcykpO1xuICAgIHN0cmVhbS5waXBlKHRoaXMsIHtlbmQ6IGZhbHNlfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gc3RyZWFtO1xuICB0aGlzLndyaXRlKHZhbHVlKTtcbiAgdGhpcy5fZ2V0TmV4dCgpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVFcnJvcnMgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5fZW1pdEVycm9yKGVycik7XG4gIH0pO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMucGF1c2VTdHJlYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYodGhpcy5wYXVzZVN0cmVhbXMgJiYgdGhpcy5fY3VycmVudFN0cmVhbSAmJiB0eXBlb2YodGhpcy5fY3VycmVudFN0cmVhbS5wYXVzZSkgPT0gJ2Z1bmN0aW9uJykgdGhpcy5fY3VycmVudFN0cmVhbS5wYXVzZSgpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmVsZWFzZWQpIHtcbiAgICB0aGlzLl9yZWxlYXNlZCA9IHRydWU7XG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5fZ2V0TmV4dCgpO1xuICB9XG5cbiAgaWYodGhpcy5wYXVzZVN0cmVhbXMgJiYgdGhpcy5fY3VycmVudFN0cmVhbSAmJiB0eXBlb2YodGhpcy5fY3VycmVudFN0cmVhbS5yZXN1bWUpID09ICdmdW5jdGlvbicpIHRoaXMuX2N1cnJlbnRTdHJlYW0ucmVzdW1lKCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuZW1pdCgnZW5kJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gbnVsbDtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fY2hlY2tEYXRhU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVEYXRhU2l6ZSgpO1xuICBpZiAodGhpcy5kYXRhU2l6ZSA8PSB0aGlzLm1heERhdGFTaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPVxuICAgICdEZWxheWVkU3RyZWFtI21heERhdGFTaXplIG9mICcgKyB0aGlzLm1heERhdGFTaXplICsgJyBieXRlcyBleGNlZWRlZC4nO1xuICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fdXBkYXRlRGF0YVNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kYXRhU2l6ZSA9IDA7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9zdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgaWYgKCFzdHJlYW0uZGF0YVNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmRhdGFTaXplICs9IHN0cmVhbS5kYXRhU2l6ZTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnRTdHJlYW0gJiYgdGhpcy5fY3VycmVudFN0cmVhbS5kYXRhU2l6ZSkge1xuICAgIHRoaXMuZGF0YVNpemUgKz0gdGhpcy5fY3VycmVudFN0cmVhbS5kYXRhU2l6ZTtcbiAgfVxufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9lbWl0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///801\n")},855:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var ms = __webpack_require__(1880);\n\nmodule.exports = function (time, iat) {\n  var timestamp = iat || Math.floor(Date.now() / 1000);\n\n  if (typeof time === 'string') {\n    var milliseconds = ms(time);\n    if (typeof milliseconds === 'undefined') {\n      return;\n    }\n    return Math.floor(timestamp + milliseconds / 1000);\n  } else if (typeof time === 'number') {\n    return timestamp + time;\n  } else {\n    return;\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU1LmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVMsbUJBQU8sQ0FBQyxJQUFJOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvanNvbndlYnRva2VuL2xpYi90aW1lc3Bhbi5qcz9mNGU2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBtcyA9IHJlcXVpcmUoJ21zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRpbWUsIGlhdCkge1xuICB2YXIgdGltZXN0YW1wID0gaWF0IHx8IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gIGlmICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbXModGltZSk7XG4gICAgaWYgKHR5cGVvZiBtaWxsaXNlY29uZHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKHRpbWVzdGFtcCArIG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0aW1lc3RhbXAgKyB0aW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///855\n")},857:n=>{"use strict";n.exports=require("os")},909:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA5LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxJQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanM/ODg0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///909\n")},998:(module,__unused_webpack_exports,__webpack_require__)=>{eval("const fs = __webpack_require__(9896)\nconst path = __webpack_require__(6928)\nconst os = __webpack_require__(857)\nconst crypto = __webpack_require__(6982)\nconst packageJson = __webpack_require__(56)\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  const vaultPath = _vaultPath(options)\n\n  // Parse .env.vault\n  const result = DotenvModule.configDotenv({ path: vaultPath })\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.log(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = Boolean(options && options.debug)\n  if (debug) {\n    _debug('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsedAll, options)\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n    }\n  }\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLFVBQVU7QUFDVixxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQix1QkFBdUI7O0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvZG90ZW52L2xpYi9tYWluLmpzP2VkMTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG5jb25zdCBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG5cbmNvbnN0IHZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbmNvbnN0IExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZ1xuXG4vLyBQYXJzZSBzcmMgaW50byBhbiBPYmplY3RcbmZ1bmN0aW9uIHBhcnNlIChzcmMpIHtcbiAgY29uc3Qgb2JqID0ge31cblxuICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBzdHJpbmdcbiAgbGV0IGxpbmVzID0gc3JjLnRvU3RyaW5nKClcblxuICAvLyBDb252ZXJ0IGxpbmUgYnJlYWtzIHRvIHNhbWUgZm9ybWF0XG4gIGxpbmVzID0gbGluZXMucmVwbGFjZSgvXFxyXFxuPy9tZywgJ1xcbicpXG5cbiAgbGV0IG1hdGNoXG4gIHdoaWxlICgobWF0Y2ggPSBMSU5FLmV4ZWMobGluZXMpKSAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5ID0gbWF0Y2hbMV1cblxuICAgIC8vIERlZmF1bHQgdW5kZWZpbmVkIG9yIG51bGwgdG8gZW1wdHkgc3RyaW5nXG4gICAgbGV0IHZhbHVlID0gKG1hdGNoWzJdIHx8ICcnKVxuXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgLy8gQ2hlY2sgaWYgZG91YmxlIHF1b3RlZFxuICAgIGNvbnN0IG1heWJlUXVvdGUgPSB2YWx1ZVswXVxuXG4gICAgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3Rlc1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihbJ1wiYF0pKFtcXHNcXFNdKilcXDEkL21nLCAnJDInKVxuXG4gICAgLy8gRXhwYW5kIG5ld2xpbmVzIGlmIGRvdWJsZSBxdW90ZWRcbiAgICBpZiAobWF5YmVRdW90ZSA9PT0gJ1wiJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpXG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIG9iamVjdFxuICAgIG9ialtrZXldID0gdmFsdWVcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gX3BhcnNlVmF1bHQgKG9wdGlvbnMpIHtcbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIFBhcnNlIC5lbnYudmF1bHRcbiAgY29uc3QgcmVzdWx0ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudih7IHBhdGg6IHZhdWx0UGF0aCB9KVxuICBpZiAoIXJlc3VsdC5wYXJzZWQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE1JU1NJTkdfREFUQTogQ2Fubm90IHBhcnNlICR7dmF1bHRQYXRofSBmb3IgYW4gdW5rbm93biByZWFzb25gKVxuICAgIGVyci5jb2RlID0gJ01JU1NJTkdfREFUQSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIGhhbmRsZSBzY2VuYXJpbyBmb3IgY29tbWEgc2VwYXJhdGVkIGtleXMgLSBmb3IgdXNlIHdpdGgga2V5IHJvdGF0aW9uXG4gIC8vIGV4YW1wbGU6IERPVEVOVl9LRVk9XCJkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kLGRvdGVudjovLzprZXlfNzg5MEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PXByb2RcIlxuICBjb25zdCBrZXlzID0gX2RvdGVudktleShvcHRpb25zKS5zcGxpdCgnLCcpXG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cbiAgbGV0IGRlY3J5cHRlZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBmdWxsIGtleVxuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXS50cmltKClcblxuICAgICAgLy8gR2V0IGluc3RydWN0aW9ucyBmb3IgZGVjcnlwdFxuICAgICAgY29uc3QgYXR0cnMgPSBfaW5zdHJ1Y3Rpb25zKHJlc3VsdCwga2V5KVxuXG4gICAgICAvLyBEZWNyeXB0XG4gICAgICBkZWNyeXB0ZWQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdChhdHRycy5jaXBoZXJ0ZXh0LCBhdHRycy5rZXkpXG5cbiAgICAgIGJyZWFrXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGxhc3Qga2V5XG4gICAgICBpZiAoaSArIDEgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICAvLyB0cnkgbmV4dCBrZXlcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBkZWNyeXB0ZWQgLmVudiBzdHJpbmdcbiAgcmV0dXJuIERvdGVudk1vZHVsZS5wYXJzZShkZWNyeXB0ZWQpXG59XG5cbmZ1bmN0aW9uIF93YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW1dBUk5dICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZGVidWcgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bREVCVUddICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZG90ZW52S2V5IChvcHRpb25zKSB7XG4gIC8vIHByaW9yaXRpemUgZGV2ZWxvcGVyIGRpcmVjdGx5IHNldHRpbmcgb3B0aW9ucy5ET1RFTlZfS0VZXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuRE9URU5WX0tFWSAmJiBvcHRpb25zLkRPVEVOVl9LRVkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBvcHRpb25zLkRPVEVOVl9LRVlcbiAgfVxuXG4gIC8vIHNlY29uZGFyeSBpbmZyYSBhbHJlYWR5IGNvbnRhaW5zIGEgRE9URU5WX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICBpZiAocHJvY2Vzcy5lbnYuRE9URU5WX0tFWSAmJiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuRE9URU5WX0tFWVxuICB9XG5cbiAgLy8gZmFsbGJhY2sgdG8gZW1wdHkgc3RyaW5nXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBfaW5zdHJ1Y3Rpb25zIChyZXN1bHQsIGRvdGVudktleSkge1xuICAvLyBQYXJzZSBET1RFTlZfS0VZLiBGb3JtYXQgaXMgYSBVUklcbiAgbGV0IHVyaVxuICB0cnkge1xuICAgIHVyaSA9IG5ldyBVUkwoZG90ZW52S2V5KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5jb2RlID09PSAnRVJSX0lOVkFMSURfVVJMJykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IFdyb25nIGZvcm1hdC4gTXVzdCBiZSBpbiB2YWxpZCB1cmkgZm9ybWF0IGxpa2UgZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9ZGV2ZWxvcG1lbnQnKVxuICAgICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIC8vIEdldCBkZWNyeXB0IGtleVxuICBjb25zdCBrZXkgPSB1cmkucGFzc3dvcmRcbiAgaWYgKCFrZXkpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBrZXkgcGFydCcpXG4gICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gR2V0IGVudmlyb25tZW50XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXJpLnNlYXJjaFBhcmFtcy5nZXQoJ2Vudmlyb25tZW50JylcbiAgaWYgKCFlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGVudmlyb25tZW50IHBhcnQnKVxuICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIEdldCBjaXBoZXJ0ZXh0IHBheWxvYWRcbiAgY29uc3QgZW52aXJvbm1lbnRLZXkgPSBgRE9URU5WX1ZBVUxUXyR7ZW52aXJvbm1lbnQudG9VcHBlckNhc2UoKX1gXG4gIGNvbnN0IGNpcGhlcnRleHQgPSByZXN1bHQucGFyc2VkW2Vudmlyb25tZW50S2V5XSAvLyBET1RFTlZfVkFVTFRfUFJPRFVDVElPTlxuICBpZiAoIWNpcGhlcnRleHQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE5PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlQ6IENhbm5vdCBsb2NhdGUgZW52aXJvbm1lbnQgJHtlbnZpcm9ubWVudEtleX0gaW4geW91ciAuZW52LnZhdWx0IGZpbGUuYClcbiAgICBlcnIuY29kZSA9ICdOT1RfRk9VTkRfRE9URU5WX0VOVklST05NRU5UJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgcmV0dXJuIHsgY2lwaGVydGV4dCwga2V5IH1cbn1cblxuZnVuY3Rpb24gX3ZhdWx0UGF0aCAob3B0aW9ucykge1xuICBsZXQgcG9zc2libGVWYXVsdFBhdGggPSBudWxsXG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkge1xuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XG4gICAgICAgICAgcG9zc2libGVWYXVsdFBhdGggPSBmaWxlcGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBmaWxlcGF0aCA6IGAke2ZpbGVwYXRofS52YXVsdGBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBvcHRpb25zLnBhdGggOiBgJHtvcHRpb25zLnBhdGh9LnZhdWx0YFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudi52YXVsdCcpXG4gIH1cblxuICBpZiAoZnMuZXhpc3RzU3luYyhwb3NzaWJsZVZhdWx0UGF0aCkpIHtcbiAgICByZXR1cm4gcG9zc2libGVWYXVsdFBhdGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlSG9tZSAoZW52UGF0aCkge1xuICByZXR1cm4gZW52UGF0aFswXSA9PT0gJ34nID8gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgZW52UGF0aC5zbGljZSgxKSkgOiBlbnZQYXRoXG59XG5cbmZ1bmN0aW9uIF9jb25maWdWYXVsdCAob3B0aW9ucykge1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuICBpZiAoZGVidWcpIHtcbiAgICBfZGVidWcoJ0xvYWRpbmcgZW52IGZyb20gZW5jcnlwdGVkIC5lbnYudmF1bHQnKVxuICB9XG5cbiAgY29uc3QgcGFyc2VkID0gRG90ZW52TW9kdWxlLl9wYXJzZVZhdWx0KG9wdGlvbnMpXG5cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMpXG5cbiAgcmV0dXJuIHsgcGFyc2VkIH1cbn1cblxuZnVuY3Rpb24gY29uZmlnRG90ZW52IChvcHRpb25zKSB7XG4gIGNvbnN0IGRvdGVudlBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYnKVxuICBsZXQgZW5jb2RpbmcgPSAndXRmOCdcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nXG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBfZGVidWcoJ05vIGVuY29kaW5nIGlzIHNwZWNpZmllZC4gVVRGLTggaXMgdXNlZCBieSBkZWZhdWx0JylcbiAgICB9XG4gIH1cblxuICBsZXQgb3B0aW9uUGF0aHMgPSBbZG90ZW52UGF0aF0gLy8gZGVmYXVsdCwgbG9vayBmb3IgLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhdGgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbX3Jlc29sdmVIb21lKG9wdGlvbnMucGF0aCldXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvblBhdGhzID0gW10gLy8gcmVzZXQgZGVmYXVsdFxuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgb3B0aW9uUGF0aHMucHVzaChfcmVzb2x2ZUhvbWUoZmlsZXBhdGgpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1aWxkIHRoZSBwYXJzZWQgZGF0YSBpbiBhIHRlbXBvcmFyeSBvYmplY3QgKGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm4gaXQpLiAgT25jZSB3ZSBoYXZlIHRoZSBmaW5hbFxuICAvLyBwYXJzZWQgZGF0YSwgd2Ugd2lsbCBjb21iaW5lIGl0IHdpdGggcHJvY2Vzcy5lbnYgKG9yIG9wdGlvbnMucHJvY2Vzc0VudiBpZiBwcm92aWRlZCkuXG4gIGxldCBsYXN0RXJyb3JcbiAgY29uc3QgcGFyc2VkQWxsID0ge31cbiAgZm9yIChjb25zdCBwYXRoIG9mIG9wdGlvblBhdGhzKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNwZWNpZnlpbmcgYW4gZW5jb2RpbmcgcmV0dXJucyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgYnVmZmVyXG4gICAgICBjb25zdCBwYXJzZWQgPSBEb3RlbnZNb2R1bGUucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhdGgsIHsgZW5jb2RpbmcgfSkpXG5cbiAgICAgIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwYXJzZWRBbGwsIHBhcnNlZCwgb3B0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgX2RlYnVnKGBGYWlsZWQgdG8gbG9hZCAke3BhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgICBsYXN0RXJyb3IgPSBlXG4gICAgfVxuICB9XG5cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWRBbGwsIG9wdGlvbnMpXG5cbiAgaWYgKGxhc3RFcnJvcikge1xuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsLCBlcnJvcjogbGFzdEVycm9yIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBwYXJzZWQ6IHBhcnNlZEFsbCB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGVzIHByb2Nlc3MuZW52IGZyb20gLmVudiBmaWxlXG5mdW5jdGlvbiBjb25maWcgKG9wdGlvbnMpIHtcbiAgLy8gZmFsbGJhY2sgdG8gb3JpZ2luYWwgZG90ZW52IGlmIERPVEVOVl9LRVkgaXMgbm90IHNldFxuICBpZiAoX2RvdGVudktleShvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIGRvdGVudktleSBleGlzdHMgYnV0IC5lbnYudmF1bHQgZmlsZSBkb2VzIG5vdCBleGlzdFxuICBpZiAoIXZhdWx0UGF0aCkge1xuICAgIF93YXJuKGBZb3Ugc2V0IERPVEVOVl9LRVkgYnV0IHlvdSBhcmUgbWlzc2luZyBhIC5lbnYudmF1bHQgZmlsZSBhdCAke3ZhdWx0UGF0aH0uIERpZCB5b3UgZm9yZ2V0IHRvIGJ1aWxkIGl0P2ApXG5cbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHQob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gZGVjcnlwdCAoZW5jcnlwdGVkLCBrZXlTdHIpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oa2V5U3RyLnNsaWNlKC02NCksICdoZXgnKVxuICBsZXQgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZCwgJ2Jhc2U2NCcpXG5cbiAgY29uc3Qgbm9uY2UgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIDEyKVxuICBjb25zdCBhdXRoVGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtMTYpXG4gIGNpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDEyLCAtMTYpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhZXNnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIG5vbmNlKVxuICAgIGFlc2djbS5zZXRBdXRoVGFnKGF1dGhUYWcpXG4gICAgcmV0dXJuIGAke2Flc2djbS51cGRhdGUoY2lwaGVydGV4dCl9JHthZXNnY20uZmluYWwoKX1gXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaXNSYW5nZSA9IGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvclxuICAgIGNvbnN0IGludmFsaWRLZXlMZW5ndGggPSBlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBrZXkgbGVuZ3RoJ1xuICAgIGNvbnN0IGRlY3J5cHRpb25GYWlsZWQgPSBlcnJvci5tZXNzYWdlID09PSAnVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJ1xuXG4gICAgaWYgKGlzUmFuZ2UgfHwgaW52YWxpZEtleUxlbmd0aCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IEl0IG11c3QgYmUgNjQgY2hhcmFjdGVycyBsb25nIChvciBtb3JlKScpXG4gICAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2UgaWYgKGRlY3J5cHRpb25GYWlsZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignREVDUllQVElPTl9GQUlMRUQ6IFBsZWFzZSBjaGVjayB5b3VyIERPVEVOVl9LRVknKVxuICAgICAgZXJyLmNvZGUgPSAnREVDUllQVElPTl9GQUlMRUQnXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGUgcHJvY2Vzcy5lbnYgd2l0aCBwYXJzZWQgdmFsdWVzXG5mdW5jdGlvbiBwb3B1bGF0ZSAocHJvY2Vzc0VudiwgcGFyc2VkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcbiAgY29uc3Qgb3ZlcnJpZGUgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVycmlkZSlcblxuICBpZiAodHlwZW9mIHBhcnNlZCAhPT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ09CSkVDVF9SRVFVSVJFRDogUGxlYXNlIGNoZWNrIHRoZSBwcm9jZXNzRW52IGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBwb3B1bGF0ZScpXG4gICAgZXJyLmNvZGUgPSAnT0JKRUNUX1JFUVVJUkVEJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gU2V0IHByb2Nlc3MuZW52XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcnNlZCkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3NFbnYsIGtleSkpIHtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgICAgfVxuXG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgV0FTIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3YXMgTk9UIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBEb3RlbnZNb2R1bGUgPSB7XG4gIGNvbmZpZ0RvdGVudixcbiAgX2NvbmZpZ1ZhdWx0LFxuICBfcGFyc2VWYXVsdCxcbiAgY29uZmlnLFxuICBkZWNyeXB0LFxuICBwYXJzZSxcbiAgcG9wdWxhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMuY29uZmlnRG90ZW52ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudlxubW9kdWxlLmV4cG9ydHMuX2NvbmZpZ1ZhdWx0ID0gRG90ZW52TW9kdWxlLl9jb25maWdWYXVsdFxubW9kdWxlLmV4cG9ydHMuX3BhcnNlVmF1bHQgPSBEb3RlbnZNb2R1bGUuX3BhcnNlVmF1bHRcbm1vZHVsZS5leHBvcnRzLmNvbmZpZyA9IERvdGVudk1vZHVsZS5jb25maWdcbm1vZHVsZS5leHBvcnRzLmRlY3J5cHQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBEb3RlbnZNb2R1bGUucGFyc2Vcbm1vZHVsZS5leHBvcnRzLnBvcHVsYXRlID0gRG90ZW52TW9kdWxlLnBvcHVsYXRlXG5cbm1vZHVsZS5leHBvcnRzID0gRG90ZW52TW9kdWxlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///998\n")},1002:module=>{"use strict";eval("\n\n/** @type {import('./functionApply')} */\nmodule.exports = Function.prototype.apply;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLDJCQUEyQjtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2Z1bmN0aW9uQXBwbHkuanM/ZTE2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2Z1bmN0aW9uQXBwbHknKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1002\n")},1045:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/*jshint node:true */\n\nvar Buffer = (__webpack_require__(181).Buffer); // browserify\nvar SlowBuffer = (__webpack_require__(181).SlowBuffer);\n\nmodule.exports = bufferEq;\n\nfunction bufferEq(a, b) {\n\n  // shortcutting on type is necessary for correctness\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    return false;\n  }\n\n  // buffer sizes should be well-known information, so despite this\n  // shortcutting, it doesn't leak any information about the *contents* of the\n  // buffers.\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  var c = 0;\n  for (var i = 0; i < a.length; i++) {\n    /*jshint bitwise:false */\n    c |= a[i] ^ b[i]; // XOR\n  }\n  return c === 0;\n}\n\nbufferEq.install = function() {\n  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {\n    return bufferEq(this, that);\n  };\n};\n\nvar origBufEqual = Buffer.prototype.equal;\nvar origSlowBufEqual = SlowBuffer.prototype.equal;\nbufferEq.restore = function() {\n  Buffer.prototype.equal = origBufEqual;\n  SlowBuffer.prototype.equal = origSlowBufEqual;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA0NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsYUFBYSxpQ0FBd0IsRUFBRTtBQUN2QyxpQkFBaUIscUNBQTRCOztBQUU3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9idWZmZXItZXF1YWwtY29uc3RhbnQtdGltZS9pbmRleC5qcz9iNWNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjsgLy8gYnJvd3NlcmlmeVxudmFyIFNsb3dCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5TbG93QnVmZmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlckVxO1xuXG5mdW5jdGlvbiBidWZmZXJFcShhLCBiKSB7XG5cbiAgLy8gc2hvcnRjdXR0aW5nIG9uIHR5cGUgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0bmVzc1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gYnVmZmVyIHNpemVzIHNob3VsZCBiZSB3ZWxsLWtub3duIGluZm9ybWF0aW9uLCBzbyBkZXNwaXRlIHRoaXNcbiAgLy8gc2hvcnRjdXR0aW5nLCBpdCBkb2Vzbid0IGxlYWsgYW55IGluZm9ybWF0aW9uIGFib3V0IHRoZSAqY29udGVudHMqIG9mIHRoZVxuICAvLyBidWZmZXJzLlxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAvKmpzaGludCBiaXR3aXNlOmZhbHNlICovXG4gICAgYyB8PSBhW2ldIF4gYltpXTsgLy8gWE9SXG4gIH1cbiAgcmV0dXJuIGMgPT09IDA7XG59XG5cbmJ1ZmZlckVxLmluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5lcXVhbCA9IFNsb3dCdWZmZXIucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gZXF1YWwodGhhdCkge1xuICAgIHJldHVybiBidWZmZXJFcSh0aGlzLCB0aGF0KTtcbiAgfTtcbn07XG5cbnZhciBvcmlnQnVmRXF1YWwgPSBCdWZmZXIucHJvdG90eXBlLmVxdWFsO1xudmFyIG9yaWdTbG93QnVmRXF1YWwgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5lcXVhbDtcbmJ1ZmZlckVxLnJlc3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5lcXVhbCA9IG9yaWdCdWZFcXVhbDtcbiAgU2xvd0J1ZmZlci5wcm90b3R5cGUuZXF1YWwgPSBvcmlnU2xvd0J1ZkVxdWFsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1045\n")},1064:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar $Object = __webpack_require__(9612);\n\n/** @type {import('./Object.getPrototypeOf')} */\nmodule.exports = $Object.getPrototypeOf || null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsSUFBaUI7O0FBRXZDLFdBQVcsbUNBQW1DO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvZ2V0LXByb3RvL09iamVjdC5nZXRQcm90b3R5cGVPZi5qcz8xN2JjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyICRPYmplY3QgPSByZXF1aXJlKCdlcy1vYmplY3QtYXRvbXMnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vT2JqZWN0LmdldFByb3RvdHlwZU9mJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgbnVsbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1064\n")},1123:module=>{"use strict";eval("\n\nconst numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyMy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanM/Mjg3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1123\n")},1237:module=>{"use strict";eval("\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIzNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGtCQUFrQjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9ldmFsLmpzPzQxN2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9ldmFsJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWxFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1237\n")},1261:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst Range = __webpack_require__(8311)\nconst gt = __webpack_require__(5580)\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLElBQWtCO0FBQ3hDLFdBQVcsbUJBQU8sQ0FBQyxJQUFpQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQkFBb0I7QUFDdkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanM/OTY0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcblxuY29uc3QgbWluVmVyc2lvbiA9IChyYW5nZSwgbG9vc2UpID0+IHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKVxuXG4gIGxldCBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG51bGxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IHNldE1pbiA9IG51bGxcbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAvLyBDbG9uZSB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNvbXBhcmF0b3IncyBzZW12ZXIgb2JqZWN0LlxuICAgICAgY29uc3QgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbilcbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB2ZXIucmF3ID0gY29tcHZlci5mb3JtYXQoKVxuICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBpZiAoIXNldE1pbiB8fCBndChjb21wdmVyLCBzZXRNaW4pKSB7XG4gICAgICAgICAgICBzZXRNaW4gPSBjb21wdmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi9cbiAgICAgICAgICBicmVha1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvcGVyYXRpb246ICR7Y29tcGFyYXRvci5vcGVyYXRvcn1gKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHNldE1pbiAmJiAoIW1pbnZlciB8fCBndChtaW52ZXIsIHNldE1pbikpKSB7XG4gICAgICBtaW52ZXIgPSBzZXRNaW5cbiAgICB9XG4gIH1cblxuICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblZlcnNpb25cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1261\n")},1288:n=>{"use strict";n.exports=require("electron")},1333:module=>{"use strict";eval("\n\n/** @type {import('./shams')} */\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLDRDQUE0Qzs7QUFFNUMsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQyxrRUFBa0U7QUFDbEUscUVBQXFFOztBQUVyRTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHVDQUF1Qzs7QUFFdkMsMkRBQTJEO0FBQzNELCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEMsMkVBQTJFOztBQUUzRSx5R0FBeUc7O0FBRXpHO0FBQ0EsNkNBQTZDOztBQUU3Qyw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xELHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanM/MTY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3NoYW1zJyl9ICovXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdC8qKiBAdHlwZSB7eyBbayBpbiBzeW1ib2xdPzogdW5rbm93biB9fSAqL1xuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHZhciBfIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblx0XHR2YXIgZGVzY3JpcHRvciA9IC8qKiBAdHlwZSB7UHJvcGVydHlEZXNjcmlwdG9yfSAqLyAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSkpO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1333\n")},1362:module=>{eval("// populates missing values\nmodule.exports = function(dst, src) {\n\n  Object.keys(src).forEach(function(prop)\n  {\n    dst[prop] = dst[prop] || src[prop];\n  });\n\n  return dst;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM2Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS9saWIvcG9wdWxhdGUuanM/MTIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwb3B1bGF0ZXMgbWlzc2luZyB2YWx1ZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZHN0LCBzcmMpIHtcblxuICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goZnVuY3Rpb24ocHJvcClcbiAge1xuICAgIGRzdFtwcm9wXSA9IGRzdFtwcm9wXSB8fCBzcmNbcHJvcF07XG4gIH0pO1xuXG4gIHJldHVybiBkc3Q7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1362\n")},1514:module=>{"use strict";eval("\n\n/** @type {import('./abs')} */\nmodule.exports = Math.abs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUxNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGlCQUFpQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9hYnMuanM/MTdhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2FicycpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmFicztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1514\n")},1691:(module,__unused_webpack_exports,__webpack_require__)=>{eval("const JsonWebTokenError = __webpack_require__(1741);\nconst NotBeforeError = __webpack_require__(3726);\nconst TokenExpiredError = __webpack_require__(8980);\nconst decode = __webpack_require__(7260);\nconst timespan = __webpack_require__(855);\nconst validateAsymmetricKey = __webpack_require__(7019);\nconst PS_SUPPORTED = __webpack_require__(4977);\nconst jws = __webpack_require__(5747);\nconst {KeyObject, createSecretKey, createPublicKey} = __webpack_require__(6982);\n\nconst PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];\nconst RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\nconst HS_ALGS = ['HS256', 'HS384', 'HS512'];\n\nif (PS_SUPPORTED) {\n  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');\n}\n\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\n  if ((typeof options === 'function') && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  //clone this object since we are going to mutate it.\n  options = Object.assign({}, options);\n\n  let done;\n\n  if (callback) {\n    done = callback;\n  } else {\n    done = function(err, data) {\n      if (err) throw err;\n      return data;\n    };\n  }\n\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\n  }\n\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\n  }\n\n  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {\n    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));\n  }\n\n  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\n\n  if (!jwtString){\n    return done(new JsonWebTokenError('jwt must be provided'));\n  }\n\n  if (typeof jwtString !== 'string') {\n    return done(new JsonWebTokenError('jwt must be a string'));\n  }\n\n  const parts = jwtString.split('.');\n\n  if (parts.length !== 3){\n    return done(new JsonWebTokenError('jwt malformed'));\n  }\n\n  let decodedToken;\n\n  try {\n    decodedToken = decode(jwtString, { complete: true });\n  } catch(err) {\n    return done(err);\n  }\n\n  if (!decodedToken) {\n    return done(new JsonWebTokenError('invalid token'));\n  }\n\n  const header = decodedToken.header;\n  let getSecret;\n\n  if(typeof secretOrPublicKey === 'function') {\n    if(!callback) {\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\n    }\n\n    getSecret = secretOrPublicKey;\n  }\n  else {\n    getSecret = function(header, secretCallback) {\n      return secretCallback(null, secretOrPublicKey);\n    };\n  }\n\n  return getSecret(header, function(err, secretOrPublicKey) {\n    if(err) {\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\n    }\n\n    const hasSignature = parts[2].trim() !== '';\n\n    if (!hasSignature && secretOrPublicKey){\n      return done(new JsonWebTokenError('jwt signature is required'));\n    }\n\n    if (hasSignature && !secretOrPublicKey) {\n      return done(new JsonWebTokenError('secret or public key must be provided'));\n    }\n\n    if (!hasSignature && !options.algorithms) {\n      return done(new JsonWebTokenError('please specify \"none\" in \"algorithms\" to verify unsigned tokens'));\n    }\n\n    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {\n      try {\n        secretOrPublicKey = createPublicKey(secretOrPublicKey);\n      } catch (_) {\n        try {\n          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);\n        } catch (_) {\n          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))\n        }\n      }\n    }\n\n    if (!options.algorithms) {\n      if (secretOrPublicKey.type === 'secret') {\n        options.algorithms = HS_ALGS;\n      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {\n        options.algorithms = RSA_KEY_ALGS\n      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {\n        options.algorithms = EC_KEY_ALGS\n      } else {\n        options.algorithms = PUB_KEY_ALGS\n      }\n    }\n\n    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {\n      return done(new JsonWebTokenError('invalid algorithm'));\n    }\n\n    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))\n    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {\n      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))\n    }\n\n    if (!options.allowInvalidAsymmetricKeyTypes) {\n      try {\n        validateAsymmetricKey(header.alg, secretOrPublicKey);\n      } catch (e) {\n        return done(e);\n      }\n    }\n\n    let valid;\n\n    try {\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\n    } catch (e) {\n      return done(e);\n    }\n\n    if (!valid) {\n      return done(new JsonWebTokenError('invalid signature'));\n    }\n\n    const payload = decodedToken.payload;\n\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\n      if (typeof payload.nbf !== 'number') {\n        return done(new JsonWebTokenError('invalid nbf value'));\n      }\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\n      }\n    }\n\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\n      if (typeof payload.exp !== 'number') {\n        return done(new JsonWebTokenError('invalid exp value'));\n      }\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\n      }\n    }\n\n    if (options.audience) {\n      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\n      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n\n      const match = target.some(function (targetAudience) {\n        return audiences.some(function (audience) {\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\n        });\n      });\n\n      if (!match) {\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\n      }\n    }\n\n    if (options.issuer) {\n      const invalid_issuer =\n              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\n              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\n\n      if (invalid_issuer) {\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\n      }\n    }\n\n    if (options.subject) {\n      if (payload.sub !== options.subject) {\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\n      }\n    }\n\n    if (options.jwtid) {\n      if (payload.jti !== options.jwtid) {\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\n      }\n    }\n\n    if (options.nonce) {\n      if (payload.nonce !== options.nonce) {\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\n      }\n    }\n\n    if (options.maxAge) {\n      if (typeof payload.iat !== 'number') {\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\n      }\n\n      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);\n      if (typeof maxAgeTimestamp === 'undefined') {\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n      }\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\n      }\n    }\n\n    if (options.complete === true) {\n      const signature = decodedToken.signature;\n\n      return done(null, {\n        header: header,\n        payload: payload,\n        signature: signature\n      });\n    }\n\n    return done(null, payload);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwQkFBMEIsbUJBQU8sQ0FBQyxJQUF5QjtBQUMzRCx1QkFBdUIsbUJBQU8sQ0FBQyxJQUFzQjtBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyxJQUF5QjtBQUMzRCxlQUFlLG1CQUFPLENBQUMsSUFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxHQUFnQjtBQUN6Qyw4QkFBOEIsbUJBQU8sQ0FBQyxJQUE2QjtBQUNuRSxxQkFBcUIsbUJBQU8sQ0FBQyxJQUFtQjtBQUNoRCxZQUFZLG1CQUFPLENBQUMsSUFBSztBQUN6QixPQUFPLDZDQUE2QyxFQUFFLG1CQUFPLENBQUMsSUFBUTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpR0FBaUcsV0FBVztBQUM1RyxNQUFNO0FBQ04sbUdBQW1HLFdBQVc7QUFDOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvanNvbndlYnRva2VuL3ZlcmlmeS5qcz8wZWVjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEpzb25XZWJUb2tlbkVycm9yID0gcmVxdWlyZSgnLi9saWIvSnNvbldlYlRva2VuRXJyb3InKTtcbmNvbnN0IE5vdEJlZm9yZUVycm9yID0gcmVxdWlyZSgnLi9saWIvTm90QmVmb3JlRXJyb3InKTtcbmNvbnN0IFRva2VuRXhwaXJlZEVycm9yID0gcmVxdWlyZSgnLi9saWIvVG9rZW5FeHBpcmVkRXJyb3InKTtcbmNvbnN0IGRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5jb25zdCB0aW1lc3BhbiA9IHJlcXVpcmUoJy4vbGliL3RpbWVzcGFuJyk7XG5jb25zdCB2YWxpZGF0ZUFzeW1tZXRyaWNLZXkgPSByZXF1aXJlKCcuL2xpYi92YWxpZGF0ZUFzeW1tZXRyaWNLZXknKTtcbmNvbnN0IFBTX1NVUFBPUlRFRCA9IHJlcXVpcmUoJy4vbGliL3BzU3VwcG9ydGVkJyk7XG5jb25zdCBqd3MgPSByZXF1aXJlKCdqd3MnKTtcbmNvbnN0IHtLZXlPYmplY3QsIGNyZWF0ZVNlY3JldEtleSwgY3JlYXRlUHVibGljS2V5fSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5cbmNvbnN0IFBVQl9LRVlfQUxHUyA9IFsnUlMyNTYnLCAnUlMzODQnLCAnUlM1MTInXTtcbmNvbnN0IEVDX0tFWV9BTEdTID0gWydFUzI1NicsICdFUzM4NCcsICdFUzUxMiddO1xuY29uc3QgUlNBX0tFWV9BTEdTID0gWydSUzI1NicsICdSUzM4NCcsICdSUzUxMiddO1xuY29uc3QgSFNfQUxHUyA9IFsnSFMyNTYnLCAnSFMzODQnLCAnSFM1MTInXTtcblxuaWYgKFBTX1NVUFBPUlRFRCkge1xuICBQVUJfS0VZX0FMR1Muc3BsaWNlKFBVQl9LRVlfQUxHUy5sZW5ndGgsIDAsICdQUzI1NicsICdQUzM4NCcsICdQUzUxMicpO1xuICBSU0FfS0VZX0FMR1Muc3BsaWNlKFJTQV9LRVlfQUxHUy5sZW5ndGgsIDAsICdQUzI1NicsICdQUzM4NCcsICdQUzUxMicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChqd3RTdHJpbmcsIHNlY3JldE9yUHVibGljS2V5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAoKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSAmJiAhY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy9jbG9uZSB0aGlzIG9iamVjdCBzaW5jZSB3ZSBhcmUgZ29pbmcgdG8gbXV0YXRlIGl0LlxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgbGV0IGRvbmU7XG5cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZG9uZSA9IGNhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIGRvbmUgPSBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHRocm93IGVycjtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gIH1cblxuICBpZiAob3B0aW9ucy5jbG9ja1RpbWVzdGFtcCAmJiB0eXBlb2Ygb3B0aW9ucy5jbG9ja1RpbWVzdGFtcCAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2Nsb2NrVGltZXN0YW1wIG11c3QgYmUgYSBudW1iZXInKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5ub25jZSAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0aW9ucy5ub25jZSAhPT0gJ3N0cmluZycgfHwgb3B0aW9ucy5ub25jZS50cmltKCkgPT09ICcnKSkge1xuICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignbm9uY2UgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5hbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXMgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignYWxsb3dJbnZhbGlkQXN5bW1ldHJpY0tleVR5cGVzIG11c3QgYmUgYSBib29sZWFuJykpO1xuICB9XG5cbiAgY29uc3QgY2xvY2tUaW1lc3RhbXAgPSBvcHRpb25zLmNsb2NrVGltZXN0YW1wIHx8IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gIGlmICghand0U3RyaW5nKXtcbiAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBtdXN0IGJlIHByb3ZpZGVkJykpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBqd3RTdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdqd3QgbXVzdCBiZSBhIHN0cmluZycpKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnRzID0gand0U3RyaW5nLnNwbGl0KCcuJyk7XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMyl7XG4gICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdqd3QgbWFsZm9ybWVkJykpO1xuICB9XG5cbiAgbGV0IGRlY29kZWRUb2tlbjtcblxuICB0cnkge1xuICAgIGRlY29kZWRUb2tlbiA9IGRlY29kZShqd3RTdHJpbmcsIHsgY29tcGxldGU6IHRydWUgfSk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgfVxuXG4gIGlmICghZGVjb2RlZFRva2VuKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdpbnZhbGlkIHRva2VuJykpO1xuICB9XG5cbiAgY29uc3QgaGVhZGVyID0gZGVjb2RlZFRva2VuLmhlYWRlcjtcbiAgbGV0IGdldFNlY3JldDtcblxuICBpZih0eXBlb2Ygc2VjcmV0T3JQdWJsaWNLZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZighY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcigndmVyaWZ5IG11c3QgYmUgY2FsbGVkIGFzeW5jaHJvbm91cyBpZiBzZWNyZXQgb3IgcHVibGljIGtleSBpcyBwcm92aWRlZCBhcyBhIGNhbGxiYWNrJykpO1xuICAgIH1cblxuICAgIGdldFNlY3JldCA9IHNlY3JldE9yUHVibGljS2V5O1xuICB9XG4gIGVsc2Uge1xuICAgIGdldFNlY3JldCA9IGZ1bmN0aW9uKGhlYWRlciwgc2VjcmV0Q2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBzZWNyZXRDYWxsYmFjayhudWxsLCBzZWNyZXRPclB1YmxpY0tleSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBnZXRTZWNyZXQoaGVhZGVyLCBmdW5jdGlvbihlcnIsIHNlY3JldE9yUHVibGljS2V5KSB7XG4gICAgaWYoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2Vycm9yIGluIHNlY3JldCBvciBwdWJsaWMga2V5IGNhbGxiYWNrOiAnICsgZXJyLm1lc3NhZ2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNTaWduYXR1cmUgPSBwYXJ0c1syXS50cmltKCkgIT09ICcnO1xuXG4gICAgaWYgKCFoYXNTaWduYXR1cmUgJiYgc2VjcmV0T3JQdWJsaWNLZXkpe1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdqd3Qgc2lnbmF0dXJlIGlzIHJlcXVpcmVkJykpO1xuICAgIH1cblxuICAgIGlmIChoYXNTaWduYXR1cmUgJiYgIXNlY3JldE9yUHVibGljS2V5KSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ3NlY3JldCBvciBwdWJsaWMga2V5IG11c3QgYmUgcHJvdmlkZWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNTaWduYXR1cmUgJiYgIW9wdGlvbnMuYWxnb3JpdGhtcykge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdwbGVhc2Ugc3BlY2lmeSBcIm5vbmVcIiBpbiBcImFsZ29yaXRobXNcIiB0byB2ZXJpZnkgdW5zaWduZWQgdG9rZW5zJykpO1xuICAgIH1cblxuICAgIGlmIChzZWNyZXRPclB1YmxpY0tleSAhPSBudWxsICYmICEoc2VjcmV0T3JQdWJsaWNLZXkgaW5zdGFuY2VvZiBLZXlPYmplY3QpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWNyZXRPclB1YmxpY0tleSA9IGNyZWF0ZVB1YmxpY0tleShzZWNyZXRPclB1YmxpY0tleSk7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VjcmV0T3JQdWJsaWNLZXkgPSBjcmVhdGVTZWNyZXRLZXkodHlwZW9mIHNlY3JldE9yUHVibGljS2V5ID09PSAnc3RyaW5nJyA/IEJ1ZmZlci5mcm9tKHNlY3JldE9yUHVibGljS2V5KSA6IHNlY3JldE9yUHVibGljS2V5KTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignc2VjcmV0T3JQdWJsaWNLZXkgaXMgbm90IHZhbGlkIGtleSBtYXRlcmlhbCcpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmFsZ29yaXRobXMpIHtcbiAgICAgIGlmIChzZWNyZXRPclB1YmxpY0tleS50eXBlID09PSAnc2VjcmV0Jykge1xuICAgICAgICBvcHRpb25zLmFsZ29yaXRobXMgPSBIU19BTEdTO1xuICAgICAgfSBlbHNlIGlmIChbJ3JzYScsICdyc2EtcHNzJ10uaW5jbHVkZXMoc2VjcmV0T3JQdWJsaWNLZXkuYXN5bW1ldHJpY0tleVR5cGUpKSB7XG4gICAgICAgIG9wdGlvbnMuYWxnb3JpdGhtcyA9IFJTQV9LRVlfQUxHU1xuICAgICAgfSBlbHNlIGlmIChzZWNyZXRPclB1YmxpY0tleS5hc3ltbWV0cmljS2V5VHlwZSA9PT0gJ2VjJykge1xuICAgICAgICBvcHRpb25zLmFsZ29yaXRobXMgPSBFQ19LRVlfQUxHU1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5hbGdvcml0aG1zID0gUFVCX0tFWV9BTEdTXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtcy5pbmRleE9mKGRlY29kZWRUb2tlbi5oZWFkZXIuYWxnKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignaW52YWxpZCBhbGdvcml0aG0nKSk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5hbGcuc3RhcnRzV2l0aCgnSFMnKSAmJiBzZWNyZXRPclB1YmxpY0tleS50eXBlICE9PSAnc2VjcmV0Jykge1xuICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKChgc2VjcmV0T3JQdWJsaWNLZXkgbXVzdCBiZSBhIHN5bW1ldHJpYyBrZXkgd2hlbiB1c2luZyAke2hlYWRlci5hbGd9YCkpKVxuICAgIH0gZWxzZSBpZiAoL14oPzpSU3xQU3xFUykvLnRlc3QoaGVhZGVyLmFsZykgJiYgc2VjcmV0T3JQdWJsaWNLZXkudHlwZSAhPT0gJ3B1YmxpYycpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcigoYHNlY3JldE9yUHVibGljS2V5IG11c3QgYmUgYW4gYXN5bW1ldHJpYyBrZXkgd2hlbiB1c2luZyAke2hlYWRlci5hbGd9YCkpKVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5hbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlQXN5bW1ldHJpY0tleShoZWFkZXIuYWxnLCBzZWNyZXRPclB1YmxpY0tleSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkb25lKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB2YWxpZDtcblxuICAgIHRyeSB7XG4gICAgICB2YWxpZCA9IGp3cy52ZXJpZnkoand0U3RyaW5nLCBkZWNvZGVkVG9rZW4uaGVhZGVyLmFsZywgc2VjcmV0T3JQdWJsaWNLZXkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBkb25lKGUpO1xuICAgIH1cblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignaW52YWxpZCBzaWduYXR1cmUnKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZWRUb2tlbi5wYXlsb2FkO1xuXG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLm5iZiAhPT0gJ3VuZGVmaW5lZCcgJiYgIW9wdGlvbnMuaWdub3JlTm90QmVmb3JlKSB7XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQubmJmICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2ludmFsaWQgbmJmIHZhbHVlJykpO1xuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQubmJmID4gY2xvY2tUaW1lc3RhbXAgKyAob3B0aW9ucy5jbG9ja1RvbGVyYW5jZSB8fCAwKSkge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgTm90QmVmb3JlRXJyb3IoJ2p3dCBub3QgYWN0aXZlJywgbmV3IERhdGUocGF5bG9hZC5uYmYgKiAxMDAwKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGF5bG9hZC5leHAgIT09ICd1bmRlZmluZWQnICYmICFvcHRpb25zLmlnbm9yZUV4cGlyYXRpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5leHAgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignaW52YWxpZCBleHAgdmFsdWUnKSk7XG4gICAgICB9XG4gICAgICBpZiAoY2xvY2tUaW1lc3RhbXAgPj0gcGF5bG9hZC5leHAgKyAob3B0aW9ucy5jbG9ja1RvbGVyYW5jZSB8fCAwKSkge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgVG9rZW5FeHBpcmVkRXJyb3IoJ2p3dCBleHBpcmVkJywgbmV3IERhdGUocGF5bG9hZC5leHAgKiAxMDAwKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmF1ZGllbmNlKSB7XG4gICAgICBjb25zdCBhdWRpZW5jZXMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXVkaWVuY2UpID8gb3B0aW9ucy5hdWRpZW5jZSA6IFtvcHRpb25zLmF1ZGllbmNlXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IEFycmF5LmlzQXJyYXkocGF5bG9hZC5hdWQpID8gcGF5bG9hZC5hdWQgOiBbcGF5bG9hZC5hdWRdO1xuXG4gICAgICBjb25zdCBtYXRjaCA9IHRhcmdldC5zb21lKGZ1bmN0aW9uICh0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICByZXR1cm4gYXVkaWVuY2VzLnNvbWUoZnVuY3Rpb24gKGF1ZGllbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGF1ZGllbmNlIGluc3RhbmNlb2YgUmVnRXhwID8gYXVkaWVuY2UudGVzdCh0YXJnZXRBdWRpZW5jZSkgOiBhdWRpZW5jZSA9PT0gdGFyZ2V0QXVkaWVuY2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEpzb25XZWJUb2tlbkVycm9yKCdqd3QgYXVkaWVuY2UgaW52YWxpZC4gZXhwZWN0ZWQ6ICcgKyBhdWRpZW5jZXMuam9pbignIG9yICcpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaXNzdWVyKSB7XG4gICAgICBjb25zdCBpbnZhbGlkX2lzc3VlciA9XG4gICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5pc3N1ZXIgPT09ICdzdHJpbmcnICYmIHBheWxvYWQuaXNzICE9PSBvcHRpb25zLmlzc3VlcikgfHxcbiAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5pc3N1ZXIpICYmIG9wdGlvbnMuaXNzdWVyLmluZGV4T2YocGF5bG9hZC5pc3MpID09PSAtMSk7XG5cbiAgICAgIGlmIChpbnZhbGlkX2lzc3Vlcikge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBpc3N1ZXIgaW52YWxpZC4gZXhwZWN0ZWQ6ICcgKyBvcHRpb25zLmlzc3VlcikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN1YmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLnN1YiAhPT0gb3B0aW9ucy5zdWJqZWN0KSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignand0IHN1YmplY3QgaW52YWxpZC4gZXhwZWN0ZWQ6ICcgKyBvcHRpb25zLnN1YmplY3QpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5qd3RpZCkge1xuICAgICAgaWYgKHBheWxvYWQuanRpICE9PSBvcHRpb25zLmp3dGlkKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignand0IGp3dGlkIGludmFsaWQuIGV4cGVjdGVkOiAnICsgb3B0aW9ucy5qd3RpZCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlKSB7XG4gICAgICBpZiAocGF5bG9hZC5ub25jZSAhPT0gb3B0aW9ucy5ub25jZSkge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ2p3dCBub25jZSBpbnZhbGlkLiBleHBlY3RlZDogJyArIG9wdGlvbnMubm9uY2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5pYXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBKc29uV2ViVG9rZW5FcnJvcignaWF0IHJlcXVpcmVkIHdoZW4gbWF4QWdlIGlzIHNwZWNpZmllZCcpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF4QWdlVGltZXN0YW1wID0gdGltZXNwYW4ob3B0aW9ucy5tYXhBZ2UsIHBheWxvYWQuaWF0KTtcbiAgICAgIGlmICh0eXBlb2YgbWF4QWdlVGltZXN0YW1wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZG9uZShuZXcgSnNvbldlYlRva2VuRXJyb3IoJ1wibWF4QWdlXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMgb3Igc3RyaW5nIHJlcHJlc2VudGluZyBhIHRpbWVzcGFuIGVnOiBcIjFkXCIsIFwiMjBoXCIsIDYwJykpO1xuICAgICAgfVxuICAgICAgaWYgKGNsb2NrVGltZXN0YW1wID49IG1heEFnZVRpbWVzdGFtcCArIChvcHRpb25zLmNsb2NrVG9sZXJhbmNlIHx8IDApKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBUb2tlbkV4cGlyZWRFcnJvcignbWF4QWdlIGV4Y2VlZGVkJywgbmV3IERhdGUobWF4QWdlVGltZXN0YW1wICogMTAwMCkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jb21wbGV0ZSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZGVjb2RlZFRva2VuLnNpZ25hdHVyZTtcblxuICAgICAgcmV0dXJuIGRvbmUobnVsbCwge1xuICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkb25lKG51bGwsIHBheWxvYWQpO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1691\n")},1729:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst parse = __webpack_require__(144)\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyOS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsR0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzPzNiZDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1729\n")},1741:module=>{eval("var JsonWebTokenError = function (message, error) {\n  Error.call(this, message);\n  if(Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  }\n  this.name = 'JsonWebTokenError';\n  this.message = message;\n  if (error) this.inner = error;\n};\n\nJsonWebTokenError.prototype = Object.create(Error.prototype);\nJsonWebTokenError.prototype.constructor = JsonWebTokenError;\n\nmodule.exports = JsonWebTokenError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc0MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9saWIvSnNvbldlYlRva2VuRXJyb3IuanM/MjkxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSnNvbldlYlRva2VuRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3IpIHtcbiAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgaWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxuICB0aGlzLm5hbWUgPSAnSnNvbldlYlRva2VuRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICBpZiAoZXJyb3IpIHRoaXMuaW5uZXIgPSBlcnJvcjtcbn07XG5cbkpzb25XZWJUb2tlbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkpzb25XZWJUb2tlbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpzb25XZWJUb2tlbkVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25XZWJUb2tlbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1741\n")},1763:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc2My5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanM/ZjE4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTG9vc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1763\n")},1813:n=>{"use strict";n.exports=JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}')},1832:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst parse = __webpack_require__(144)\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // If the main part has no difference\n    if (lowVersion.compareMain(highVersion) === 0) {\n      if (lowVersion.minor && !lowVersion.patch) {\n        return 'minor'\n      }\n      return 'patch'\n    }\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgzMi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsR0FBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanM/NjI3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMiwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgY29tcGFyaXNvbiA9IHYxLmNvbXBhcmUodjIpXG5cbiAgaWYgKGNvbXBhcmlzb24gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdjFIaWdoZXIgPSBjb21wYXJpc29uID4gMFxuICBjb25zdCBoaWdoVmVyc2lvbiA9IHYxSGlnaGVyID8gdjEgOiB2MlxuICBjb25zdCBsb3dWZXJzaW9uID0gdjFIaWdoZXIgPyB2MiA6IHYxXG4gIGNvbnN0IGhpZ2hIYXNQcmUgPSAhIWhpZ2hWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG4gIGNvbnN0IGxvd0hhc1ByZSA9ICEhbG93VmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aFxuXG4gIGlmIChsb3dIYXNQcmUgJiYgIWhpZ2hIYXNQcmUpIHtcbiAgICAvLyBHb2luZyBmcm9tIHByZXJlbGVhc2UgLT4gbm8gcHJlcmVsZWFzZSByZXF1aXJlcyBzb21lIHNwZWNpYWwgY2FzaW5nXG5cbiAgICAvLyBJZiB0aGUgbG93IHZlcnNpb24gaGFzIG9ubHkgYSBtYWpvciwgdGhlbiBpdCB3aWxsIGFsd2F5cyBiZSBhIG1ham9yXG4gICAgLy8gU29tZSBleGFtcGxlczpcbiAgICAvLyAxLjAuMC0xIC0+IDEuMC4wXG4gICAgLy8gMS4wLjAtMSAtPiAxLjEuMVxuICAgIC8vIDEuMC4wLTEgLT4gMi4wLjBcbiAgICBpZiAoIWxvd1ZlcnNpb24ucGF0Y2ggJiYgIWxvd1ZlcnNpb24ubWlub3IpIHtcbiAgICAgIHJldHVybiAnbWFqb3InXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG1haW4gcGFydCBoYXMgbm8gZGlmZmVyZW5jZVxuICAgIGlmIChsb3dWZXJzaW9uLmNvbXBhcmVNYWluKGhpZ2hWZXJzaW9uKSA9PT0gMCkge1xuICAgICAgaWYgKGxvd1ZlcnNpb24ubWlub3IgJiYgIWxvd1ZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuICdtaW5vcidcbiAgICAgIH1cbiAgICAgIHJldHVybiAncGF0Y2gnXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRoZSBgcHJlYCBwcmVmaXggaWYgd2UgYXJlIGdvaW5nIHRvIGEgcHJlcmVsZWFzZSB2ZXJzaW9uXG4gIGNvbnN0IHByZWZpeCA9IGhpZ2hIYXNQcmUgPyAncHJlJyA6ICcnXG5cbiAgaWYgKHYxLm1ham9yICE9PSB2Mi5tYWpvcikge1xuICAgIHJldHVybiBwcmVmaXggKyAnbWFqb3InXG4gIH1cblxuICBpZiAodjEubWlub3IgIT09IHYyLm1pbm9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtaW5vcidcbiAgfVxuXG4gIGlmICh2MS5wYXRjaCAhPT0gdjIucGF0Y2gpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ3BhdGNoJ1xuICB9XG5cbiAgLy8gaGlnaCBhbmQgbG93IGFyZSBwcmVsZWFzZXNcbiAgcmV0dXJuICdwcmVyZWxlYXNlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1832\n")},1873:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports =\n{\n  parallel      : __webpack_require__(8798),\n  serial        : __webpack_require__(2081),\n  serialOrdered : __webpack_require__(28)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsSUFBZTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFhO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLEVBQW9CO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvaW5kZXguanM/OTYyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG57XG4gIHBhcmFsbGVsICAgICAgOiByZXF1aXJlKCcuL3BhcmFsbGVsLmpzJyksXG4gIHNlcmlhbCAgICAgICAgOiByZXF1aXJlKCcuL3NlcmlhbC5qcycpLFxuICBzZXJpYWxPcmRlcmVkIDogcmVxdWlyZSgnLi9zZXJpYWxPcmRlcmVkLmpzJylcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1873\n")},1880:module=>{eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/NzgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1880\n")},1977:(module,__unused_webpack_exports,__webpack_require__)=>{eval("const semver = __webpack_require__(9589);\n\nmodule.exports = semver.satisfies(process.version, '>=15.7.0');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBUTs7QUFFL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9qc29ud2VidG9rZW4vbGliL2FzeW1tZXRyaWNLZXlEZXRhaWxzU3VwcG9ydGVkLmpzP2NkNzMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2VtdmVyLnNhdGlzZmllcyhwcm9jZXNzLnZlcnNpb24sICc+PTE1LjcuMCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1977\n")},2010:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar Buffer = (__webpack_require__(2861).Buffer);\n\nvar getParamBytesForAlg = __webpack_require__(3527);\n\nvar MAX_OCTET = 0x80,\n\tCLASS_UNIVERSAL = 0,\n\tPRIMITIVE_BIT = 0x20,\n\tTAG_SEQ = 0x10,\n\tTAG_INT = 0x02,\n\tENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),\n\tENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);\n\nfunction base64Url(base64) {\n\treturn base64\n\t\t.replace(/=/g, '')\n\t\t.replace(/\\+/g, '-')\n\t\t.replace(/\\//g, '_');\n}\n\nfunction signatureAsBuffer(signature) {\n\tif (Buffer.isBuffer(signature)) {\n\t\treturn signature;\n\t} else if ('string' === typeof signature) {\n\t\treturn Buffer.from(signature, 'base64');\n\t}\n\n\tthrow new TypeError('ECDSA signature must be a Base64 string or a Buffer');\n}\n\nfunction derToJose(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\t// the DER encoded param should at most be the param size, plus a padding\n\t// zero, since due to being a signed integer\n\tvar maxEncodedParamLength = paramBytes + 1;\n\n\tvar inputLength = signature.length;\n\n\tvar offset = 0;\n\tif (signature[offset++] !== ENCODED_TAG_SEQ) {\n\t\tthrow new Error('Could not find expected \"seq\"');\n\t}\n\n\tvar seqLength = signature[offset++];\n\tif (seqLength === (MAX_OCTET | 1)) {\n\t\tseqLength = signature[offset++];\n\t}\n\n\tif (inputLength - offset < seqLength) {\n\t\tthrow new Error('\"seq\" specified length of \"' + seqLength + '\", only \"' + (inputLength - offset) + '\" remaining');\n\t}\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"r\"');\n\t}\n\n\tvar rLength = signature[offset++];\n\n\tif (inputLength - offset - 2 < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", only \"' + (inputLength - offset - 2) + '\" available');\n\t}\n\n\tif (maxEncodedParamLength < rLength) {\n\t\tthrow new Error('\"r\" specified length of \"' + rLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar rOffset = offset;\n\toffset += rLength;\n\n\tif (signature[offset++] !== ENCODED_TAG_INT) {\n\t\tthrow new Error('Could not find expected \"int\" for \"s\"');\n\t}\n\n\tvar sLength = signature[offset++];\n\n\tif (inputLength - offset !== sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", expected \"' + (inputLength - offset) + '\"');\n\t}\n\n\tif (maxEncodedParamLength < sLength) {\n\t\tthrow new Error('\"s\" specified length of \"' + sLength + '\", max of \"' + maxEncodedParamLength + '\" is acceptable');\n\t}\n\n\tvar sOffset = offset;\n\toffset += sLength;\n\n\tif (offset !== inputLength) {\n\t\tthrow new Error('Expected to consume entire buffer, but \"' + (inputLength - offset) + '\" bytes remain');\n\t}\n\n\tvar rPadding = paramBytes - rLength,\n\t\tsPadding = paramBytes - sLength;\n\n\tvar dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n\tfor (offset = 0; offset < rPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n\n\toffset = paramBytes;\n\n\tfor (var o = offset; offset < o + sPadding; ++offset) {\n\t\tdst[offset] = 0;\n\t}\n\tsignature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n\n\tdst = dst.toString('base64');\n\tdst = base64Url(dst);\n\n\treturn dst;\n}\n\nfunction countPadding(buf, start, stop) {\n\tvar padding = 0;\n\twhile (start + padding < stop && buf[start + padding] === 0) {\n\t\t++padding;\n\t}\n\n\tvar needsSign = buf[start + padding] >= MAX_OCTET;\n\tif (needsSign) {\n\t\t--padding;\n\t}\n\n\treturn padding;\n}\n\nfunction joseToDer(signature, alg) {\n\tsignature = signatureAsBuffer(signature);\n\tvar paramBytes = getParamBytesForAlg(alg);\n\n\tvar signatureBytes = signature.length;\n\tif (signatureBytes !== paramBytes * 2) {\n\t\tthrow new TypeError('\"' + alg + '\" signatures must be \"' + paramBytes * 2 + '\" bytes, saw \"' + signatureBytes + '\"');\n\t}\n\n\tvar rPadding = countPadding(signature, 0, paramBytes);\n\tvar sPadding = countPadding(signature, paramBytes, signature.length);\n\tvar rLength = paramBytes - rPadding;\n\tvar sLength = paramBytes - sPadding;\n\n\tvar rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n\n\tvar shortLength = rsBytes < MAX_OCTET;\n\n\tvar dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n\n\tvar offset = 0;\n\tdst[offset++] = ENCODED_TAG_SEQ;\n\tif (shortLength) {\n\t\t// Bit 8 has value \"0\"\n\t\t// bits 7-1 give the length.\n\t\tdst[offset++] = rsBytes;\n\t} else {\n\t\t// Bit 8 of first octet has value \"1\"\n\t\t// bits 7-1 give the number of additional length octets.\n\t\tdst[offset++] = MAX_OCTET\t| 1;\n\t\t// length, base 256\n\t\tdst[offset++] = rsBytes & 0xff;\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = rLength;\n\tif (rPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\toffset += signature.copy(dst, offset, 0, paramBytes);\n\t} else {\n\t\toffset += signature.copy(dst, offset, rPadding, paramBytes);\n\t}\n\tdst[offset++] = ENCODED_TAG_INT;\n\tdst[offset++] = sLength;\n\tif (sPadding < 0) {\n\t\tdst[offset++] = 0;\n\t\tsignature.copy(dst, offset, paramBytes);\n\t} else {\n\t\tsignature.copy(dst, offset, paramBytes + sPadding);\n\t}\n\n\treturn dst;\n}\n\nmodule.exports = {\n\tderToJose: derToJose,\n\tjoseToDer: joseToDer\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLGtDQUE2Qjs7QUFFMUMsMEJBQTBCLG1CQUFPLENBQUMsSUFBdUI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9lY2RzYS1zaWctZm9ybWF0dGVyL3NyYy9lY2RzYS1zaWctZm9ybWF0dGVyLmpzPzhhM2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBnZXRQYXJhbUJ5dGVzRm9yQWxnID0gcmVxdWlyZSgnLi9wYXJhbS1ieXRlcy1mb3ItYWxnJyk7XG5cbnZhciBNQVhfT0NURVQgPSAweDgwLFxuXHRDTEFTU19VTklWRVJTQUwgPSAwLFxuXHRQUklNSVRJVkVfQklUID0gMHgyMCxcblx0VEFHX1NFUSA9IDB4MTAsXG5cdFRBR19JTlQgPSAweDAyLFxuXHRFTkNPREVEX1RBR19TRVEgPSAoVEFHX1NFUSB8IFBSSU1JVElWRV9CSVQpIHwgKENMQVNTX1VOSVZFUlNBTCA8PCA2KSxcblx0RU5DT0RFRF9UQUdfSU5UID0gVEFHX0lOVCB8IChDTEFTU19VTklWRVJTQUwgPDwgNik7XG5cbmZ1bmN0aW9uIGJhc2U2NFVybChiYXNlNjQpIHtcblx0cmV0dXJuIGJhc2U2NFxuXHRcdC5yZXBsYWNlKC89L2csICcnKVxuXHRcdC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuXHRcdC5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbn1cblxuZnVuY3Rpb24gc2lnbmF0dXJlQXNCdWZmZXIoc2lnbmF0dXJlKSB7XG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoc2lnbmF0dXJlKSkge1xuXHRcdHJldHVybiBzaWduYXR1cmU7XG5cdH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBzaWduYXR1cmUpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmZyb20oc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG5cdH1cblxuXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFQ0RTQSBzaWduYXR1cmUgbXVzdCBiZSBhIEJhc2U2NCBzdHJpbmcgb3IgYSBCdWZmZXInKTtcbn1cblxuZnVuY3Rpb24gZGVyVG9Kb3NlKHNpZ25hdHVyZSwgYWxnKSB7XG5cdHNpZ25hdHVyZSA9IHNpZ25hdHVyZUFzQnVmZmVyKHNpZ25hdHVyZSk7XG5cdHZhciBwYXJhbUJ5dGVzID0gZ2V0UGFyYW1CeXRlc0ZvckFsZyhhbGcpO1xuXG5cdC8vIHRoZSBERVIgZW5jb2RlZCBwYXJhbSBzaG91bGQgYXQgbW9zdCBiZSB0aGUgcGFyYW0gc2l6ZSwgcGx1cyBhIHBhZGRpbmdcblx0Ly8gemVybywgc2luY2UgZHVlIHRvIGJlaW5nIGEgc2lnbmVkIGludGVnZXJcblx0dmFyIG1heEVuY29kZWRQYXJhbUxlbmd0aCA9IHBhcmFtQnl0ZXMgKyAxO1xuXG5cdHZhciBpbnB1dExlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG5cblx0dmFyIG9mZnNldCA9IDA7XG5cdGlmIChzaWduYXR1cmVbb2Zmc2V0KytdICE9PSBFTkNPREVEX1RBR19TRVEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGV4cGVjdGVkIFwic2VxXCInKTtcblx0fVxuXG5cdHZhciBzZXFMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuXHRpZiAoc2VxTGVuZ3RoID09PSAoTUFYX09DVEVUIHwgMSkpIHtcblx0XHRzZXFMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuXHR9XG5cblx0aWYgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0IDwgc2VxTGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdcInNlcVwiIHNwZWNpZmllZCBsZW5ndGggb2YgXCInICsgc2VxTGVuZ3RoICsgJ1wiLCBvbmx5IFwiJyArIChpbnB1dExlbmd0aCAtIG9mZnNldCkgKyAnXCIgcmVtYWluaW5nJyk7XG5cdH1cblxuXHRpZiAoc2lnbmF0dXJlW29mZnNldCsrXSAhPT0gRU5DT0RFRF9UQUdfSU5UKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBleHBlY3RlZCBcImludFwiIGZvciBcInJcIicpO1xuXHR9XG5cblx0dmFyIHJMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuXG5cdGlmIChpbnB1dExlbmd0aCAtIG9mZnNldCAtIDIgPCByTGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdcInJcIiBzcGVjaWZpZWQgbGVuZ3RoIG9mIFwiJyArIHJMZW5ndGggKyAnXCIsIG9ubHkgXCInICsgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0IC0gMikgKyAnXCIgYXZhaWxhYmxlJyk7XG5cdH1cblxuXHRpZiAobWF4RW5jb2RlZFBhcmFtTGVuZ3RoIDwgckxlbmd0aCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignXCJyXCIgc3BlY2lmaWVkIGxlbmd0aCBvZiBcIicgKyByTGVuZ3RoICsgJ1wiLCBtYXggb2YgXCInICsgbWF4RW5jb2RlZFBhcmFtTGVuZ3RoICsgJ1wiIGlzIGFjY2VwdGFibGUnKTtcblx0fVxuXG5cdHZhciByT2Zmc2V0ID0gb2Zmc2V0O1xuXHRvZmZzZXQgKz0gckxlbmd0aDtcblxuXHRpZiAoc2lnbmF0dXJlW29mZnNldCsrXSAhPT0gRU5DT0RFRF9UQUdfSU5UKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBleHBlY3RlZCBcImludFwiIGZvciBcInNcIicpO1xuXHR9XG5cblx0dmFyIHNMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuXG5cdGlmIChpbnB1dExlbmd0aCAtIG9mZnNldCAhPT0gc0xlbmd0aCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignXCJzXCIgc3BlY2lmaWVkIGxlbmd0aCBvZiBcIicgKyBzTGVuZ3RoICsgJ1wiLCBleHBlY3RlZCBcIicgKyAoaW5wdXRMZW5ndGggLSBvZmZzZXQpICsgJ1wiJyk7XG5cdH1cblxuXHRpZiAobWF4RW5jb2RlZFBhcmFtTGVuZ3RoIDwgc0xlbmd0aCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignXCJzXCIgc3BlY2lmaWVkIGxlbmd0aCBvZiBcIicgKyBzTGVuZ3RoICsgJ1wiLCBtYXggb2YgXCInICsgbWF4RW5jb2RlZFBhcmFtTGVuZ3RoICsgJ1wiIGlzIGFjY2VwdGFibGUnKTtcblx0fVxuXG5cdHZhciBzT2Zmc2V0ID0gb2Zmc2V0O1xuXHRvZmZzZXQgKz0gc0xlbmd0aDtcblxuXHRpZiAob2Zmc2V0ICE9PSBpbnB1dExlbmd0aCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gY29uc3VtZSBlbnRpcmUgYnVmZmVyLCBidXQgXCInICsgKGlucHV0TGVuZ3RoIC0gb2Zmc2V0KSArICdcIiBieXRlcyByZW1haW4nKTtcblx0fVxuXG5cdHZhciByUGFkZGluZyA9IHBhcmFtQnl0ZXMgLSByTGVuZ3RoLFxuXHRcdHNQYWRkaW5nID0gcGFyYW1CeXRlcyAtIHNMZW5ndGg7XG5cblx0dmFyIGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShyUGFkZGluZyArIHJMZW5ndGggKyBzUGFkZGluZyArIHNMZW5ndGgpO1xuXG5cdGZvciAob2Zmc2V0ID0gMDsgb2Zmc2V0IDwgclBhZGRpbmc7ICsrb2Zmc2V0KSB7XG5cdFx0ZHN0W29mZnNldF0gPSAwO1xuXHR9XG5cdHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCByT2Zmc2V0ICsgTWF0aC5tYXgoLXJQYWRkaW5nLCAwKSwgck9mZnNldCArIHJMZW5ndGgpO1xuXG5cdG9mZnNldCA9IHBhcmFtQnl0ZXM7XG5cblx0Zm9yICh2YXIgbyA9IG9mZnNldDsgb2Zmc2V0IDwgbyArIHNQYWRkaW5nOyArK29mZnNldCkge1xuXHRcdGRzdFtvZmZzZXRdID0gMDtcblx0fVxuXHRzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgc09mZnNldCArIE1hdGgubWF4KC1zUGFkZGluZywgMCksIHNPZmZzZXQgKyBzTGVuZ3RoKTtcblxuXHRkc3QgPSBkc3QudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHRkc3QgPSBiYXNlNjRVcmwoZHN0KTtcblxuXHRyZXR1cm4gZHN0O1xufVxuXG5mdW5jdGlvbiBjb3VudFBhZGRpbmcoYnVmLCBzdGFydCwgc3RvcCkge1xuXHR2YXIgcGFkZGluZyA9IDA7XG5cdHdoaWxlIChzdGFydCArIHBhZGRpbmcgPCBzdG9wICYmIGJ1ZltzdGFydCArIHBhZGRpbmddID09PSAwKSB7XG5cdFx0KytwYWRkaW5nO1xuXHR9XG5cblx0dmFyIG5lZWRzU2lnbiA9IGJ1ZltzdGFydCArIHBhZGRpbmddID49IE1BWF9PQ1RFVDtcblx0aWYgKG5lZWRzU2lnbikge1xuXHRcdC0tcGFkZGluZztcblx0fVxuXG5cdHJldHVybiBwYWRkaW5nO1xufVxuXG5mdW5jdGlvbiBqb3NlVG9EZXIoc2lnbmF0dXJlLCBhbGcpIHtcblx0c2lnbmF0dXJlID0gc2lnbmF0dXJlQXNCdWZmZXIoc2lnbmF0dXJlKTtcblx0dmFyIHBhcmFtQnl0ZXMgPSBnZXRQYXJhbUJ5dGVzRm9yQWxnKGFsZyk7XG5cblx0dmFyIHNpZ25hdHVyZUJ5dGVzID0gc2lnbmF0dXJlLmxlbmd0aDtcblx0aWYgKHNpZ25hdHVyZUJ5dGVzICE9PSBwYXJhbUJ5dGVzICogMikge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiJyArIGFsZyArICdcIiBzaWduYXR1cmVzIG11c3QgYmUgXCInICsgcGFyYW1CeXRlcyAqIDIgKyAnXCIgYnl0ZXMsIHNhdyBcIicgKyBzaWduYXR1cmVCeXRlcyArICdcIicpO1xuXHR9XG5cblx0dmFyIHJQYWRkaW5nID0gY291bnRQYWRkaW5nKHNpZ25hdHVyZSwgMCwgcGFyYW1CeXRlcyk7XG5cdHZhciBzUGFkZGluZyA9IGNvdW50UGFkZGluZyhzaWduYXR1cmUsIHBhcmFtQnl0ZXMsIHNpZ25hdHVyZS5sZW5ndGgpO1xuXHR2YXIgckxlbmd0aCA9IHBhcmFtQnl0ZXMgLSByUGFkZGluZztcblx0dmFyIHNMZW5ndGggPSBwYXJhbUJ5dGVzIC0gc1BhZGRpbmc7XG5cblx0dmFyIHJzQnl0ZXMgPSAxICsgMSArIHJMZW5ndGggKyAxICsgMSArIHNMZW5ndGg7XG5cblx0dmFyIHNob3J0TGVuZ3RoID0gcnNCeXRlcyA8IE1BWF9PQ1RFVDtcblxuXHR2YXIgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKChzaG9ydExlbmd0aCA/IDIgOiAzKSArIHJzQnl0ZXMpO1xuXG5cdHZhciBvZmZzZXQgPSAwO1xuXHRkc3Rbb2Zmc2V0KytdID0gRU5DT0RFRF9UQUdfU0VRO1xuXHRpZiAoc2hvcnRMZW5ndGgpIHtcblx0XHQvLyBCaXQgOCBoYXMgdmFsdWUgXCIwXCJcblx0XHQvLyBiaXRzIDctMSBnaXZlIHRoZSBsZW5ndGguXG5cdFx0ZHN0W29mZnNldCsrXSA9IHJzQnl0ZXM7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQml0IDggb2YgZmlyc3Qgb2N0ZXQgaGFzIHZhbHVlIFwiMVwiXG5cdFx0Ly8gYml0cyA3LTEgZ2l2ZSB0aGUgbnVtYmVyIG9mIGFkZGl0aW9uYWwgbGVuZ3RoIG9jdGV0cy5cblx0XHRkc3Rbb2Zmc2V0KytdID0gTUFYX09DVEVUXHR8IDE7XG5cdFx0Ly8gbGVuZ3RoLCBiYXNlIDI1NlxuXHRcdGRzdFtvZmZzZXQrK10gPSByc0J5dGVzICYgMHhmZjtcblx0fVxuXHRkc3Rbb2Zmc2V0KytdID0gRU5DT0RFRF9UQUdfSU5UO1xuXHRkc3Rbb2Zmc2V0KytdID0gckxlbmd0aDtcblx0aWYgKHJQYWRkaW5nIDwgMCkge1xuXHRcdGRzdFtvZmZzZXQrK10gPSAwO1xuXHRcdG9mZnNldCArPSBzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgMCwgcGFyYW1CeXRlcyk7XG5cdH0gZWxzZSB7XG5cdFx0b2Zmc2V0ICs9IHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCByUGFkZGluZywgcGFyYW1CeXRlcyk7XG5cdH1cblx0ZHN0W29mZnNldCsrXSA9IEVOQ09ERURfVEFHX0lOVDtcblx0ZHN0W29mZnNldCsrXSA9IHNMZW5ndGg7XG5cdGlmIChzUGFkZGluZyA8IDApIHtcblx0XHRkc3Rbb2Zmc2V0KytdID0gMDtcblx0XHRzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgcGFyYW1CeXRlcyk7XG5cdH0gZWxzZSB7XG5cdFx0c2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHBhcmFtQnl0ZXMgKyBzUGFkZGluZyk7XG5cdH1cblxuXHRyZXR1cm4gZHN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0ZGVyVG9Kb3NlOiBkZXJUb0pvc2UsXG5cdGpvc2VUb0Rlcjogam9zZVRvRGVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2010\n")},2018:n=>{"use strict";n.exports=require("tty")},2081:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var serialOrdered = __webpack_require__(28);\n\n// Public API\nmodule.exports = serial;\n\n/**\n * Runs iterator over provided array elements in series\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction serial(list, iterator, callback)\n{\n  return serialOrdered(list, iterator, null, callback);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA4MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IsbUJBQU8sQ0FBQyxFQUFvQjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L3NlcmlhbC5qcz82YzczIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXJpYWxPcmRlcmVkID0gcmVxdWlyZSgnLi9zZXJpYWxPcmRlcmVkLmpzJyk7XG5cbi8vIFB1YmxpYyBBUElcbm1vZHVsZS5leHBvcnRzID0gc2VyaWFsO1xuXG4vKipcbiAqIFJ1bnMgaXRlcmF0b3Igb3ZlciBwcm92aWRlZCBhcnJheSBlbGVtZW50cyBpbiBzZXJpZXNcbiAqXG4gKiBAcGFyYW0gICB7YXJyYXl8b2JqZWN0fSBsaXN0IC0gYXJyYXkgb3Igb2JqZWN0IChuYW1lZCBsaXN0KSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBpdGVyYXRvciB0byBydW5cbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBpbnZva2VkIHdoZW4gYWxsIGVsZW1lbnRzIHByb2Nlc3NlZFxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIGpvYnMgdGVybWluYXRvclxuICovXG5mdW5jdGlvbiBzZXJpYWwobGlzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKVxue1xuICByZXR1cm4gc2VyaWFsT3JkZXJlZChsaXN0LCBpdGVyYXRvciwgbnVsbCwgY2FsbGJhY2spO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2081\n")},2111:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst eq = __webpack_require__(4641)\nconst neq = __webpack_require__(3999)\nconst gt = __webpack_require__(5580)\nconst gte = __webpack_require__(4089)\nconst lt = __webpack_require__(7059)\nconst lte = __webpack_require__(5200)\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjExMS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsSUFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsSUFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsSUFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsSUFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsSUFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsSUFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NtcC5qcz81NGMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPT09IGJcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGIudmVyc2lvblxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgIT09IGJcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnIT0nOlxuICAgICAgcmV0dXJuIG5lcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz4nOlxuICAgICAgcmV0dXJuIGd0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuIGx0KGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGx0ZShhLCBiLCBsb29zZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke29wfWApXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY21wXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2111\n")},2203:n=>{"use strict";n.exports=require("stream")},2313:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var defer = __webpack_require__(405);\n\n// API\nmodule.exports = async;\n\n/**\n * Runs provided callback asynchronously\n * even if callback itself is not\n *\n * @param   {function} callback - callback to invoke\n * @returns {function} - augmented callback\n */\nfunction async(callback)\n{\n  var isAsync = false;\n\n  // check if async happened\n  defer(function() { isAsync = true; });\n\n  return function async_callback(err, result)\n  {\n    if (isAsync)\n    {\n      callback(err, result);\n    }\n    else\n    {\n      defer(function nextTick_callback()\n      {\n        callback(err, result);\n      });\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsR0FBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi9hc3luYy5qcz84ZWNmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWZlciA9IHJlcXVpcmUoJy4vZGVmZXIuanMnKTtcblxuLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuXG4vKipcbiAqIFJ1bnMgcHJvdmlkZWQgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcbiAqIGV2ZW4gaWYgY2FsbGJhY2sgaXRzZWxmIGlzIG5vdFxuICpcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsYmFjayB0byBpbnZva2VcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBhdWdtZW50ZWQgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYXN5bmMoY2FsbGJhY2spXG57XG4gIHZhciBpc0FzeW5jID0gZmFsc2U7XG5cbiAgLy8gY2hlY2sgaWYgYXN5bmMgaGFwcGVuZWRcbiAgZGVmZXIoZnVuY3Rpb24oKSB7IGlzQXN5bmMgPSB0cnVlOyB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gYXN5bmNfY2FsbGJhY2soZXJyLCByZXN1bHQpXG4gIHtcbiAgICBpZiAoaXNBc3luYylcbiAgICB7XG4gICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICBkZWZlcihmdW5jdGlvbiBuZXh0VGlja19jYWxsYmFjaygpXG4gICAgICB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2313\n")},2525:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\n// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(7638)\nconst compare = __webpack_require__(560)\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUyNS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxJQUEyQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyxHQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sdUJBQXVCLElBQUk7QUFDM0IsTUFBTTtBQUNOLHVCQUF1QixJQUFJO0FBQzNCLE1BQU07QUFDTixxQkFBcUIsS0FBSyxJQUFJLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcz9iZmE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBnaXZlbiBhIHNldCBvZiB2ZXJzaW9ucyBhbmQgYSByYW5nZSwgY3JlYXRlIGEgXCJzaW1wbGlmaWVkXCIgcmFuZ2Vcbi8vIHRoYXQgaW5jbHVkZXMgdGhlIHNhbWUgdmVyc2lvbnMgdGhhdCB0aGUgb3JpZ2luYWwgcmFuZ2UgZG9lc1xuLy8gSWYgdGhlIG9yaWdpbmFsIHJhbmdlIGlzIHNob3J0ZXIgdGhhbiB0aGUgc2ltcGxpZmllZCBvbmUsIHJldHVybiB0aGF0LlxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxubW9kdWxlLmV4cG9ydHMgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHNldCA9IFtdXG4gIGxldCBmaXJzdCA9IG51bGxcbiAgbGV0IHByZXYgPSBudWxsXG4gIGNvbnN0IHYgPSB2ZXJzaW9ucy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKVxuICAgIGlmIChpbmNsdWRlZCkge1xuICAgICAgcHJldiA9IHZlcnNpb25cbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSB2ZXJzaW9uXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHNldC5wdXNoKFtmaXJzdCwgcHJldl0pXG4gICAgICB9XG4gICAgICBwcmV2ID0gbnVsbFxuICAgICAgZmlyc3QgPSBudWxsXG4gICAgfVxuICB9XG4gIGlmIChmaXJzdCkge1xuICAgIHNldC5wdXNoKFtmaXJzdCwgbnVsbF0pXG4gIH1cblxuICBjb25zdCByYW5nZXMgPSBbXVxuICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2Ygc2V0KSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICByYW5nZXMucHVzaChtaW4pXG4gICAgfSBlbHNlIGlmICghbWF4ICYmIG1pbiA9PT0gdlswXSkge1xuICAgICAgcmFuZ2VzLnB1c2goJyonKVxuICAgIH0gZWxzZSBpZiAoIW1heCkge1xuICAgICAgcmFuZ2VzLnB1c2goYD49JHttaW59YClcbiAgICB9IGVsc2UgaWYgKG1pbiA9PT0gdlswXSkge1xuICAgICAgcmFuZ2VzLnB1c2goYDw9JHttYXh9YClcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApXG4gICAgfVxuICB9XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSByYW5nZXMuam9pbignIHx8ICcpXG4gIGNvbnN0IG9yaWdpbmFsID0gdHlwZW9mIHJhbmdlLnJhdyA9PT0gJ3N0cmluZycgPyByYW5nZS5yYXcgOiBTdHJpbmcocmFuZ2UpXG4gIHJldHVybiBzaW1wbGlmaWVkLmxlbmd0aCA8IG9yaWdpbmFsLmxlbmd0aCA/IHNpbXBsaWZpZWQgOiByYW5nZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2525\n")},2613:n=>{"use strict";n.exports=require("assert")},2851:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*global module*/\nvar Buffer = (__webpack_require__(181).Buffer);\n\nmodule.exports = function toString(obj) {\n  if (typeof obj === 'string')\n    return obj;\n  if (typeof obj === 'number' || Buffer.isBuffer(obj))\n    return obj.toString();\n  return JSON.stringify(obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg1MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsaUNBQXdCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2p3cy9saWIvdG9zdHJpbmcuanM/MGRhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBtb2R1bGUqL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b1N0cmluZyhvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBvYmo7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCBCdWZmZXIuaXNCdWZmZXIob2JqKSlcbiAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2851\n")},2861:(module,exports,__webpack_require__)=>{eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(181)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLEdBQVE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRSxjQUFjO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzPzg3MDciXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2861\n")},2938:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkzOC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanM/MDZiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2938\n")},3007:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwNy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanM/NzkwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpID0+IHtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllckJhc2UgPSBpZGVudGlmaWVyXG4gICAgaWRlbnRpZmllciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKFxuICAgICAgdmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlciA/IHZlcnNpb24udmVyc2lvbiA6IHZlcnNpb24sXG4gICAgICBvcHRpb25zXG4gICAgKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3007\n")},3093:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar $isNaN = __webpack_require__(4459);\n\n/** @type {import('./sign')} */\nmodule.exports = function sign(number) {\n\tif ($isNaN(number) || number === 0) {\n\t\treturn number;\n\t}\n\treturn number < 0 ? -1 : +1;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA5My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsSUFBUzs7QUFFOUIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL3NpZ24uanM/OGNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCcuL2lzTmFOJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3NpZ24nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2lnbihudW1iZXIpIHtcblx0aWYgKCRpc05hTihudW1iZXIpIHx8IG51bWJlciA9PT0gMCkge1xuXHRcdHJldHVybiBudW1iZXI7XG5cdH1cblx0cmV0dXJuIG51bWJlciA8IDAgPyAtMSA6ICsxO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3093\n")},3126:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar bind = __webpack_require__(6743);\nvar $TypeError = __webpack_require__(9675);\n\nvar $call = __webpack_require__(76);\nvar $actualApply = __webpack_require__(3144);\n\n/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */\nmodule.exports = function callBindBasic(args) {\n\tif (args.length < 1 || typeof args[0] !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\treturn $actualApply(bind, $call, args);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEyNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsSUFBZTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjs7QUFFekMsWUFBWSxtQkFBTyxDQUFDLEVBQWdCO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLElBQWU7O0FBRTFDLFdBQVcsdUVBQXVFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2luZGV4LmpzP2Y5YWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcblxudmFyICRjYWxsID0gcmVxdWlyZSgnLi9mdW5jdGlvbkNhbGwnKTtcbnZhciAkYWN0dWFsQXBwbHkgPSByZXF1aXJlKCcuL2FjdHVhbEFwcGx5Jyk7XG5cbi8qKiBAdHlwZSB7KGFyZ3M6IFtGdW5jdGlvbiwgdGhpc0FyZz86IHVua25vd24sIC4uLmFyZ3M6IHVua25vd25bXV0pID0+IEZ1bmN0aW9ufSBUT0RPIEZJWE1FLCBmaW5kIGEgd2F5IHRvIHVzZSBpbXBvcnQoJy4nKSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZEJhc2ljKGFyZ3MpIHtcblx0aWYgKGFyZ3MubGVuZ3RoIDwgMSB8fCB0eXBlb2YgYXJnc1swXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdhIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG5cdH1cblx0cmV0dXJuICRhY3R1YWxBcHBseShiaW5kLCAkY2FsbCwgYXJncyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3126\n")},3144:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar bind = __webpack_require__(6743);\n\nvar $apply = __webpack_require__(1002);\nvar $call = __webpack_require__(76);\nvar $reflectApply = __webpack_require__(7119);\n\n/** @type {import('./actualApply')} */\nmodule.exports = $reflectApply || bind.call($call, $apply);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE0NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsSUFBZTs7QUFFbEMsYUFBYSxtQkFBTyxDQUFDLElBQWlCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyxFQUFnQjtBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyxJQUFnQjs7QUFFNUMsV0FBVyx5QkFBeUI7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQtYXBwbHktaGVscGVycy9hY3R1YWxBcHBseS5qcz8zYjZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbnZhciAkYXBwbHkgPSByZXF1aXJlKCcuL2Z1bmN0aW9uQXBwbHknKTtcbnZhciAkY2FsbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25DYWxsJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IHJlcXVpcmUoJy4vcmVmbGVjdEFwcGx5Jyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2FjdHVhbEFwcGx5Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9ICRyZWZsZWN0QXBwbHkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3144\n")},3164:(module,__unused_webpack_exports,__webpack_require__)=>{eval('var url = __webpack_require__(7016);\nvar URL = url.URL;\nvar http = __webpack_require__(8611);\nvar https = __webpack_require__(5692);\nvar Writable = (__webpack_require__(2203).Writable);\nvar assert = __webpack_require__(2613);\nvar debug = __webpack_require__(7507);\n\n// Preventive platform detection\n// istanbul ignore next\n(function detectUnsupportedEnvironment() {\n  var looksLikeNode = typeof process !== "undefined";\n  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";\n  var looksLikeV8 = isFunction(Error.captureStackTrace);\n  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {\n    console.warn("The follow-redirects package should be excluded from browser builds.");\n  }\n}());\n\n// Whether to use the native URL object or the legacy url module\nvar useNativeURL = false;\ntry {\n  assert(new URL(""));\n}\ncatch (error) {\n  useNativeURL = error.code === "ERR_INVALID_URL";\n}\n\n// URL fields to preserve in copy operations\nvar preservedUrlFields = [\n  "auth",\n  "host",\n  "hostname",\n  "href",\n  "path",\n  "pathname",\n  "port",\n  "protocol",\n  "query",\n  "search",\n  "hash",\n];\n\n// Create handlers that pass events from native requests\nvar events = ["abort", "aborted", "connect", "error", "socket", "timeout"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar InvalidUrlError = createErrorType(\n  "ERR_INVALID_URL",\n  "Invalid URL",\n  TypeError\n);\nvar RedirectionError = createErrorType(\n  "ERR_FR_REDIRECTION_FAILURE",\n  "Redirected request failed"\n);\nvar TooManyRedirectsError = createErrorType(\n  "ERR_FR_TOO_MANY_REDIRECTS",\n  "Maximum number of redirects exceeded",\n  RedirectionError\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",\n  "Request body larger than maxBodyLength limit"\n);\nvar WriteAfterEndError = createErrorType(\n  "ERR_STREAM_WRITE_AFTER_END",\n  "write after end"\n);\n\n// istanbul ignore next\nvar destroy = Writable.prototype.destroy || noop;\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on("response", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    try {\n      self._processResponse(response);\n    }\n    catch (cause) {\n      self.emit("error", cause instanceof RedirectionError ?\n        cause : new RedirectionError({ cause: cause }));\n    }\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  destroyRequest(this._currentRequest);\n  this._currentRequest.abort();\n  this.emit("abort");\n};\n\nRedirectableRequest.prototype.destroy = function (error) {\n  destroyRequest(this._currentRequest, error);\n  destroy.call(this, error);\n  return this;\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!isString(data) && !isBuffer(data)) {\n    throw new TypeError("data should be a string, Buffer or Uint8Array");\n  }\n  if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn\'t invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don\'t exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit("error", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (isFunction(data)) {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener("timeout", socket.destroy);\n    socket.addListener("timeout", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit("timeout");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener("abort", clearTimer);\n    self.removeListener("error", clearTimer);\n    self.removeListener("response", clearTimer);\n    self.removeListener("close", clearTimer);\n    if (callback) {\n      self.removeListener("timeout", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener("socket", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on("timeout", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once("socket", startTimer);\n  }\n\n  // Clean up on events\n  this.on("socket", destroyOnTimeout);\n  this.on("abort", clearTimer);\n  this.on("error", clearTimer);\n  this.on("response", clearTimer);\n  this.on("close", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  "flushHeaders", "getHeader",\n  "setNoDelay", "setSocketKeepAlive",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n["aborted", "connection", "socket"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf("?");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    throw new TypeError("Unsupported protocol " + protocol);\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.slice(0, -1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request and set up its event handlers\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  request._redirectable = this;\n  for (var event of events) {\n    request.on(event, eventHandlers[event]);\n  }\n\n  // RFC72305.3.1: When making a request directly to an origin server, []\n  // a client MUST send only the absolute path [] as the request-target.\n  this._currentUrl = /^\\//.test(this._options.path) ?\n    url.format(this._options) :\n    // When making a request to a proxy, []\n    // a client MUST send the target URI in absolute-form [].\n    this._options.path;\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      // istanbul ignore else\n      if (request === self._currentRequest) {\n        // Report any write errors\n        // istanbul ignore if\n        if (error) {\n          self.emit("error", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          // istanbul ignore else\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC72316.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n  // If the response is not a redirect; return it as-is\n  var location = response.headers.location;\n  if (!location || this._options.followRedirects === false ||\n      statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit("response", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n    return;\n  }\n\n  // The response is a redirect, so abort the current request\n  destroyRequest(this._currentRequest);\n  // Discard the remainder of the response to avoid waiting for data\n  response.destroy();\n\n  // RFC72316.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., "infinite" redirection loops).\n  if (++this._redirectCount > this._options.maxRedirects) {\n    throw new TooManyRedirectsError();\n  }\n\n  // Store the request headers if applicable\n  var requestHeaders;\n  var beforeRedirect = this._options.beforeRedirect;\n  if (beforeRedirect) {\n    requestHeaders = Object.assign({\n      // The Host header was set by nativeProtocol.request\n      Host: response.req.getHeader("host"),\n    }, this._options.headers);\n  }\n\n  // RFC72316.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, []\n  // RFC72316.4.23: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n  var method = this._options.method;\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||\n      // RFC72316.4.4: The 303 (See Other) status code indicates that\n      // the server is redirecting the user agent to a different resource []\n      // A user agent can perform a retrieval request targeting that URI\n      // (a GET or HEAD request if using HTTP) []\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = "GET";\n    // Drop a possible entity and headers related to it\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  }\n\n  // Drop the Host header, as the redirect might lead to a different host\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n  // If the redirect is relative, carry over the host of the last request\n  var currentUrlParts = parseUrl(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\n\n  // Create the redirected request\n  var redirectUrl = resolveUrl(location, currentUrl);\n  debug("redirecting to", redirectUrl.href);\n  this._isRedirect = true;\n  spreadUrlObject(redirectUrl, this._options);\n\n  // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n  if (redirectUrl.protocol !== currentUrlParts.protocol &&\n     redirectUrl.protocol !== "https:" ||\n     redirectUrl.host !== currentHost &&\n     !isSubdomain(redirectUrl.host, currentHost)) {\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\n  }\n\n  // Evaluate the beforeRedirect callback\n  if (isFunction(beforeRedirect)) {\n    var responseDetails = {\n      headers: response.headers,\n      statusCode: statusCode,\n    };\n    var requestDetails = {\n      url: currentUrl,\n      method: method,\n      headers: requestHeaders,\n    };\n    beforeRedirect(this._options, responseDetails, requestDetails);\n    this._sanitizeOptions(this._options);\n  }\n\n  // Perform the redirected request\n  this._performRequest();\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + ":";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters, ensuring that input is an object\n      if (isURL(input)) {\n        input = spreadUrlObject(input);\n      }\n      else if (isString(input)) {\n        input = spreadUrlObject(parseUrl(input));\n      }\n      else {\n        callback = options;\n        options = validateUrl(input);\n        input = { protocol: protocol };\n      }\n      if (isFunction(options)) {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      if (!isString(options.host) && !isString(options.hostname)) {\n        options.hostname = "::1";\n      }\n\n      assert.equal(options.protocol, protocol, "protocol mismatch");\n      debug("options", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\nfunction noop() { /* empty */ }\n\nfunction parseUrl(input) {\n  var parsed;\n  // istanbul ignore else\n  if (useNativeURL) {\n    parsed = new URL(input);\n  }\n  else {\n    // Ensure the URL is valid and absolute\n    parsed = validateUrl(url.parse(input));\n    if (!isString(parsed.protocol)) {\n      throw new InvalidUrlError({ input });\n    }\n  }\n  return parsed;\n}\n\nfunction resolveUrl(relative, base) {\n  // istanbul ignore next\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\n}\n\nfunction validateUrl(input) {\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  return input;\n}\n\nfunction spreadUrlObject(urlObject, target) {\n  var spread = target || {};\n  for (var key of preservedUrlFields) {\n    spread[key] = urlObject[key];\n  }\n\n  // Fix IPv6 hostname\n  if (spread.hostname.startsWith("[")) {\n    spread.hostname = spread.hostname.slice(1, -1);\n  }\n  // Ensure port is a number\n  if (spread.port !== "") {\n    spread.port = Number(spread.port);\n  }\n  // Concatenate path\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\n\n  return spread;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return (lastValue === null || typeof lastValue === "undefined") ?\n    undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, message, baseClass) {\n  // Create constructor\n  function CustomError(properties) {\n    // istanbul ignore else\n    if (isFunction(Error.captureStackTrace)) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    Object.assign(this, properties || {});\n    this.code = code;\n    this.message = this.cause ? message + ": " + this.cause.message : message;\n  }\n\n  // Attach constructor and set default properties\n  CustomError.prototype = new (baseClass || Error)();\n  Object.defineProperties(CustomError.prototype, {\n    constructor: {\n      value: CustomError,\n      enumerable: false,\n    },\n    name: {\n      value: "Error [" + code + "]",\n      enumerable: false,\n    },\n  });\n  return CustomError;\n}\n\nfunction destroyRequest(request, error) {\n  for (var event of events) {\n    request.removeListener(event, eventHandlers[event]);\n  }\n  request.on("error", noop);\n  request.destroy(error);\n}\n\nfunction isSubdomain(subdomain, domain) {\n  assert(isString(subdomain) && isString(domain));\n  var dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);\n}\n\nfunction isString(value) {\n  return typeof value === "string" || value instanceof String;\n}\n\nfunction isFunction(value) {\n  return typeof value === "function";\n}\n\nfunction isBuffer(value) {\n  return typeof value === "object" && ("length" in value);\n}\n\nfunction isURL(value) {\n  return URL && value instanceof URL;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBSztBQUN2QjtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxJQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxJQUFPO0FBQzNCLGVBQWUsb0NBQTBCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxJQUFRO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyxJQUFTOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdDQUF3QztBQUMvRCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1COztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNFQUFzRTtBQUN2RixhQUFhLGtFQUFrRTtBQUMvRSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9pbmRleC5qcz9kMzlhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xudmFyIFVSTCA9IHVybC5VUkw7XG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xudmFyIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZShcInN0cmVhbVwiKS5Xcml0YWJsZTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIGRlYnVnID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5cbi8vIFByZXZlbnRpdmUgcGxhdGZvcm0gZGV0ZWN0aW9uXG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuKGZ1bmN0aW9uIGRldGVjdFVuc3VwcG9ydGVkRW52aXJvbm1lbnQoKSB7XG4gIHZhciBsb29rc0xpa2VOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCI7XG4gIHZhciBsb29rc0xpa2VCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIHZhciBsb29rc0xpa2VWOCA9IGlzRnVuY3Rpb24oRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpO1xuICBpZiAoIWxvb2tzTGlrZU5vZGUgJiYgKGxvb2tzTGlrZUJyb3dzZXIgfHwgIWxvb2tzTGlrZVY4KSkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBmb2xsb3ctcmVkaXJlY3RzIHBhY2thZ2Ugc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gYnJvd3NlciBidWlsZHMuXCIpO1xuICB9XG59KCkpO1xuXG4vLyBXaGV0aGVyIHRvIHVzZSB0aGUgbmF0aXZlIFVSTCBvYmplY3Qgb3IgdGhlIGxlZ2FjeSB1cmwgbW9kdWxlXG52YXIgdXNlTmF0aXZlVVJMID0gZmFsc2U7XG50cnkge1xuICBhc3NlcnQobmV3IFVSTChcIlwiKSk7XG59XG5jYXRjaCAoZXJyb3IpIHtcbiAgdXNlTmF0aXZlVVJMID0gZXJyb3IuY29kZSA9PT0gXCJFUlJfSU5WQUxJRF9VUkxcIjtcbn1cblxuLy8gVVJMIGZpZWxkcyB0byBwcmVzZXJ2ZSBpbiBjb3B5IG9wZXJhdGlvbnNcbnZhciBwcmVzZXJ2ZWRVcmxGaWVsZHMgPSBbXG4gIFwiYXV0aFwiLFxuICBcImhvc3RcIixcbiAgXCJob3N0bmFtZVwiLFxuICBcImhyZWZcIixcbiAgXCJwYXRoXCIsXG4gIFwicGF0aG5hbWVcIixcbiAgXCJwb3J0XCIsXG4gIFwicHJvdG9jb2xcIixcbiAgXCJxdWVyeVwiLFxuICBcInNlYXJjaFwiLFxuICBcImhhc2hcIixcbl07XG5cbi8vIENyZWF0ZSBoYW5kbGVycyB0aGF0IHBhc3MgZXZlbnRzIGZyb20gbmF0aXZlIHJlcXVlc3RzXG52YXIgZXZlbnRzID0gW1wiYWJvcnRcIiwgXCJhYm9ydGVkXCIsIFwiY29ubmVjdFwiLCBcImVycm9yXCIsIFwic29ja2V0XCIsIFwidGltZW91dFwiXTtcbnZhciBldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgdGhpcy5fcmVkaXJlY3RhYmxlLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9O1xufSk7XG5cbi8vIEVycm9yIHR5cGVzIHdpdGggY29kZXNcbnZhciBJbnZhbGlkVXJsRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX0lOVkFMSURfVVJMXCIsXG4gIFwiSW52YWxpZCBVUkxcIixcbiAgVHlwZUVycm9yXG4pO1xudmFyIFJlZGlyZWN0aW9uRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX0ZSX1JFRElSRUNUSU9OX0ZBSUxVUkVcIixcbiAgXCJSZWRpcmVjdGVkIHJlcXVlc3QgZmFpbGVkXCJcbik7XG52YXIgVG9vTWFueVJlZGlyZWN0c0Vycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxuICBcIkVSUl9GUl9UT09fTUFOWV9SRURJUkVDVFNcIixcbiAgXCJNYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHMgZXhjZWVkZWRcIixcbiAgUmVkaXJlY3Rpb25FcnJvclxuKTtcbnZhciBNYXhCb2R5TGVuZ3RoRXhjZWVkZWRFcnJvciA9IGNyZWF0ZUVycm9yVHlwZShcbiAgXCJFUlJfRlJfTUFYX0JPRFlfTEVOR1RIX0VYQ0VFREVEXCIsXG4gIFwiUmVxdWVzdCBib2R5IGxhcmdlciB0aGFuIG1heEJvZHlMZW5ndGggbGltaXRcIlxuKTtcbnZhciBXcml0ZUFmdGVyRW5kRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXG4gIFwiRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkRcIixcbiAgXCJ3cml0ZSBhZnRlciBlbmRcIlxuKTtcblxuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbnZhciBkZXN0cm95ID0gV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgfHwgbm9vcDtcblxuLy8gQW4gSFRUUChTKSByZXF1ZXN0IHRoYXQgY2FuIGJlIHJlZGlyZWN0ZWRcbmZ1bmN0aW9uIFJlZGlyZWN0YWJsZVJlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VDYWxsYmFjaykge1xuICAvLyBJbml0aWFsaXplIHRoZSByZXF1ZXN0XG4gIFdyaXRhYmxlLmNhbGwodGhpcyk7XG4gIHRoaXMuX3Nhbml0aXplT3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gIHRoaXMuX2VuZGluZyA9IGZhbHNlO1xuICB0aGlzLl9yZWRpcmVjdENvdW50ID0gMDtcbiAgdGhpcy5fcmVkaXJlY3RzID0gW107XG4gIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoID0gMDtcbiAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XG5cbiAgLy8gQXR0YWNoIGEgY2FsbGJhY2sgaWYgcGFzc2VkXG4gIGlmIChyZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbihcInJlc3BvbnNlXCIsIHJlc3BvbnNlQ2FsbGJhY2spO1xuICB9XG5cbiAgLy8gUmVhY3QgdG8gcmVzcG9uc2VzIG9mIG5hdGl2ZSByZXF1ZXN0c1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5fcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBjYXVzZSBpbnN0YW5jZW9mIFJlZGlyZWN0aW9uRXJyb3IgP1xuICAgICAgICBjYXVzZSA6IG5ldyBSZWRpcmVjdGlvbkVycm9yKHsgY2F1c2U6IGNhdXNlIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGVyZm9ybSB0aGUgZmlyc3QgcmVxdWVzdFxuICB0aGlzLl9wZXJmb3JtUmVxdWVzdCgpO1xufVxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICBkZXN0cm95UmVxdWVzdCh0aGlzLl9jdXJyZW50UmVxdWVzdCk7XG4gIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LmFib3J0KCk7XG4gIHRoaXMuZW1pdChcImFib3J0XCIpO1xufTtcblxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICBkZXN0cm95UmVxdWVzdCh0aGlzLl9jdXJyZW50UmVxdWVzdCwgZXJyb3IpO1xuICBkZXN0cm95LmNhbGwodGhpcywgZXJyb3IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFdyaXRlcyBidWZmZXJlZCBkYXRhIHRvIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgLy8gV3JpdGluZyBpcyBub3QgYWxsb3dlZCBpZiBlbmQgaGFzIGJlZW4gY2FsbGVkXG4gIGlmICh0aGlzLl9lbmRpbmcpIHtcbiAgICB0aHJvdyBuZXcgV3JpdGVBZnRlckVuZEVycm9yKCk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBpbnB1dCBhbmQgc2hpZnQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcbiAgaWYgKCFpc1N0cmluZyhkYXRhKSAmJiAhaXNCdWZmZXIoZGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSBzaG91bGQgYmUgYSBzdHJpbmcsIEJ1ZmZlciBvciBVaW50OEFycmF5XCIpO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgLy8gSWdub3JlIGVtcHR5IGJ1ZmZlcnMsIHNpbmNlIHdyaXRpbmcgdGhlbSBkb2Vzbid0IGludm9rZSB0aGUgY2FsbGJhY2tcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yMjA2NlxuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBPbmx5IHdyaXRlIHdoZW4gd2UgZG9uJ3QgZXhjZWVkIHRoZSBtYXhpbXVtIGJvZHkgbGVuZ3RoXG4gIGlmICh0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCArIGRhdGEubGVuZ3RoIDw9IHRoaXMuX29wdGlvbnMubWF4Qm9keUxlbmd0aCkge1xuICAgIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycy5wdXNoKHsgZGF0YTogZGF0YSwgZW5jb2Rpbmc6IGVuY29kaW5nIH0pO1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LndyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gIH1cbiAgLy8gRXJyb3Igd2hlbiB3ZSBleGNlZWQgdGhlIG1heGltdW0gYm9keSBsZW5ndGhcbiAgZWxzZSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IE1heEJvZHlMZW5ndGhFeGNlZWRlZEVycm9yKCkpO1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgfVxufTtcblxuLy8gRW5kcyB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAvLyBTaGlmdCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxuICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xuICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICBkYXRhID0gZW5jb2RpbmcgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICAvLyBXcml0ZSBkYXRhIGlmIG5lZWRlZCBhbmQgZW5kXG4gIGlmICghZGF0YSkge1xuICAgIHRoaXMuX2VuZGVkID0gdGhpcy5fZW5kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC5lbmQobnVsbCwgbnVsbCwgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudFJlcXVlc3QgPSB0aGlzLl9jdXJyZW50UmVxdWVzdDtcbiAgICB0aGlzLndyaXRlKGRhdGEsIGVuY29kaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWU7XG4gICAgICBjdXJyZW50UmVxdWVzdC5lbmQobnVsbCwgbnVsbCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIHRoaXMuX2VuZGluZyA9IHRydWU7XG4gIH1cbn07XG5cbi8vIFNldHMgYSBoZWFkZXIgdmFsdWUgb24gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9vcHRpb25zLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgdGhpcy5fY3VycmVudFJlcXVlc3Quc2V0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbn07XG5cbi8vIENsZWFycyBhIGhlYWRlciB2YWx1ZSBvbiB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMuX29wdGlvbnMuaGVhZGVyc1tuYW1lXTtcbiAgdGhpcy5fY3VycmVudFJlcXVlc3QucmVtb3ZlSGVhZGVyKG5hbWUpO1xufTtcblxuLy8gR2xvYmFsIHRpbWVvdXQgZm9yIGFsbCB1bmRlcmx5aW5nIHJlcXVlc3RzXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKG1zZWNzLCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gRGVzdHJveXMgdGhlIHNvY2tldCBvbiB0aW1lb3V0XG4gIGZ1bmN0aW9uIGRlc3Ryb3lPblRpbWVvdXQoc29ja2V0KSB7XG4gICAgc29ja2V0LnNldFRpbWVvdXQobXNlY3MpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcihcInRpbWVvdXRcIiwgc29ja2V0LmRlc3Ryb3kpO1xuICAgIHNvY2tldC5hZGRMaXN0ZW5lcihcInRpbWVvdXRcIiwgc29ja2V0LmRlc3Ryb3kpO1xuICB9XG5cbiAgLy8gU2V0cyB1cCBhIHRpbWVyIHRvIHRyaWdnZXIgYSB0aW1lb3V0IGV2ZW50XG4gIGZ1bmN0aW9uIHN0YXJ0VGltZXIoc29ja2V0KSB7XG4gICAgaWYgKHNlbGYuX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICB9XG4gICAgc2VsZi5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KFwidGltZW91dFwiKTtcbiAgICAgIGNsZWFyVGltZXIoKTtcbiAgICB9LCBtc2Vjcyk7XG4gICAgZGVzdHJveU9uVGltZW91dChzb2NrZXQpO1xuICB9XG5cbiAgLy8gU3RvcHMgYSB0aW1lb3V0IGZyb20gdHJpZ2dlcmluZ1xuICBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0XG4gICAgaWYgKHNlbGYuX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICAgIHNlbGYuX3RpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGFsbCBhdHRhY2hlZCBsaXN0ZW5lcnNcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwiYWJvcnRcIiwgY2xlYXJUaW1lcik7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGNsZWFyVGltZXIpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJyZXNwb25zZVwiLCBjbGVhclRpbWVyKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY2xlYXJUaW1lcik7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwidGltZW91dFwiLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICghc2VsZi5zb2NrZXQpIHtcbiAgICAgIHNlbGYuX2N1cnJlbnRSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKFwic29ja2V0XCIsIHN0YXJ0VGltZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF0dGFjaCBjYWxsYmFjayBpZiBwYXNzZWRcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbihcInRpbWVvdXRcIiwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU3RhcnQgdGhlIHRpbWVyIGlmIG9yIHdoZW4gdGhlIHNvY2tldCBpcyBvcGVuZWRcbiAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgc3RhcnRUaW1lcih0aGlzLnNvY2tldCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5fY3VycmVudFJlcXVlc3Qub25jZShcInNvY2tldFwiLCBzdGFydFRpbWVyKTtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIG9uIGV2ZW50c1xuICB0aGlzLm9uKFwic29ja2V0XCIsIGRlc3Ryb3lPblRpbWVvdXQpO1xuICB0aGlzLm9uKFwiYWJvcnRcIiwgY2xlYXJUaW1lcik7XG4gIHRoaXMub24oXCJlcnJvclwiLCBjbGVhclRpbWVyKTtcbiAgdGhpcy5vbihcInJlc3BvbnNlXCIsIGNsZWFyVGltZXIpO1xuICB0aGlzLm9uKFwiY2xvc2VcIiwgY2xlYXJUaW1lcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQcm94eSBhbGwgb3RoZXIgcHVibGljIENsaWVudFJlcXVlc3QgbWV0aG9kc1xuW1xuICBcImZsdXNoSGVhZGVyc1wiLCBcImdldEhlYWRlclwiLFxuICBcInNldE5vRGVsYXlcIiwgXCJzZXRTb2NrZXRLZWVwQWxpdmVcIixcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIFJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFttZXRob2RdKGEsIGIpO1xuICB9O1xufSk7XG5cbi8vIFByb3h5IGFsbCBwdWJsaWMgQ2xpZW50UmVxdWVzdCBwcm9wZXJ0aWVzXG5bXCJhYm9ydGVkXCIsIFwiY29ubmVjdGlvblwiLCBcInNvY2tldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFtwcm9wZXJ0eV07IH0sXG4gIH0pO1xufSk7XG5cblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9zYW5pdGl6ZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyBFbnN1cmUgaGVhZGVycyBhcmUgYWx3YXlzIHByZXNlbnRcbiAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgfVxuXG4gIC8vIFNpbmNlIGh0dHAucmVxdWVzdCB0cmVhdHMgaG9zdCBhcyBhbiBhbGlhcyBvZiBob3N0bmFtZSxcbiAgLy8gYnV0IHRoZSB1cmwgbW9kdWxlIGludGVycHJldHMgaG9zdCBhcyBob3N0bmFtZSBwbHVzIHBvcnQsXG4gIC8vIGVsaW1pbmF0ZSB0aGUgaG9zdCBwcm9wZXJ0eSB0byBhdm9pZCBjb25mdXNpb24uXG4gIGlmIChvcHRpb25zLmhvc3QpIHtcbiAgICAvLyBVc2UgaG9zdG5hbWUgaWYgc2V0LCBiZWNhdXNlIGl0IGhhcyBwcmVjZWRlbmNlXG4gICAgaWYgKCFvcHRpb25zLmhvc3RuYW1lKSB7XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gb3B0aW9ucy5ob3N0O1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgLy8gQ29tcGxldGUgdGhlIFVSTCBvYmplY3Qgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKCFvcHRpb25zLnBhdGhuYW1lICYmIG9wdGlvbnMucGF0aCkge1xuICAgIHZhciBzZWFyY2hQb3MgPSBvcHRpb25zLnBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaFBvcyA8IDApIHtcbiAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoMCwgc2VhcmNoUG9zKTtcbiAgICAgIG9wdGlvbnMuc2VhcmNoID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZyhzZWFyY2hQb3MpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vLyBFeGVjdXRlcyB0aGUgbmV4dCBuYXRpdmUgcmVxdWVzdCAoaW5pdGlhbCBvciByZWRpcmVjdClcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9wZXJmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gTG9hZCB0aGUgbmF0aXZlIHByb3RvY29sXG4gIHZhciBwcm90b2NvbCA9IHRoaXMuX29wdGlvbnMucHJvdG9jb2w7XG4gIHZhciBuYXRpdmVQcm90b2NvbCA9IHRoaXMuX29wdGlvbnMubmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXTtcbiAgaWYgKCFuYXRpdmVQcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBwcm90b2NvbCBcIiArIHByb3RvY29sKTtcbiAgfVxuXG4gIC8vIElmIHNwZWNpZmllZCwgdXNlIHRoZSBhZ2VudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyAoSFRUUCBhbmQgSFRUUFMgdXNlIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMpXG4gIGlmICh0aGlzLl9vcHRpb25zLmFnZW50cykge1xuICAgIHZhciBzY2hlbWUgPSBwcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgdGhpcy5fb3B0aW9ucy5hZ2VudCA9IHRoaXMuX29wdGlvbnMuYWdlbnRzW3NjaGVtZV07XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5hdGl2ZSByZXF1ZXN0IGFuZCBzZXQgdXAgaXRzIGV2ZW50IGhhbmRsZXJzXG4gIHZhciByZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3QgPVxuICAgICAgICBuYXRpdmVQcm90b2NvbC5yZXF1ZXN0KHRoaXMuX29wdGlvbnMsIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UpO1xuICByZXF1ZXN0Ll9yZWRpcmVjdGFibGUgPSB0aGlzO1xuICBmb3IgKHZhciBldmVudCBvZiBldmVudHMpIHtcbiAgICByZXF1ZXN0Lm9uKGV2ZW50LCBldmVudEhhbmRsZXJzW2V2ZW50XSk7XG4gIH1cblxuICAvLyBSRkM3MjMwwqc1LjMuMTogV2hlbiBtYWtpbmcgYSByZXF1ZXN0IGRpcmVjdGx5IHRvIGFuIG9yaWdpbiBzZXJ2ZXIsIFvigKZdXG4gIC8vIGEgY2xpZW50IE1VU1Qgc2VuZCBvbmx5IHRoZSBhYnNvbHV0ZSBwYXRoIFvigKZdIGFzIHRoZSByZXF1ZXN0LXRhcmdldC5cbiAgdGhpcy5fY3VycmVudFVybCA9IC9eXFwvLy50ZXN0KHRoaXMuX29wdGlvbnMucGF0aCkgP1xuICAgIHVybC5mb3JtYXQodGhpcy5fb3B0aW9ucykgOlxuICAgIC8vIFdoZW4gbWFraW5nIGEgcmVxdWVzdCB0byBhIHByb3h5LCBb4oCmXVxuICAgIC8vIGEgY2xpZW50IE1VU1Qgc2VuZCB0aGUgdGFyZ2V0IFVSSSBpbiBhYnNvbHV0ZS1mb3JtIFvigKZdLlxuICAgIHRoaXMuX29wdGlvbnMucGF0aDtcblxuICAvLyBFbmQgYSByZWRpcmVjdGVkIHJlcXVlc3RcbiAgLy8gKFRoZSBmaXJzdCByZXF1ZXN0IG11c3QgYmUgZW5kZWQgZXhwbGljaXRseSB3aXRoIFJlZGlyZWN0YWJsZVJlcXVlc3QjZW5kKVxuICBpZiAodGhpcy5faXNSZWRpcmVjdCkge1xuICAgIC8vIFdyaXRlIHRoZSByZXF1ZXN0IGVudGl0eSBhbmQgZW5kXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYnVmZmVycyA9IHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycztcbiAgICAoZnVuY3Rpb24gd3JpdGVOZXh0KGVycm9yKSB7XG4gICAgICAvLyBPbmx5IHdyaXRlIGlmIHRoaXMgcmVxdWVzdCBoYXMgbm90IGJlZW4gcmVkaXJlY3RlZCB5ZXRcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgICBpZiAocmVxdWVzdCA9PT0gc2VsZi5fY3VycmVudFJlcXVlc3QpIHtcbiAgICAgICAgLy8gUmVwb3J0IGFueSB3cml0ZSBlcnJvcnNcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSB0aGUgbmV4dCBidWZmZXIgaWYgdGhlcmUgYXJlIHN0aWxsIGxlZnRcbiAgICAgICAgZWxzZSBpZiAoaSA8IGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaSsrXTtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICAgICAgICAgIGlmICghcmVxdWVzdC5maW5pc2hlZCkge1xuICAgICAgICAgICAgcmVxdWVzdC53cml0ZShidWZmZXIuZGF0YSwgYnVmZmVyLmVuY29kaW5nLCB3cml0ZU5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbmQgdGhlIHJlcXVlc3QgaWYgYGVuZGAgaGFzIGJlZW4gY2FsbGVkIG9uIHVzXG4gICAgICAgIGVsc2UgaWYgKHNlbGYuX2VuZGVkKSB7XG4gICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0oKSk7XG4gIH1cbn07XG5cbi8vIFByb2Nlc3NlcyBhIHJlc3BvbnNlIGZyb20gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9wcm9jZXNzUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgLy8gU3RvcmUgdGhlIHJlZGlyZWN0ZWQgcmVzcG9uc2VcbiAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICBpZiAodGhpcy5fb3B0aW9ucy50cmFja1JlZGlyZWN0cykge1xuICAgIHRoaXMuX3JlZGlyZWN0cy5wdXNoKHtcbiAgICAgIHVybDogdGhpcy5fY3VycmVudFVybCxcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUkZDNzIzMcKnNi40OiBUaGUgM3h4IChSZWRpcmVjdGlvbikgY2xhc3Mgb2Ygc3RhdHVzIGNvZGUgaW5kaWNhdGVzXG4gIC8vIHRoYXQgZnVydGhlciBhY3Rpb24gbmVlZHMgdG8gYmUgdGFrZW4gYnkgdGhlIHVzZXIgYWdlbnQgaW4gb3JkZXIgdG9cbiAgLy8gZnVsZmlsbCB0aGUgcmVxdWVzdC4gSWYgYSBMb2NhdGlvbiBoZWFkZXIgZmllbGQgaXMgcHJvdmlkZWQsXG4gIC8vIHRoZSB1c2VyIGFnZW50IE1BWSBhdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGl0cyByZXF1ZXN0IHRvIHRoZSBVUklcbiAgLy8gcmVmZXJlbmNlZCBieSB0aGUgTG9jYXRpb24gZmllbGQgdmFsdWUsXG4gIC8vIGV2ZW4gaWYgdGhlIHNwZWNpZmljIHN0YXR1cyBjb2RlIGlzIG5vdCB1bmRlcnN0b29kLlxuXG4gIC8vIElmIHRoZSByZXNwb25zZSBpcyBub3QgYSByZWRpcmVjdDsgcmV0dXJuIGl0IGFzLWlzXG4gIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gIGlmICghbG9jYXRpb24gfHwgdGhpcy5fb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgPT09IGZhbHNlIHx8XG4gICAgICBzdGF0dXNDb2RlIDwgMzAwIHx8IHN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgcmVzcG9uc2UucmVzcG9uc2VVcmwgPSB0aGlzLl9jdXJyZW50VXJsO1xuICAgIHJlc3BvbnNlLnJlZGlyZWN0cyA9IHRoaXMuX3JlZGlyZWN0cztcbiAgICB0aGlzLmVtaXQoXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG5cbiAgICAvLyBDbGVhbiB1cFxuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZSByZXNwb25zZSBpcyBhIHJlZGlyZWN0LCBzbyBhYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0XG4gIGRlc3Ryb3lSZXF1ZXN0KHRoaXMuX2N1cnJlbnRSZXF1ZXN0KTtcbiAgLy8gRGlzY2FyZCB0aGUgcmVtYWluZGVyIG9mIHRoZSByZXNwb25zZSB0byBhdm9pZCB3YWl0aW5nIGZvciBkYXRhXG4gIHJlc3BvbnNlLmRlc3Ryb3koKTtcblxuICAvLyBSRkM3MjMxwqc2LjQ6IEEgY2xpZW50IFNIT1VMRCBkZXRlY3QgYW5kIGludGVydmVuZVxuICAvLyBpbiBjeWNsaWNhbCByZWRpcmVjdGlvbnMgKGkuZS4sIFwiaW5maW5pdGVcIiByZWRpcmVjdGlvbiBsb29wcykuXG4gIGlmICgrK3RoaXMuX3JlZGlyZWN0Q291bnQgPiB0aGlzLl9vcHRpb25zLm1heFJlZGlyZWN0cykge1xuICAgIHRocm93IG5ldyBUb29NYW55UmVkaXJlY3RzRXJyb3IoKTtcbiAgfVxuXG4gIC8vIFN0b3JlIHRoZSByZXF1ZXN0IGhlYWRlcnMgaWYgYXBwbGljYWJsZVxuICB2YXIgcmVxdWVzdEhlYWRlcnM7XG4gIHZhciBiZWZvcmVSZWRpcmVjdCA9IHRoaXMuX29wdGlvbnMuYmVmb3JlUmVkaXJlY3Q7XG4gIGlmIChiZWZvcmVSZWRpcmVjdCkge1xuICAgIHJlcXVlc3RIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAvLyBUaGUgSG9zdCBoZWFkZXIgd2FzIHNldCBieSBuYXRpdmVQcm90b2NvbC5yZXF1ZXN0XG4gICAgICBIb3N0OiByZXNwb25zZS5yZXEuZ2V0SGVhZGVyKFwiaG9zdFwiKSxcbiAgICB9LCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xuICB9XG5cbiAgLy8gUkZDNzIzMcKnNi40OiBBdXRvbWF0aWMgcmVkaXJlY3Rpb24gbmVlZHMgdG8gZG9uZSB3aXRoXG4gIC8vIGNhcmUgZm9yIG1ldGhvZHMgbm90IGtub3duIHRvIGJlIHNhZmUsIFvigKZdXG4gIC8vIFJGQzcyMzHCpzYuNC4y4oCTMzogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgYSB1c2VyIGFnZW50IE1BWSBjaGFuZ2VcbiAgLy8gdGhlIHJlcXVlc3QgbWV0aG9kIGZyb20gUE9TVCB0byBHRVQgZm9yIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3QuXG4gIHZhciBtZXRob2QgPSB0aGlzLl9vcHRpb25zLm1ldGhvZDtcbiAgaWYgKChzdGF0dXNDb2RlID09PSAzMDEgfHwgc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiB0aGlzLl9vcHRpb25zLm1ldGhvZCA9PT0gXCJQT1NUXCIgfHxcbiAgICAgIC8vIFJGQzcyMzHCpzYuNC40OiBUaGUgMzAzIChTZWUgT3RoZXIpIHN0YXR1cyBjb2RlIGluZGljYXRlcyB0aGF0XG4gICAgICAvLyB0aGUgc2VydmVyIGlzIHJlZGlyZWN0aW5nIHRoZSB1c2VyIGFnZW50IHRvIGEgZGlmZmVyZW50IHJlc291cmNlIFvigKZdXG4gICAgICAvLyBBIHVzZXIgYWdlbnQgY2FuIHBlcmZvcm0gYSByZXRyaWV2YWwgcmVxdWVzdCB0YXJnZXRpbmcgdGhhdCBVUklcbiAgICAgIC8vIChhIEdFVCBvciBIRUFEIHJlcXVlc3QgaWYgdXNpbmcgSFRUUCkgW+KApl1cbiAgICAgIChzdGF0dXNDb2RlID09PSAzMDMpICYmICEvXig/OkdFVHxIRUFEKSQvLnRlc3QodGhpcy5fb3B0aW9ucy5tZXRob2QpKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5tZXRob2QgPSBcIkdFVFwiO1xuICAgIC8vIERyb3AgYSBwb3NzaWJsZSBlbnRpdHkgYW5kIGhlYWRlcnMgcmVsYXRlZCB0byBpdFxuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuICAgIHJlbW92ZU1hdGNoaW5nSGVhZGVycygvXmNvbnRlbnQtL2ksIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7XG4gIH1cblxuICAvLyBEcm9wIHRoZSBIb3N0IGhlYWRlciwgYXMgdGhlIHJlZGlyZWN0IG1pZ2h0IGxlYWQgdG8gYSBkaWZmZXJlbnQgaG9zdFxuICB2YXIgY3VycmVudEhvc3RIZWFkZXIgPSByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL15ob3N0JC9pLCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xuXG4gIC8vIElmIHRoZSByZWRpcmVjdCBpcyByZWxhdGl2ZSwgY2Fycnkgb3ZlciB0aGUgaG9zdCBvZiB0aGUgbGFzdCByZXF1ZXN0XG4gIHZhciBjdXJyZW50VXJsUGFydHMgPSBwYXJzZVVybCh0aGlzLl9jdXJyZW50VXJsKTtcbiAgdmFyIGN1cnJlbnRIb3N0ID0gY3VycmVudEhvc3RIZWFkZXIgfHwgY3VycmVudFVybFBhcnRzLmhvc3Q7XG4gIHZhciBjdXJyZW50VXJsID0gL15cXHcrOi8udGVzdChsb2NhdGlvbikgPyB0aGlzLl9jdXJyZW50VXJsIDpcbiAgICB1cmwuZm9ybWF0KE9iamVjdC5hc3NpZ24oY3VycmVudFVybFBhcnRzLCB7IGhvc3Q6IGN1cnJlbnRIb3N0IH0pKTtcblxuICAvLyBDcmVhdGUgdGhlIHJlZGlyZWN0ZWQgcmVxdWVzdFxuICB2YXIgcmVkaXJlY3RVcmwgPSByZXNvbHZlVXJsKGxvY2F0aW9uLCBjdXJyZW50VXJsKTtcbiAgZGVidWcoXCJyZWRpcmVjdGluZyB0b1wiLCByZWRpcmVjdFVybC5ocmVmKTtcbiAgdGhpcy5faXNSZWRpcmVjdCA9IHRydWU7XG4gIHNwcmVhZFVybE9iamVjdChyZWRpcmVjdFVybCwgdGhpcy5fb3B0aW9ucyk7XG5cbiAgLy8gRHJvcCBjb25maWRlbnRpYWwgaGVhZGVycyB3aGVuIHJlZGlyZWN0aW5nIHRvIGEgbGVzcyBzZWN1cmUgcHJvdG9jb2xcbiAgLy8gb3IgdG8gYSBkaWZmZXJlbnQgZG9tYWluIHRoYXQgaXMgbm90IGEgc3VwZXJkb21haW5cbiAgaWYgKHJlZGlyZWN0VXJsLnByb3RvY29sICE9PSBjdXJyZW50VXJsUGFydHMucHJvdG9jb2wgJiZcbiAgICAgcmVkaXJlY3RVcmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIgfHxcbiAgICAgcmVkaXJlY3RVcmwuaG9zdCAhPT0gY3VycmVudEhvc3QgJiZcbiAgICAgIWlzU3ViZG9tYWluKHJlZGlyZWN0VXJsLmhvc3QsIGN1cnJlbnRIb3N0KSkge1xuICAgIHJlbW92ZU1hdGNoaW5nSGVhZGVycygvXig/Oig/OnByb3h5LSk/YXV0aG9yaXphdGlvbnxjb29raWUpJC9pLCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xuICB9XG5cbiAgLy8gRXZhbHVhdGUgdGhlIGJlZm9yZVJlZGlyZWN0IGNhbGxiYWNrXG4gIGlmIChpc0Z1bmN0aW9uKGJlZm9yZVJlZGlyZWN0KSkge1xuICAgIHZhciByZXNwb25zZURldGFpbHMgPSB7XG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcbiAgICB9O1xuICAgIHZhciByZXF1ZXN0RGV0YWlscyA9IHtcbiAgICAgIHVybDogY3VycmVudFVybCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgaGVhZGVyczogcmVxdWVzdEhlYWRlcnMsXG4gICAgfTtcbiAgICBiZWZvcmVSZWRpcmVjdCh0aGlzLl9vcHRpb25zLCByZXNwb25zZURldGFpbHMsIHJlcXVlc3REZXRhaWxzKTtcbiAgICB0aGlzLl9zYW5pdGl6ZU9wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gIH1cblxuICAvLyBQZXJmb3JtIHRoZSByZWRpcmVjdGVkIHJlcXVlc3RcbiAgdGhpcy5fcGVyZm9ybVJlcXVlc3QoKTtcbn07XG5cbi8vIFdyYXBzIHRoZSBrZXkvdmFsdWUgb2JqZWN0IG9mIHByb3RvY29scyB3aXRoIHJlZGlyZWN0IGZ1bmN0aW9uYWxpdHlcbmZ1bmN0aW9uIHdyYXAocHJvdG9jb2xzKSB7XG4gIC8vIERlZmF1bHQgc2V0dGluZ3NcbiAgdmFyIGV4cG9ydHMgPSB7XG4gICAgbWF4UmVkaXJlY3RzOiAyMSxcbiAgICBtYXhCb2R5TGVuZ3RoOiAxMCAqIDEwMjQgKiAxMDI0LFxuICB9O1xuXG4gIC8vIFdyYXAgZWFjaCBwcm90b2NvbFxuICB2YXIgbmF0aXZlUHJvdG9jb2xzID0ge307XG4gIE9iamVjdC5rZXlzKHByb3RvY29scykuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgdmFyIHByb3RvY29sID0gc2NoZW1lICsgXCI6XCI7XG4gICAgdmFyIG5hdGl2ZVByb3RvY29sID0gbmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXSA9IHByb3RvY29sc1tzY2hlbWVdO1xuICAgIHZhciB3cmFwcGVkUHJvdG9jb2wgPSBleHBvcnRzW3NjaGVtZV0gPSBPYmplY3QuY3JlYXRlKG5hdGl2ZVByb3RvY29sKTtcblxuICAgIC8vIEV4ZWN1dGVzIGEgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIGZ1bmN0aW9uIHJlcXVlc3QoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBQYXJzZSBwYXJhbWV0ZXJzLCBlbnN1cmluZyB0aGF0IGlucHV0IGlzIGFuIG9iamVjdFxuICAgICAgaWYgKGlzVVJMKGlucHV0KSkge1xuICAgICAgICBpbnB1dCA9IHNwcmVhZFVybE9iamVjdChpbnB1dCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICAgICAgaW5wdXQgPSBzcHJlYWRVcmxPYmplY3QocGFyc2VVcmwoaW5wdXQpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB2YWxpZGF0ZVVybChpbnB1dCk7XG4gICAgICAgIGlucHV0ID0geyBwcm90b2NvbDogcHJvdG9jb2wgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBkZWZhdWx0c1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBtYXhSZWRpcmVjdHM6IGV4cG9ydHMubWF4UmVkaXJlY3RzLFxuICAgICAgICBtYXhCb2R5TGVuZ3RoOiBleHBvcnRzLm1heEJvZHlMZW5ndGgsXG4gICAgICB9LCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLm5hdGl2ZVByb3RvY29scyA9IG5hdGl2ZVByb3RvY29scztcbiAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5ob3N0KSAmJiAhaXNTdHJpbmcob3B0aW9ucy5ob3N0bmFtZSkpIHtcbiAgICAgICAgb3B0aW9ucy5ob3N0bmFtZSA9IFwiOjoxXCI7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydC5lcXVhbChvcHRpb25zLnByb3RvY29sLCBwcm90b2NvbCwgXCJwcm90b2NvbCBtaXNtYXRjaFwiKTtcbiAgICAgIGRlYnVnKFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBuZXcgUmVkaXJlY3RhYmxlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLy8gRXhlY3V0ZXMgYSBHRVQgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xuICAgIGZ1bmN0aW9uIGdldChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIHZhciB3cmFwcGVkUmVxdWVzdCA9IHdyYXBwZWRQcm90b2NvbC5yZXF1ZXN0KGlucHV0LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB3cmFwcGVkUmVxdWVzdC5lbmQoKTtcbiAgICAgIHJldHVybiB3cmFwcGVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgdGhlIHByb3BlcnRpZXMgb24gdGhlIHdyYXBwZWQgcHJvdG9jb2xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkUHJvdG9jb2wsIHtcbiAgICAgIHJlcXVlc3Q6IHsgdmFsdWU6IHJlcXVlc3QsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgIGdldDogeyB2YWx1ZTogZ2V0LCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsgLyogZW1wdHkgKi8gfVxuXG5mdW5jdGlvbiBwYXJzZVVybChpbnB1dCkge1xuICB2YXIgcGFyc2VkO1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICBpZiAodXNlTmF0aXZlVVJMKSB7XG4gICAgcGFyc2VkID0gbmV3IFVSTChpbnB1dCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRW5zdXJlIHRoZSBVUkwgaXMgdmFsaWQgYW5kIGFic29sdXRlXG4gICAgcGFyc2VkID0gdmFsaWRhdGVVcmwodXJsLnBhcnNlKGlucHV0KSk7XG4gICAgaWYgKCFpc1N0cmluZyhwYXJzZWQucHJvdG9jb2wpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFVybEVycm9yKHsgaW5wdXQgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwocmVsYXRpdmUsIGJhc2UpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgcmV0dXJuIHVzZU5hdGl2ZVVSTCA/IG5ldyBVUkwocmVsYXRpdmUsIGJhc2UpIDogcGFyc2VVcmwodXJsLnJlc29sdmUoYmFzZSwgcmVsYXRpdmUpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVVcmwoaW5wdXQpIHtcbiAgaWYgKC9eXFxbLy50ZXN0KGlucHV0Lmhvc3RuYW1lKSAmJiAhL15cXFtbOjAtOWEtZl0rXFxdJC9pLnRlc3QoaW5wdXQuaG9zdG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRVcmxFcnJvcih7IGlucHV0OiBpbnB1dC5ocmVmIHx8IGlucHV0IH0pO1xuICB9XG4gIGlmICgvXlxcWy8udGVzdChpbnB1dC5ob3N0KSAmJiAhL15cXFtbOjAtOWEtZl0rXFxdKDpcXGQrKT8kL2kudGVzdChpbnB1dC5ob3N0KSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVXJsRXJyb3IoeyBpbnB1dDogaW5wdXQuaHJlZiB8fCBpbnB1dCB9KTtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cbmZ1bmN0aW9uIHNwcmVhZFVybE9iamVjdCh1cmxPYmplY3QsIHRhcmdldCkge1xuICB2YXIgc3ByZWFkID0gdGFyZ2V0IHx8IHt9O1xuICBmb3IgKHZhciBrZXkgb2YgcHJlc2VydmVkVXJsRmllbGRzKSB7XG4gICAgc3ByZWFkW2tleV0gPSB1cmxPYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8vIEZpeCBJUHY2IGhvc3RuYW1lXG4gIGlmIChzcHJlYWQuaG9zdG5hbWUuc3RhcnRzV2l0aChcIltcIikpIHtcbiAgICBzcHJlYWQuaG9zdG5hbWUgPSBzcHJlYWQuaG9zdG5hbWUuc2xpY2UoMSwgLTEpO1xuICB9XG4gIC8vIEVuc3VyZSBwb3J0IGlzIGEgbnVtYmVyXG4gIGlmIChzcHJlYWQucG9ydCAhPT0gXCJcIikge1xuICAgIHNwcmVhZC5wb3J0ID0gTnVtYmVyKHNwcmVhZC5wb3J0KTtcbiAgfVxuICAvLyBDb25jYXRlbmF0ZSBwYXRoXG4gIHNwcmVhZC5wYXRoID0gc3ByZWFkLnNlYXJjaCA/IHNwcmVhZC5wYXRobmFtZSArIHNwcmVhZC5zZWFyY2ggOiBzcHJlYWQucGF0aG5hbWU7XG5cbiAgcmV0dXJuIHNwcmVhZDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKHJlZ2V4LCBoZWFkZXJzKSB7XG4gIHZhciBsYXN0VmFsdWU7XG4gIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKHJlZ2V4LnRlc3QoaGVhZGVyKSkge1xuICAgICAgbGFzdFZhbHVlID0gaGVhZGVyc1toZWFkZXJdO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChsYXN0VmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGxhc3RWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikgP1xuICAgIHVuZGVmaW5lZCA6IFN0cmluZyhsYXN0VmFsdWUpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIGJhc2VDbGFzcykge1xuICAvLyBDcmVhdGUgY29uc3RydWN0b3JcbiAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IocHJvcGVydGllcykge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgaWYgKGlzRnVuY3Rpb24oRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY2F1c2UgPyBtZXNzYWdlICsgXCI6IFwiICsgdGhpcy5jYXVzZS5tZXNzYWdlIDogbWVzc2FnZTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBjb25zdHJ1Y3RvciBhbmQgc2V0IGRlZmF1bHQgcHJvcGVydGllc1xuICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBuZXcgKGJhc2VDbGFzcyB8fCBFcnJvcikoKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBDdXN0b21FcnJvcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgdmFsdWU6IFwiRXJyb3IgW1wiICsgY29kZSArIFwiXVwiLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG4gIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxuZnVuY3Rpb24gZGVzdHJveVJlcXVlc3QocmVxdWVzdCwgZXJyb3IpIHtcbiAgZm9yICh2YXIgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcihldmVudCwgZXZlbnRIYW5kbGVyc1tldmVudF0pO1xuICB9XG4gIHJlcXVlc3Qub24oXCJlcnJvclwiLCBub29wKTtcbiAgcmVxdWVzdC5kZXN0cm95KGVycm9yKTtcbn1cblxuZnVuY3Rpb24gaXNTdWJkb21haW4oc3ViZG9tYWluLCBkb21haW4pIHtcbiAgYXNzZXJ0KGlzU3RyaW5nKHN1YmRvbWFpbikgJiYgaXNTdHJpbmcoZG9tYWluKSk7XG4gIHZhciBkb3QgPSBzdWJkb21haW4ubGVuZ3RoIC0gZG9tYWluLmxlbmd0aCAtIDE7XG4gIHJldHVybiBkb3QgPiAwICYmIHN1YmRvbWFpbltkb3RdID09PSBcIi5cIiAmJiBzdWJkb21haW4uZW5kc1dpdGgoZG9tYWluKTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgKFwibGVuZ3RoXCIgaW4gdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpc1VSTCh2YWx1ZSkge1xuICByZXR1cm4gVVJMICYmIHZhbHVlIGluc3RhbmNlb2YgVVJMO1xufVxuXG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXAoeyBodHRwOiBodHRwLCBodHRwczogaHR0cHMgfSk7XG5tb2R1bGUuZXhwb3J0cy53cmFwID0gd3JhcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3164\n')},3387:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*global module*/\nvar Buffer = (__webpack_require__(2861).Buffer);\nvar DataStream = __webpack_require__(8948);\nvar jwa = __webpack_require__(8789);\nvar Stream = __webpack_require__(2203);\nvar toString = __webpack_require__(2851);\nvar util = __webpack_require__(9023);\n\nfunction base64url(string, encoding) {\n  return Buffer\n    .from(string, encoding)\n    .toString('base64')\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n\nfunction jwsSecuredInput(header, payload, encoding) {\n  encoding = encoding || 'utf8';\n  var encodedHeader = base64url(toString(header), 'binary');\n  var encodedPayload = base64url(toString(payload), encoding);\n  return util.format('%s.%s', encodedHeader, encodedPayload);\n}\n\nfunction jwsSign(opts) {\n  var header = opts.header;\n  var payload = opts.payload;\n  var secretOrKey = opts.secret || opts.privateKey;\n  var encoding = opts.encoding;\n  var algo = jwa(header.alg);\n  var securedInput = jwsSecuredInput(header, payload, encoding);\n  var signature = algo.sign(securedInput, secretOrKey);\n  return util.format('%s.%s', securedInput, signature);\n}\n\nfunction SignStream(opts) {\n  var secret = opts.secret||opts.privateKey||opts.key;\n  var secretStream = new DataStream(secret);\n  this.readable = true;\n  this.header = opts.header;\n  this.encoding = opts.encoding;\n  this.secret = this.privateKey = this.key = secretStream;\n  this.payload = new DataStream(opts.payload);\n  this.secret.once('close', function () {\n    if (!this.payload.writable && this.readable)\n      this.sign();\n  }.bind(this));\n\n  this.payload.once('close', function () {\n    if (!this.secret.writable && this.readable)\n      this.sign();\n  }.bind(this));\n}\nutil.inherits(SignStream, Stream);\n\nSignStream.prototype.sign = function sign() {\n  try {\n    var signature = jwsSign({\n      header: this.header,\n      payload: this.payload.buffer,\n      secret: this.secret.buffer,\n      encoding: this.encoding\n    });\n    this.emit('done', signature);\n    this.emit('data', signature);\n    this.emit('end');\n    this.readable = false;\n    return signature;\n  } catch (e) {\n    this.readable = false;\n    this.emit('error', e);\n    this.emit('close');\n  }\n};\n\nSignStream.sign = jwsSign;\n\nmodule.exports = SignStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsa0NBQTZCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLElBQWU7QUFDeEMsVUFBVSxtQkFBTyxDQUFDLElBQUs7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLElBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLElBQVk7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLElBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2p3cy9saWIvc2lnbi1zdHJlYW0uanM/NmMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBtb2R1bGUqL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIERhdGFTdHJlYW0gPSByZXF1aXJlKCcuL2RhdGEtc3RyZWFtJyk7XG52YXIgandhID0gcmVxdWlyZSgnandhJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3Rvc3RyaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gYmFzZTY0dXJsKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIEJ1ZmZlclxuICAgIC5mcm9tKHN0cmluZywgZW5jb2RpbmcpXG4gICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIC5yZXBsYWNlKC89L2csICcnKVxuICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKTtcbn1cblxuZnVuY3Rpb24gandzU2VjdXJlZElucHV0KGhlYWRlciwgcGF5bG9hZCwgZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG4gIHZhciBlbmNvZGVkSGVhZGVyID0gYmFzZTY0dXJsKHRvU3RyaW5nKGhlYWRlciksICdiaW5hcnknKTtcbiAgdmFyIGVuY29kZWRQYXlsb2FkID0gYmFzZTY0dXJsKHRvU3RyaW5nKHBheWxvYWQpLCBlbmNvZGluZyk7XG4gIHJldHVybiB1dGlsLmZvcm1hdCgnJXMuJXMnLCBlbmNvZGVkSGVhZGVyLCBlbmNvZGVkUGF5bG9hZCk7XG59XG5cbmZ1bmN0aW9uIGp3c1NpZ24ob3B0cykge1xuICB2YXIgaGVhZGVyID0gb3B0cy5oZWFkZXI7XG4gIHZhciBwYXlsb2FkID0gb3B0cy5wYXlsb2FkO1xuICB2YXIgc2VjcmV0T3JLZXkgPSBvcHRzLnNlY3JldCB8fCBvcHRzLnByaXZhdGVLZXk7XG4gIHZhciBlbmNvZGluZyA9IG9wdHMuZW5jb2Rpbmc7XG4gIHZhciBhbGdvID0gandhKGhlYWRlci5hbGcpO1xuICB2YXIgc2VjdXJlZElucHV0ID0gandzU2VjdXJlZElucHV0KGhlYWRlciwgcGF5bG9hZCwgZW5jb2RpbmcpO1xuICB2YXIgc2lnbmF0dXJlID0gYWxnby5zaWduKHNlY3VyZWRJbnB1dCwgc2VjcmV0T3JLZXkpO1xuICByZXR1cm4gdXRpbC5mb3JtYXQoJyVzLiVzJywgc2VjdXJlZElucHV0LCBzaWduYXR1cmUpO1xufVxuXG5mdW5jdGlvbiBTaWduU3RyZWFtKG9wdHMpIHtcbiAgdmFyIHNlY3JldCA9IG9wdHMuc2VjcmV0fHxvcHRzLnByaXZhdGVLZXl8fG9wdHMua2V5O1xuICB2YXIgc2VjcmV0U3RyZWFtID0gbmV3IERhdGFTdHJlYW0oc2VjcmV0KTtcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gIHRoaXMuaGVhZGVyID0gb3B0cy5oZWFkZXI7XG4gIHRoaXMuZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nO1xuICB0aGlzLnNlY3JldCA9IHRoaXMucHJpdmF0ZUtleSA9IHRoaXMua2V5ID0gc2VjcmV0U3RyZWFtO1xuICB0aGlzLnBheWxvYWQgPSBuZXcgRGF0YVN0cmVhbShvcHRzLnBheWxvYWQpO1xuICB0aGlzLnNlY3JldC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMucGF5bG9hZC53cml0YWJsZSAmJiB0aGlzLnJlYWRhYmxlKVxuICAgICAgdGhpcy5zaWduKCk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5wYXlsb2FkLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5zZWNyZXQud3JpdGFibGUgJiYgdGhpcy5yZWFkYWJsZSlcbiAgICAgIHRoaXMuc2lnbigpO1xuICB9LmJpbmQodGhpcykpO1xufVxudXRpbC5pbmhlcml0cyhTaWduU3RyZWFtLCBTdHJlYW0pO1xuXG5TaWduU3RyZWFtLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgc2lnbmF0dXJlID0gandzU2lnbih7XG4gICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkLmJ1ZmZlcixcbiAgICAgIHNlY3JldDogdGhpcy5zZWNyZXQuYnVmZmVyLFxuICAgICAgZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmdcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ2RvbmUnLCBzaWduYXR1cmUpO1xuICAgIHRoaXMuZW1pdCgnZGF0YScsIHNpZ25hdHVyZSk7XG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICB9XG59O1xuXG5TaWduU3RyZWFtLnNpZ24gPSBqd3NTaWduO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25TdHJlYW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3387\n")},3527:module=>{"use strict";eval("\n\nfunction getParamSize(keySize) {\n\tvar result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);\n\treturn result;\n}\n\nvar paramBytesForAlg = {\n\tES256: getParamSize(256),\n\tES384: getParamSize(384),\n\tES512: getParamSize(521)\n};\n\nfunction getParamBytesForAlg(alg) {\n\tvar paramBytes = paramBytesForAlg[alg];\n\tif (paramBytes) {\n\t\treturn paramBytes;\n\t}\n\n\tthrow new Error('Unknown algorithm \"' + alg + '\"');\n}\n\nmodule.exports = getParamBytesForAlg;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUyNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VjZHNhLXNpZy1mb3JtYXR0ZXIvc3JjL3BhcmFtLWJ5dGVzLWZvci1hbGcuanM/MmUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldFBhcmFtU2l6ZShrZXlTaXplKSB7XG5cdHZhciByZXN1bHQgPSAoKGtleVNpemUgLyA4KSB8IDApICsgKGtleVNpemUgJSA4ID09PSAwID8gMCA6IDEpO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgcGFyYW1CeXRlc0ZvckFsZyA9IHtcblx0RVMyNTY6IGdldFBhcmFtU2l6ZSgyNTYpLFxuXHRFUzM4NDogZ2V0UGFyYW1TaXplKDM4NCksXG5cdEVTNTEyOiBnZXRQYXJhbVNpemUoNTIxKVxufTtcblxuZnVuY3Rpb24gZ2V0UGFyYW1CeXRlc0ZvckFsZyhhbGcpIHtcblx0dmFyIHBhcmFtQnl0ZXMgPSBwYXJhbUJ5dGVzRm9yQWxnW2FsZ107XG5cdGlmIChwYXJhbUJ5dGVzKSB7XG5cdFx0cmV0dXJuIHBhcmFtQnl0ZXM7XG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYWxnb3JpdGhtIFwiJyArIGFsZyArICdcIicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFBhcmFtQnl0ZXNGb3JBbGc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3527\n")},3628:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar reflectGetProto = __webpack_require__(8648);\nvar originalGetProto = __webpack_require__(1064);\n\nvar getDunderProto = __webpack_require__(7176);\n\n/** @type {import('.')} */\nmodule.exports = reflectGetProto\n\t? function getProto(O) {\n\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\treturn reflectGetProto(O);\n\t}\n\t: originalGetProto\n\t\t? function getProto(O) {\n\t\t\tif (!O || (typeof O !== 'object' && typeof O !== 'function')) {\n\t\t\t\tthrow new TypeError('getProto: not an object');\n\t\t\t}\n\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\treturn originalGetProto(O);\n\t\t}\n\t\t: getDunderProto\n\t\t\t? function getProto(O) {\n\t\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\t\treturn getDunderProto(O);\n\t\t\t}\n\t\t\t: null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUN4RCx1QkFBdUIsbUJBQU8sQ0FBQyxJQUF5Qjs7QUFFeEQscUJBQXFCLG1CQUFPLENBQUMsSUFBa0I7O0FBRS9DLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2dldC1wcm90by9pbmRleC5qcz84MzNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZmxlY3RHZXRQcm90byA9IHJlcXVpcmUoJy4vUmVmbGVjdC5nZXRQcm90b3R5cGVPZicpO1xudmFyIG9yaWdpbmFsR2V0UHJvdG8gPSByZXF1aXJlKCcuL09iamVjdC5nZXRQcm90b3R5cGVPZicpO1xuXG52YXIgZ2V0RHVuZGVyUHJvdG8gPSByZXF1aXJlKCdkdW5kZXItcHJvdG8vZ2V0Jyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RHZXRQcm90b1xuXHQ/IGZ1bmN0aW9uIGdldFByb3RvKE8pIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGNhbid0IG5hcnJvdyBpbnNpZGUgYSBjbG9zdXJlLCBmb3Igc29tZSByZWFzb25cblx0XHRyZXR1cm4gcmVmbGVjdEdldFByb3RvKE8pO1xuXHR9XG5cdDogb3JpZ2luYWxHZXRQcm90b1xuXHRcdD8gZnVuY3Rpb24gZ2V0UHJvdG8oTykge1xuXHRcdFx0aWYgKCFPIHx8ICh0eXBlb2YgTyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIE8gIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldFByb3RvOiBub3QgYW4gb2JqZWN0Jyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGNhbid0IG5hcnJvdyBpbnNpZGUgYSBjbG9zdXJlLCBmb3Igc29tZSByZWFzb25cblx0XHRcdHJldHVybiBvcmlnaW5hbEdldFByb3RvKE8pO1xuXHRcdH1cblx0XHQ6IGdldER1bmRlclByb3RvXG5cdFx0XHQ/IGZ1bmN0aW9uIGdldFByb3RvKE8pIHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUUyBjYW4ndCBuYXJyb3cgaW5zaWRlIGEgY2xvc3VyZSwgZm9yIHNvbWUgcmVhc29uXG5cdFx0XHRcdHJldHVybiBnZXREdW5kZXJQcm90byhPKTtcblx0XHRcdH1cblx0XHRcdDogbnVsbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3628\n")},3639:module=>{eval("/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n * as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && objectToString.call(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzbnVtYmVyL2luZGV4LmpzPzY3ZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggMy4wLjMgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICogYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlclRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3639\n")},3726:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var JsonWebTokenError = __webpack_require__(1741);\n\nvar NotBeforeError = function (message, date) {\n  JsonWebTokenError.call(this, message);\n  this.name = 'NotBeforeError';\n  this.date = date;\n};\n\nNotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);\n\nNotBeforeError.prototype.constructor = NotBeforeError;\n\nmodule.exports = NotBeforeError;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcyNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFxQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9saWIvTm90QmVmb3JlRXJyb3IuanM/ZjMwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSnNvbldlYlRva2VuRXJyb3IgPSByZXF1aXJlKCcuL0pzb25XZWJUb2tlbkVycm9yJyk7XG5cbnZhciBOb3RCZWZvcmVFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRlKSB7XG4gIEpzb25XZWJUb2tlbkVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gIHRoaXMubmFtZSA9ICdOb3RCZWZvcmVFcnJvcic7XG4gIHRoaXMuZGF0ZSA9IGRhdGU7XG59O1xuXG5Ob3RCZWZvcmVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzb25XZWJUb2tlbkVycm9yLnByb3RvdHlwZSk7XG5cbk5vdEJlZm9yZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vdEJlZm9yZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vdEJlZm9yZUVycm9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3726\n")},3874:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst Range = __webpack_require__(8311)\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3NC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsSUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdmFsaWQuanM/Y2VmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3874\n")},3904:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = __webpack_require__(8587)\nconst { safeRe: re, t } = __webpack_require__(9718)\nconst cmp = __webpack_require__(2111)\nconst debug = __webpack_require__(7272)\nconst SemVer = __webpack_require__(3908)\nconst Range = __webpack_require__(8311)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwNC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLElBQTJCO0FBQ3hELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxJQUFnQjtBQUNsRCxZQUFZLG1CQUFPLENBQUMsSUFBa0I7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLElBQW1CO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxJQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcz9iZjAwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcCA9IGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbignICcpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpXG4gICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlcyB3aGVyZSBub3RoaW5nIGNhbiBwb3NzaWJseSBiZSBsb3dlclxuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZSA9PT0gJzwwLjAuMC0wJyB8fCBjb21wLnZhbHVlID09PSAnPDAuMC4wLTAnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykgfHwgY29tcC52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGluY3JlYXNpbmcgKD4gb3IgPj0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBkZWNyZWFzaW5nICg8IG9yIDw9KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gc2FtZSBTZW1WZXIgYW5kIGJvdGggc2lkZXMgYXJlIGluY2x1c2l2ZSAoPD0gb3IgPj0pXG4gICAgaWYgKFxuICAgICAgKHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb24pICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykgJiYgY29tcC5vcGVyYXRvci5pbmNsdWRlcygnPScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGxlc3MgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBncmVhdGVyIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyYXRvclxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgc2FmZVJlOiByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3904\n")},3908:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst debug = __webpack_require__(7272)\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(6874)\nconst { safeRe: re, t } = __webpack_require__(9718)\n\nconst parseOptions = __webpack_require__(8587)\nconst { compareIdentifiers } = __webpack_require__(1123)\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n        version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    if (release.startsWith('pre')) {\n      if (!identifier && identifierBase === false) {\n        throw new Error('invalid increment argument: identifier is empty')\n      }\n      // Avoid an invalid semver results\n      if (identifier) {\n        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE])\n        if (!match || match[1] !== identifier) {\n          throw new Error(`invalid identifier: ${identifier}`)\n        }\n      }\n    }\n\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'release':\n        if (this.prerelease.length === 0) {\n          throw new Error(`version ${this.raw} is not a prerelease`)\n        }\n        this.prerelease.length = 0\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwOC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsSUFBbUI7QUFDekMsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLElBQXVCO0FBQ3hFLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxJQUFnQjs7QUFFbEQscUJBQXFCLG1CQUFPLENBQUMsSUFBMkI7QUFDeEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLElBQXlCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBFQUEwRSxlQUFlO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDN0Q7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qcz9kZjAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IHsgTUFYX0xFTkdUSCwgTUFYX1NBRkVfSU5URUdFUiB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IHsgc2FmZVJlOiByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgY29tcGFyZUlkZW50aWZpZXJzIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jbGFzcyBTZW1WZXIge1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZlcnNpb24uIE11c3QgYmUgYSBzdHJpbmcuIEdvdCB0eXBlIFwiJHt0eXBlb2YgdmVyc2lvbn1cIi5gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygnYnVpbGQgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBpZiAocmVsZWFzZS5zdGFydHNXaXRoKCdwcmUnKSkge1xuICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiBpZGVudGlmaWVyIGlzIGVtcHR5JylcbiAgICAgIH1cbiAgICAgIC8vIEF2b2lkIGFuIGludmFsaWQgc2VtdmVyIHJlc3VsdHNcbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gYC0ke2lkZW50aWZpZXJ9YC5tYXRjaCh0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LlBSRVJFTEVBU0VMT09TRV0gOiByZVt0LlBSRVJFTEVBU0VdKVxuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdICE9PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlkZW50aWZpZXI6ICR7aWRlbnRpZmllcn1gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2ZXJzaW9uICR7dGhpcy5yYXd9IGlzIG5vdCBhIHByZXJlbGVhc2VgKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLnJhdyA9IHRoaXMuZm9ybWF0KClcbiAgICBpZiAodGhpcy5idWlsZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmF3ICs9IGArJHt0aGlzLmJ1aWxkLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3908\n")},3927:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compareBuild = __webpack_require__(909)\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkyNy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixxQkFBcUIsbUJBQU8sQ0FBQyxHQUFpQjtBQUM5QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzPzk1ODgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3927\n")},3999:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk5OS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcz83NmRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IG5lcSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDBcbm1vZHVsZS5leHBvcnRzID0gbmVxXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3999\n")},4039:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(1333);\n\n/** @type {import('.')} */\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAzOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLElBQVM7O0FBRXJDLFdBQVcsYUFBYTtBQUN4QjtBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckMsOENBQThDO0FBQzlDLDBDQUEwQzs7QUFFMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzPzUxNTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4039\n")},4040:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = {\n  decode: __webpack_require__(7260),\n  verify: __webpack_require__(1691),\n  sign: __webpack_require__(7651),\n  JsonWebTokenError: __webpack_require__(1741),\n  NotBeforeError: __webpack_require__(3726),\n  TokenExpiredError: __webpack_require__(8980),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA0MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxJQUFVO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxJQUFVO0FBQzVCLFFBQVEsbUJBQU8sQ0FBQyxJQUFRO0FBQ3hCLHFCQUFxQixtQkFBTyxDQUFDLElBQXlCO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLElBQXNCO0FBQ2hELHFCQUFxQixtQkFBTyxDQUFDLElBQXlCO0FBQ3REIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvanNvbndlYnRva2VuL2luZGV4LmpzPzE0YjciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUnKSxcbiAgdmVyaWZ5OiByZXF1aXJlKCcuL3ZlcmlmeScpLFxuICBzaWduOiByZXF1aXJlKCcuL3NpZ24nKSxcbiAgSnNvbldlYlRva2VuRXJyb3I6IHJlcXVpcmUoJy4vbGliL0pzb25XZWJUb2tlbkVycm9yJyksXG4gIE5vdEJlZm9yZUVycm9yOiByZXF1aXJlKCcuL2xpYi9Ob3RCZWZvcmVFcnJvcicpLFxuICBUb2tlbkV4cGlyZWRFcnJvcjogcmVxdWlyZSgnLi9saWIvVG9rZW5FeHBpcmVkRXJyb3InKSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4040\n")},4089:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA4OS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qcz8wZTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMFxubW9kdWxlLmV4cG9ydHMgPSBndGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4089\n")},4277:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compareBuild = __webpack_require__(909)\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI3Ny5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixxQkFBcUIsbUJBQU8sQ0FBQyxHQUFpQjtBQUM5QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcz9kYmIzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2NvbXBhcmUtYnVpbGQnKVxuY29uc3QgcnNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gcnNvcnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4277\n")},4459:module=>{"use strict";eval("\n\n/** @type {import('./isNaN')} */\nmodule.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ1OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9tYXRoLWludHJpbnNpY3MvaXNOYU4uanM/OGM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2lzTmFOJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBpc05hTihhKSB7XG5cdHJldHVybiBhICE9PSBhO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4459\n")},4493:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ5My5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanM/MmM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGF0Y2ggPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4493\n")},4555:module=>{eval("// API\nmodule.exports = abort;\n\n/**\n * Aborts leftover active jobs\n *\n * @param {object} state - current state object\n */\nfunction abort(state)\n{\n  Object.keys(state.jobs).forEach(clean.bind(state));\n\n  // reset leftover jobs\n  state.jobs = {};\n}\n\n/**\n * Cleans up leftover job by invoking abort function for the provided job id\n *\n * @this  state\n * @param {string|number} key - job id to abort\n */\nfunction clean(key)\n{\n  if (typeof this.jobs[key] == 'function')\n  {\n    this.jobs[key]();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU1NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi9hYm9ydC5qcz85NTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBhYm9ydDtcblxuLyoqXG4gKiBBYm9ydHMgbGVmdG92ZXIgYWN0aXZlIGpvYnNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBjdXJyZW50IHN0YXRlIG9iamVjdFxuICovXG5mdW5jdGlvbiBhYm9ydChzdGF0ZSlcbntcbiAgT2JqZWN0LmtleXMoc3RhdGUuam9icykuZm9yRWFjaChjbGVhbi5iaW5kKHN0YXRlKSk7XG5cbiAgLy8gcmVzZXQgbGVmdG92ZXIgam9ic1xuICBzdGF0ZS5qb2JzID0ge307XG59XG5cbi8qKlxuICogQ2xlYW5zIHVwIGxlZnRvdmVyIGpvYiBieSBpbnZva2luZyBhYm9ydCBmdW5jdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGpvYiBpZFxuICpcbiAqIEB0aGlzICBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBrZXkgLSBqb2IgaWQgdG8gYWJvcnRcbiAqL1xuZnVuY3Rpb24gY2xlYW4oa2V5KVxue1xuICBpZiAodHlwZW9mIHRoaXMuam9ic1trZXldID09ICdmdW5jdGlvbicpXG4gIHtcbiAgICB0aGlzLmpvYnNba2V5XSgpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4555\n")},4623:(module,__unused_webpack_exports,__webpack_require__)=>{eval("const semver = __webpack_require__(9589);\n\nmodule.exports = semver.satisfies(process.version, '>=16.9.0');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYyMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBUTs7QUFFL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9qc29ud2VidG9rZW4vbGliL3JzYVBzc0tleURldGFpbHNTdXBwb3J0ZWQuanM/ZDcxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZW12ZXIuc2F0aXNmaWVzKHByb2Nlc3MudmVyc2lvbiwgJz49MTYuOS4wJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4623\n")},4641:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY0MS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2VxLmpzP2M1ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4641\n")},4977:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var semver = __webpack_require__(9589);\n\nmodule.exports = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBUTs7QUFFN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9qc29ud2VidG9rZW4vbGliL3BzU3VwcG9ydGVkLmpzP2VmMmEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbXZlci5zYXRpc2ZpZXMocHJvY2Vzcy52ZXJzaW9uLCAnXjYuMTIuMCB8fCA+PTguMC4wJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4977\n")},5032:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst Range = __webpack_require__(8311)\nconst Comparator = __webpack_require__(3904)\nconst { ANY } = Comparator\nconst satisfies = __webpack_require__(7638)\nconst compare = __webpack_require__(560)\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAzMi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsSUFBcUI7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsSUFBMEI7QUFDckQsUUFBUSxNQUFNO0FBQ2Qsa0JBQWtCLG1CQUFPLENBQUMsSUFBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsR0FBeUI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc3Vic2V0LmpzPzIzZDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZS5qcycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yLmpzJylcbmNvbnN0IHsgQU5ZIH0gPSBDb21wYXJhdG9yXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5cbi8vIENvbXBsZXggcmFuZ2UgYHIxIHx8IHIyIHx8IC4uLmAgaXMgYSBzdWJzZXQgb2YgYFIxIHx8IFIyIHx8IC4uLmAgaWZmOlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCBpcyBhIG51bGwgc2V0LCBPUlxuLy8gLSBFdmVyeSBzaW1wbGUgcmFuZ2UgYHIxLCByMiwgLi4uYCB3aGljaCBpcyBub3QgYSBudWxsIHNldCBpcyBhIHN1YnNldCBvZlxuLy8gICBzb21lIGBSMSwgUjIsIC4uLmBcbi8vXG4vLyBTaW1wbGUgcmFuZ2UgYGMxIGMyIC4uLmAgaXMgYSBzdWJzZXQgb2Ygc2ltcGxlIHJhbmdlIGBDMSBDMiAuLi5gIGlmZjpcbi8vIC0gSWYgYyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3IsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiBmYWxzZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBjIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvclxuLy8gICAtIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIHRydWVcbi8vICAgLSBlbHNlIHJlcGxhY2UgQyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIExldCBFUSBiZSB0aGUgc2V0IG9mID0gY29tcGFyYXRvcnMgaW4gY1xuLy8gLSBJZiBFUSBpcyBtb3JlIHRoYW4gb25lLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIExldCBHVCBiZSB0aGUgaGlnaGVzdCA+IG9yID49IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBMZXQgTFQgYmUgdGhlIGxvd2VzdCA8IG9yIDw9IGNvbXBhcmF0b3IgaW4gY1xuLy8gLSBJZiBHVCBhbmQgTFQsIGFuZCBHVC5zZW12ZXIgPiBMVC5zZW12ZXIsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gSWYgYW55IEMgaXMgYSA9IHJhbmdlLCBhbmQgR1Qgb3IgTFQgYXJlIHNldCwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEVRXG4vLyAgIC0gSWYgR1QsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IEdULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgTFQsIGFuZCBFUSBkb2VzIG5vdCBzYXRpc2Z5IExULCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAgIC0gSWYgRVEgc2F0aXNmaWVzIGV2ZXJ5IEMsIHJldHVybiB0cnVlXG4vLyAgIC0gRWxzZSByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgR1Rcbi8vICAgLSBJZiBHVC5zZW12ZXIgaXMgbG93ZXIgdGhhbiBhbnkgPiBvciA+PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdUIGlzID49LCBhbmQgR1Quc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBHVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBMVFxuLy8gICAtIElmIExULnNlbXZlciBpcyBncmVhdGVyIHRoYW4gYW55IDwgb3IgPD0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBMVCBpcyA8PSwgYW5kIExULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgTFQuc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gRWxzZSByZXR1cm4gdHJ1ZVxuXG5jb25zdCBzdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgIGNvbnRpbnVlIE9VVEVSXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHRoZSBudWxsIHNldCBpcyBhIHN1YnNldCBvZiBldmVyeXRoaW5nLCBidXQgbnVsbCBzaW1wbGUgcmFuZ2VzIGluXG4gICAgLy8gYSBjb21wbGV4IHJhbmdlIHNob3VsZCBiZSBpZ25vcmVkLiAgc28gaWYgd2Ugc2F3IGEgbm9uLW51bGwgcmFuZ2UsXG4gICAgLy8gdGhlbiB3ZSBrbm93IHRoaXMgaXNuJ3QgYSBzdWJzZXQsIGJ1dCBpZiBFVkVSWSBzaW1wbGUgcmFuZ2Ugd2FzIG51bGwsXG4gICAgLy8gdGhlbiBpdCBpcyBhIHN1YnNldC5cbiAgICBpZiAoc2F3Tm9uTnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IG1pbmltdW1WZXJzaW9uV2l0aFByZVJlbGVhc2UgPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpXVxuY29uc3QgbWluaW11bVZlcnNpb24gPSBbbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKV1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3ViLmxlbmd0aCA9PT0gMSAmJiBzdWJbMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YiA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbSA9IG1pbmltdW1WZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXFTZXQgPSBuZXcgU2V0KClcbiAgbGV0IGd0LCBsdFxuICBmb3IgKGNvbnN0IGMgb2Ygc3ViKSB7XG4gICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgIGx0ID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICAgIH1cbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgZ3RsdENvbXBcbiAgaWYgKGd0ICYmIGx0KSB7XG4gICAgZ3RsdENvbXAgPSBjb21wYXJlKGd0LnNlbXZlciwgbHQuc2VtdmVyLCBvcHRpb25zKVxuICAgIGlmIChndGx0Q29tcCA+IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGhpZ2hlciwgbG93ZXJcbiAgbGV0IGhhc0RvbUxULCBoYXNEb21HVFxuICAvLyBpZiB0aGUgc3Vic2V0IGhhcyBhIHByZXJlbGVhc2UsIHdlIG5lZWQgYSBjb21wYXJhdG9yIGluIHRoZSBzdXBlcnNldFxuICAvLyB3aXRoIHRoZSBzYW1lIHR1cGxlIGFuZCBhIHByZXJlbGVhc2UsIG9yIGl0J3Mgbm90IGEgc3Vic2V0XG4gIGxldCBuZWVkRG9tTFRQcmUgPSBsdCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgbHQuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gbHQuc2VtdmVyIDogZmFsc2VcbiAgbGV0IG5lZWREb21HVFByZSA9IGd0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBndC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBndC5zZW12ZXIgOiBmYWxzZVxuICAvLyBleGNlcHRpb246IDwxLjIuMy0wIGlzIHRoZSBzYW1lIGFzIDwxLjIuM1xuICBpZiAobmVlZERvbUxUUHJlICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbHQub3BlcmF0b3IgPT09ICc8JyAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZVswXSA9PT0gMCkge1xuICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgaGFzRG9tR1QgPSBoYXNEb21HVCB8fCBjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49J1xuICAgIGhhc0RvbUxUID0gaGFzRG9tTFQgfHwgYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PSdcbiAgICBpZiAoZ3QpIHtcbiAgICAgIGlmIChuZWVkRG9tR1RQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tR1RQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tR1RQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tR1RQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tR1RQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgaGlnaGVyID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChoaWdoZXIgPT09IGMgJiYgaGlnaGVyICE9PSBndCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobHQpIHtcbiAgICAgIGlmIChuZWVkRG9tTFRQcmUpIHtcbiAgICAgICAgaWYgKGMuc2VtdmVyLnByZXJlbGVhc2UgJiYgYy5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1ham9yID09PSBuZWVkRG9tTFRQcmUubWFqb3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLm1pbm9yID09PSBuZWVkRG9tTFRQcmUubWlub3IgJiZcbiAgICAgICAgICAgIGMuc2VtdmVyLnBhdGNoID09PSBuZWVkRG9tTFRQcmUucGF0Y2gpIHtcbiAgICAgICAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpIHtcbiAgICAgICAgbG93ZXIgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAobG93ZXIgPT09IGMgJiYgbG93ZXIgIT09IGx0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYy5vcGVyYXRvciAmJiAobHQgfHwgZ3QpICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgYSA8IG9yID4sIGFuZCBub3RoaW5nIGluIHRoZSBkb20sIHRoZW4gbXVzdCBiZSBmYWxzZVxuICAvLyBVTkxFU1MgaXQgd2FzIGxpbWl0ZWQgYnkgYW5vdGhlciByYW5nZSBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAvLyBFZywgPjEuMC4wIDwxLjAuMSBpcyBzdGlsbCBhIHN1YnNldCBvZiA8Mi4wLjBcbiAgaWYgKGd0ICYmIGhhc0RvbUxUICYmICFsdCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA+PTEuMi4zIGlzIGxvd2VyIHRoYW4gPjEuMi4zXG5jb25zdCBoaWdoZXJHVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSkge1xuICAgIHJldHVybiBiXG4gIH1cbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5032\n")},5200:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIwMC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0ZS5qcz82ZGRjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMFxubW9kdWxlLmV4cG9ydHMgPSBsdGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5200\n")},5342:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst outside = __webpack_require__(7075)\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFXO0FBQ25DO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbHRyLmpzP2RiMGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5jb25zdCBsdHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gbHRyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5342\n")},5345:module=>{"use strict";eval("\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGlCQUFpQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy91cmkuanM/NjdkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VyaScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBVUklFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5345\n")},5571:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\n// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(7075)\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3MS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLElBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzPzU2NmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuY29uc3QgZ3RyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGd0clxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5571\n")},5580:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU4MC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0LmpzP2VlYzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5580\n")},5692:n=>{"use strict";n.exports=require("https")},5747:(__unused_webpack_module,exports,__webpack_require__)=>{eval("/*global exports*/\nvar SignStream = __webpack_require__(3387);\nvar VerifyStream = __webpack_require__(7599);\n\nvar ALGORITHMS = [\n  'HS256', 'HS384', 'HS512',\n  'RS256', 'RS384', 'RS512',\n  'PS256', 'PS384', 'PS512',\n  'ES256', 'ES384', 'ES512'\n];\n\nexports.ALGORITHMS = ALGORITHMS;\nexports.sign = SignStream.sign;\nexports.verify = VerifyStream.verify;\nexports.decode = VerifyStream.decode;\nexports.isValid = VerifyStream.isValid;\nexports.createSign = function createSign(opts) {\n  return new SignStream(opts);\n};\nexports.createVerify = function createVerify(opts) {\n  return new VerifyStream(opts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc0Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLElBQW1CO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLElBQXFCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvandzL2luZGV4LmpzPzMzZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgZXhwb3J0cyovXG52YXIgU2lnblN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3NpZ24tc3RyZWFtJyk7XG52YXIgVmVyaWZ5U3RyZWFtID0gcmVxdWlyZSgnLi9saWIvdmVyaWZ5LXN0cmVhbScpO1xuXG52YXIgQUxHT1JJVEhNUyA9IFtcbiAgJ0hTMjU2JywgJ0hTMzg0JywgJ0hTNTEyJyxcbiAgJ1JTMjU2JywgJ1JTMzg0JywgJ1JTNTEyJyxcbiAgJ1BTMjU2JywgJ1BTMzg0JywgJ1BTNTEyJyxcbiAgJ0VTMjU2JywgJ0VTMzg0JywgJ0VTNTEyJ1xuXTtcblxuZXhwb3J0cy5BTEdPUklUSE1TID0gQUxHT1JJVEhNUztcbmV4cG9ydHMuc2lnbiA9IFNpZ25TdHJlYW0uc2lnbjtcbmV4cG9ydHMudmVyaWZ5ID0gVmVyaWZ5U3RyZWFtLnZlcmlmeTtcbmV4cG9ydHMuZGVjb2RlID0gVmVyaWZ5U3RyZWFtLmRlY29kZTtcbmV4cG9ydHMuaXNWYWxpZCA9IFZlcmlmeVN0cmVhbS5pc1ZhbGlkO1xuZXhwb3J0cy5jcmVhdGVTaWduID0gZnVuY3Rpb24gY3JlYXRlU2lnbihvcHRzKSB7XG4gIHJldHVybiBuZXcgU2lnblN0cmVhbShvcHRzKTtcbn07XG5leHBvcnRzLmNyZWF0ZVZlcmlmeSA9IGZ1bmN0aW9uIGNyZWF0ZVZlcmlmeShvcHRzKSB7XG4gIHJldHVybiBuZXcgVmVyaWZ5U3RyZWFtKG9wdHMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5747\n")},5753:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = __webpack_require__(7833);\n} else {\n  module.exports = __webpack_require__(6033);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsMENBQXdDO0FBQzFDLEVBQUU7QUFDRixFQUFFLDBDQUFxQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcz80MTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5753\n")},5795:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\n/** @type {import('.')} */\nvar $gOPD = __webpack_require__(6549);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc5NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGFBQWE7QUFDeEIsWUFBWSxtQkFBTyxDQUFDLElBQVE7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2dvcGQvaW5kZXguanM/MmFhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG52YXIgJGdPUEQgPSByZXF1aXJlKCcuL2dPUEQnKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5795\n")},5880:module=>{"use strict";eval("\n\n/** @type {import('./pow')} */\nmodule.exports = Math.pow;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg4MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGlCQUFpQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9wb3cuanM/NTllYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3BvdycpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnBvdztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5880\n")},5931:module=>{eval("/**\n * lodash 4.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @type Function\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n}\n\nmodule.exports = isString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkzMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc3N0cmluZy9pbmRleC5qcz85OWY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIDQuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5931\n")},6033:(module,exports,__webpack_require__)=>{eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(2018);\nvar util = __webpack_require__(9023);\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(9910);\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = __webpack_require__(9896);\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = __webpack_require__(9278);\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLElBQUs7QUFDdkIsV0FBVyxtQkFBTyxDQUFDLElBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwwQ0FBbUM7QUFDN0MsWUFBWTtBQUNaLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsSUFBSTtBQUMzQiw0Q0FBNEMsa0JBQWtCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLElBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcz82MTI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgLy8gY2FtZWwtY2FzZVxuICB2YXIgcHJvcCA9IGtleVxuICAgIC5zdWJzdHJpbmcoNilcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC9fKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgaykgeyByZXR1cm4gay50b1VwcGVyQ2FzZSgpIH0pO1xuXG4gIC8vIGNvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuICB2YXIgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcbiAgaWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gdHJ1ZTtcbiAgZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IGZhbHNlO1xuICBlbHNlIGlmICh2YWwgPT09ICdudWxsJykgdmFsID0gbnVsbDtcbiAgZWxzZSB2YWwgPSBOdW1iZXIodmFsKTtcblxuICBvYmpbcHJvcF0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogVGhlIGZpbGUgZGVzY3JpcHRvciB0byB3cml0ZSB0aGUgYGRlYnVnKClgIGNhbGxzIHRvLlxuICogU2V0IHRoZSBgREVCVUdfRkRgIGVudiB2YXJpYWJsZSB0byBvdmVycmlkZSB3aXRoIGFub3RoZXIgdmFsdWUuIGkuZS46XG4gKlxuICogICAkIERFQlVHX0ZEPTMgbm9kZSBzY3JpcHQuanMgMz5kZWJ1Zy5sb2dcbiAqL1xuXG52YXIgZmQgPSBwYXJzZUludChwcm9jZXNzLmVudi5ERUJVR19GRCwgMTApIHx8IDI7XG5cbmlmICgxICE9PSBmZCAmJiAyICE9PSBmZCkge1xuICB1dGlsLmRlcHJlY2F0ZShmdW5jdGlvbigpe30sICdleGNlcHQgZm9yIHN0ZGVycigyKSBhbmQgc3Rkb3V0KDEpLCBhbnkgb3RoZXIgdXNhZ2Ugb2YgREVCVUdfRkQgaXMgZGVwcmVjYXRlZC4gT3ZlcnJpZGUgZGVidWcubG9nIGlmIHlvdSB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBsb2cgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0LmlvL2RlYnVnX2ZkKScpKClcbn1cblxudmFyIHN0cmVhbSA9IDEgPT09IGZkID8gcHJvY2Vzcy5zdGRvdXQgOlxuICAgICAgICAgICAgIDIgPT09IGZkID8gcHJvY2Vzcy5zdGRlcnIgOlxuICAgICAgICAgICAgIGNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0oZmQpO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzXG4gICAgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKVxuICAgIDogdHR5LmlzYXR0eShmZCk7XG59XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG4gICAgLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKVxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2U7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBwcmVmaXggPSAnICBcXHUwMDFiWzMnICsgYyArICc7MW0nICsgbmFtZSArICcgJyArICdcXHUwMDFiWzBtJztcblxuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgICBhcmdzLnB1c2goJ1xcdTAwMWJbMycgKyBjICsgJ20rJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFiWzBtJyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKVxuICAgICAgKyAnICcgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcbiAgfVxufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBgc3RyZWFtYC5cbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcbiAgICAvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogQ29waWVkIGZyb20gYG5vZGUvc3JjL25vZGUuanNgLlxuICpcbiAqIFhYWDogSXQncyBsYW1lIHRoYXQgbm9kZSBkb2Vzbid0IGV4cG9zZSB0aGlzIEFQSSBvdXQtb2YtdGhlLWJveC4gSXQgYWxzb1xuICogcmVsaWVzIG9uIHRoZSB1bmRvY3VtZW50ZWQgYHR0eV93cmFwLmd1ZXNzSGFuZGxlVHlwZSgpYCB3aGljaCBpcyBhbHNvIGxhbWUuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbSAoZmQpIHtcbiAgdmFyIHN0cmVhbTtcbiAgdmFyIHR0eV93cmFwID0gcHJvY2Vzcy5iaW5kaW5nKCd0dHlfd3JhcCcpO1xuXG4gIC8vIE5vdGUgc3RyZWFtLl90eXBlIGlzIHVzZWQgZm9yIHRlc3QtbW9kdWxlLWxvYWQtbGlzdC5qc1xuXG4gIHN3aXRjaCAodHR5X3dyYXAuZ3Vlc3NIYW5kbGVUeXBlKGZkKSkge1xuICAgIGNhc2UgJ1RUWSc6XG4gICAgICBzdHJlYW0gPSBuZXcgdHR5LldyaXRlU3RyZWFtKGZkKTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICd0dHknO1xuXG4gICAgICAvLyBIYWNrIHRvIGhhdmUgc3RyZWFtIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIGFsaXZlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcyNlxuICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmIHN0cmVhbS5faGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0ZJTEUnOlxuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBmcy5TeW5jV3JpdGVTdHJlYW0oZmQsIHsgYXV0b0Nsb3NlOiBmYWxzZSB9KTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdmcyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BJUEUnOlxuICAgIGNhc2UgJ1RDUCc6XG4gICAgICB2YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG4gICAgICBzdHJlYW0gPSBuZXcgbmV0LlNvY2tldCh7XG4gICAgICAgIGZkOiBmZCxcbiAgICAgICAgcmVhZGFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZJWE1FIFNob3VsZCBwcm9iYWJseSBoYXZlIGFuIG9wdGlvbiBpbiBuZXQuU29ja2V0IHRvIGNyZWF0ZSBhXG4gICAgICAvLyBzdHJlYW0gZnJvbSBhbiBleGlzdGluZyBmZCB3aGljaCBpcyB3cml0YWJsZSBvbmx5LiBCdXQgZm9yIG5vd1xuICAgICAgLy8gd2UnbGwganVzdCBhZGQgdGhpcyBoYWNrIGFuZCBzZXQgdGhlIGByZWFkYWJsZWAgbWVtYmVyIHRvIGZhbHNlLlxuICAgICAgLy8gVGVzdDogLi9ub2RlIHRlc3QvZml4dHVyZXMvZWNoby5qcyA8IC9ldGMvcGFzc3dkXG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZWFkID0gbnVsbDtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdwaXBlJztcblxuICAgICAgLy8gRklYTUUgSGFjayB0byBoYXZlIHN0cmVhbSBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBhbGl2ZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MjZcbiAgICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uX2hhbmRsZS51bnJlZikge1xuICAgICAgICBzdHJlYW0uX2hhbmRsZS51bnJlZigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gUHJvYmFibHkgYW4gZXJyb3Igb24gaW4gdXZfZ3Vlc3NfaGFuZGxlKClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wbGVtZW50IG1lLiBVbmtub3duIHN0cmVhbSBmaWxlIHR5cGUhJyk7XG4gIH1cblxuICAvLyBGb3Igc3VwcG9ydGluZyBsZWdhY3kgQVBJIHdlIHB1dCB0aGUgRkQgaGVyZS5cbiAgc3RyZWFtLmZkID0gZmQ7XG5cbiAgc3RyZWFtLl9pc1N0ZGlvID0gdHJ1ZTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQgKGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBwcm9jZXNzLmVudi5ERUJVR2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6033\n")},6049:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = __webpack_require__(7598)\nvar extname = (__webpack_require__(6928).extname)\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA0OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLElBQVM7QUFDMUIsY0FBYyxtQ0FBdUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxTQUFTO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixnQkFBZ0IsS0FBSztBQUNyQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9taW1lLXR5cGVzL2luZGV4LmpzP2NjMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtaW1lLXR5cGVzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZGIgPSByZXF1aXJlKCdtaW1lLWRiJylcbnZhciBleHRuYW1lID0gcmVxdWlyZSgncGF0aCcpLmV4dG5hbWVcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgRVhUUkFDVF9UWVBFX1JFR0VYUCA9IC9eXFxzKihbXjtcXHNdKikoPzo7fFxcc3wkKS9cbnZhciBURVhUX1RZUEVfUkVHRVhQID0gL150ZXh0XFwvL2lcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNoYXJzZXQgPSBjaGFyc2V0XG5leHBvcnRzLmNoYXJzZXRzID0geyBsb29rdXA6IGNoYXJzZXQgfVxuZXhwb3J0cy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlXG5leHBvcnRzLmV4dGVuc2lvbiA9IGV4dGVuc2lvblxuZXhwb3J0cy5leHRlbnNpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuZXhwb3J0cy5sb29rdXAgPSBsb29rdXBcbmV4cG9ydHMudHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbi8vIFBvcHVsYXRlIHRoZSBleHRlbnNpb25zL3R5cGVzIG1hcHNcbnBvcHVsYXRlTWFwcyhleHBvcnRzLmV4dGVuc2lvbnMsIGV4cG9ydHMudHlwZXMpXG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGNoYXJzZXQgZm9yIGEgTUlNRSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBjaGFyc2V0ICh0eXBlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBtZWRpYS10eXBlclxuICB2YXIgbWF0Y2ggPSBFWFRSQUNUX1RZUEVfUkVHRVhQLmV4ZWModHlwZSlcbiAgdmFyIG1pbWUgPSBtYXRjaCAmJiBkYlttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXVxuXG4gIGlmIChtaW1lICYmIG1pbWUuY2hhcnNldCkge1xuICAgIHJldHVybiBtaW1lLmNoYXJzZXRcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdGV4dC8qIHRvIHV0Zi04XG4gIGlmIChtYXRjaCAmJiBURVhUX1RZUEVfUkVHRVhQLnRlc3QobWF0Y2hbMV0pKSB7XG4gICAgcmV0dXJuICdVVEYtOCdcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bGwgQ29udGVudC1UeXBlIGhlYWRlciBnaXZlbiBhIE1JTUUgdHlwZSBvciBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gY29udGVudFR5cGUgKHN0cikge1xuICAvLyBUT0RPOiBzaG91bGQgdGhpcyBldmVuIGJlIGluIHRoaXMgbW9kdWxlP1xuICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIG1pbWUgPSBzdHIuaW5kZXhPZignLycpID09PSAtMVxuICAgID8gZXhwb3J0cy5sb29rdXAoc3RyKVxuICAgIDogc3RyXG5cbiAgaWYgKCFtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUT0RPOiB1c2UgY29udGVudC10eXBlIG9yIG90aGVyIG1vZHVsZVxuICBpZiAobWltZS5pbmRleE9mKCdjaGFyc2V0JykgPT09IC0xKSB7XG4gICAgdmFyIGNoYXJzZXQgPSBleHBvcnRzLmNoYXJzZXQobWltZSlcbiAgICBpZiAoY2hhcnNldCkgbWltZSArPSAnOyBjaGFyc2V0PScgKyBjaGFyc2V0LnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIHJldHVybiBtaW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGV4dGVuc2lvbiBmb3IgYSBNSU1FIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGV4dGVuc2lvbiAodHlwZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUT0RPOiB1c2UgbWVkaWEtdHlwZXJcbiAgdmFyIG1hdGNoID0gRVhUUkFDVF9UWVBFX1JFR0VYUC5leGVjKHR5cGUpXG5cbiAgLy8gZ2V0IGV4dGVuc2lvbnNcbiAgdmFyIGV4dHMgPSBtYXRjaCAmJiBleHBvcnRzLmV4dGVuc2lvbnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV1cblxuICBpZiAoIWV4dHMgfHwgIWV4dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXh0c1swXVxufVxuXG4vKipcbiAqIExvb2t1cCB0aGUgTUlNRSB0eXBlIGZvciBhIGZpbGUgcGF0aC9leHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAocGF0aCkge1xuICBpZiAoIXBhdGggfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBnZXQgdGhlIGV4dGVuc2lvbiAoXCJleHRcIiBvciBcIi5leHRcIiBvciBmdWxsIHBhdGgpXG4gIHZhciBleHRlbnNpb24gPSBleHRuYW1lKCd4LicgKyBwYXRoKVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnN1YnN0cigxKVxuXG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy50eXBlc1tleHRlbnNpb25dIHx8IGZhbHNlXG59XG5cbi8qKlxuICogUG9wdWxhdGUgdGhlIGV4dGVuc2lvbnMgYW5kIHR5cGVzIG1hcHMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvcHVsYXRlTWFwcyAoZXh0ZW5zaW9ucywgdHlwZXMpIHtcbiAgLy8gc291cmNlIHByZWZlcmVuY2UgKGxlYXN0IC0+IG1vc3QpXG4gIHZhciBwcmVmZXJlbmNlID0gWyduZ2lueCcsICdhcGFjaGUnLCB1bmRlZmluZWQsICdpYW5hJ11cblxuICBPYmplY3Qua2V5cyhkYikuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoTWltZVR5cGUgKHR5cGUpIHtcbiAgICB2YXIgbWltZSA9IGRiW3R5cGVdXG4gICAgdmFyIGV4dHMgPSBtaW1lLmV4dGVuc2lvbnNcblxuICAgIGlmICghZXh0cyB8fCAhZXh0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG1pbWUgLT4gZXh0ZW5zaW9uc1xuICAgIGV4dGVuc2lvbnNbdHlwZV0gPSBleHRzXG5cbiAgICAvLyBleHRlbnNpb24gLT4gbWltZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dHNbaV1cblxuICAgICAgaWYgKHR5cGVzW2V4dGVuc2lvbl0pIHtcbiAgICAgICAgdmFyIGZyb20gPSBwcmVmZXJlbmNlLmluZGV4T2YoZGJbdHlwZXNbZXh0ZW5zaW9uXV0uc291cmNlKVxuICAgICAgICB2YXIgdG8gPSBwcmVmZXJlbmNlLmluZGV4T2YobWltZS5zb3VyY2UpXG5cbiAgICAgICAgaWYgKHR5cGVzW2V4dGVuc2lvbl0gIT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nICYmXG4gICAgICAgICAgKGZyb20gPiB0byB8fCAoZnJvbSA9PT0gdG8gJiYgdHlwZXNbZXh0ZW5zaW9uXS5zdWJzdHIoMCwgMTIpID09PSAnYXBwbGljYXRpb24vJykpKSB7XG4gICAgICAgICAgLy8gc2tpcCB0aGUgcmVtYXBwaW5nXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIGV4dGVuc2lvbiAtPiBtaW1lXG4gICAgICB0eXBlc1tleHRlbnNpb25dID0gdHlwZVxuICAgIH1cbiAgfSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6049\n")},6111:module=>{eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object ? baseValues(object, keys(object)) : [];\n}\n\nmodule.exports = includes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pbmNsdWRlcy9pbmRleC5qcz85Y2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA/IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5jbHVkZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6111\n")},6170:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst parse = __webpack_require__(144)\nconst { safeRe: re, t } = __webpack_require__(9718)\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE3MC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLEdBQVM7QUFDL0IsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLElBQWdCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsU0FBUztBQUMxRSw0REFBNEQsU0FBUzs7QUFFckUsa0JBQWtCLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNO0FBQy9EO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvZXJjZS5qcz83OTczIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRUZVTExdIDogcmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy8gV2l0aCBpbmNsdWRlUHJlcmVsZWFzZSBvcHRpb24gc2V0LCAnMS4yLjMuNC1yYycgd2FudHMgdG8gY29lcmNlICcyLjMuNC1yYycsIG5vdCAnMi4zLjQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBjb25zdCBjb2VyY2VSdGxSZWdleCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRVJUTEZVTExdIDogcmVbdC5DT0VSQ0VSVExdXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSBjb2VyY2VSdGxSZWdleC5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICBjb2VyY2VSdGxSZWdleC5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgY29lcmNlUnRsUmVnZXgubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtYWpvciA9IG1hdGNoWzJdXG4gIGNvbnN0IG1pbm9yID0gbWF0Y2hbM10gfHwgJzAnXG4gIGNvbnN0IHBhdGNoID0gbWF0Y2hbNF0gfHwgJzAnXG4gIGNvbnN0IHByZXJlbGVhc2UgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIG1hdGNoWzVdID8gYC0ke21hdGNoWzVdfWAgOiAnJ1xuICBjb25zdCBidWlsZCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgbWF0Y2hbNl0gPyBgKyR7bWF0Y2hbNl19YCA6ICcnXG5cbiAgcmV0dXJuIHBhcnNlKGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSR7cHJlcmVsZWFzZX0ke2J1aWxkfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6170\n")},6188:module=>{"use strict";eval("\n\n/** @type {import('./max')} */\nmodule.exports = Math.max;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE4OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGlCQUFpQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9tYXguanM/ZTA1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL21heCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLm1heDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6188\n")},6254:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1NC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWlub3IuanM/NjA5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWlub3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yXG5tb2R1bGUuZXhwb3J0cyA9IG1pbm9yXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6254\n")},6276:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var abort = __webpack_require__(4555)\n  , async = __webpack_require__(2313)\n  ;\n\n// API\nmodule.exports = terminator;\n\n/**\n * Terminates jobs in the attached state context\n *\n * @this  AsyncKitState#\n * @param {function} callback - final callback to invoke after termination\n */\nfunction terminator(callback)\n{\n  if (!Object.keys(this.jobs).length)\n  {\n    return;\n  }\n\n  // fast forward iteration index\n  this.index = this.size;\n\n  // abort jobs\n  abort(this);\n\n  // send back results we have so far\n  async(callback)(null, this.results);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBWTtBQUNoQyxZQUFZLG1CQUFPLENBQUMsSUFBWTtBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9saWIvdGVybWluYXRvci5qcz8xMjk1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhYm9ydCA9IHJlcXVpcmUoJy4vYWJvcnQuanMnKVxuICAsIGFzeW5jID0gcmVxdWlyZSgnLi9hc3luYy5qcycpXG4gIDtcblxuLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHRlcm1pbmF0b3I7XG5cbi8qKlxuICogVGVybWluYXRlcyBqb2JzIGluIHRoZSBhdHRhY2hlZCBzdGF0ZSBjb250ZXh0XG4gKlxuICogQHRoaXMgIEFzeW5jS2l0U3RhdGUjXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGZpbmFsIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciB0ZXJtaW5hdGlvblxuICovXG5mdW5jdGlvbiB0ZXJtaW5hdG9yKGNhbGxiYWNrKVxue1xuICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuam9icykubGVuZ3RoKVxuICB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZmFzdCBmb3J3YXJkIGl0ZXJhdGlvbiBpbmRleFxuICB0aGlzLmluZGV4ID0gdGhpcy5zaXplO1xuXG4gIC8vIGFib3J0IGpvYnNcbiAgYWJvcnQodGhpcyk7XG5cbiAgLy8gc2VuZCBiYWNrIHJlc3VsdHMgd2UgaGF2ZSBzbyBmYXJcbiAgYXN5bmMoY2FsbGJhY2spKG51bGwsIHRoaXMucmVzdWx0cyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6276\n")},6504:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar parseUrl = (__webpack_require__(7016).parse);\n\nvar DEFAULT_PORTS = {\n  ftp: 21,\n  gopher: 70,\n  http: 80,\n  https: 443,\n  ws: 80,\n  wss: 443,\n};\n\nvar stringEndsWith = String.prototype.endsWith || function(s) {\n  return s.length <= this.length &&\n    this.indexOf(s, this.length - s.length) !== -1;\n};\n\n/**\n * @param {string|object} url - The URL, or the result from url.parse.\n * @return {string} The URL of the proxy that should handle the request to the\n *  given URL. If no proxy is set, this will be an empty string.\n */\nfunction getProxyForUrl(url) {\n  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};\n  var proto = parsedUrl.protocol;\n  var hostname = parsedUrl.host;\n  var port = parsedUrl.port;\n  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {\n    return '';  // Don't proxy URLs without a valid scheme or host.\n  }\n\n  proto = proto.split(':', 1)[0];\n  // Stripping ports in this way instead of using parsedUrl.hostname to make\n  // sure that the brackets around IPv6 addresses are kept.\n  hostname = hostname.replace(/:\\d*$/, '');\n  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;\n  if (!shouldProxy(hostname, port)) {\n    return '';  // Don't proxy URLs that match NO_PROXY.\n  }\n\n  var proxy =\n    getEnv('npm_config_' + proto + '_proxy') ||\n    getEnv(proto + '_proxy') ||\n    getEnv('npm_config_proxy') ||\n    getEnv('all_proxy');\n  if (proxy && proxy.indexOf('://') === -1) {\n    // Missing scheme in proxy, default to the requested URL's scheme.\n    proxy = proto + '://' + proxy;\n  }\n  return proxy;\n}\n\n/**\n * Determines whether a given URL should be proxied.\n *\n * @param {string} hostname - The host name of the URL.\n * @param {number} port - The effective port of the URL.\n * @returns {boolean} Whether the given URL should be proxied.\n * @private\n */\nfunction shouldProxy(hostname, port) {\n  var NO_PROXY =\n    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();\n  if (!NO_PROXY) {\n    return true;  // Always proxy if NO_PROXY is not set.\n  }\n  if (NO_PROXY === '*') {\n    return false;  // Never proxy if wildcard is set.\n  }\n\n  return NO_PROXY.split(/[,\\s]/).every(function(proxy) {\n    if (!proxy) {\n      return true;  // Skip zero-length hosts.\n    }\n    var parsedProxy = proxy.match(/^(.+):(\\d+)$/);\n    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;\n    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;\n    if (parsedProxyPort && parsedProxyPort !== port) {\n      return true;  // Skip if ports don't match.\n    }\n\n    if (!/^[.*]/.test(parsedProxyHostname)) {\n      // No wildcards, so stop proxying if there is an exact match.\n      return hostname !== parsedProxyHostname;\n    }\n\n    if (parsedProxyHostname.charAt(0) === '*') {\n      // Remove leading wildcard.\n      parsedProxyHostname = parsedProxyHostname.slice(1);\n    }\n    // Stop proxying if the hostname ends with the no_proxy host.\n    return !stringEndsWith.call(hostname, parsedProxyHostname);\n  });\n}\n\n/**\n * Get the value for an environment variable.\n *\n * @param {string} key - The name of the environment variable.\n * @return {string} The value of the environment variable.\n * @private\n */\nfunction getEnv(key) {\n  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';\n}\n\nexports.getProxyForUrl = getProxyForUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUwNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLGlDQUFvQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9wcm94eS1mcm9tLWVudi9pbmRleC5qcz9lNzFiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlVXJsID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG5cbnZhciBERUZBVUxUX1BPUlRTID0ge1xuICBmdHA6IDIxLFxuICBnb3BoZXI6IDcwLFxuICBodHRwOiA4MCxcbiAgaHR0cHM6IDQ0MyxcbiAgd3M6IDgwLFxuICB3c3M6IDQ0Myxcbn07XG5cbnZhciBzdHJpbmdFbmRzV2l0aCA9IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggfHwgZnVuY3Rpb24ocykge1xuICByZXR1cm4gcy5sZW5ndGggPD0gdGhpcy5sZW5ndGggJiZcbiAgICB0aGlzLmluZGV4T2YocywgdGhpcy5sZW5ndGggLSBzLmxlbmd0aCkgIT09IC0xO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHVybCAtIFRoZSBVUkwsIG9yIHRoZSByZXN1bHQgZnJvbSB1cmwucGFyc2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIHByb3h5IHRoYXQgc2hvdWxkIGhhbmRsZSB0aGUgcmVxdWVzdCB0byB0aGVcbiAqICBnaXZlbiBVUkwuIElmIG5vIHByb3h5IGlzIHNldCwgdGhpcyB3aWxsIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJveHlGb3JVcmwodXJsKSB7XG4gIHZhciBwYXJzZWRVcmwgPSB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyA/IHBhcnNlVXJsKHVybCkgOiB1cmwgfHwge307XG4gIHZhciBwcm90byA9IHBhcnNlZFVybC5wcm90b2NvbDtcbiAgdmFyIGhvc3RuYW1lID0gcGFyc2VkVXJsLmhvc3Q7XG4gIHZhciBwb3J0ID0gcGFyc2VkVXJsLnBvcnQ7XG4gIGlmICh0eXBlb2YgaG9zdG5hbWUgIT09ICdzdHJpbmcnIHx8ICFob3N0bmFtZSB8fCB0eXBlb2YgcHJvdG8gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICcnOyAgLy8gRG9uJ3QgcHJveHkgVVJMcyB3aXRob3V0IGEgdmFsaWQgc2NoZW1lIG9yIGhvc3QuXG4gIH1cblxuICBwcm90byA9IHByb3RvLnNwbGl0KCc6JywgMSlbMF07XG4gIC8vIFN0cmlwcGluZyBwb3J0cyBpbiB0aGlzIHdheSBpbnN0ZWFkIG9mIHVzaW5nIHBhcnNlZFVybC5ob3N0bmFtZSB0byBtYWtlXG4gIC8vIHN1cmUgdGhhdCB0aGUgYnJhY2tldHMgYXJvdW5kIElQdjYgYWRkcmVzc2VzIGFyZSBrZXB0LlxuICBob3N0bmFtZSA9IGhvc3RuYW1lLnJlcGxhY2UoLzpcXGQqJC8sICcnKTtcbiAgcG9ydCA9IHBhcnNlSW50KHBvcnQpIHx8IERFRkFVTFRfUE9SVFNbcHJvdG9dIHx8IDA7XG4gIGlmICghc2hvdWxkUHJveHkoaG9zdG5hbWUsIHBvcnQpKSB7XG4gICAgcmV0dXJuICcnOyAgLy8gRG9uJ3QgcHJveHkgVVJMcyB0aGF0IG1hdGNoIE5PX1BST1hZLlxuICB9XG5cbiAgdmFyIHByb3h5ID1cbiAgICBnZXRFbnYoJ25wbV9jb25maWdfJyArIHByb3RvICsgJ19wcm94eScpIHx8XG4gICAgZ2V0RW52KHByb3RvICsgJ19wcm94eScpIHx8XG4gICAgZ2V0RW52KCducG1fY29uZmlnX3Byb3h5JykgfHxcbiAgICBnZXRFbnYoJ2FsbF9wcm94eScpO1xuICBpZiAocHJveHkgJiYgcHJveHkuaW5kZXhPZignOi8vJykgPT09IC0xKSB7XG4gICAgLy8gTWlzc2luZyBzY2hlbWUgaW4gcHJveHksIGRlZmF1bHQgdG8gdGhlIHJlcXVlc3RlZCBVUkwncyBzY2hlbWUuXG4gICAgcHJveHkgPSBwcm90byArICc6Ly8nICsgcHJveHk7XG4gIH1cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIFVSTCBzaG91bGQgYmUgcHJveGllZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWUgLSBUaGUgaG9zdCBuYW1lIG9mIHRoZSBVUkwuXG4gKiBAcGFyYW0ge251bWJlcn0gcG9ydCAtIFRoZSBlZmZlY3RpdmUgcG9ydCBvZiB0aGUgVVJMLlxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIFVSTCBzaG91bGQgYmUgcHJveGllZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFByb3h5KGhvc3RuYW1lLCBwb3J0KSB7XG4gIHZhciBOT19QUk9YWSA9XG4gICAgKGdldEVudignbnBtX2NvbmZpZ19ub19wcm94eScpIHx8IGdldEVudignbm9fcHJveHknKSkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFOT19QUk9YWSkge1xuICAgIHJldHVybiB0cnVlOyAgLy8gQWx3YXlzIHByb3h5IGlmIE5PX1BST1hZIGlzIG5vdCBzZXQuXG4gIH1cbiAgaWYgKE5PX1BST1hZID09PSAnKicpIHtcbiAgICByZXR1cm4gZmFsc2U7ICAvLyBOZXZlciBwcm94eSBpZiB3aWxkY2FyZCBpcyBzZXQuXG4gIH1cblxuICByZXR1cm4gTk9fUFJPWFkuc3BsaXQoL1ssXFxzXS8pLmV2ZXJ5KGZ1bmN0aW9uKHByb3h5KSB7XG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuIHRydWU7ICAvLyBTa2lwIHplcm8tbGVuZ3RoIGhvc3RzLlxuICAgIH1cbiAgICB2YXIgcGFyc2VkUHJveHkgPSBwcm94eS5tYXRjaCgvXiguKyk6KFxcZCspJC8pO1xuICAgIHZhciBwYXJzZWRQcm94eUhvc3RuYW1lID0gcGFyc2VkUHJveHkgPyBwYXJzZWRQcm94eVsxXSA6IHByb3h5O1xuICAgIHZhciBwYXJzZWRQcm94eVBvcnQgPSBwYXJzZWRQcm94eSA/IHBhcnNlSW50KHBhcnNlZFByb3h5WzJdKSA6IDA7XG4gICAgaWYgKHBhcnNlZFByb3h5UG9ydCAmJiBwYXJzZWRQcm94eVBvcnQgIT09IHBvcnQpIHtcbiAgICAgIHJldHVybiB0cnVlOyAgLy8gU2tpcCBpZiBwb3J0cyBkb24ndCBtYXRjaC5cbiAgICB9XG5cbiAgICBpZiAoIS9eWy4qXS8udGVzdChwYXJzZWRQcm94eUhvc3RuYW1lKSkge1xuICAgICAgLy8gTm8gd2lsZGNhcmRzLCBzbyBzdG9wIHByb3h5aW5nIGlmIHRoZXJlIGlzIGFuIGV4YWN0IG1hdGNoLlxuICAgICAgcmV0dXJuIGhvc3RuYW1lICE9PSBwYXJzZWRQcm94eUhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmIChwYXJzZWRQcm94eUhvc3RuYW1lLmNoYXJBdCgwKSA9PT0gJyonKSB7XG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB3aWxkY2FyZC5cbiAgICAgIHBhcnNlZFByb3h5SG9zdG5hbWUgPSBwYXJzZWRQcm94eUhvc3RuYW1lLnNsaWNlKDEpO1xuICAgIH1cbiAgICAvLyBTdG9wIHByb3h5aW5nIGlmIHRoZSBob3N0bmFtZSBlbmRzIHdpdGggdGhlIG5vX3Byb3h5IGhvc3QuXG4gICAgcmV0dXJuICFzdHJpbmdFbmRzV2l0aC5jYWxsKGhvc3RuYW1lLCBwYXJzZWRQcm94eUhvc3RuYW1lKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEVudihrZXkpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52W2tleS50b0xvd2VyQ2FzZSgpXSB8fCBwcm9jZXNzLmVudltrZXkudG9VcHBlckNhc2UoKV0gfHwgJyc7XG59XG5cbmV4cG9ydHMuZ2V0UHJveHlGb3JVcmwgPSBnZXRQcm94eUZvclVybDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6504\n")},6549:module=>{"use strict";eval("\n\n/** @type {import('./gOPD')} */\nmodule.exports = Object.getOwnPropertyDescriptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU0OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGtCQUFrQjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2dvcGQvZ09QRC5qcz82YzNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZ09QRCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6549\n")},6585:module=>{eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcz8xNDY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6585\n")},6743:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar implementation = __webpack_require__(9353);\n\nmodule.exports = Function.prototype.bind || implementation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc0My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxJQUFrQjs7QUFFL0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzPzBmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6743\n")},6780:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst Range = __webpack_require__(8311)\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc4MC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsSUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzP2Q3YzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6780\n")},6874:module=>{"use strict";eval("\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg3NC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9jb25zdGFudHMuanM/ZmU0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG4vLyBNYXggc2FmZSBsZW5ndGggZm9yIGEgYnVpbGQgaWRlbnRpZmllci4gVGhlIG1heCBsZW5ndGggbWludXMgNiBjaGFyYWN0ZXJzIGZvclxuLy8gdGhlIHNob3J0ZXN0IHZlcnNpb24gd2l0aCBhIGJ1aWxkIDAuMC4wK0JVSUxELlxuY29uc3QgTUFYX1NBRkVfQlVJTERfTEVOR1RIID0gTUFYX0xFTkdUSCAtIDZcblxuY29uc3QgUkVMRUFTRV9UWVBFUyA9IFtcbiAgJ21ham9yJyxcbiAgJ3ByZW1ham9yJyxcbiAgJ21pbm9yJyxcbiAgJ3ByZW1pbm9yJyxcbiAgJ3BhdGNoJyxcbiAgJ3ByZXBhdGNoJyxcbiAgJ3ByZXJlbGVhc2UnLFxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfQlVJTERfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBSRUxFQVNFX1RZUEVTLFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRTogMGIwMDEsXG4gIEZMQUdfTE9PU0U6IDBiMDEwLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6874\n")},6928:n=>{"use strict";n.exports=require("path")},6953:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst parse = __webpack_require__(144)\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk1My5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsR0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcz84MmFjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgdmFsaWQgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6953\n")},6982:n=>{"use strict";n.exports=require("crypto")},7016:n=>{"use strict";n.exports=require("url")},7019:(module,__unused_webpack_exports,__webpack_require__)=>{eval("const ASYMMETRIC_KEY_DETAILS_SUPPORTED = __webpack_require__(1977);\nconst RSA_PSS_KEY_DETAILS_SUPPORTED = __webpack_require__(4623);\n\nconst allowedAlgorithmsForKeys = {\n  'ec': ['ES256', 'ES384', 'ES512'],\n  'rsa': ['RS256', 'PS256', 'RS384', 'PS384', 'RS512', 'PS512'],\n  'rsa-pss': ['PS256', 'PS384', 'PS512']\n};\n\nconst allowedCurves = {\n  ES256: 'prime256v1',\n  ES384: 'secp384r1',\n  ES512: 'secp521r1',\n};\n\nmodule.exports = function(algorithm, key) {\n  if (!algorithm || !key) return;\n\n  const keyType = key.asymmetricKeyType;\n  if (!keyType) return;\n\n  const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];\n\n  if (!allowedAlgorithms) {\n    throw new Error(`Unknown key type \"${keyType}\".`);\n  }\n\n  if (!allowedAlgorithms.includes(algorithm)) {\n    throw new Error(`\"alg\" parameter for \"${keyType}\" key type must be one of: ${allowedAlgorithms.join(', ')}.`)\n  }\n\n  /*\n   * Ignore the next block from test coverage because it gets executed\n   * conditionally depending on the Node version. Not ignoring it would\n   * prevent us from reaching the target % of coverage for versions of\n   * Node under 15.7.0.\n   */\n  /* istanbul ignore next */\n  if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {\n    switch (keyType) {\n    case 'ec':\n      const keyCurve = key.asymmetricKeyDetails.namedCurve;\n      const allowedCurve = allowedCurves[algorithm];\n\n      if (keyCurve !== allowedCurve) {\n        throw new Error(`\"alg\" parameter \"${algorithm}\" requires curve \"${allowedCurve}\".`);\n      }\n      break;\n\n    case 'rsa-pss':\n      if (RSA_PSS_KEY_DETAILS_SUPPORTED) {\n        const length = parseInt(algorithm.slice(-3), 10);\n        const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;\n\n        if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {\n          throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of \"alg\" ${algorithm}.`);\n        }\n\n        if (saltLength !== undefined && saltLength > length >> 3) {\n          throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of \"alg\" ${algorithm}.`)\n        }\n      }\n      break;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAxOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsbUJBQU8sQ0FBQyxJQUFpQztBQUNsRixzQ0FBc0MsbUJBQU8sQ0FBQyxJQUE2Qjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEOztBQUVBO0FBQ0EsNENBQTRDLFFBQVEsNkJBQTZCLDZCQUE2QjtBQUM5Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsVUFBVSxvQkFBb0IsYUFBYTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7O0FBRS9ELG9DQUFvQyxPQUFPO0FBQzNDLDBIQUEwSCxVQUFVO0FBQ3BJOztBQUVBO0FBQ0Esc0lBQXNJLFVBQVU7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvanNvbndlYnRva2VuL2xpYi92YWxpZGF0ZUFzeW1tZXRyaWNLZXkuanM/MTdiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBU1lNTUVUUklDX0tFWV9ERVRBSUxTX1NVUFBPUlRFRCA9IHJlcXVpcmUoJy4vYXN5bW1ldHJpY0tleURldGFpbHNTdXBwb3J0ZWQnKTtcbmNvbnN0IFJTQV9QU1NfS0VZX0RFVEFJTFNfU1VQUE9SVEVEID0gcmVxdWlyZSgnLi9yc2FQc3NLZXlEZXRhaWxzU3VwcG9ydGVkJyk7XG5cbmNvbnN0IGFsbG93ZWRBbGdvcml0aG1zRm9yS2V5cyA9IHtcbiAgJ2VjJzogWydFUzI1NicsICdFUzM4NCcsICdFUzUxMiddLFxuICAncnNhJzogWydSUzI1NicsICdQUzI1NicsICdSUzM4NCcsICdQUzM4NCcsICdSUzUxMicsICdQUzUxMiddLFxuICAncnNhLXBzcyc6IFsnUFMyNTYnLCAnUFMzODQnLCAnUFM1MTInXVxufTtcblxuY29uc3QgYWxsb3dlZEN1cnZlcyA9IHtcbiAgRVMyNTY6ICdwcmltZTI1NnYxJyxcbiAgRVMzODQ6ICdzZWNwMzg0cjEnLFxuICBFUzUxMjogJ3NlY3A1MjFyMScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIGlmICghYWxnb3JpdGhtIHx8ICFrZXkpIHJldHVybjtcblxuICBjb25zdCBrZXlUeXBlID0ga2V5LmFzeW1tZXRyaWNLZXlUeXBlO1xuICBpZiAoIWtleVR5cGUpIHJldHVybjtcblxuICBjb25zdCBhbGxvd2VkQWxnb3JpdGhtcyA9IGFsbG93ZWRBbGdvcml0aG1zRm9yS2V5c1trZXlUeXBlXTtcblxuICBpZiAoIWFsbG93ZWRBbGdvcml0aG1zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGtleSB0eXBlIFwiJHtrZXlUeXBlfVwiLmApO1xuICB9XG5cbiAgaWYgKCFhbGxvd2VkQWxnb3JpdGhtcy5pbmNsdWRlcyhhbGdvcml0aG0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImFsZ1wiIHBhcmFtZXRlciBmb3IgXCIke2tleVR5cGV9XCIga2V5IHR5cGUgbXVzdCBiZSBvbmUgb2Y6ICR7YWxsb3dlZEFsZ29yaXRobXMuam9pbignLCAnKX0uYClcbiAgfVxuXG4gIC8qXG4gICAqIElnbm9yZSB0aGUgbmV4dCBibG9jayBmcm9tIHRlc3QgY292ZXJhZ2UgYmVjYXVzZSBpdCBnZXRzIGV4ZWN1dGVkXG4gICAqIGNvbmRpdGlvbmFsbHkgZGVwZW5kaW5nIG9uIHRoZSBOb2RlIHZlcnNpb24uIE5vdCBpZ25vcmluZyBpdCB3b3VsZFxuICAgKiBwcmV2ZW50IHVzIGZyb20gcmVhY2hpbmcgdGhlIHRhcmdldCAlIG9mIGNvdmVyYWdlIGZvciB2ZXJzaW9ucyBvZlxuICAgKiBOb2RlIHVuZGVyIDE1LjcuMC5cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChBU1lNTUVUUklDX0tFWV9ERVRBSUxTX1NVUFBPUlRFRCkge1xuICAgIHN3aXRjaCAoa2V5VHlwZSkge1xuICAgIGNhc2UgJ2VjJzpcbiAgICAgIGNvbnN0IGtleUN1cnZlID0ga2V5LmFzeW1tZXRyaWNLZXlEZXRhaWxzLm5hbWVkQ3VydmU7XG4gICAgICBjb25zdCBhbGxvd2VkQ3VydmUgPSBhbGxvd2VkQ3VydmVzW2FsZ29yaXRobV07XG5cbiAgICAgIGlmIChrZXlDdXJ2ZSAhPT0gYWxsb3dlZEN1cnZlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJhbGdcIiBwYXJhbWV0ZXIgXCIke2FsZ29yaXRobX1cIiByZXF1aXJlcyBjdXJ2ZSBcIiR7YWxsb3dlZEN1cnZlfVwiLmApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyc2EtcHNzJzpcbiAgICAgIGlmIChSU0FfUFNTX0tFWV9ERVRBSUxTX1NVUFBPUlRFRCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChhbGdvcml0aG0uc2xpY2UoLTMpLCAxMCk7XG4gICAgICAgIGNvbnN0IHsgaGFzaEFsZ29yaXRobSwgbWdmMUhhc2hBbGdvcml0aG0sIHNhbHRMZW5ndGggfSA9IGtleS5hc3ltbWV0cmljS2V5RGV0YWlscztcblxuICAgICAgICBpZiAoaGFzaEFsZ29yaXRobSAhPT0gYHNoYSR7bGVuZ3RofWAgfHwgbWdmMUhhc2hBbGdvcml0aG0gIT09IGhhc2hBbGdvcml0aG0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQga2V5IGZvciB0aGlzIG9wZXJhdGlvbiwgaXRzIFJTQS1QU1MgcGFyYW1ldGVycyBkbyBub3QgbWVldCB0aGUgcmVxdWlyZW1lbnRzIG9mIFwiYWxnXCIgJHthbGdvcml0aG19LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNhbHRMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBzYWx0TGVuZ3RoID4gbGVuZ3RoID4+IDMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQga2V5IGZvciB0aGlzIG9wZXJhdGlvbiwgaXRzIFJTQS1QU1MgcGFyYW1ldGVyIHNhbHRMZW5ndGggZG9lcyBub3QgbWVldCB0aGUgcmVxdWlyZW1lbnRzIG9mIFwiYWxnXCIgJHthbGdvcml0aG19LmApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7019\n")},7059:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA1OS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzPzI0MjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7059\n")},7075:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst Comparator = __webpack_require__(3904)\nconst { ANY } = Comparator\nconst Range = __webpack_require__(8311)\nconst satisfies = __webpack_require__(7638)\nconst gt = __webpack_require__(5580)\nconst lt = __webpack_require__(7059)\nconst lte = __webpack_require__(5200)\nconst gte = __webpack_require__(4089)\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA3NS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsSUFBdUI7QUFDbEQsUUFBUSxNQUFNO0FBQ2QsY0FBYyxtQkFBTyxDQUFDLElBQWtCO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLElBQXdCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQyxJQUFpQjtBQUNwQyxXQUFXLG1CQUFPLENBQUMsSUFBaUI7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLElBQWtCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyxJQUFrQjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanM/ZDFlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7075\n")},7083:module=>{eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Creates a function that invokes `func`, with the `this` binding and arguments\n * of the created function, while it's called less than `n` times. Subsequent\n * calls to the created function return the result of the last `func` invocation.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {number} n The number of calls at which `func` is no longer invoked.\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new restricted function.\n * @example\n *\n * jQuery(element).on('click', _.before(5, addContactToList));\n * // => Allows adding up to 4 contacts to the list.\n */\nfunction before(n, func) {\n  var result;\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  n = toInteger(n);\n  return function() {\n    if (--n > 0) {\n      result = func.apply(this, arguments);\n    }\n    if (n <= 1) {\n      func = undefined;\n    }\n    return result;\n  };\n}\n\n/**\n * Creates a function that is restricted to invoking `func` once. Repeat calls\n * to the function return the value of the first invocation. The `func` is\n * invoked with the `this` binding and arguments of the created function.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new restricted function.\n * @example\n *\n * var initialize = _.once(createApplication);\n * initialize();\n * initialize();\n * // => `createApplication` is invoked once\n */\nfunction once(func) {\n  return before(2, func);\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = once;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gub25jZS9pbmRleC5qcz9lYjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICovXG5mdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBuID0gdG9JbnRlZ2VyKG4pO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tbiA+IDApIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKG4gPD0gMSkge1xuICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAqIGluaXRpYWxpemUoKTtcbiAqIGluaXRpYWxpemUoKTtcbiAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gKi9cbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9uY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7083\n")},7119:module=>{"use strict";eval("\n\n/** @type {import('./reflectApply')} */\nmodule.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzExOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLDBCQUEwQjtBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL3JlZmxlY3RBcHBseS5qcz82YjNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmVmbGVjdEFwcGx5Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0ICYmIFJlZmxlY3QuYXBwbHk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7119\n")},7140:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js\nvar common_utils_namespaceObject = {};\n__webpack_require__.r(common_utils_namespaceObject);\n__webpack_require__.d(common_utils_namespaceObject, {\n  hasBrowserEnv: () => (hasBrowserEnv),\n  hasStandardBrowserEnv: () => (hasStandardBrowserEnv),\n  hasStandardBrowserWebWorkerEnv: () => (hasStandardBrowserWebWorkerEnv),\n  navigator: () => (_navigator),\n  origin: () => (origin)\n});\n\n// EXTERNAL MODULE: external "electron"\nvar external_electron_ = __webpack_require__(1288);\n// EXTERNAL MODULE: external "path"\nvar external_path_ = __webpack_require__(6928);\n;// ./node_modules/@azure/msal-common/dist/utils/Constants.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst Constants_Constants = {\r\n    LIBRARY_NAME: "MSAL.JS",\r\n    SKU: "msal.js.common",\r\n    // Prefix for all library cache entries\r\n    CACHE_PREFIX: "msal",\r\n    // default authority\r\n    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",\r\n    DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",\r\n    DEFAULT_COMMON_TENANT: "common",\r\n    // ADFS String\r\n    ADFS: "adfs",\r\n    DSTS: "dstsv2",\r\n    // Default AAD Instance Discovery Endpoint\r\n    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",\r\n    // CIAM URL\r\n    CIAM_AUTH_URL: ".ciamlogin.com",\r\n    AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",\r\n    // Resource delimiter - used for certain cache entries\r\n    RESOURCE_DELIM: "|",\r\n    // Placeholder for non-existent account ids/objects\r\n    NO_ACCOUNT: "NO_ACCOUNT",\r\n    // Claims\r\n    CLAIMS: "claims",\r\n    // Consumer UTID\r\n    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",\r\n    // Default scopes\r\n    OPENID_SCOPE: "openid",\r\n    PROFILE_SCOPE: "profile",\r\n    OFFLINE_ACCESS_SCOPE: "offline_access",\r\n    EMAIL_SCOPE: "email",\r\n    CODE_GRANT_TYPE: "authorization_code",\r\n    RT_GRANT_TYPE: "refresh_token",\r\n    S256_CODE_CHALLENGE_METHOD: "S256",\r\n    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",\r\n    AUTHORIZATION_PENDING: "authorization_pending",\r\n    NOT_DEFINED: "not_defined",\r\n    EMPTY_STRING: "",\r\n    NOT_APPLICABLE: "N/A",\r\n    NOT_AVAILABLE: "Not Available",\r\n    FORWARD_SLASH: "/",\r\n    IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",\r\n    IMDS_VERSION: "2020-06-01",\r\n    IMDS_TIMEOUT: 2000,\r\n    AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",\r\n    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",\r\n    KNOWN_PUBLIC_CLOUDS: [\r\n        "login.microsoftonline.com",\r\n        "login.windows.net",\r\n        "login.microsoft.com",\r\n        "sts.windows.net",\r\n    ],\r\n    SHR_NONCE_VALIDITY: 240,\r\n    INVALID_INSTANCE: "invalid_instance",\r\n};\r\nconst HttpStatus = {\r\n    SUCCESS: 200,\r\n    SUCCESS_RANGE_START: 200,\r\n    SUCCESS_RANGE_END: 299,\r\n    REDIRECT: 302,\r\n    CLIENT_ERROR: 400,\r\n    CLIENT_ERROR_RANGE_START: 400,\r\n    BAD_REQUEST: 400,\r\n    UNAUTHORIZED: 401,\r\n    NOT_FOUND: 404,\r\n    REQUEST_TIMEOUT: 408,\r\n    GONE: 410,\r\n    TOO_MANY_REQUESTS: 429,\r\n    CLIENT_ERROR_RANGE_END: 499,\r\n    SERVER_ERROR: 500,\r\n    SERVER_ERROR_RANGE_START: 500,\r\n    SERVICE_UNAVAILABLE: 503,\r\n    GATEWAY_TIMEOUT: 504,\r\n    SERVER_ERROR_RANGE_END: 599,\r\n    MULTI_SIDED_ERROR: 600,\r\n};\r\nconst OIDC_DEFAULT_SCOPES = [\r\n    Constants_Constants.OPENID_SCOPE,\r\n    Constants_Constants.PROFILE_SCOPE,\r\n    Constants_Constants.OFFLINE_ACCESS_SCOPE,\r\n];\r\nconst OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants_Constants.EMAIL_SCOPE];\r\n/**\r\n * Request header names\r\n */\r\nconst HeaderNames = {\r\n    CONTENT_TYPE: "Content-Type",\r\n    CONTENT_LENGTH: "Content-Length",\r\n    RETRY_AFTER: "Retry-After",\r\n    CCS_HEADER: "X-AnchorMailbox",\r\n    WWWAuthenticate: "WWW-Authenticate",\r\n    AuthenticationInfo: "Authentication-Info",\r\n    X_MS_REQUEST_ID: "x-ms-request-id",\r\n    X_MS_HTTP_VERSION: "x-ms-httpver",\r\n};\r\n/**\r\n * Persistent cache keys MSAL which stay while user is logged in.\r\n */\r\nconst PersistentCacheKeys = {\r\n    ACTIVE_ACCOUNT_FILTERS: "active-account-filters", // new cache entry for active_account for a more robust version for browser\r\n};\r\n/**\r\n * String constants related to AAD Authority\r\n */\r\nconst AADAuthorityConstants = {\r\n    COMMON: "common",\r\n    ORGANIZATIONS: "organizations",\r\n    CONSUMERS: "consumers",\r\n};\r\n/**\r\n * Claims request keys\r\n */\r\nconst ClaimsRequestKeys = {\r\n    ACCESS_TOKEN: "access_token",\r\n    XMS_CC: "xms_cc",\r\n};\r\n/**\r\n * we considered making this "enum" in the request instead of string, however it looks like the allowed list of\r\n * prompt values kept changing over past couple of years. There are some undocumented prompt values for some\r\n * internal partners too, hence the choice of generic "string" type instead of the "enum"\r\n */\r\nconst PromptValue = {\r\n    LOGIN: "login",\r\n    SELECT_ACCOUNT: "select_account",\r\n    CONSENT: "consent",\r\n    NONE: "none",\r\n    CREATE: "create",\r\n    NO_SESSION: "no_session",\r\n};\r\n/**\r\n * allowed values for codeVerifier\r\n */\r\nconst CodeChallengeMethodValues = {\r\n    PLAIN: "plain",\r\n    S256: "S256",\r\n};\r\n/**\r\n * Allowed values for response_type\r\n */\r\nconst OAuthResponseType = {\r\n    CODE: "code",\r\n    IDTOKEN_TOKEN: "id_token token",\r\n    IDTOKEN_TOKEN_REFRESHTOKEN: "id_token token refresh_token",\r\n};\r\n/**\r\n * allowed values for server response type\r\n * @deprecated Use ResponseMode instead\r\n */\r\nconst ServerResponseType = {\r\n    QUERY: "query",\r\n    FRAGMENT: "fragment",\r\n};\r\n/**\r\n * allowed values for response_mode\r\n */\r\nconst ResponseMode = {\r\n    QUERY: "query",\r\n    FRAGMENT: "fragment",\r\n    FORM_POST: "form_post",\r\n};\r\n/**\r\n * allowed grant_type\r\n */\r\nconst GrantType = {\r\n    IMPLICIT_GRANT: "implicit",\r\n    AUTHORIZATION_CODE_GRANT: "authorization_code",\r\n    CLIENT_CREDENTIALS_GRANT: "client_credentials",\r\n    RESOURCE_OWNER_PASSWORD_GRANT: "password",\r\n    REFRESH_TOKEN_GRANT: "refresh_token",\r\n    DEVICE_CODE_GRANT: "device_code",\r\n    JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer",\r\n};\r\n/**\r\n * Account types in Cache\r\n */\r\nconst CacheAccountType = {\r\n    MSSTS_ACCOUNT_TYPE: "MSSTS",\r\n    ADFS_ACCOUNT_TYPE: "ADFS",\r\n    MSAV1_ACCOUNT_TYPE: "MSA",\r\n    GENERIC_ACCOUNT_TYPE: "Generic", // NTLM, Kerberos, FBA, Basic etc\r\n};\r\n/**\r\n * Separators used in cache\r\n */\r\nconst Separators = {\r\n    CACHE_KEY_SEPARATOR: "-",\r\n    CLIENT_INFO_SEPARATOR: ".",\r\n};\r\n/**\r\n * Credential Type stored in the cache\r\n */\r\nconst CredentialType = {\r\n    ID_TOKEN: "IdToken",\r\n    ACCESS_TOKEN: "AccessToken",\r\n    ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",\r\n    REFRESH_TOKEN: "RefreshToken",\r\n};\r\n/**\r\n * Combine all cache types\r\n */\r\nconst CacheType = {\r\n    ADFS: 1001,\r\n    MSA: 1002,\r\n    MSSTS: 1003,\r\n    GENERIC: 1004,\r\n    ACCESS_TOKEN: 2001,\r\n    REFRESH_TOKEN: 2002,\r\n    ID_TOKEN: 2003,\r\n    APP_METADATA: 3001,\r\n    UNDEFINED: 9999,\r\n};\r\n/**\r\n * More Cache related constants\r\n */\r\nconst APP_METADATA = "appmetadata";\r\nconst CLIENT_INFO = "client_info";\r\nconst THE_FAMILY_ID = "1";\r\nconst AUTHORITY_METADATA_CONSTANTS = {\r\n    CACHE_KEY: "authority-metadata",\r\n    REFRESH_TIME_SECONDS: 3600 * 24, // 24 Hours\r\n};\r\nconst AuthorityMetadataSource = {\r\n    CONFIG: "config",\r\n    CACHE: "cache",\r\n    NETWORK: "network",\r\n    HARDCODED_VALUES: "hardcoded_values",\r\n};\r\nconst SERVER_TELEM_CONSTANTS = {\r\n    SCHEMA_VERSION: 5,\r\n    MAX_CUR_HEADER_BYTES: 80,\r\n    MAX_LAST_HEADER_BYTES: 330,\r\n    MAX_CACHED_ERRORS: 50,\r\n    CACHE_KEY: "server-telemetry",\r\n    CATEGORY_SEPARATOR: "|",\r\n    VALUE_SEPARATOR: ",",\r\n    OVERFLOW_TRUE: "1",\r\n    OVERFLOW_FALSE: "0",\r\n    UNKNOWN_ERROR: "unknown_error",\r\n};\r\n/**\r\n * Type of the authentication request\r\n */\r\nconst AuthenticationScheme = {\r\n    BEARER: "Bearer",\r\n    POP: "pop",\r\n    SSH: "ssh-cert",\r\n};\r\n/**\r\n * Constants related to throttling\r\n */\r\nconst ThrottlingConstants = {\r\n    // Default time to throttle RequestThumbprint in seconds\r\n    DEFAULT_THROTTLE_TIME_SECONDS: 60,\r\n    // Default maximum time to throttle in seconds, overrides what the server sends back\r\n    DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,\r\n    // Prefix for storing throttling entries\r\n    THROTTLING_PREFIX: "throttling",\r\n    // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling\r\n    X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429",\r\n};\r\nconst Errors = {\r\n    INVALID_GRANT_ERROR: "invalid_grant",\r\n    CLIENT_MISMATCH_ERROR: "client_mismatch",\r\n};\r\n/**\r\n * Password grant parameters\r\n */\r\nconst PasswordGrantConstants = {\r\n    username: "username",\r\n    password: "password",\r\n};\r\n/**\r\n * Region Discovery Sources\r\n */\r\nconst RegionDiscoverySources = {\r\n    FAILED_AUTO_DETECTION: "1",\r\n    INTERNAL_CACHE: "2",\r\n    ENVIRONMENT_VARIABLE: "3",\r\n    IMDS: "4",\r\n};\r\n/**\r\n * Region Discovery Outcomes\r\n */\r\nconst RegionDiscoveryOutcomes = {\r\n    CONFIGURED_MATCHES_DETECTED: "1",\r\n    CONFIGURED_NO_AUTO_DETECTION: "2",\r\n    CONFIGURED_NOT_DETECTED: "3",\r\n    AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",\r\n    AUTO_DETECTION_REQUESTED_FAILED: "5",\r\n};\r\n/**\r\n * Specifies the reason for fetching the access token from the identity provider\r\n */\r\nconst Constants_CacheOutcome = {\r\n    // When a token is found in the cache or the cache is not supposed to be hit when making the request\r\n    NOT_APPLICABLE: "0",\r\n    // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested\r\n    FORCE_REFRESH_OR_CLAIMS: "1",\r\n    // When the token request goes to the identity provider because no cached access token exists\r\n    NO_CACHED_ACCESS_TOKEN: "2",\r\n    // When the token request goes to the identity provider because cached access token expired\r\n    CACHED_ACCESS_TOKEN_EXPIRED: "3",\r\n    // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed\r\n    PROACTIVELY_REFRESHED: "4",\r\n};\r\nconst JsonWebTokenTypes = {\r\n    Jwt: "JWT",\r\n    Jwk: "JWK",\r\n    Pop: "pop",\r\n};\r\nconst ONE_DAY_IN_MS = 86400000;\r\n// Token renewal offset default in seconds\r\nconst DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;\r\nconst Constants_EncodingTypes = {\r\n    BASE64: "base64",\r\n    HEX: "hex",\r\n    UTF8: "utf-8",\r\n};\n\n\n//# sourceMappingURL=Constants.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/utils/Constants.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n// MSI Constants. Docs for MSI are available here https://docs.microsoft.com/azure/app-service/overview-managed-identity\r\nconst Constants_DEFAULT_MANAGED_IDENTITY_ID = "system_assigned_managed_identity";\r\nconst MANAGED_IDENTITY_DEFAULT_TENANT = "managed_identity";\r\nconst Constants_DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = (/* unused pure expression or super */ null && (`https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`));\r\n/**\r\n * Managed Identity Headers - used in network requests\r\n */\r\nconst ManagedIdentityHeaders = {\r\n    AUTHORIZATION_HEADER_NAME: "Authorization",\r\n    METADATA_HEADER_NAME: "Metadata",\r\n    APP_SERVICE_SECRET_HEADER_NAME: "X-IDENTITY-HEADER",\r\n    ML_AND_SF_SECRET_HEADER_NAME: "secret",\r\n};\r\n/**\r\n * Managed Identity Query Parameters - used in network requests\r\n */\r\nconst ManagedIdentityQueryParameters = {\r\n    API_VERSION: "api-version",\r\n    RESOURCE: "resource",\r\n    SHA256_TOKEN_TO_REFRESH: "token_sha256_to_refresh",\r\n    XMS_CC: "xms_cc",\r\n};\r\n/**\r\n * Managed Identity Environment Variable Names\r\n */\r\nconst ManagedIdentityEnvironmentVariableNames = {\r\n    AZURE_POD_IDENTITY_AUTHORITY_HOST: "AZURE_POD_IDENTITY_AUTHORITY_HOST",\r\n    IDENTITY_ENDPOINT: "IDENTITY_ENDPOINT",\r\n    IDENTITY_HEADER: "IDENTITY_HEADER",\r\n    IDENTITY_SERVER_THUMBPRINT: "IDENTITY_SERVER_THUMBPRINT",\r\n    IMDS_ENDPOINT: "IMDS_ENDPOINT",\r\n    MSI_ENDPOINT: "MSI_ENDPOINT",\r\n    MSI_SECRET: "MSI_SECRET",\r\n};\r\n/**\r\n * Managed Identity Source Names\r\n * @public\r\n */\r\nconst Constants_ManagedIdentitySourceNames = {\r\n    APP_SERVICE: "AppService",\r\n    AZURE_ARC: "AzureArc",\r\n    CLOUD_SHELL: "CloudShell",\r\n    DEFAULT_TO_IMDS: "DefaultToImds",\r\n    IMDS: "Imds",\r\n    MACHINE_LEARNING: "MachineLearning",\r\n    SERVICE_FABRIC: "ServiceFabric",\r\n};\r\n/**\r\n * Managed Identity Ids\r\n */\r\nconst Constants_ManagedIdentityIdType = {\r\n    SYSTEM_ASSIGNED: "system-assigned",\r\n    USER_ASSIGNED_CLIENT_ID: "user-assigned-client-id",\r\n    USER_ASSIGNED_RESOURCE_ID: "user-assigned-resource-id",\r\n    USER_ASSIGNED_OBJECT_ID: "user-assigned-object-id",\r\n};\r\n/**\r\n * http methods\r\n */\r\nconst HttpMethod = {\r\n    GET: "get",\r\n    POST: "post",\r\n};\r\nconst ProxyStatus = {\r\n    SUCCESS: HttpStatus.SUCCESS,\r\n    SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,\r\n    SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,\r\n    SERVER_ERROR: HttpStatus.SERVER_ERROR,\r\n};\r\n/**\r\n * Constants used for region discovery\r\n */\r\nconst REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";\r\nconst MSAL_FORCE_REGION = "MSAL_FORCE_REGION";\r\n/**\r\n * Constant used for PKCE\r\n */\r\nconst RANDOM_OCTET_SIZE = 32;\r\n/**\r\n * Constants used in PKCE\r\n */\r\nconst Hash = {\r\n    SHA256: "sha256",\r\n};\r\n/**\r\n * Constants for encoding schemes\r\n */\r\nconst CharSet = {\r\n    CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",\r\n};\r\n/**\r\n * Constants\r\n */\r\nconst utils_Constants_Constants = {\r\n    MSAL_SKU: "msal.js.node",\r\n    JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",\r\n    AUTHORIZATION_PENDING: "authorization_pending",\r\n    HTTP_PROTOCOL: "http://",\r\n    LOCALHOST: "localhost",\r\n};\r\n/**\r\n * API Codes for Telemetry purposes.\r\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\r\n * 0-99 Silent Flow\r\n * 600-699 Device Code Flow\r\n * 800-899 Auth Code Flow\r\n */\r\nconst ApiId = {\r\n    acquireTokenSilent: 62,\r\n    acquireTokenByUsernamePassword: 371,\r\n    acquireTokenByDeviceCode: 671,\r\n    acquireTokenByClientCredential: 771,\r\n    acquireTokenByCode: 871,\r\n    acquireTokenByRefreshToken: 872,\r\n};\r\n/**\r\n * JWT  constants\r\n */\r\nconst JwtConstants = {\r\n    ALGORITHM: "alg",\r\n    RSA_256: "RS256",\r\n    PSS_256: "PS256",\r\n    X5T_256: "x5t#S256",\r\n    X5T: "x5t",\r\n    X5C: "x5c",\r\n    AUDIENCE: "aud",\r\n    EXPIRATION_TIME: "exp",\r\n    ISSUER: "iss",\r\n    SUBJECT: "sub",\r\n    NOT_BEFORE: "nbf",\r\n    JWT_ID: "jti",\r\n};\r\nconst LOOPBACK_SERVER_CONSTANTS = {\r\n    INTERVAL_MS: 100,\r\n    TIMEOUT_MS: 5000,\r\n};\r\nconst AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES = 4096; // 4 KB\n\n\n//# sourceMappingURL=Constants.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/AuthErrorCodes.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * AuthErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nconst unexpectedError = "unexpected_error";\r\nconst postRequestFailed = "post_request_failed";\n\n\n//# sourceMappingURL=AuthErrorCodes.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/AuthError.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst AuthErrorMessages = {\r\n    [unexpectedError]: "Unexpected error in authentication.",\r\n    [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details.",\r\n};\r\n/**\r\n * AuthErrorMessage class containing string constants used by error codes and messages.\r\n * @deprecated Use AuthErrorCodes instead\r\n */\r\nconst AuthErrorMessage = {\r\n    unexpectedError: {\r\n        code: unexpectedError,\r\n        desc: AuthErrorMessages[unexpectedError],\r\n    },\r\n    postRequestFailed: {\r\n        code: postRequestFailed,\r\n        desc: AuthErrorMessages[postRequestFailed],\r\n    },\r\n};\r\n/**\r\n * General error class thrown by the MSAL.js library.\r\n */\r\nclass AuthError extends Error {\r\n    constructor(errorCode, errorMessage, suberror) {\r\n        const errorString = errorMessage\r\n            ? `${errorCode}: ${errorMessage}`\r\n            : errorCode;\r\n        super(errorString);\r\n        Object.setPrototypeOf(this, AuthError.prototype);\r\n        this.errorCode = errorCode || Constants_Constants.EMPTY_STRING;\r\n        this.errorMessage = errorMessage || Constants_Constants.EMPTY_STRING;\r\n        this.subError = suberror || Constants_Constants.EMPTY_STRING;\r\n        this.name = "AuthError";\r\n    }\r\n    setCorrelationId(correlationId) {\r\n        this.correlationId = correlationId;\r\n    }\r\n}\r\nfunction createAuthError(code, additionalMessage) {\r\n    return new AuthError(code, additionalMessage\r\n        ? `${AuthErrorMessages[code]} ${additionalMessage}`\r\n        : AuthErrorMessages[code]);\r\n}\n\n\n//# sourceMappingURL=AuthError.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/telemetry/server/ServerTelemetryManager.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst skuGroupSeparator = ",";\r\nconst skuValueSeparator = "|";\r\nfunction makeExtraSkuString(params) {\r\n    const { skus, libraryName, libraryVersion, extensionName, extensionVersion, } = params;\r\n    const skuMap = new Map([\r\n        [0, [libraryName, libraryVersion]],\r\n        [2, [extensionName, extensionVersion]],\r\n    ]);\r\n    let skuArr = [];\r\n    if (skus?.length) {\r\n        skuArr = skus.split(skuGroupSeparator);\r\n        // Ignore invalid input sku param\r\n        if (skuArr.length < 4) {\r\n            return skus;\r\n        }\r\n    }\r\n    else {\r\n        skuArr = Array.from({ length: 4 }, () => skuValueSeparator);\r\n    }\r\n    skuMap.forEach((value, key) => {\r\n        if (value.length === 2 && value[0]?.length && value[1]?.length) {\r\n            setSku({\r\n                skuArr,\r\n                index: key,\r\n                skuName: value[0],\r\n                skuVersion: value[1],\r\n            });\r\n        }\r\n    });\r\n    return skuArr.join(skuGroupSeparator);\r\n}\r\nfunction setSku(params) {\r\n    const { skuArr, index, skuName, skuVersion } = params;\r\n    if (index >= skuArr.length) {\r\n        return;\r\n    }\r\n    skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);\r\n}\r\n/** @internal */\r\nclass ServerTelemetryManager {\r\n    constructor(telemetryRequest, cacheManager) {\r\n        this.cacheOutcome = Constants_CacheOutcome.NOT_APPLICABLE;\r\n        this.cacheManager = cacheManager;\r\n        this.apiId = telemetryRequest.apiId;\r\n        this.correlationId = telemetryRequest.correlationId;\r\n        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants_Constants.EMPTY_STRING;\r\n        this.wrapperVer = telemetryRequest.wrapperVer || Constants_Constants.EMPTY_STRING;\r\n        this.telemetryCacheKey =\r\n            SERVER_TELEM_CONSTANTS.CACHE_KEY +\r\n                Separators.CACHE_KEY_SEPARATOR +\r\n                telemetryRequest.clientId;\r\n    }\r\n    /**\r\n     * API to add MSER Telemetry to request\r\n     */\r\n    generateCurrentRequestHeaderValue() {\r\n        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;\r\n        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];\r\n        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();\r\n        if (nativeBrokerErrorCode?.length) {\r\n            platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);\r\n        }\r\n        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\r\n        const regionDiscoveryFields = this.getRegionDiscoveryFields();\r\n        const requestWithRegionDiscoveryFields = [\r\n            request,\r\n            regionDiscoveryFields,\r\n        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\r\n        return [\r\n            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,\r\n            requestWithRegionDiscoveryFields,\r\n            platformFields,\r\n        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\r\n    }\r\n    /**\r\n     * API to add MSER Telemetry for the last failed request\r\n     */\r\n    generateLastRequestHeaderValue() {\r\n        const lastRequests = this.getLastRequests();\r\n        const maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);\r\n        const failedRequests = lastRequests.failedRequests\r\n            .slice(0, 2 * maxErrors)\r\n            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\r\n        const errors = lastRequests.errors\r\n            .slice(0, maxErrors)\r\n            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\r\n        const errorCount = lastRequests.errors.length;\r\n        // Indicate whether this header contains all data or partial data\r\n        const overflow = maxErrors < errorCount\r\n            ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE\r\n            : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;\r\n        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\r\n        return [\r\n            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,\r\n            lastRequests.cacheHits,\r\n            failedRequests,\r\n            errors,\r\n            platformFields,\r\n        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\r\n    }\r\n    /**\r\n     * API to cache token failures for MSER data capture\r\n     * @param error\r\n     */\r\n    cacheFailedRequest(error) {\r\n        const lastRequests = this.getLastRequests();\r\n        if (lastRequests.errors.length >=\r\n            SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {\r\n            // Remove a cached error to make room, first in first out\r\n            lastRequests.failedRequests.shift(); // apiId\r\n            lastRequests.failedRequests.shift(); // correlationId\r\n            lastRequests.errors.shift();\r\n        }\r\n        lastRequests.failedRequests.push(this.apiId, this.correlationId);\r\n        if (error instanceof Error && !!error && error.toString()) {\r\n            if (error instanceof AuthError) {\r\n                if (error.subError) {\r\n                    lastRequests.errors.push(error.subError);\r\n                }\r\n                else if (error.errorCode) {\r\n                    lastRequests.errors.push(error.errorCode);\r\n                }\r\n                else {\r\n                    lastRequests.errors.push(error.toString());\r\n                }\r\n            }\r\n            else {\r\n                lastRequests.errors.push(error.toString());\r\n            }\r\n        }\r\n        else {\r\n            lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);\r\n        }\r\n        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\r\n        return;\r\n    }\r\n    /**\r\n     * Update server telemetry cache entry by incrementing cache hit counter\r\n     */\r\n    incrementCacheHits() {\r\n        const lastRequests = this.getLastRequests();\r\n        lastRequests.cacheHits += 1;\r\n        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\r\n        return lastRequests.cacheHits;\r\n    }\r\n    /**\r\n     * Get the server telemetry entity from cache or initialize a new one\r\n     */\r\n    getLastRequests() {\r\n        const initialValue = {\r\n            failedRequests: [],\r\n            errors: [],\r\n            cacheHits: 0,\r\n        };\r\n        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);\r\n        return lastRequests || initialValue;\r\n    }\r\n    /**\r\n     * Remove server telemetry cache entry\r\n     */\r\n    clearTelemetryCache() {\r\n        const lastRequests = this.getLastRequests();\r\n        const numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);\r\n        const errorCount = lastRequests.errors.length;\r\n        if (numErrorsFlushed === errorCount) {\r\n            // All errors were sent on last request, clear Telemetry cache\r\n            this.cacheManager.removeItem(this.telemetryCacheKey);\r\n        }\r\n        else {\r\n            // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed\r\n            const serverTelemEntity = {\r\n                failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),\r\n                errors: lastRequests.errors.slice(numErrorsFlushed),\r\n                cacheHits: 0,\r\n            };\r\n            this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the maximum number of errors that can be flushed to the server in the next network request\r\n     * @param serverTelemetryEntity\r\n     */\r\n    static maxErrorsToSend(serverTelemetryEntity) {\r\n        let i;\r\n        let maxErrors = 0;\r\n        let dataSize = 0;\r\n        const errorCount = serverTelemetryEntity.errors.length;\r\n        for (i = 0; i < errorCount; i++) {\r\n            // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs\r\n            const apiId = serverTelemetryEntity.failedRequests[2 * i] ||\r\n                Constants_Constants.EMPTY_STRING;\r\n            const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] ||\r\n                Constants_Constants.EMPTY_STRING;\r\n            const errorCode = serverTelemetryEntity.errors[i] || Constants_Constants.EMPTY_STRING;\r\n            // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators\r\n            dataSize +=\r\n                apiId.toString().length +\r\n                    correlationId.toString().length +\r\n                    errorCode.length +\r\n                    3;\r\n            if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {\r\n                // Adding this entry to the header would still keep header size below the limit\r\n                maxErrors += 1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return maxErrors;\r\n    }\r\n    /**\r\n     * Get the region discovery fields\r\n     *\r\n     * @returns string\r\n     */\r\n    getRegionDiscoveryFields() {\r\n        const regionDiscoveryFields = [];\r\n        regionDiscoveryFields.push(this.regionUsed || Constants_Constants.EMPTY_STRING);\r\n        regionDiscoveryFields.push(this.regionSource || Constants_Constants.EMPTY_STRING);\r\n        regionDiscoveryFields.push(this.regionOutcome || Constants_Constants.EMPTY_STRING);\r\n        return regionDiscoveryFields.join(",");\r\n    }\r\n    /**\r\n     * Update the region discovery metadata\r\n     *\r\n     * @param regionDiscoveryMetadata\r\n     * @returns void\r\n     */\r\n    updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {\r\n        this.regionUsed = regionDiscoveryMetadata.region_used;\r\n        this.regionSource = regionDiscoveryMetadata.region_source;\r\n        this.regionOutcome = regionDiscoveryMetadata.region_outcome;\r\n    }\r\n    /**\r\n     * Set cache outcome\r\n     */\r\n    setCacheOutcome(cacheOutcome) {\r\n        this.cacheOutcome = cacheOutcome;\r\n    }\r\n    setNativeBrokerErrorCode(errorCode) {\r\n        const lastRequests = this.getLastRequests();\r\n        lastRequests.nativeBrokerErrorCode = errorCode;\r\n        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\r\n    }\r\n    getNativeBrokerErrorCode() {\r\n        return this.getLastRequests().nativeBrokerErrorCode;\r\n    }\r\n    clearNativeBrokerErrorCode() {\r\n        const lastRequests = this.getLastRequests();\r\n        delete lastRequests.nativeBrokerErrorCode;\r\n        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\r\n    }\r\n    static makeExtraSkuString(params) {\r\n        return makeExtraSkuString(params);\r\n    }\r\n}\n\n\n//# sourceMappingURL=ServerTelemetryManager.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/constants/AADServerParamKeys.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst CLIENT_ID = "client_id";\r\nconst REDIRECT_URI = "redirect_uri";\r\nconst RESPONSE_TYPE = "response_type";\r\nconst RESPONSE_MODE = "response_mode";\r\nconst GRANT_TYPE = "grant_type";\r\nconst CLAIMS = "claims";\r\nconst SCOPE = "scope";\r\nconst ERROR = "error";\r\nconst ERROR_DESCRIPTION = "error_description";\r\nconst ACCESS_TOKEN = "access_token";\r\nconst ID_TOKEN = "id_token";\r\nconst REFRESH_TOKEN = "refresh_token";\r\nconst EXPIRES_IN = "expires_in";\r\nconst REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";\r\nconst STATE = "state";\r\nconst NONCE = "nonce";\r\nconst PROMPT = "prompt";\r\nconst SESSION_STATE = "session_state";\r\nconst AADServerParamKeys_CLIENT_INFO = "client_info";\r\nconst CODE = "code";\r\nconst CODE_CHALLENGE = "code_challenge";\r\nconst CODE_CHALLENGE_METHOD = "code_challenge_method";\r\nconst CODE_VERIFIER = "code_verifier";\r\nconst CLIENT_REQUEST_ID = "client-request-id";\r\nconst X_CLIENT_SKU = "x-client-SKU";\r\nconst X_CLIENT_VER = "x-client-VER";\r\nconst X_CLIENT_OS = "x-client-OS";\r\nconst X_CLIENT_CPU = "x-client-CPU";\r\nconst X_CLIENT_CURR_TELEM = "x-client-current-telemetry";\r\nconst X_CLIENT_LAST_TELEM = "x-client-last-telemetry";\r\nconst X_MS_LIB_CAPABILITY = "x-ms-lib-capability";\r\nconst X_APP_NAME = "x-app-name";\r\nconst X_APP_VER = "x-app-ver";\r\nconst POST_LOGOUT_URI = "post_logout_redirect_uri";\r\nconst ID_TOKEN_HINT = "id_token_hint";\r\nconst DEVICE_CODE = "device_code";\r\nconst CLIENT_SECRET = "client_secret";\r\nconst CLIENT_ASSERTION = "client_assertion";\r\nconst CLIENT_ASSERTION_TYPE = "client_assertion_type";\r\nconst TOKEN_TYPE = "token_type";\r\nconst REQ_CNF = "req_cnf";\r\nconst OBO_ASSERTION = "assertion";\r\nconst REQUESTED_TOKEN_USE = "requested_token_use";\r\nconst ON_BEHALF_OF = "on_behalf_of";\r\nconst FOCI = "foci";\r\nconst CCS_HEADER = "X-AnchorMailbox";\r\nconst RETURN_SPA_CODE = "return_spa_code";\r\nconst AADServerParamKeys_NATIVE_BROKER = "nativebroker";\r\nconst LOGOUT_HINT = "logout_hint";\r\nconst SID = "sid";\r\nconst LOGIN_HINT = "login_hint";\r\nconst DOMAIN_HINT = "domain_hint";\r\nconst X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";\r\nconst BROKER_CLIENT_ID = "brk_client_id";\r\nconst BROKER_REDIRECT_URI = "brk_redirect_uri";\r\nconst INSTANCE_AWARE = "instance_aware";\r\nconst AADServerParamKeys_EAR_JWK = "ear_jwk";\r\nconst AADServerParamKeys_EAR_JWE_CRYPTO = "ear_jwe_crypto";\n\n\n//# sourceMappingURL=AADServerParamKeys.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/ServerError.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Error thrown when there is an error with the server code, for example, unavailability.\r\n */\r\nclass ServerError_ServerError extends AuthError {\r\n    constructor(errorCode, errorMessage, subError, errorNo, status) {\r\n        super(errorCode, errorMessage, subError);\r\n        this.name = "ServerError";\r\n        this.errorNo = errorNo;\r\n        this.status = status;\r\n        Object.setPrototypeOf(this, ServerError_ServerError.prototype);\r\n    }\r\n}\n\n\n//# sourceMappingURL=ServerError.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/logger/Logger.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Log message level.\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel["Error"] = 0] = "Error";\r\n    LogLevel[LogLevel["Warning"] = 1] = "Warning";\r\n    LogLevel[LogLevel["Info"] = 2] = "Info";\r\n    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";\r\n    LogLevel[LogLevel["Trace"] = 4] = "Trace";\r\n})(LogLevel || (LogLevel = {}));\r\n/**\r\n * Class which facilitates logging of messages to a specific place.\r\n */\r\nclass Logger_Logger {\r\n    constructor(loggerOptions, packageName, packageVersion) {\r\n        // Current log level, defaults to info.\r\n        this.level = LogLevel.Info;\r\n        const defaultLoggerCallback = () => {\r\n            return;\r\n        };\r\n        const setLoggerOptions = loggerOptions || Logger_Logger.createDefaultLoggerOptions();\r\n        this.localCallback =\r\n            setLoggerOptions.loggerCallback || defaultLoggerCallback;\r\n        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;\r\n        this.level =\r\n            typeof setLoggerOptions.logLevel === "number"\r\n                ? setLoggerOptions.logLevel\r\n                : LogLevel.Info;\r\n        this.correlationId =\r\n            setLoggerOptions.correlationId || Constants_Constants.EMPTY_STRING;\r\n        this.packageName = packageName || Constants_Constants.EMPTY_STRING;\r\n        this.packageVersion = packageVersion || Constants_Constants.EMPTY_STRING;\r\n    }\r\n    static createDefaultLoggerOptions() {\r\n        return {\r\n            loggerCallback: () => {\r\n                // allow users to not set loggerCallback\r\n            },\r\n            piiLoggingEnabled: false,\r\n            logLevel: LogLevel.Info,\r\n        };\r\n    }\r\n    /**\r\n     * Create new Logger with existing configurations.\r\n     */\r\n    clone(packageName, packageVersion, correlationId) {\r\n        return new Logger_Logger({\r\n            loggerCallback: this.localCallback,\r\n            piiLoggingEnabled: this.piiLoggingEnabled,\r\n            logLevel: this.level,\r\n            correlationId: correlationId || this.correlationId,\r\n        }, packageName, packageVersion);\r\n    }\r\n    /**\r\n     * Log message with required options.\r\n     */\r\n    logMessage(logMessage, options) {\r\n        if (options.logLevel > this.level ||\r\n            (!this.piiLoggingEnabled && options.containsPii)) {\r\n            return;\r\n        }\r\n        const timestamp = new Date().toUTCString();\r\n        // Add correlationId to logs if set, correlationId provided on log messages take precedence\r\n        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;\r\n        const log = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${LogLevel[options.logLevel]} - ${logMessage}`;\r\n        // debug(`msal:${LogLevel[options.logLevel]}${options.containsPii ? "-Pii": Constants.EMPTY_STRING}${options.context ? `:${options.context}` : Constants.EMPTY_STRING}`)(logMessage);\r\n        this.executeCallback(options.logLevel, log, options.containsPii || false);\r\n    }\r\n    /**\r\n     * Execute callback with message.\r\n     */\r\n    executeCallback(level, message, containsPii) {\r\n        if (this.localCallback) {\r\n            this.localCallback(level, message, containsPii);\r\n        }\r\n    }\r\n    /**\r\n     * Logs error messages.\r\n     */\r\n    error(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Error,\r\n            containsPii: false,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs error messages with PII.\r\n     */\r\n    errorPii(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Error,\r\n            containsPii: true,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs warning messages.\r\n     */\r\n    warning(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Warning,\r\n            containsPii: false,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs warning messages with PII.\r\n     */\r\n    warningPii(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Warning,\r\n            containsPii: true,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs info messages.\r\n     */\r\n    info(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Info,\r\n            containsPii: false,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs info messages with PII.\r\n     */\r\n    infoPii(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Info,\r\n            containsPii: true,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs verbose messages.\r\n     */\r\n    verbose(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Verbose,\r\n            containsPii: false,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs verbose messages with PII.\r\n     */\r\n    verbosePii(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Verbose,\r\n            containsPii: true,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs trace messages.\r\n     */\r\n    trace(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Trace,\r\n            containsPii: false,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Logs trace messages with PII.\r\n     */\r\n    tracePii(message, correlationId) {\r\n        this.logMessage(message, {\r\n            logLevel: LogLevel.Trace,\r\n            containsPii: true,\r\n            correlationId: correlationId || Constants_Constants.EMPTY_STRING,\r\n        });\r\n    }\r\n    /**\r\n     * Returns whether PII Logging is enabled or not.\r\n     */\r\n    isPiiLoggingEnabled() {\r\n        return this.piiLoggingEnabled || false;\r\n    }\r\n}\n\n\n//# sourceMappingURL=Logger.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/AuthorityType.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Authority types supported by MSAL.\r\n */\r\nconst AuthorityType = {\r\n    Default: 0,\r\n    Adfs: 1,\r\n    Dsts: 2,\r\n    Ciam: 3,\r\n};\n\n\n//# sourceMappingURL=AuthorityType.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/OpenIdConfigResponse.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nfunction isOpenIdConfigResponse(response) {\r\n    return (response.hasOwnProperty("authorization_endpoint") &&\r\n        response.hasOwnProperty("token_endpoint") &&\r\n        response.hasOwnProperty("issuer") &&\r\n        response.hasOwnProperty("jwks_uri"));\r\n}\n\n\n//# sourceMappingURL=OpenIdConfigResponse.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/ClientConfigurationErrorCodes.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst redirectUriEmpty = "redirect_uri_empty";\r\nconst claimsRequestParsingError = "claims_request_parsing_error";\r\nconst authorityUriInsecure = "authority_uri_insecure";\r\nconst urlParseError = "url_parse_error";\r\nconst urlEmptyError = "empty_url_error";\r\nconst emptyInputScopesError = "empty_input_scopes_error";\r\nconst invalidPromptValue = "invalid_prompt_value";\r\nconst invalidClaims = "invalid_claims";\r\nconst tokenRequestEmpty = "token_request_empty";\r\nconst logoutRequestEmpty = "logout_request_empty";\r\nconst invalidCodeChallengeMethod = "invalid_code_challenge_method";\r\nconst pkceParamsMissing = "pkce_params_missing";\r\nconst invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";\r\nconst invalidAuthorityMetadata = "invalid_authority_metadata";\r\nconst untrustedAuthority = "untrusted_authority";\r\nconst missingSshJwk = "missing_ssh_jwk";\r\nconst missingSshKid = "missing_ssh_kid";\r\nconst missingNonceAuthenticationHeader = "missing_nonce_authentication_header";\r\nconst invalidAuthenticationHeader = "invalid_authentication_header";\r\nconst cannotSetOIDCOptions = "cannot_set_OIDCOptions";\r\nconst cannotAllowPlatformBroker = "cannot_allow_platform_broker";\r\nconst authorityMismatch = "authority_mismatch";\n\n\n//# sourceMappingURL=ClientConfigurationErrorCodes.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/ClientConfigurationError.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst ClientConfigurationErrorMessages = {\r\n    [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",\r\n    [claimsRequestParsingError]: "Could not parse the given claims request object.",\r\n    [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",\r\n    [urlParseError]: "URL could not be parsed into appropriate segments.",\r\n    [urlEmptyError]: "URL was empty or null.",\r\n    [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",\r\n    [invalidPromptValue]: "Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest",\r\n    [invalidClaims]: "Given claims parameter must be a stringified JSON object.",\r\n    [tokenRequestEmpty]: "Token request was empty and not found in cache.",\r\n    [logoutRequestEmpty]: "The logout request was null or undefined.",\r\n    [invalidCodeChallengeMethod]: \'code_challenge_method passed is invalid. Valid values are "plain" and "S256".\',\r\n    [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",\r\n    [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",\r\n    [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",\r\n    [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",\r\n    [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",\r\n    [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",\r\n    [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",\r\n    [invalidAuthenticationHeader]: "Invalid authentication header provided",\r\n    [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",\r\n    [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",\r\n    [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.",\r\n};\r\n/**\r\n * ClientConfigurationErrorMessage class containing string constants used by error codes and messages.\r\n * @deprecated Use ClientConfigurationErrorCodes instead\r\n */\r\nconst ClientConfigurationErrorMessage = {\r\n    redirectUriNotSet: {\r\n        code: redirectUriEmpty,\r\n        desc: ClientConfigurationErrorMessages[redirectUriEmpty],\r\n    },\r\n    claimsRequestParsingError: {\r\n        code: claimsRequestParsingError,\r\n        desc: ClientConfigurationErrorMessages[claimsRequestParsingError],\r\n    },\r\n    authorityUriInsecure: {\r\n        code: authorityUriInsecure,\r\n        desc: ClientConfigurationErrorMessages[authorityUriInsecure],\r\n    },\r\n    urlParseError: {\r\n        code: urlParseError,\r\n        desc: ClientConfigurationErrorMessages[urlParseError],\r\n    },\r\n    urlEmptyError: {\r\n        code: urlEmptyError,\r\n        desc: ClientConfigurationErrorMessages[urlEmptyError],\r\n    },\r\n    emptyScopesError: {\r\n        code: emptyInputScopesError,\r\n        desc: ClientConfigurationErrorMessages[emptyInputScopesError],\r\n    },\r\n    invalidPrompt: {\r\n        code: invalidPromptValue,\r\n        desc: ClientConfigurationErrorMessages[invalidPromptValue],\r\n    },\r\n    invalidClaimsRequest: {\r\n        code: invalidClaims,\r\n        desc: ClientConfigurationErrorMessages[invalidClaims],\r\n    },\r\n    tokenRequestEmptyError: {\r\n        code: tokenRequestEmpty,\r\n        desc: ClientConfigurationErrorMessages[tokenRequestEmpty],\r\n    },\r\n    logoutRequestEmptyError: {\r\n        code: logoutRequestEmpty,\r\n        desc: ClientConfigurationErrorMessages[logoutRequestEmpty],\r\n    },\r\n    invalidCodeChallengeMethod: {\r\n        code: invalidCodeChallengeMethod,\r\n        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod],\r\n    },\r\n    invalidCodeChallengeParams: {\r\n        code: pkceParamsMissing,\r\n        desc: ClientConfigurationErrorMessages[pkceParamsMissing],\r\n    },\r\n    invalidCloudDiscoveryMetadata: {\r\n        code: invalidCloudDiscoveryMetadata,\r\n        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata],\r\n    },\r\n    invalidAuthorityMetadata: {\r\n        code: invalidAuthorityMetadata,\r\n        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata],\r\n    },\r\n    untrustedAuthority: {\r\n        code: untrustedAuthority,\r\n        desc: ClientConfigurationErrorMessages[untrustedAuthority],\r\n    },\r\n    missingSshJwk: {\r\n        code: missingSshJwk,\r\n        desc: ClientConfigurationErrorMessages[missingSshJwk],\r\n    },\r\n    missingSshKid: {\r\n        code: missingSshKid,\r\n        desc: ClientConfigurationErrorMessages[missingSshKid],\r\n    },\r\n    missingNonceAuthenticationHeader: {\r\n        code: missingNonceAuthenticationHeader,\r\n        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader],\r\n    },\r\n    invalidAuthenticationHeader: {\r\n        code: invalidAuthenticationHeader,\r\n        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader],\r\n    },\r\n    cannotSetOIDCOptions: {\r\n        code: cannotSetOIDCOptions,\r\n        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions],\r\n    },\r\n    cannotAllowPlatformBroker: {\r\n        code: cannotAllowPlatformBroker,\r\n        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker],\r\n    },\r\n    authorityMismatch: {\r\n        code: authorityMismatch,\r\n        desc: ClientConfigurationErrorMessages[authorityMismatch],\r\n    },\r\n};\r\n/**\r\n * Error thrown when there is an error in configuration of the MSAL.js library.\r\n */\r\nclass ClientConfigurationError extends AuthError {\r\n    constructor(errorCode) {\r\n        super(errorCode, ClientConfigurationErrorMessages[errorCode]);\r\n        this.name = "ClientConfigurationError";\r\n        Object.setPrototypeOf(this, ClientConfigurationError.prototype);\r\n    }\r\n}\r\nfunction ClientConfigurationError_createClientConfigurationError(errorCode) {\r\n    return new ClientConfigurationError(errorCode);\r\n}\n\n\n//# sourceMappingURL=ClientConfigurationError.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/utils/StringUtils.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * @hidden\r\n */\r\nclass StringUtils {\r\n    /**\r\n     * Check if stringified object is empty\r\n     * @param strObj\r\n     */\r\n    static isEmptyObj(strObj) {\r\n        if (strObj) {\r\n            try {\r\n                const obj = JSON.parse(strObj);\r\n                return Object.keys(obj).length === 0;\r\n            }\r\n            catch (e) { }\r\n        }\r\n        return true;\r\n    }\r\n    static startsWith(str, search) {\r\n        return str.indexOf(search) === 0;\r\n    }\r\n    static endsWith(str, search) {\r\n        return (str.length >= search.length &&\r\n            str.lastIndexOf(search) === str.length - search.length);\r\n    }\r\n    /**\r\n     * Parses string into an object.\r\n     *\r\n     * @param query\r\n     */\r\n    static queryStringToObject(query) {\r\n        const obj = {};\r\n        const params = query.split("&");\r\n        const decode = (s) => decodeURIComponent(s.replace(/\\+/g, " "));\r\n        params.forEach((pair) => {\r\n            if (pair.trim()) {\r\n                const [key, value] = pair.split(/=(.+)/g, 2); // Split on the first occurence of the \'=\' character\r\n                if (key && value) {\r\n                    obj[decode(key)] = decode(value);\r\n                }\r\n            }\r\n        });\r\n        return obj;\r\n    }\r\n    /**\r\n     * Trims entries in an array.\r\n     *\r\n     * @param arr\r\n     */\r\n    static trimArrayEntries(arr) {\r\n        return arr.map((entry) => entry.trim());\r\n    }\r\n    /**\r\n     * Removes empty strings from array\r\n     * @param arr\r\n     */\r\n    static removeEmptyStringsFromArray(arr) {\r\n        return arr.filter((entry) => {\r\n            return !!entry;\r\n        });\r\n    }\r\n    /**\r\n     * Attempts to parse a string into JSON\r\n     * @param str\r\n     */\r\n    static jsonParseHelper(str) {\r\n        try {\r\n            return JSON.parse(str);\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Tests if a given string matches a given pattern, with support for wildcards and queries.\r\n     * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries\r\n     * @param input String to match against\r\n     */\r\n    static matchPattern(pattern, input) {\r\n        /**\r\n         * Wildcard support: https://stackoverflow.com/a/3117248/4888559\r\n         * Queries: replaces "?" in string with escaped "\\?" for regex test\r\n         */\r\n        // eslint-disable-next-line security/detect-non-literal-regexp\r\n        const regex = new RegExp(pattern\r\n            .replace(/\\\\/g, "\\\\\\\\")\r\n            .replace(/\\*/g, "[^ ]*")\r\n            .replace(/\\?/g, "\\\\?"));\r\n        return regex.test(input);\r\n    }\r\n}\n\n\n//# sourceMappingURL=StringUtils.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/ClientAuthErrorCodes.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst clientInfoDecodingError = "client_info_decoding_error";\r\nconst clientInfoEmptyError = "client_info_empty_error";\r\nconst tokenParsingError = "token_parsing_error";\r\nconst nullOrEmptyToken = "null_or_empty_token";\r\nconst endpointResolutionError = "endpoints_resolution_error";\r\nconst networkError = "network_error";\r\nconst openIdConfigError = "openid_config_error";\r\nconst hashNotDeserialized = "hash_not_deserialized";\r\nconst ClientAuthErrorCodes_invalidState = "invalid_state";\r\nconst ClientAuthErrorCodes_stateMismatch = "state_mismatch";\r\nconst ClientAuthErrorCodes_stateNotFound = "state_not_found";\r\nconst nonceMismatch = "nonce_mismatch";\r\nconst authTimeNotFound = "auth_time_not_found";\r\nconst maxAgeTranspired = "max_age_transpired";\r\nconst multipleMatchingTokens = "multiple_matching_tokens";\r\nconst multipleMatchingAccounts = "multiple_matching_accounts";\r\nconst multipleMatchingAppMetadata = "multiple_matching_appMetadata";\r\nconst requestCannotBeMade = "request_cannot_be_made";\r\nconst cannotRemoveEmptyScope = "cannot_remove_empty_scope";\r\nconst cannotAppendScopeSet = "cannot_append_scopeset";\r\nconst emptyInputScopeSet = "empty_input_scopeset";\r\nconst deviceCodePollingCancelled = "device_code_polling_cancelled";\r\nconst deviceCodeExpired = "device_code_expired";\r\nconst deviceCodeUnknownError = "device_code_unknown_error";\r\nconst noAccountInSilentRequest = "no_account_in_silent_request";\r\nconst invalidCacheRecord = "invalid_cache_record";\r\nconst invalidCacheEnvironment = "invalid_cache_environment";\r\nconst noAccountFound = "no_account_found";\r\nconst noCryptoObject = "no_crypto_object";\r\nconst unexpectedCredentialType = "unexpected_credential_type";\r\nconst invalidAssertion = "invalid_assertion";\r\nconst invalidClientCredential = "invalid_client_credential";\r\nconst tokenRefreshRequired = "token_refresh_required";\r\nconst userTimeoutReached = "user_timeout_reached";\r\nconst tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";\r\nconst ClientAuthErrorCodes_authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";\r\nconst bindingKeyNotRemoved = "binding_key_not_removed";\r\nconst endSessionEndpointNotSupported = "end_session_endpoint_not_supported";\r\nconst keyIdMissing = "key_id_missing";\r\nconst noNetworkConnectivity = "no_network_connectivity";\r\nconst userCanceled = "user_canceled";\r\nconst missingTenantIdError = "missing_tenant_id_error";\r\nconst methodNotImplemented = "method_not_implemented";\r\nconst nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";\n\n\n//# sourceMappingURL=ClientAuthErrorCodes.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/ClientAuthError.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * ClientAuthErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nconst ClientAuthErrorMessages = {\r\n    [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",\r\n    [clientInfoEmptyError]: "The client info was empty",\r\n    [tokenParsingError]: "Token cannot be parsed",\r\n    [nullOrEmptyToken]: "The token is null or empty",\r\n    [endpointResolutionError]: "Endpoints cannot be resolved",\r\n    [networkError]: "Network request failed",\r\n    [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",\r\n    [hashNotDeserialized]: "The hash parameters could not be deserialized",\r\n    [ClientAuthErrorCodes_invalidState]: "State was not the expected format",\r\n    [ClientAuthErrorCodes_stateMismatch]: "State mismatch error",\r\n    [ClientAuthErrorCodes_stateNotFound]: "State not found",\r\n    [nonceMismatch]: "Nonce mismatch error",\r\n    [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable." +\r\n        " auth_time is an optional claim and is not enabled by default - it must be enabled." +\r\n        " See https://aka.ms/msaljs/optional-claims for more information.",\r\n    [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",\r\n    [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. " +\r\n        "Call AcquireToken again providing more requirements such as authority or account.",\r\n    [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",\r\n    [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",\r\n    [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",\r\n    [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",\r\n    [cannotAppendScopeSet]: "Cannot append ScopeSet",\r\n    [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",\r\n    [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",\r\n    [deviceCodeExpired]: "Device code is expired.",\r\n    [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",\r\n    [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",\r\n    [invalidCacheRecord]: "Cache record object was null or undefined.",\r\n    [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",\r\n    [noAccountFound]: "No account found in cache for given key.",\r\n    [noCryptoObject]: "No crypto object detected.",\r\n    [unexpectedCredentialType]: "Unexpected credential type.",\r\n    [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",\r\n    [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",\r\n    [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",\r\n    [userTimeoutReached]: "User defined timeout for device code polling reached",\r\n    [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",\r\n    [ClientAuthErrorCodes_authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",\r\n    [bindingKeyNotRemoved]: "Could not remove the credential\'s binding key from storage.",\r\n    [endSessionEndpointNotSupported]: "The provided authority does not support logout",\r\n    [keyIdMissing]: "A keyId value is missing from the requested bound token\'s cache record and is required to match the token to it\'s stored binding key.",\r\n    [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",\r\n    [userCanceled]: "User cancelled the flow.",\r\n    [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",\r\n    [methodNotImplemented]: "This method has not been implemented",\r\n    [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled",\r\n};\r\n/**\r\n * String constants used by error codes and messages.\r\n * @deprecated Use ClientAuthErrorCodes instead\r\n */\r\nconst ClientAuthErrorMessage = {\r\n    clientInfoDecodingError: {\r\n        code: clientInfoDecodingError,\r\n        desc: ClientAuthErrorMessages[clientInfoDecodingError],\r\n    },\r\n    clientInfoEmptyError: {\r\n        code: clientInfoEmptyError,\r\n        desc: ClientAuthErrorMessages[clientInfoEmptyError],\r\n    },\r\n    tokenParsingError: {\r\n        code: tokenParsingError,\r\n        desc: ClientAuthErrorMessages[tokenParsingError],\r\n    },\r\n    nullOrEmptyToken: {\r\n        code: nullOrEmptyToken,\r\n        desc: ClientAuthErrorMessages[nullOrEmptyToken],\r\n    },\r\n    endpointResolutionError: {\r\n        code: endpointResolutionError,\r\n        desc: ClientAuthErrorMessages[endpointResolutionError],\r\n    },\r\n    networkError: {\r\n        code: networkError,\r\n        desc: ClientAuthErrorMessages[networkError],\r\n    },\r\n    unableToGetOpenidConfigError: {\r\n        code: openIdConfigError,\r\n        desc: ClientAuthErrorMessages[openIdConfigError],\r\n    },\r\n    hashNotDeserialized: {\r\n        code: hashNotDeserialized,\r\n        desc: ClientAuthErrorMessages[hashNotDeserialized],\r\n    },\r\n    invalidStateError: {\r\n        code: ClientAuthErrorCodes_invalidState,\r\n        desc: ClientAuthErrorMessages[ClientAuthErrorCodes_invalidState],\r\n    },\r\n    stateMismatchError: {\r\n        code: ClientAuthErrorCodes_stateMismatch,\r\n        desc: ClientAuthErrorMessages[ClientAuthErrorCodes_stateMismatch],\r\n    },\r\n    stateNotFoundError: {\r\n        code: ClientAuthErrorCodes_stateNotFound,\r\n        desc: ClientAuthErrorMessages[ClientAuthErrorCodes_stateNotFound],\r\n    },\r\n    nonceMismatchError: {\r\n        code: nonceMismatch,\r\n        desc: ClientAuthErrorMessages[nonceMismatch],\r\n    },\r\n    authTimeNotFoundError: {\r\n        code: authTimeNotFound,\r\n        desc: ClientAuthErrorMessages[authTimeNotFound],\r\n    },\r\n    maxAgeTranspired: {\r\n        code: maxAgeTranspired,\r\n        desc: ClientAuthErrorMessages[maxAgeTranspired],\r\n    },\r\n    multipleMatchingTokens: {\r\n        code: multipleMatchingTokens,\r\n        desc: ClientAuthErrorMessages[multipleMatchingTokens],\r\n    },\r\n    multipleMatchingAccounts: {\r\n        code: multipleMatchingAccounts,\r\n        desc: ClientAuthErrorMessages[multipleMatchingAccounts],\r\n    },\r\n    multipleMatchingAppMetadata: {\r\n        code: multipleMatchingAppMetadata,\r\n        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata],\r\n    },\r\n    tokenRequestCannotBeMade: {\r\n        code: requestCannotBeMade,\r\n        desc: ClientAuthErrorMessages[requestCannotBeMade],\r\n    },\r\n    removeEmptyScopeError: {\r\n        code: cannotRemoveEmptyScope,\r\n        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope],\r\n    },\r\n    appendScopeSetError: {\r\n        code: cannotAppendScopeSet,\r\n        desc: ClientAuthErrorMessages[cannotAppendScopeSet],\r\n    },\r\n    emptyInputScopeSetError: {\r\n        code: emptyInputScopeSet,\r\n        desc: ClientAuthErrorMessages[emptyInputScopeSet],\r\n    },\r\n    DeviceCodePollingCancelled: {\r\n        code: deviceCodePollingCancelled,\r\n        desc: ClientAuthErrorMessages[deviceCodePollingCancelled],\r\n    },\r\n    DeviceCodeExpired: {\r\n        code: deviceCodeExpired,\r\n        desc: ClientAuthErrorMessages[deviceCodeExpired],\r\n    },\r\n    DeviceCodeUnknownError: {\r\n        code: deviceCodeUnknownError,\r\n        desc: ClientAuthErrorMessages[deviceCodeUnknownError],\r\n    },\r\n    NoAccountInSilentRequest: {\r\n        code: noAccountInSilentRequest,\r\n        desc: ClientAuthErrorMessages[noAccountInSilentRequest],\r\n    },\r\n    invalidCacheRecord: {\r\n        code: invalidCacheRecord,\r\n        desc: ClientAuthErrorMessages[invalidCacheRecord],\r\n    },\r\n    invalidCacheEnvironment: {\r\n        code: invalidCacheEnvironment,\r\n        desc: ClientAuthErrorMessages[invalidCacheEnvironment],\r\n    },\r\n    noAccountFound: {\r\n        code: noAccountFound,\r\n        desc: ClientAuthErrorMessages[noAccountFound],\r\n    },\r\n    noCryptoObj: {\r\n        code: noCryptoObject,\r\n        desc: ClientAuthErrorMessages[noCryptoObject],\r\n    },\r\n    unexpectedCredentialType: {\r\n        code: unexpectedCredentialType,\r\n        desc: ClientAuthErrorMessages[unexpectedCredentialType],\r\n    },\r\n    invalidAssertion: {\r\n        code: invalidAssertion,\r\n        desc: ClientAuthErrorMessages[invalidAssertion],\r\n    },\r\n    invalidClientCredential: {\r\n        code: invalidClientCredential,\r\n        desc: ClientAuthErrorMessages[invalidClientCredential],\r\n    },\r\n    tokenRefreshRequired: {\r\n        code: tokenRefreshRequired,\r\n        desc: ClientAuthErrorMessages[tokenRefreshRequired],\r\n    },\r\n    userTimeoutReached: {\r\n        code: userTimeoutReached,\r\n        desc: ClientAuthErrorMessages[userTimeoutReached],\r\n    },\r\n    tokenClaimsRequired: {\r\n        code: tokenClaimsCnfRequiredForSignedJwt,\r\n        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt],\r\n    },\r\n    noAuthorizationCodeFromServer: {\r\n        code: ClientAuthErrorCodes_authorizationCodeMissingFromServerResponse,\r\n        desc: ClientAuthErrorMessages[ClientAuthErrorCodes_authorizationCodeMissingFromServerResponse],\r\n    },\r\n    bindingKeyNotRemovedError: {\r\n        code: bindingKeyNotRemoved,\r\n        desc: ClientAuthErrorMessages[bindingKeyNotRemoved],\r\n    },\r\n    logoutNotSupported: {\r\n        code: endSessionEndpointNotSupported,\r\n        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported],\r\n    },\r\n    keyIdMissing: {\r\n        code: keyIdMissing,\r\n        desc: ClientAuthErrorMessages[keyIdMissing],\r\n    },\r\n    noNetworkConnectivity: {\r\n        code: noNetworkConnectivity,\r\n        desc: ClientAuthErrorMessages[noNetworkConnectivity],\r\n    },\r\n    userCanceledError: {\r\n        code: userCanceled,\r\n        desc: ClientAuthErrorMessages[userCanceled],\r\n    },\r\n    missingTenantIdError: {\r\n        code: missingTenantIdError,\r\n        desc: ClientAuthErrorMessages[missingTenantIdError],\r\n    },\r\n    nestedAppAuthBridgeDisabled: {\r\n        code: nestedAppAuthBridgeDisabled,\r\n        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled],\r\n    },\r\n};\r\n/**\r\n * Error thrown when there is an error in the client code running on the browser.\r\n */\r\nclass ClientAuthError extends AuthError {\r\n    constructor(errorCode, additionalMessage) {\r\n        super(errorCode, additionalMessage\r\n            ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}`\r\n            : ClientAuthErrorMessages[errorCode]);\r\n        this.name = "ClientAuthError";\r\n        Object.setPrototypeOf(this, ClientAuthError.prototype);\r\n    }\r\n}\r\nfunction ClientAuthError_createClientAuthError(errorCode, additionalMessage) {\r\n    return new ClientAuthError(errorCode, additionalMessage);\r\n}\n\n\n//# sourceMappingURL=ClientAuthError.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/utils/UrlUtils.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Parses hash string from given string. Returns empty string if no hash symbol is found.\r\n * @param hashString\r\n */\r\nfunction stripLeadingHashOrQuery(responseString) {\r\n    if (responseString.startsWith("#/")) {\r\n        return responseString.substring(2);\r\n    }\r\n    else if (responseString.startsWith("#") ||\r\n        responseString.startsWith("?")) {\r\n        return responseString.substring(1);\r\n    }\r\n    return responseString;\r\n}\r\n/**\r\n * Returns URL hash as server auth code response object.\r\n */\r\nfunction getDeserializedResponse(responseString) {\r\n    // Check if given hash is empty\r\n    if (!responseString || responseString.indexOf("=") < 0) {\r\n        return null;\r\n    }\r\n    try {\r\n        // Strip the # or ? symbol if present\r\n        const normalizedResponse = stripLeadingHashOrQuery(responseString);\r\n        // If # symbol was not present, above will return empty string, so give original hash value\r\n        const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));\r\n        // Check for known response properties\r\n        if (deserializedHash.code ||\r\n            deserializedHash.ear_jwe ||\r\n            deserializedHash.error ||\r\n            deserializedHash.error_description ||\r\n            deserializedHash.state) {\r\n            return deserializedHash;\r\n        }\r\n    }\r\n    catch (e) {\r\n        throw ClientAuthError_createClientAuthError(hashNotDeserialized);\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Utility to create a URL from the params map\r\n */\r\nfunction mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {\r\n    const queryParameterArray = new Array();\r\n    parameters.forEach((value, key) => {\r\n        if (!encodeExtraParams &&\r\n            extraQueryParameters &&\r\n            key in extraQueryParameters) {\r\n            queryParameterArray.push(`${key}=${value}`);\r\n        }\r\n        else {\r\n            queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);\r\n        }\r\n    });\r\n    return queryParameterArray.join("&");\r\n}\n\n\n//# sourceMappingURL=UrlUtils.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/url/UrlString.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Url object class which can perform various transformations on url strings.\r\n */\r\nclass UrlString {\r\n    get urlString() {\r\n        return this._urlString;\r\n    }\r\n    constructor(url) {\r\n        this._urlString = url;\r\n        if (!this._urlString) {\r\n            // Throws error if url is empty\r\n            throw ClientConfigurationError_createClientConfigurationError(urlEmptyError);\r\n        }\r\n        if (!url.includes("#")) {\r\n            this._urlString = UrlString.canonicalizeUri(url);\r\n        }\r\n    }\r\n    /**\r\n     * Ensure urls are lower case and end with a / character.\r\n     * @param url\r\n     */\r\n    static canonicalizeUri(url) {\r\n        if (url) {\r\n            let lowerCaseUrl = url.toLowerCase();\r\n            if (StringUtils.endsWith(lowerCaseUrl, "?")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -1);\r\n            }\r\n            else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {\r\n                lowerCaseUrl = lowerCaseUrl.slice(0, -2);\r\n            }\r\n            if (!StringUtils.endsWith(lowerCaseUrl, "/")) {\r\n                lowerCaseUrl += "/";\r\n            }\r\n            return lowerCaseUrl;\r\n        }\r\n        return url;\r\n    }\r\n    /**\r\n     * Throws if urlString passed is not a valid authority URI string.\r\n     */\r\n    validateAsUri() {\r\n        // Attempts to parse url for uri components\r\n        let components;\r\n        try {\r\n            components = this.getUrlComponents();\r\n        }\r\n        catch (e) {\r\n            throw ClientConfigurationError_createClientConfigurationError(urlParseError);\r\n        }\r\n        // Throw error if URI or path segments are not parseable.\r\n        if (!components.HostNameAndPort || !components.PathSegments) {\r\n            throw ClientConfigurationError_createClientConfigurationError(urlParseError);\r\n        }\r\n        // Throw error if uri is insecure.\r\n        if (!components.Protocol ||\r\n            components.Protocol.toLowerCase() !== "https:") {\r\n            throw ClientConfigurationError_createClientConfigurationError(authorityUriInsecure);\r\n        }\r\n    }\r\n    /**\r\n     * Given a url and a query string return the url with provided query string appended\r\n     * @param url\r\n     * @param queryString\r\n     */\r\n    static appendQueryString(url, queryString) {\r\n        if (!queryString) {\r\n            return url;\r\n        }\r\n        return url.indexOf("?") < 0\r\n            ? `${url}?${queryString}`\r\n            : `${url}&${queryString}`;\r\n    }\r\n    /**\r\n     * Returns a url with the hash removed\r\n     * @param url\r\n     */\r\n    static removeHashFromUrl(url) {\r\n        return UrlString.canonicalizeUri(url.split("#")[0]);\r\n    }\r\n    /**\r\n     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\r\n     * @param href The url\r\n     * @param tenantId The tenant id to replace\r\n     */\r\n    replaceTenantPath(tenantId) {\r\n        const urlObject = this.getUrlComponents();\r\n        const pathArray = urlObject.PathSegments;\r\n        if (tenantId &&\r\n            pathArray.length !== 0 &&\r\n            (pathArray[0] === AADAuthorityConstants.COMMON ||\r\n                pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\r\n            pathArray[0] = tenantId;\r\n        }\r\n        return UrlString.constructAuthorityUriFromObject(urlObject);\r\n    }\r\n    /**\r\n     * Parses out the components from a url string.\r\n     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\r\n     */\r\n    getUrlComponents() {\r\n        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\r\n        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?");\r\n        // If url string does not match regEx, we throw an error\r\n        const match = this.urlString.match(regEx);\r\n        if (!match) {\r\n            throw ClientConfigurationError_createClientConfigurationError(urlParseError);\r\n        }\r\n        // Url component object\r\n        const urlComponents = {\r\n            Protocol: match[1],\r\n            HostNameAndPort: match[4],\r\n            AbsolutePath: match[5],\r\n            QueryString: match[7],\r\n        };\r\n        let pathSegments = urlComponents.AbsolutePath.split("/");\r\n        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\r\n        urlComponents.PathSegments = pathSegments;\r\n        if (urlComponents.QueryString &&\r\n            urlComponents.QueryString.endsWith("/")) {\r\n            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\r\n        }\r\n        return urlComponents;\r\n    }\r\n    static getDomainFromUrl(url) {\r\n        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");\r\n        const match = url.match(regEx);\r\n        if (!match) {\r\n            throw ClientConfigurationError_createClientConfigurationError(urlParseError);\r\n        }\r\n        return match[2];\r\n    }\r\n    static getAbsoluteUrl(relativeUrl, baseUrl) {\r\n        if (relativeUrl[0] === Constants_Constants.FORWARD_SLASH) {\r\n            const url = new UrlString(baseUrl);\r\n            const baseComponents = url.getUrlComponents();\r\n            return (baseComponents.Protocol +\r\n                "//" +\r\n                baseComponents.HostNameAndPort +\r\n                relativeUrl);\r\n        }\r\n        return relativeUrl;\r\n    }\r\n    static constructAuthorityUriFromObject(urlObject) {\r\n        return new UrlString(urlObject.Protocol +\r\n            "//" +\r\n            urlObject.HostNameAndPort +\r\n            "/" +\r\n            urlObject.PathSegments.join("/"));\r\n    }\r\n    /**\r\n     * Check if the hash of the URL string contains known properties\r\n     * @deprecated This API will be removed in a future version\r\n     */\r\n    static hashContainsKnownProperties(response) {\r\n        return !!getDeserializedResponse(response);\r\n    }\r\n}\n\n\n//# sourceMappingURL=UrlString.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/AuthorityMetadata.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst rawMetdataJSON = {\r\n    endpointMetadata: {\r\n        "login.microsoftonline.com": {\r\n            token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",\r\n            jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",\r\n            issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",\r\n            authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",\r\n            end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout",\r\n        },\r\n        "login.chinacloudapi.cn": {\r\n            token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",\r\n            jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",\r\n            issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",\r\n            authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",\r\n            end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout",\r\n        },\r\n        "login.microsoftonline.us": {\r\n            token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",\r\n            jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",\r\n            issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",\r\n            authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",\r\n            end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout",\r\n        },\r\n    },\r\n    instanceDiscoveryMetadata: {\r\n        tenant_discovery_endpoint: "https://{canonicalAuthority}/v2.0/.well-known/openid-configuration",\r\n        metadata: [\r\n            {\r\n                preferred_network: "login.microsoftonline.com",\r\n                preferred_cache: "login.windows.net",\r\n                aliases: [\r\n                    "login.microsoftonline.com",\r\n                    "login.windows.net",\r\n                    "login.microsoft.com",\r\n                    "sts.windows.net",\r\n                ],\r\n            },\r\n            {\r\n                preferred_network: "login.partner.microsoftonline.cn",\r\n                preferred_cache: "login.partner.microsoftonline.cn",\r\n                aliases: [\r\n                    "login.partner.microsoftonline.cn",\r\n                    "login.chinacloudapi.cn",\r\n                ],\r\n            },\r\n            {\r\n                preferred_network: "login.microsoftonline.de",\r\n                preferred_cache: "login.microsoftonline.de",\r\n                aliases: ["login.microsoftonline.de"],\r\n            },\r\n            {\r\n                preferred_network: "login.microsoftonline.us",\r\n                preferred_cache: "login.microsoftonline.us",\r\n                aliases: [\r\n                    "login.microsoftonline.us",\r\n                    "login.usgovcloudapi.net",\r\n                ],\r\n            },\r\n            {\r\n                preferred_network: "login-us.microsoftonline.com",\r\n                preferred_cache: "login-us.microsoftonline.com",\r\n                aliases: ["login-us.microsoftonline.com"],\r\n            },\r\n        ],\r\n    },\r\n};\r\nconst EndpointMetadata = rawMetdataJSON.endpointMetadata;\r\nconst InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;\r\nconst InstanceDiscoveryMetadataAliases = new Set();\r\nInstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {\r\n    metadataEntry.aliases.forEach((alias) => {\r\n        InstanceDiscoveryMetadataAliases.add(alias);\r\n    });\r\n});\r\n/**\r\n * Attempts to get an aliases array from the static authority metadata sources based on the canonical authority host\r\n * @param staticAuthorityOptions\r\n * @param logger\r\n * @returns\r\n */\r\nfunction getAliasesFromStaticSources(staticAuthorityOptions, logger) {\r\n    let staticAliases;\r\n    const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;\r\n    if (canonicalAuthority) {\r\n        const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;\r\n        staticAliases =\r\n            getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger) ||\r\n                getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger) ||\r\n                staticAuthorityOptions.knownAuthorities;\r\n    }\r\n    return staticAliases || [];\r\n}\r\n/**\r\n * Returns aliases for from the raw cloud discovery metadata passed in\r\n * @param authorityHost\r\n * @param rawCloudDiscoveryMetadata\r\n * @returns\r\n */\r\nfunction getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger) {\r\n    logger?.trace(`getAliasesFromMetadata called with source: ${source}`);\r\n    if (authorityHost && cloudDiscoveryMetadata) {\r\n        const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);\r\n        if (metadata) {\r\n            logger?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);\r\n            return metadata.aliases;\r\n        }\r\n        else {\r\n            logger?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Get cloud discovery metadata for common authorities\r\n */\r\nfunction getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {\r\n    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);\r\n    return metadata;\r\n}\r\n/**\r\n * Searches instance discovery network response for the entry that contains the host in the aliases list\r\n * @param response\r\n * @param authority\r\n */\r\nfunction getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {\r\n    for (let i = 0; i < response.length; i++) {\r\n        const metadata = response[i];\r\n        if (metadata.aliases.includes(authorityHost)) {\r\n            return metadata;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n\n//# sourceMappingURL=AuthorityMetadata.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/ProtocolMode.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Protocol modes supported by MSAL.\r\n */\r\nconst ProtocolMode_ProtocolMode = {\r\n    /**\r\n     * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features\r\n     */\r\n    AAD: "AAD",\r\n    /**\r\n     * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.\r\n     * Support is limited for this mode.\r\n     */\r\n    OIDC: "OIDC",\r\n    /**\r\n     * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features\r\n     */\r\n    EAR: "EAR",\r\n};\n\n\n//# sourceMappingURL=ProtocolMode.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/AuthorityOptions.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst AzureCloudInstance = {\r\n    // AzureCloudInstance is not specified.\r\n    None: "none",\r\n    // Microsoft Azure public cloud\r\n    AzurePublic: "https://login.microsoftonline.com",\r\n    // Microsoft PPE\r\n    AzurePpe: "https://login.windows-ppe.net",\r\n    // Microsoft Chinese national/regional cloud\r\n    AzureChina: "https://login.chinacloudapi.cn",\r\n    // Microsoft German national/regional cloud ("Black Forest")\r\n    AzureGermany: "https://login.microsoftonline.de",\r\n    // US Government cloud\r\n    AzureUsGovernment: "https://login.microsoftonline.us",\r\n};\n\n\n//# sourceMappingURL=AuthorityOptions.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryResponse.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nfunction isCloudInstanceDiscoveryResponse(response) {\r\n    return (response.hasOwnProperty("tenant_discovery_endpoint") &&\r\n        response.hasOwnProperty("metadata"));\r\n}\n\n\n//# sourceMappingURL=CloudInstanceDiscoveryResponse.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/CloudInstanceDiscoveryErrorResponse.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nfunction isCloudInstanceDiscoveryErrorResponse(response) {\r\n    return (response.hasOwnProperty("error") &&\r\n        response.hasOwnProperty("error_description"));\r\n}\n\n\n//# sourceMappingURL=CloudInstanceDiscoveryErrorResponse.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceEvent.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Enumeration of operations that are instrumented by have their performance measured by the PerformanceClient.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nconst PerformanceEvents = {\r\n    /**\r\n     * acquireTokenByCode API (msal-browser and msal-node).\r\n     * Used to acquire tokens by trading an authorization code against the token endpoint.\r\n     */\r\n    AcquireTokenByCode: "acquireTokenByCode",\r\n    /**\r\n     * acquireTokenByRefreshToken API (msal-browser and msal-node).\r\n     * Used to renew an access token using a refresh token against the token endpoint.\r\n     */\r\n    AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",\r\n    /**\r\n     * acquireTokenSilent API (msal-browser and msal-node).\r\n     * Used to silently acquire a new access token (from the cache or the network).\r\n     */\r\n    AcquireTokenSilent: "acquireTokenSilent",\r\n    /**\r\n     * acquireTokenSilentAsync (msal-browser).\r\n     * Internal API for acquireTokenSilent.\r\n     */\r\n    AcquireTokenSilentAsync: "acquireTokenSilentAsync",\r\n    /**\r\n     * acquireTokenPopup (msal-browser).\r\n     * Used to acquire a new access token interactively through pop ups\r\n     */\r\n    AcquireTokenPopup: "acquireTokenPopup",\r\n    /**\r\n     * acquireTokenPreRedirect (msal-browser).\r\n     * First part of the redirect flow.\r\n     * Used to acquire a new access token interactively through redirects.\r\n     */\r\n    AcquireTokenPreRedirect: "acquireTokenPreRedirect",\r\n    /**\r\n     * acquireTokenRedirect (msal-browser).\r\n     * Second part of the redirect flow.\r\n     * Used to acquire a new access token interactively through redirects.\r\n     */\r\n    AcquireTokenRedirect: "acquireTokenRedirect",\r\n    /**\r\n     * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).\r\n     * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.\r\n     */\r\n    CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",\r\n    /**\r\n     * signJwt API in CryptoOpts class (msal-browser).\r\n     * Used to signed a pop token.\r\n     */\r\n    CryptoOptsSignJwt: "cryptoOptsSignJwt",\r\n    /**\r\n     * acquireToken API in the SilentCacheClient class (msal-browser).\r\n     * Used to read access tokens from the cache.\r\n     */\r\n    SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",\r\n    /**\r\n     * acquireToken API in the SilentIframeClient class (msal-browser).\r\n     * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.\r\n     */\r\n    SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",\r\n    AwaitConcurrentIframe: "awaitConcurrentIframe",\r\n    /**\r\n     * acquireToken API in SilentRereshClient (msal-browser).\r\n     * Used to acquire a new set of tokens from the token endpoint using a refresh token.\r\n     */\r\n    SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",\r\n    /**\r\n     * ssoSilent API (msal-browser).\r\n     * Used to silently acquire an authorization code and set of tokens using a hidden iframe.\r\n     */\r\n    SsoSilent: "ssoSilent",\r\n    /**\r\n     * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).\r\n     * Used to load authority metadata for a request.\r\n     */\r\n    StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",\r\n    /**\r\n     * acquireToken APIs in msal-browser.\r\n     * Used to make an /authorize endpoint call with native brokering enabled.\r\n     */\r\n    FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",\r\n    /**\r\n     * acquireToken API in NativeInteractionClient class (msal-browser).\r\n     * Used to acquire a token from Native component when native brokering is enabled.\r\n     */\r\n    NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",\r\n    /**\r\n     * Time spent creating default headers for requests to token endpoint\r\n     */\r\n    BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",\r\n    /**\r\n     * Time spent sending/waiting for the response of a request to the token endpoint\r\n     */\r\n    NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",\r\n    RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",\r\n    AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",\r\n    /**\r\n     * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).\r\n     */\r\n    BrokerHandhshake: "brokerHandshake",\r\n    /**\r\n     * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .\r\n     */\r\n    AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",\r\n    /**\r\n     * Time taken for token acquisition by broker\r\n     */\r\n    AcquireTokenByBroker: "acquireTokenByBroker",\r\n    /**\r\n     * Time spent on the network for refresh token acquisition\r\n     */\r\n    RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",\r\n    /**\r\n     * Time taken for acquiring refresh token , records RT size\r\n     */\r\n    RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",\r\n    /**\r\n     * Time taken for acquiring cached refresh token\r\n     */\r\n    RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",\r\n    /**\r\n     * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).\r\n     */\r\n    RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",\r\n    /**\r\n     * Helper function to create token request body in RefreshTokenClient (msal-common).\r\n     */\r\n    RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",\r\n    /**\r\n     * acquireTokenFromCache (msal-browser).\r\n     * Internal API for acquiring token from cache\r\n     */\r\n    AcquireTokenFromCache: "acquireTokenFromCache",\r\n    SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",\r\n    SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",\r\n    /**\r\n     * acquireTokenBySilentIframe (msal-browser).\r\n     * Internal API for acquiring token by silent Iframe\r\n     */\r\n    AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",\r\n    /**\r\n     * Internal API for initializing base request in BaseInteractionClient (msal-browser)\r\n     */\r\n    InitializeBaseRequest: "initializeBaseRequest",\r\n    /**\r\n     * Internal API for initializing silent request in SilentCacheClient (msal-browser)\r\n     */\r\n    InitializeSilentRequest: "initializeSilentRequest",\r\n    InitializeClientApplication: "initializeClientApplication",\r\n    InitializeCache: "initializeCache",\r\n    /**\r\n     * Helper function in SilentIframeClient class (msal-browser).\r\n     */\r\n    SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",\r\n    /**\r\n     * SilentHandler\r\n     */\r\n    SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",\r\n    SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",\r\n    SilentHandlerLoadFrame: "silentHandlerLoadFrame",\r\n    SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",\r\n    /**\r\n     * Helper functions in StandardInteractionClient class (msal-browser)\r\n     */\r\n    StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",\r\n    StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",\r\n    StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",\r\n    /**\r\n     * getAuthCodeUrl API (msal-browser and msal-node).\r\n     */\r\n    GetAuthCodeUrl: "getAuthCodeUrl",\r\n    GetStandardParams: "getStandardParams",\r\n    /**\r\n     * Functions from InteractionHandler (msal-browser)\r\n     */\r\n    HandleCodeResponseFromServer: "handleCodeResponseFromServer",\r\n    HandleCodeResponse: "handleCodeResponse",\r\n    HandleResponseEar: "handleResponseEar",\r\n    HandleResponsePlatformBroker: "handleResponsePlatformBroker",\r\n    HandleResponseCode: "handleResponseCode",\r\n    UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",\r\n    /**\r\n     * APIs in Authorization Code Client (msal-common)\r\n     */\r\n    AuthClientAcquireToken: "authClientAcquireToken",\r\n    AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",\r\n    AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",\r\n    /**\r\n     * Generate functions in PopTokenGenerator (msal-common)\r\n     */\r\n    PopTokenGenerateCnf: "popTokenGenerateCnf",\r\n    PopTokenGenerateKid: "popTokenGenerateKid",\r\n    /**\r\n     * handleServerTokenResponse API in ResponseHandler (msal-common)\r\n     */\r\n    HandleServerTokenResponse: "handleServerTokenResponse",\r\n    DeserializeResponse: "deserializeResponse",\r\n    /**\r\n     * Authority functions\r\n     */\r\n    AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",\r\n    AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",\r\n    AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",\r\n    AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",\r\n    AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",\r\n    AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",\r\n    AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",\r\n    AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",\r\n    /**\r\n     * Region Discovery functions\r\n     */\r\n    RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",\r\n    RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",\r\n    RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",\r\n    AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",\r\n    GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",\r\n    GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",\r\n    HandleRedirectPromiseMeasurement: "handleRedirectPromise",\r\n    HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",\r\n    UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",\r\n    UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",\r\n    NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",\r\n    NativeGenerateAuthResult: "nativeGenerateAuthResult",\r\n    RemoveHiddenIframe: "removeHiddenIframe",\r\n    /**\r\n     * Cache operations\r\n     */\r\n    ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",\r\n    CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",\r\n    ImportExistingCache: "importExistingCache",\r\n    SetUserData: "setUserData",\r\n    LocalStorageUpdated: "localStorageUpdated",\r\n    /**\r\n     * Crypto Operations\r\n     */\r\n    GeneratePkceCodes: "generatePkceCodes",\r\n    GenerateCodeVerifier: "generateCodeVerifier",\r\n    GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",\r\n    Sha256Digest: "sha256Digest",\r\n    GetRandomValues: "getRandomValues",\r\n    GenerateHKDF: "generateHKDF",\r\n    GenerateBaseKey: "generateBaseKey",\r\n    Base64Decode: "base64Decode",\r\n    UrlEncodeArr: "urlEncodeArr",\r\n    Encrypt: "encrypt",\r\n    Decrypt: "decrypt",\r\n    GenerateEarKey: "generateEarKey",\r\n    DecryptEarResponse: "decryptEarResponse",\r\n};\r\nconst PerformanceEventAbbreviations = new Map([\r\n    [PerformanceEvents.AcquireTokenByCode, "ATByCode"],\r\n    [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],\r\n    [PerformanceEvents.AcquireTokenSilent, "ATS"],\r\n    [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],\r\n    [PerformanceEvents.AcquireTokenPopup, "ATPopup"],\r\n    [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],\r\n    [\r\n        PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,\r\n        "CryptoGetPKThumb",\r\n    ],\r\n    [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],\r\n    [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],\r\n    [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],\r\n    [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],\r\n    [PerformanceEvents.SsoSilent, "SsoSlt"],\r\n    [\r\n        PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,\r\n        "StdIntClientGetDiscAuth",\r\n    ],\r\n    [\r\n        PerformanceEvents.FetchAccountIdWithNativeBroker,\r\n        "FetchAccIdWithNtvBroker",\r\n    ],\r\n    [\r\n        PerformanceEvents.NativeInteractionClientAcquireToken,\r\n        "NtvIntClientAT",\r\n    ],\r\n    [\r\n        PerformanceEvents.BaseClientCreateTokenRequestHeaders,\r\n        "BaseClientCreateTReqHead",\r\n    ],\r\n    [\r\n        PerformanceEvents.NetworkClientSendPostRequestAsync,\r\n        "NetClientSendPost",\r\n    ],\r\n    [\r\n        PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,\r\n        "RTClientExecPost",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,\r\n        "AuthCodeClientExecPost",\r\n    ],\r\n    [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],\r\n    [\r\n        PerformanceEvents.AcquireTokenByRefreshTokenInBroker,\r\n        "ATByRTInBroker",\r\n    ],\r\n    [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],\r\n    [\r\n        PerformanceEvents.RefreshTokenClientExecuteTokenRequest,\r\n        "RTClientExecTReq",\r\n    ],\r\n    [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],\r\n    [\r\n        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\r\n        "RTClientATWithCachedRT",\r\n    ],\r\n    [\r\n        PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,\r\n        "RTClientATByRT",\r\n    ],\r\n    [\r\n        PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,\r\n        "RTClientCreateTReqBody",\r\n    ],\r\n    [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],\r\n    [\r\n        PerformanceEvents.SilentFlowClientAcquireCachedToken,\r\n        "SltFlowClientATCached",\r\n    ],\r\n    [\r\n        PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,\r\n        "SltFlowClientGenResFromCache",\r\n    ],\r\n    [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],\r\n    [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],\r\n    [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],\r\n    [\r\n        PerformanceEvents.InitializeClientApplication,\r\n        "InitClientApplication",\r\n    ],\r\n    [PerformanceEvents.InitializeCache, "InitCache"],\r\n    [PerformanceEvents.ImportExistingCache, "importCache"],\r\n    [PerformanceEvents.SetUserData, "setUserData"],\r\n    [PerformanceEvents.LocalStorageUpdated, "localStorageUpdated"],\r\n    [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],\r\n    [\r\n        PerformanceEvents.SilentHandlerInitiateAuthRequest,\r\n        "SHandlerInitAuthReq",\r\n    ],\r\n    [\r\n        PerformanceEvents.SilentHandlerMonitorIframeForHash,\r\n        "SltHandlerMonitorIframeForHash",\r\n    ],\r\n    [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],\r\n    [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],\r\n    [\r\n        PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\r\n        "StdIntClientCreateAuthCodeClient",\r\n    ],\r\n    [\r\n        PerformanceEvents.StandardInteractionClientGetClientConfiguration,\r\n        "StdIntClientGetClientConf",\r\n    ],\r\n    [\r\n        PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,\r\n        "StdIntClientInitAuthReq",\r\n    ],\r\n    [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],\r\n    [\r\n        PerformanceEvents.HandleCodeResponseFromServer,\r\n        "HandleCodeResFromServer",\r\n    ],\r\n    [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],\r\n    [PerformanceEvents.HandleResponseEar, "HandleRespEar"],\r\n    [PerformanceEvents.HandleResponseCode, "HandleRespCode"],\r\n    [\r\n        PerformanceEvents.HandleResponsePlatformBroker,\r\n        "HandleRespPlatBroker",\r\n    ],\r\n    [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],\r\n    [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],\r\n    [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],\r\n    [\r\n        PerformanceEvents.AuthClientCreateTokenRequestBody,\r\n        "AuthClientCreateTReqBody",\r\n    ],\r\n    [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],\r\n    [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],\r\n    [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],\r\n    [PerformanceEvents.DeserializeResponse, "DeserializeRes"],\r\n    [\r\n        PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,\r\n        "AuthFactCreateDiscInst",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorityResolveEndpointsAsync,\r\n        "AuthResolveEndpointsAsync",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,\r\n        "AuthResolveEndpointsFromLocal",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,\r\n        "AuthGetCDMetaFromNet",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,\r\n        "AuthUpdCDMeta",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,\r\n        "AuthUpdCDMetaFromNet",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorityUpdateEndpointMetadata,\r\n        "AuthUpdEndpointMeta",\r\n    ],\r\n    [\r\n        PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,\r\n        "AuthUpdMetaWithRegInfo",\r\n    ],\r\n    [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],\r\n    [\r\n        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\r\n        "RegDiscGetRegFromIMDS",\r\n    ],\r\n    [\r\n        PerformanceEvents.RegionDiscoveryGetCurrentVersion,\r\n        "RegDiscGetCurrentVer",\r\n    ],\r\n    [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],\r\n    [\r\n        PerformanceEvents.GetEndpointMetadataFromNetwork,\r\n        "GetEndpointMetaFromNet",\r\n    ],\r\n    [\r\n        PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,\r\n        "GetCDMetaFromNet",\r\n    ],\r\n    [\r\n        PerformanceEvents.HandleRedirectPromiseMeasurement,\r\n        "HandleRedirectPromise",\r\n    ],\r\n    [\r\n        PerformanceEvents.HandleNativeRedirectPromiseMeasurement,\r\n        "HandleNtvRedirectPromise",\r\n    ],\r\n    [\r\n        PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,\r\n        "UpdateCDMeta",\r\n    ],\r\n    [\r\n        PerformanceEvents.UsernamePasswordClientAcquireToken,\r\n        "UserPassClientAT",\r\n    ],\r\n    [\r\n        PerformanceEvents.NativeMessageHandlerHandshake,\r\n        "NtvMsgHandlerHandshake",\r\n    ],\r\n    [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],\r\n    [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],\r\n    [\r\n        PerformanceEvents.ClearTokensAndKeysWithClaims,\r\n        "ClearTAndKeysWithClaims",\r\n    ],\r\n    [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],\r\n    [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],\r\n    [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],\r\n    [\r\n        PerformanceEvents.GenerateCodeChallengeFromVerifier,\r\n        "GenCodeChallengeFromVerifier",\r\n    ],\r\n    [PerformanceEvents.Sha256Digest, "Sha256Digest"],\r\n    [PerformanceEvents.GetRandomValues, "GetRandomValues"],\r\n    [PerformanceEvents.GenerateHKDF, "genHKDF"],\r\n    [PerformanceEvents.GenerateBaseKey, "genBaseKey"],\r\n    [PerformanceEvents.Base64Decode, "b64Decode"],\r\n    [PerformanceEvents.UrlEncodeArr, "urlEncArr"],\r\n    [PerformanceEvents.Encrypt, "encrypt"],\r\n    [PerformanceEvents.Decrypt, "decrypt"],\r\n    [PerformanceEvents.GenerateEarKey, "genEarKey"],\r\n    [PerformanceEvents.DecryptEarResponse, "decryptEarResp"],\r\n]);\r\n/**\r\n * State of the performance event.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nconst PerformanceEventStatus = {\r\n    NotStarted: 0,\r\n    InProgress: 1,\r\n    Completed: 2,\r\n};\r\nconst IntFields = new Set([\r\n    "accessTokenSize",\r\n    "durationMs",\r\n    "idTokenSize",\r\n    "matsSilentStatus",\r\n    "matsHttpStatus",\r\n    "refreshTokenSize",\r\n    "queuedTimeMs",\r\n    "startTimeMs",\r\n    "status",\r\n    "multiMatchedAT",\r\n    "multiMatchedID",\r\n    "multiMatchedRT",\r\n    "unencryptedCacheCount",\r\n    "encryptedCacheExpiredCount",\r\n]);\n\n\n//# sourceMappingURL=PerformanceEvent.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/utils/FunctionWrappers.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Wraps a function with a performance measurement.\r\n * Usage: invoke(functionToCall, performanceClient, "EventName", "correlationId")(...argsToPassToFunction)\r\n * @param callback\r\n * @param eventName\r\n * @param logger\r\n * @param telemetryClient\r\n * @param correlationId\r\n * @returns\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst invoke = (callback, eventName, logger, telemetryClient, correlationId) => {\r\n    return (...args) => {\r\n        logger.trace(`Executing function ${eventName}`);\r\n        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);\r\n        if (correlationId) {\r\n            // Track number of times this API is called in a single request\r\n            const eventCount = eventName + "CallCount";\r\n            telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);\r\n        }\r\n        try {\r\n            const result = callback(...args);\r\n            inProgressEvent?.end({\r\n                success: true,\r\n            });\r\n            logger.trace(`Returning result from ${eventName}`);\r\n            return result;\r\n        }\r\n        catch (e) {\r\n            logger.trace(`Error occurred in ${eventName}`);\r\n            try {\r\n                logger.trace(JSON.stringify(e));\r\n            }\r\n            catch (e) {\r\n                logger.trace("Unable to print error message.");\r\n            }\r\n            inProgressEvent?.end({\r\n                success: false,\r\n            }, e);\r\n            throw e;\r\n        }\r\n    };\r\n};\r\n/**\r\n * Wraps an async function with a performance measurement.\r\n * Usage: invokeAsync(functionToCall, performanceClient, "EventName", "correlationId")(...argsToPassToFunction)\r\n * @param callback\r\n * @param eventName\r\n * @param logger\r\n * @param telemetryClient\r\n * @param correlationId\r\n * @returns\r\n * @internal\r\n *\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst invokeAsync = (callback, eventName, logger, telemetryClient, correlationId) => {\r\n    return (...args) => {\r\n        logger.trace(`Executing function ${eventName}`);\r\n        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);\r\n        if (correlationId) {\r\n            // Track number of times this API is called in a single request\r\n            const eventCount = eventName + "CallCount";\r\n            telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);\r\n        }\r\n        telemetryClient?.setPreQueueTime(eventName, correlationId);\r\n        return callback(...args)\r\n            .then((response) => {\r\n            logger.trace(`Returning result from ${eventName}`);\r\n            inProgressEvent?.end({\r\n                success: true,\r\n            });\r\n            return response;\r\n        })\r\n            .catch((e) => {\r\n            logger.trace(`Error occurred in ${eventName}`);\r\n            try {\r\n                logger.trace(JSON.stringify(e));\r\n            }\r\n            catch (e) {\r\n                logger.trace("Unable to print error message.");\r\n            }\r\n            inProgressEvent?.end({\r\n                success: false,\r\n            }, e);\r\n            throw e;\r\n        });\r\n    };\r\n};\n\n\n//# sourceMappingURL=FunctionWrappers.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass RegionDiscovery {\r\n    constructor(networkInterface, logger, performanceClient, correlationId) {\r\n        this.networkInterface = networkInterface;\r\n        this.logger = logger;\r\n        this.performanceClient = performanceClient;\r\n        this.correlationId = correlationId;\r\n    }\r\n    /**\r\n     * Detect the region from the application\'s environment.\r\n     *\r\n     * @returns Promise<string | null>\r\n     */\r\n    async detectRegion(environmentRegion, regionDiscoveryMetadata) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\r\n        // Initialize auto detected region with the region from the envrionment\r\n        let autodetectedRegionName = environmentRegion;\r\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\r\n        if (!autodetectedRegionName) {\r\n            const options = RegionDiscovery.IMDS_OPTIONS;\r\n            try {\r\n                const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants_Constants.IMDS_VERSION, options);\r\n                if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {\r\n                    autodetectedRegionName = localIMDSVersionResponse.body;\r\n                    regionDiscoveryMetadata.region_source =\r\n                        RegionDiscoverySources.IMDS;\r\n                }\r\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\r\n                if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {\r\n                    const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);\r\n                    if (!currentIMDSVersion) {\r\n                        regionDiscoveryMetadata.region_source =\r\n                            RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                        return null;\r\n                    }\r\n                    const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);\r\n                    if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {\r\n                        autodetectedRegionName =\r\n                            currentIMDSVersionResponse.body;\r\n                        regionDiscoveryMetadata.region_source =\r\n                            RegionDiscoverySources.IMDS;\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                regionDiscoveryMetadata.region_source =\r\n                    RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            regionDiscoveryMetadata.region_source =\r\n                RegionDiscoverySources.ENVIRONMENT_VARIABLE;\r\n        }\r\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\r\n        if (!autodetectedRegionName) {\r\n            regionDiscoveryMetadata.region_source =\r\n                RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n        }\r\n        return autodetectedRegionName || null;\r\n    }\r\n    /**\r\n     * Make the call to the IMDS endpoint\r\n     *\r\n     * @param imdsEndpointUrl\r\n     * @returns Promise<NetworkResponse<string>>\r\n     */\r\n    async getRegionFromIMDS(version, options) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\r\n        return this.networkInterface.sendGetRequestAsync(`${Constants_Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants_Constants.IMDS_TIMEOUT);\r\n    }\r\n    /**\r\n     * Get the most recent version of the IMDS endpoint available\r\n     *\r\n     * @returns Promise<string | null>\r\n     */\r\n    async getCurrentVersion(options) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\r\n        try {\r\n            const response = await this.networkInterface.sendGetRequestAsync(`${Constants_Constants.IMDS_ENDPOINT}?format=json`, options);\r\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\r\n            if (response.status === HttpStatus.BAD_REQUEST &&\r\n                response.body &&\r\n                response.body["newest-versions"] &&\r\n                response.body["newest-versions"].length > 0) {\r\n                return response.body["newest-versions"][0];\r\n            }\r\n            return null;\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n// Options for the IMDS endpoint request\r\nRegionDiscovery.IMDS_OPTIONS = {\r\n    headers: {\r\n        Metadata: "true",\r\n    },\r\n};\n\n\n//# sourceMappingURL=RegionDiscovery.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/account/AuthToken.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Extract token by decoding the rawToken\r\n *\r\n * @param encodedToken\r\n */\r\nfunction extractTokenClaims(encodedToken, base64Decode) {\r\n    const jswPayload = getJWSPayload(encodedToken);\r\n    // token will be decoded to get the username\r\n    try {\r\n        // base64Decode() should throw an error if there is an issue\r\n        const base64Decoded = base64Decode(jswPayload);\r\n        return JSON.parse(base64Decoded);\r\n    }\r\n    catch (err) {\r\n        throw ClientAuthError_createClientAuthError(tokenParsingError);\r\n    }\r\n}\r\n/**\r\n * decode a JWT\r\n *\r\n * @param authToken\r\n */\r\nfunction getJWSPayload(authToken) {\r\n    if (!authToken) {\r\n        throw ClientAuthError_createClientAuthError(nullOrEmptyToken);\r\n    }\r\n    const tokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\r\n    const matches = tokenPartsRegex.exec(authToken);\r\n    if (!matches || matches.length < 4) {\r\n        throw ClientAuthError_createClientAuthError(tokenParsingError);\r\n    }\r\n    /**\r\n     * const crackedToken = {\r\n     *  header: matches[1],\r\n     *  JWSPayload: matches[2],\r\n     *  JWSSig: matches[3],\r\n     * };\r\n     */\r\n    return matches[2];\r\n}\r\n/**\r\n * Determine if the token\'s max_age has transpired\r\n */\r\nfunction checkMaxAge(authTime, maxAge) {\r\n    /*\r\n     * per https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest\r\n     * To force an immediate re-authentication: If an app requires that a user re-authenticate prior to access,\r\n     * provide a value of 0 for the max_age parameter and the AS will force a fresh login.\r\n     */\r\n    const fiveMinuteSkew = 300000; // five minutes in milliseconds\r\n    if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {\r\n        throw ClientAuthError_createClientAuthError(maxAgeTranspired);\r\n    }\r\n}\n\n\n//# sourceMappingURL=AuthToken.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/utils/TimeUtils.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Utility functions for managing date and time operations.\r\n */\r\n/**\r\n * return the current time in Unix time (seconds).\r\n */\r\nfunction nowSeconds() {\r\n    // Date.getTime() returns in milliseconds.\r\n    return Math.round(new Date().getTime() / 1000.0);\r\n}\r\n/**\r\n * Converts JS Date object to seconds\r\n * @param date Date\r\n */\r\nfunction toSecondsFromDate(date) {\r\n    // Convert date to seconds\r\n    return date.getTime() / 1000;\r\n}\r\n/**\r\n * Convert seconds to JS Date object. Seconds can be in a number or string format or undefined (will still return a date).\r\n * @param seconds\r\n */\r\nfunction toDateFromSeconds(seconds) {\r\n    if (seconds) {\r\n        return new Date(Number(seconds) * 1000);\r\n    }\r\n    return new Date();\r\n}\r\n/**\r\n * check if a token is expired based on given UTC time in seconds.\r\n * @param expiresOn\r\n */\r\nfunction isTokenExpired(expiresOn, offset) {\r\n    // check for access token expiry\r\n    const expirationSec = Number(expiresOn) || 0;\r\n    const offsetCurrentTimeSec = nowSeconds() + offset;\r\n    // If current time + offset is greater than token expiration time, then token is expired.\r\n    return offsetCurrentTimeSec > expirationSec;\r\n}\r\n/**\r\n * If the current time is earlier than the time that a token was cached at, we must discard the token\r\n * i.e. The system clock was turned back after acquiring the cached token\r\n * @param cachedAt\r\n * @param offset\r\n */\r\nfunction wasClockTurnedBack(cachedAt) {\r\n    const cachedAtSec = Number(cachedAt);\r\n    return cachedAtSec > nowSeconds();\r\n}\r\n/**\r\n * Waits for t number of milliseconds\r\n * @param t number\r\n * @param value T\r\n */\r\nfunction delay(t, value) {\r\n    return new Promise((resolve) => setTimeout(() => resolve(value), t));\r\n}\n\n\n//# sourceMappingURL=TimeUtils.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/cache/utils/CacheHelpers.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Cache Key: <home_account_id>-<environment>-<credential_type>-<client_id or familyId>-<realm>-<scopes>-<claims hash>-<scheme>\r\n * IdToken Example: uid.utid-login.microsoftonline.com-idtoken-app_client_id-contoso.com\r\n * AccessToken Example: uid.utid-login.microsoftonline.com-accesstoken-app_client_id-contoso.com-scope1 scope2--pop\r\n * RefreshToken Example: uid.utid-login.microsoftonline.com-refreshtoken-1-contoso.com\r\n * @param credentialEntity\r\n * @returns\r\n */\r\nfunction generateCredentialKey(credentialEntity) {\r\n    const credentialKey = [\r\n        generateAccountId(credentialEntity),\r\n        generateCredentialId(credentialEntity),\r\n        generateTarget(credentialEntity),\r\n        generateClaimsHash(credentialEntity),\r\n        generateScheme(credentialEntity),\r\n    ];\r\n    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n}\r\n/**\r\n * Create IdTokenEntity\r\n * @param homeAccountId\r\n * @param authenticationResult\r\n * @param clientId\r\n * @param authority\r\n */\r\nfunction createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {\r\n    const idTokenEntity = {\r\n        credentialType: CredentialType.ID_TOKEN,\r\n        homeAccountId: homeAccountId,\r\n        environment: environment,\r\n        clientId: clientId,\r\n        secret: idToken,\r\n        realm: tenantId,\r\n    };\r\n    return idTokenEntity;\r\n}\r\n/**\r\n * Create AccessTokenEntity\r\n * @param homeAccountId\r\n * @param environment\r\n * @param accessToken\r\n * @param clientId\r\n * @param tenantId\r\n * @param scopes\r\n * @param expiresOn\r\n * @param extExpiresOn\r\n */\r\nfunction createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\r\n    const atEntity = {\r\n        homeAccountId: homeAccountId,\r\n        credentialType: CredentialType.ACCESS_TOKEN,\r\n        secret: accessToken,\r\n        cachedAt: nowSeconds().toString(),\r\n        expiresOn: expiresOn.toString(),\r\n        extendedExpiresOn: extExpiresOn.toString(),\r\n        environment: environment,\r\n        clientId: clientId,\r\n        realm: tenantId,\r\n        target: scopes,\r\n        tokenType: tokenType || AuthenticationScheme.BEARER,\r\n    };\r\n    if (userAssertionHash) {\r\n        atEntity.userAssertionHash = userAssertionHash;\r\n    }\r\n    if (refreshOn) {\r\n        atEntity.refreshOn = refreshOn.toString();\r\n    }\r\n    if (requestedClaims) {\r\n        atEntity.requestedClaims = requestedClaims;\r\n        atEntity.requestedClaimsHash = requestedClaimsHash;\r\n    }\r\n    /*\r\n     * Create Access Token With Auth Scheme instead of regular access token\r\n     * Cast to lower to handle "bearer" from ADFS\r\n     */\r\n    if (atEntity.tokenType?.toLowerCase() !==\r\n        AuthenticationScheme.BEARER.toLowerCase()) {\r\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\r\n        switch (atEntity.tokenType) {\r\n            case AuthenticationScheme.POP:\r\n                // Make sure keyId is present and add it to credential\r\n                const tokenClaims = extractTokenClaims(accessToken, base64Decode);\r\n                if (!tokenClaims?.cnf?.kid) {\r\n                    throw ClientAuthError_createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);\r\n                }\r\n                atEntity.keyId = tokenClaims.cnf.kid;\r\n                break;\r\n            case AuthenticationScheme.SSH:\r\n                atEntity.keyId = keyId;\r\n        }\r\n    }\r\n    return atEntity;\r\n}\r\n/**\r\n * Create RefreshTokenEntity\r\n * @param homeAccountId\r\n * @param authenticationResult\r\n * @param clientId\r\n * @param authority\r\n */\r\nfunction createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {\r\n    const rtEntity = {\r\n        credentialType: CredentialType.REFRESH_TOKEN,\r\n        homeAccountId: homeAccountId,\r\n        environment: environment,\r\n        clientId: clientId,\r\n        secret: refreshToken,\r\n    };\r\n    if (userAssertionHash) {\r\n        rtEntity.userAssertionHash = userAssertionHash;\r\n    }\r\n    if (familyId) {\r\n        rtEntity.familyId = familyId;\r\n    }\r\n    if (expiresOn) {\r\n        rtEntity.expiresOn = expiresOn.toString();\r\n    }\r\n    return rtEntity;\r\n}\r\nfunction isCredentialEntity(entity) {\r\n    return (entity.hasOwnProperty("homeAccountId") &&\r\n        entity.hasOwnProperty("environment") &&\r\n        entity.hasOwnProperty("credentialType") &&\r\n        entity.hasOwnProperty("clientId") &&\r\n        entity.hasOwnProperty("secret"));\r\n}\r\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\r\nfunction isAccessTokenEntity(entity) {\r\n    if (!entity) {\r\n        return false;\r\n    }\r\n    return (isCredentialEntity(entity) &&\r\n        entity.hasOwnProperty("realm") &&\r\n        entity.hasOwnProperty("target") &&\r\n        (entity["credentialType"] === CredentialType.ACCESS_TOKEN ||\r\n            entity["credentialType"] ===\r\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME));\r\n}\r\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\r\nfunction isIdTokenEntity(entity) {\r\n    if (!entity) {\r\n        return false;\r\n    }\r\n    return (isCredentialEntity(entity) &&\r\n        entity.hasOwnProperty("realm") &&\r\n        entity["credentialType"] === CredentialType.ID_TOKEN);\r\n}\r\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\r\nfunction isRefreshTokenEntity(entity) {\r\n    if (!entity) {\r\n        return false;\r\n    }\r\n    return (isCredentialEntity(entity) &&\r\n        entity["credentialType"] === CredentialType.REFRESH_TOKEN);\r\n}\r\n/**\r\n * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n */\r\nfunction generateAccountId(credentialEntity) {\r\n    const accountId = [\r\n        credentialEntity.homeAccountId,\r\n        credentialEntity.environment,\r\n    ];\r\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n}\r\n/**\r\n * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\r\n */\r\nfunction generateCredentialId(credentialEntity) {\r\n    const clientOrFamilyId = credentialEntity.credentialType === CredentialType.REFRESH_TOKEN\r\n        ? credentialEntity.familyId || credentialEntity.clientId\r\n        : credentialEntity.clientId;\r\n    const credentialId = [\r\n        credentialEntity.credentialType,\r\n        clientOrFamilyId,\r\n        credentialEntity.realm || "",\r\n    ];\r\n    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n}\r\n/**\r\n * Generate target key component as per schema: <target>\r\n */\r\nfunction generateTarget(credentialEntity) {\r\n    return (credentialEntity.target || "").toLowerCase();\r\n}\r\n/**\r\n * Generate requested claims key component as per schema: <requestedClaims>\r\n */\r\nfunction generateClaimsHash(credentialEntity) {\r\n    return (credentialEntity.requestedClaimsHash || "").toLowerCase();\r\n}\r\n/**\r\n * Generate scheme key componenet as per schema: <scheme>\r\n */\r\nfunction generateScheme(credentialEntity) {\r\n    /*\r\n     * PoP Tokens and SSH certs include scheme in cache key\r\n     * Cast to lowercase to handle "bearer" from ADFS\r\n     */\r\n    return credentialEntity.tokenType &&\r\n        credentialEntity.tokenType.toLowerCase() !==\r\n            AuthenticationScheme.BEARER.toLowerCase()\r\n        ? credentialEntity.tokenType.toLowerCase()\r\n        : "";\r\n}\r\n/**\r\n * validates if a given cache entry is "Telemetry", parses <key,value>\r\n * @param key\r\n * @param entity\r\n */\r\nfunction isServerTelemetryEntity(key, entity) {\r\n    const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;\r\n    let validateEntity = true;\r\n    if (entity) {\r\n        validateEntity =\r\n            entity.hasOwnProperty("failedRequests") &&\r\n                entity.hasOwnProperty("errors") &&\r\n                entity.hasOwnProperty("cacheHits");\r\n    }\r\n    return validateKey && validateEntity;\r\n}\r\n/**\r\n * validates if a given cache entry is "Throttling", parses <key,value>\r\n * @param key\r\n * @param entity\r\n */\r\nfunction isThrottlingEntity(key, entity) {\r\n    let validateKey = false;\r\n    if (key) {\r\n        validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;\r\n    }\r\n    let validateEntity = true;\r\n    if (entity) {\r\n        validateEntity = entity.hasOwnProperty("throttleTime");\r\n    }\r\n    return validateKey && validateEntity;\r\n}\r\n/**\r\n * Generate AppMetadata Cache Key as per the schema: appmetadata-<environment>-<client_id>\r\n */\r\nfunction generateAppMetadataKey({ environment, clientId, }) {\r\n    const appMetaDataKeyArray = [\r\n        APP_METADATA,\r\n        environment,\r\n        clientId,\r\n    ];\r\n    return appMetaDataKeyArray\r\n        .join(Separators.CACHE_KEY_SEPARATOR)\r\n        .toLowerCase();\r\n}\r\n/*\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\r\nfunction isAppMetadataEntity(key, entity) {\r\n    if (!entity) {\r\n        return false;\r\n    }\r\n    return (key.indexOf(APP_METADATA) === 0 &&\r\n        entity.hasOwnProperty("clientId") &&\r\n        entity.hasOwnProperty("environment"));\r\n}\r\n/**\r\n * Validates an entity: checks for all expected params\r\n * @param entity\r\n */\r\nfunction isAuthorityMetadataEntity(key, entity) {\r\n    if (!entity) {\r\n        return false;\r\n    }\r\n    return (key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 &&\r\n        entity.hasOwnProperty("aliases") &&\r\n        entity.hasOwnProperty("preferred_cache") &&\r\n        entity.hasOwnProperty("preferred_network") &&\r\n        entity.hasOwnProperty("canonical_authority") &&\r\n        entity.hasOwnProperty("authorization_endpoint") &&\r\n        entity.hasOwnProperty("token_endpoint") &&\r\n        entity.hasOwnProperty("issuer") &&\r\n        entity.hasOwnProperty("aliasesFromNetwork") &&\r\n        entity.hasOwnProperty("endpointsFromNetwork") &&\r\n        entity.hasOwnProperty("expiresAt") &&\r\n        entity.hasOwnProperty("jwks_uri"));\r\n}\r\n/**\r\n * Reset the exiresAt value\r\n */\r\nfunction generateAuthorityMetadataExpiresAt() {\r\n    return (nowSeconds() +\r\n        AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS);\r\n}\r\nfunction updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {\r\n    authorityMetadata.authorization_endpoint =\r\n        updatedValues.authorization_endpoint;\r\n    authorityMetadata.token_endpoint = updatedValues.token_endpoint;\r\n    authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;\r\n    authorityMetadata.issuer = updatedValues.issuer;\r\n    authorityMetadata.endpointsFromNetwork = fromNetwork;\r\n    authorityMetadata.jwks_uri = updatedValues.jwks_uri;\r\n}\r\nfunction updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {\r\n    authorityMetadata.aliases = updatedValues.aliases;\r\n    authorityMetadata.preferred_cache = updatedValues.preferred_cache;\r\n    authorityMetadata.preferred_network = updatedValues.preferred_network;\r\n    authorityMetadata.aliasesFromNetwork = fromNetwork;\r\n}\r\n/**\r\n * Returns whether or not the data needs to be refreshed\r\n */\r\nfunction isAuthorityMetadataExpired(metadata) {\r\n    return metadata.expiresAt <= nowSeconds();\r\n}\n\n\n//# sourceMappingURL=CacheHelpers.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/Authority.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n * @internal\r\n */\r\nclass Authority_Authority {\r\n    constructor(authority, networkInterface, cacheManager, authorityOptions, logger, correlationId, performanceClient, managedIdentity) {\r\n        this.canonicalAuthority = authority;\r\n        this._canonicalAuthority.validateAsUri();\r\n        this.networkInterface = networkInterface;\r\n        this.cacheManager = cacheManager;\r\n        this.authorityOptions = authorityOptions;\r\n        this.regionDiscoveryMetadata = {\r\n            region_used: undefined,\r\n            region_source: undefined,\r\n            region_outcome: undefined,\r\n        };\r\n        this.logger = logger;\r\n        this.performanceClient = performanceClient;\r\n        this.correlationId = correlationId;\r\n        this.managedIdentity = managedIdentity || false;\r\n        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);\r\n    }\r\n    /**\r\n     * Get {@link AuthorityType}\r\n     * @param authorityUri {@link IUri}\r\n     * @private\r\n     */\r\n    getAuthorityType(authorityUri) {\r\n        // CIAM auth url pattern is being standardized as: <tenant>.ciamlogin.com\r\n        if (authorityUri.HostNameAndPort.endsWith(Constants_Constants.CIAM_AUTH_URL)) {\r\n            return AuthorityType.Ciam;\r\n        }\r\n        const pathSegments = authorityUri.PathSegments;\r\n        if (pathSegments.length) {\r\n            switch (pathSegments[0].toLowerCase()) {\r\n                case Constants_Constants.ADFS:\r\n                    return AuthorityType.Adfs;\r\n                case Constants_Constants.DSTS:\r\n                    return AuthorityType.Dsts;\r\n            }\r\n        }\r\n        return AuthorityType.Default;\r\n    }\r\n    // See above for AuthorityType\r\n    get authorityType() {\r\n        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);\r\n    }\r\n    /**\r\n     * ProtocolMode enum representing the way endpoints are constructed.\r\n     */\r\n    get protocolMode() {\r\n        return this.authorityOptions.protocolMode;\r\n    }\r\n    /**\r\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\r\n     */\r\n    get options() {\r\n        return this.authorityOptions;\r\n    }\r\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\r\n    get canonicalAuthority() {\r\n        return this._canonicalAuthority.urlString;\r\n    }\r\n    /**\r\n     * Sets canonical authority.\r\n     */\r\n    set canonicalAuthority(url) {\r\n        this._canonicalAuthority = new UrlString(url);\r\n        this._canonicalAuthority.validateAsUri();\r\n        this._canonicalAuthorityUrlComponents = null;\r\n    }\r\n    /**\r\n     * Get authority components.\r\n     */\r\n    get canonicalAuthorityUrlComponents() {\r\n        if (!this._canonicalAuthorityUrlComponents) {\r\n            this._canonicalAuthorityUrlComponents =\r\n                this._canonicalAuthority.getUrlComponents();\r\n        }\r\n        return this._canonicalAuthorityUrlComponents;\r\n    }\r\n    /**\r\n     * Get hostname and port i.e. login.microsoftonline.com\r\n     */\r\n    get hostnameAndPort() {\r\n        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\r\n    }\r\n    /**\r\n     * Get tenant for authority.\r\n     */\r\n    get tenant() {\r\n        return this.canonicalAuthorityUrlComponents.PathSegments[0];\r\n    }\r\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\r\n    get authorizationEndpoint() {\r\n        if (this.discoveryComplete()) {\r\n            return this.replacePath(this.metadata.authorization_endpoint);\r\n        }\r\n        else {\r\n            throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n        }\r\n    }\r\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\r\n    get tokenEndpoint() {\r\n        if (this.discoveryComplete()) {\r\n            return this.replacePath(this.metadata.token_endpoint);\r\n        }\r\n        else {\r\n            throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n        }\r\n    }\r\n    get deviceCodeEndpoint() {\r\n        if (this.discoveryComplete()) {\r\n            return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));\r\n        }\r\n        else {\r\n            throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n        }\r\n    }\r\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\r\n    get endSessionEndpoint() {\r\n        if (this.discoveryComplete()) {\r\n            // ROPC policies may not have end_session_endpoint set\r\n            if (!this.metadata.end_session_endpoint) {\r\n                throw ClientAuthError_createClientAuthError(endSessionEndpointNotSupported);\r\n            }\r\n            return this.replacePath(this.metadata.end_session_endpoint);\r\n        }\r\n        else {\r\n            throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n        }\r\n    }\r\n    /**\r\n     * OAuth issuer for requests\r\n     */\r\n    get selfSignedJwtAudience() {\r\n        if (this.discoveryComplete()) {\r\n            return this.replacePath(this.metadata.issuer);\r\n        }\r\n        else {\r\n            throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n        }\r\n    }\r\n    /**\r\n     * Jwks_uri for token signing keys\r\n     */\r\n    get jwksUri() {\r\n        if (this.discoveryComplete()) {\r\n            return this.replacePath(this.metadata.jwks_uri);\r\n        }\r\n        else {\r\n            throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}\r\n     * @param authorityUri {@link IUri}\r\n     * @private\r\n     */\r\n    canReplaceTenant(authorityUri) {\r\n        return (authorityUri.PathSegments.length === 1 &&\r\n            !Authority_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) &&\r\n            this.getAuthorityType(authorityUri) === AuthorityType.Default &&\r\n            this.protocolMode !== ProtocolMode_ProtocolMode.OIDC);\r\n    }\r\n    /**\r\n     * Replaces tenant in url path with current tenant. Defaults to common.\r\n     * @param urlString\r\n     */\r\n    replaceTenant(urlString) {\r\n        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\r\n    }\r\n    /**\r\n     * Replaces path such as tenant or policy with the current tenant or policy.\r\n     * @param urlString\r\n     */\r\n    replacePath(urlString) {\r\n        let endpoint = urlString;\r\n        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\r\n        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();\r\n        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;\r\n        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\r\n        currentAuthorityParts.forEach((currentPart, index) => {\r\n            let cachedPart = cachedAuthorityParts[index];\r\n            if (index === 0 &&\r\n                this.canReplaceTenant(cachedAuthorityUrlComponents)) {\r\n                const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];\r\n                /**\r\n                 * Check if AAD canonical authority contains tenant domain name, for example "testdomain.onmicrosoft.com",\r\n                 * by comparing its first path segment to the corresponding authorization endpoint path segment, which is\r\n                 * always resolved with tenant id by OIDC.\r\n                 */\r\n                if (cachedPart !== tenantId) {\r\n                    this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);\r\n                    cachedPart = tenantId;\r\n                }\r\n            }\r\n            if (currentPart !== cachedPart) {\r\n                endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);\r\n            }\r\n        });\r\n        return this.replaceTenant(endpoint);\r\n    }\r\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\r\n    get defaultOpenIdConfigurationEndpoint() {\r\n        const canonicalAuthorityHost = this.hostnameAndPort;\r\n        if (this.canonicalAuthority.endsWith("v2.0/") ||\r\n            this.authorityType === AuthorityType.Adfs ||\r\n            (this.protocolMode === ProtocolMode_ProtocolMode.OIDC &&\r\n                !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost))) {\r\n            return `${this.canonicalAuthority}.well-known/openid-configuration`;\r\n        }\r\n        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\r\n    }\r\n    /**\r\n     * Boolean that returns whether or not tenant discovery has been completed.\r\n     */\r\n    discoveryComplete() {\r\n        return !!this.metadata;\r\n    }\r\n    /**\r\n     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\r\n     * and the /authorize, /token and logout endpoints.\r\n     */\r\n    async resolveEndpointsAsync() {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);\r\n        const metadataEntity = this.getCurrentMetadataEntity();\r\n        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);\r\n        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\r\n        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);\r\n        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {\r\n            source: endpointSource,\r\n        });\r\n        this.performanceClient?.addFields({\r\n            cloudDiscoverySource: cloudDiscoverySource,\r\n            authorityEndpointSource: endpointSource,\r\n        }, this.correlationId);\r\n    }\r\n    /**\r\n     * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built\r\n     * from the configured canonical authority\r\n     * @returns\r\n     */\r\n    getCurrentMetadataEntity() {\r\n        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\r\n        if (!metadataEntity) {\r\n            metadataEntity = {\r\n                aliases: [],\r\n                preferred_cache: this.hostnameAndPort,\r\n                preferred_network: this.hostnameAndPort,\r\n                canonical_authority: this.canonicalAuthority,\r\n                authorization_endpoint: "",\r\n                token_endpoint: "",\r\n                end_session_endpoint: "",\r\n                issuer: "",\r\n                aliasesFromNetwork: false,\r\n                endpointsFromNetwork: false,\r\n                expiresAt: generateAuthorityMetadataExpiresAt(),\r\n                jwks_uri: "",\r\n            };\r\n        }\r\n        return metadataEntity;\r\n    }\r\n    /**\r\n     * Updates cached metadata based on metadata source and sets the instance\'s metadata\r\n     * property to the same value\r\n     * @param metadataEntity\r\n     * @param cloudDiscoverySource\r\n     * @param endpointMetadataResult\r\n     */\r\n    updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {\r\n        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE &&\r\n            endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {\r\n            // Reset the expiration time unless both values came from a successful cache lookup\r\n            metadataEntity.expiresAt =\r\n                generateAuthorityMetadataExpiresAt();\r\n            metadataEntity.canonical_authority = this.canonicalAuthority;\r\n        }\r\n        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\r\n        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\r\n        this.metadata = metadataEntity;\r\n    }\r\n    /**\r\n     * Update AuthorityMetadataEntity with new endpoints and return where the information came from\r\n     * @param metadataEntity\r\n     */\r\n    async updateEndpointMetadata(metadataEntity) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);\r\n        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);\r\n        // Further update may be required for hardcoded metadata if regional metadata is preferred\r\n        if (localMetadata) {\r\n            if (localMetadata.source ===\r\n                AuthorityMetadataSource.HARDCODED_VALUES) {\r\n                // If the user prefers to use an azure region replace the global endpoints with regional information.\r\n                if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\r\n                    if (localMetadata.metadata) {\r\n                        const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);\r\n                        updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);\r\n                        metadataEntity.canonical_authority =\r\n                            this.canonicalAuthority;\r\n                    }\r\n                }\r\n            }\r\n            return localMetadata.source;\r\n        }\r\n        // Get metadata from network if local sources aren\'t available\r\n        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();\r\n        if (metadata) {\r\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\r\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\r\n                metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);\r\n            }\r\n            updateAuthorityEndpointMetadata(metadataEntity, metadata, true);\r\n            return AuthorityMetadataSource.NETWORK;\r\n        }\r\n        else {\r\n            // Metadata could not be obtained from the config, cache, network or hardcoded values\r\n            throw ClientAuthError_createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);\r\n        }\r\n    }\r\n    /**\r\n     * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config\r\n     * response if the source is hardcoded metadata\r\n     * @param metadataEntity\r\n     * @returns\r\n     */\r\n    updateEndpointMetadataFromLocalSources(metadataEntity) {\r\n        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");\r\n        const configMetadata = this.getEndpointMetadataFromConfig();\r\n        if (configMetadata) {\r\n            this.logger.verbose("Found endpoint metadata in authority configuration");\r\n            updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);\r\n            return {\r\n                source: AuthorityMetadataSource.CONFIG,\r\n            };\r\n        }\r\n        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");\r\n        // skipAuthorityMetadataCache is used to bypass hardcoded authority metadata and force a network metadata cache lookup and network metadata request if no cached response is available.\r\n        if (this.authorityOptions.skipAuthorityMetadataCache) {\r\n            this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");\r\n        }\r\n        else {\r\n            const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();\r\n            if (hardcodedMetadata) {\r\n                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);\r\n                return {\r\n                    source: AuthorityMetadataSource.HARDCODED_VALUES,\r\n                    metadata: hardcodedMetadata,\r\n                };\r\n            }\r\n            else {\r\n                this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");\r\n            }\r\n        }\r\n        // Check cached metadata entity expiration status\r\n        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);\r\n        if (this.isAuthoritySameType(metadataEntity) &&\r\n            metadataEntity.endpointsFromNetwork &&\r\n            !metadataEntityExpired) {\r\n            // No need to update\r\n            this.logger.verbose("Found endpoint metadata in the cache.");\r\n            return { source: AuthorityMetadataSource.CACHE };\r\n        }\r\n        else if (metadataEntityExpired) {\r\n            this.logger.verbose("The metadata entity is expired.");\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Compares the number of url components after the domain to determine if the cached\r\n     * authority metadata can be used for the requested authority. Protects against same domain different\r\n     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\r\n     * @param metadataEntity\r\n     */\r\n    isAuthoritySameType(metadataEntity) {\r\n        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\r\n        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\r\n        return (cachedParts.length ===\r\n            this.canonicalAuthorityUrlComponents.PathSegments.length);\r\n    }\r\n    /**\r\n     * Parse authorityMetadata config option\r\n     */\r\n    getEndpointMetadataFromConfig() {\r\n        if (this.authorityOptions.authorityMetadata) {\r\n            try {\r\n                return JSON.parse(this.authorityOptions.authorityMetadata);\r\n            }\r\n            catch (e) {\r\n                throw ClientConfigurationError_createClientConfigurationError(invalidAuthorityMetadata);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n     *\r\n     * @param hasHardcodedMetadata boolean\r\n     */\r\n    async getEndpointMetadataFromNetwork() {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);\r\n        const options = {};\r\n        /*\r\n         * TODO: Add a timeout if the authority exists in our library\'s\r\n         * hardcoded list of metadata\r\n         */\r\n        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;\r\n        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);\r\n        try {\r\n            const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);\r\n            const isValidResponse = isOpenIdConfigResponse(response.body);\r\n            if (isValidResponse) {\r\n                return response.body;\r\n            }\r\n            else {\r\n                this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);\r\n                return null;\r\n            }\r\n        }\r\n        catch (e) {\r\n            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Get OAuth endpoints for common authorities.\r\n     */\r\n    getEndpointMetadataFromHardcodedValues() {\r\n        if (this.hostnameAndPort in EndpointMetadata) {\r\n            return EndpointMetadata[this.hostnameAndPort];\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Update the retrieved metadata with regional information.\r\n     * User selected Azure region will be used if configured.\r\n     */\r\n    async updateMetadataWithRegionalInformation(metadata) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);\r\n        const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;\r\n        if (userConfiguredAzureRegion) {\r\n            if (userConfiguredAzureRegion !==\r\n                Constants_Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\r\n                this.regionDiscoveryMetadata.region_outcome =\r\n                    RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\r\n                this.regionDiscoveryMetadata.region_used =\r\n                    userConfiguredAzureRegion;\r\n                return Authority_Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);\r\n            }\r\n            const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration\r\n                ?.environmentRegion, this.regionDiscoveryMetadata);\r\n            if (autodetectedRegionName) {\r\n                this.regionDiscoveryMetadata.region_outcome =\r\n                    RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;\r\n                this.regionDiscoveryMetadata.region_used =\r\n                    autodetectedRegionName;\r\n                return Authority_Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);\r\n            }\r\n            this.regionDiscoveryMetadata.region_outcome =\r\n                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\r\n        }\r\n        return metadata;\r\n    }\r\n    /**\r\n     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\r\n     * and returns where the information was retrieved from\r\n     * @param metadataEntity\r\n     * @returns AuthorityMetadataSource\r\n     */\r\n    async updateCloudDiscoveryMetadata(metadataEntity) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);\r\n        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);\r\n        if (localMetadataSource) {\r\n            return localMetadataSource;\r\n        }\r\n        // Fallback to network as metadata source\r\n        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();\r\n        if (metadata) {\r\n            updateCloudDiscoveryMetadata(metadataEntity, metadata, true);\r\n            return AuthorityMetadataSource.NETWORK;\r\n        }\r\n        // Metadata could not be obtained from the config, cache, network or hardcoded values\r\n        throw ClientConfigurationError_createClientConfigurationError(untrustedAuthority);\r\n    }\r\n    updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {\r\n        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");\r\n        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities ||\r\n            Constants_Constants.NOT_APPLICABLE}`);\r\n        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata ||\r\n            Constants_Constants.NOT_APPLICABLE}`);\r\n        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants_Constants.NOT_APPLICABLE}`);\r\n        const metadata = this.getCloudDiscoveryMetadataFromConfig();\r\n        if (metadata) {\r\n            this.logger.verbose("Found cloud discovery metadata in authority configuration");\r\n            updateCloudDiscoveryMetadata(metadataEntity, metadata, false);\r\n            return AuthorityMetadataSource.CONFIG;\r\n        }\r\n        // If the cached metadata came from config but that config was not passed to this instance, we must go to hardcoded values\r\n        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");\r\n        if (this.options.skipAuthorityMetadataCache) {\r\n            this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");\r\n        }\r\n        else {\r\n            const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);\r\n            if (hardcodedMetadata) {\r\n                this.logger.verbose("Found cloud discovery metadata from hardcoded values.");\r\n                updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);\r\n                return AuthorityMetadataSource.HARDCODED_VALUES;\r\n            }\r\n            this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");\r\n        }\r\n        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);\r\n        if (this.isAuthoritySameType(metadataEntity) &&\r\n            metadataEntity.aliasesFromNetwork &&\r\n            !metadataEntityExpired) {\r\n            this.logger.verbose("Found cloud discovery metadata in the cache.");\r\n            // No need to update\r\n            return AuthorityMetadataSource.CACHE;\r\n        }\r\n        else if (metadataEntityExpired) {\r\n            this.logger.verbose("The metadata entity is expired.");\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Parse cloudDiscoveryMetadata config or check knownAuthorities\r\n     */\r\n    getCloudDiscoveryMetadataFromConfig() {\r\n        // CIAM does not support cloud discovery metadata\r\n        if (this.authorityType === AuthorityType.Ciam) {\r\n            this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");\r\n            return Authority_Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\r\n        }\r\n        // Check if network response was provided in config\r\n        if (this.authorityOptions.cloudDiscoveryMetadata) {\r\n            this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");\r\n            try {\r\n                this.logger.verbose("Attempting to parse the cloud discovery metadata.");\r\n                const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);\r\n                const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\r\n                this.logger.verbose("Parsed the cloud discovery metadata.");\r\n                if (metadata) {\r\n                    this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");\r\n                    return metadata;\r\n                }\r\n                else {\r\n                    this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");\r\n                }\r\n            }\r\n            catch (e) {\r\n                this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");\r\n                throw ClientConfigurationError_createClientConfigurationError(invalidCloudDiscoveryMetadata);\r\n            }\r\n        }\r\n        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\r\n        if (this.isInKnownAuthorities()) {\r\n            this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");\r\n            return Authority_Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n     *\r\n     * @param hasHardcodedMetadata boolean\r\n     */\r\n    async getCloudDiscoveryMetadataFromNetwork() {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);\r\n        const instanceDiscoveryEndpoint = `${Constants_Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\r\n        const options = {};\r\n        /*\r\n         * TODO: Add a timeout if the authority exists in our library\'s\r\n         * hardcoded list of metadata\r\n         */\r\n        let match = null;\r\n        try {\r\n            const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);\r\n            let typedResponseBody;\r\n            let metadata;\r\n            if (isCloudInstanceDiscoveryResponse(response.body)) {\r\n                typedResponseBody =\r\n                    response.body;\r\n                metadata = typedResponseBody.metadata;\r\n                this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);\r\n            }\r\n            else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {\r\n                this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request\'s status code is: ${response.status}`);\r\n                typedResponseBody =\r\n                    response.body;\r\n                if (typedResponseBody.error === Constants_Constants.INVALID_INSTANCE) {\r\n                    this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");\r\n                    return null;\r\n                }\r\n                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);\r\n                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);\r\n                this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");\r\n                metadata = [];\r\n            }\r\n            else {\r\n                this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");\r\n                return null;\r\n            }\r\n            this.logger.verbose("Attempting to find a match between the developer\'s authority and the CloudInstanceDiscoveryMetadata returned from the network request.");\r\n            match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\r\n        }\r\n        catch (error) {\r\n            if (error instanceof AuthError) {\r\n                this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.\\nError: ${error.errorCode}\\nError Description: ${error.errorMessage}`);\r\n            }\r\n            else {\r\n                const typedError = error;\r\n                this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\\nError: ${typedError.name}\\nError Description: ${typedError.message}`);\r\n            }\r\n            return null;\r\n        }\r\n        // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\r\n        if (!match) {\r\n            this.logger.warning("The developer\'s authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");\r\n            this.logger.verbose("Creating custom Authority for custom domain scenario.");\r\n            match = Authority_Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\r\n        }\r\n        return match;\r\n    }\r\n    /**\r\n     * Helper function to determine if this host is included in the knownAuthorities config option\r\n     */\r\n    isInKnownAuthorities() {\r\n        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {\r\n            return (authority &&\r\n                UrlString.getDomainFromUrl(authority).toLowerCase() ===\r\n                    this.hostnameAndPort);\r\n        });\r\n        return matches.length > 0;\r\n    }\r\n    /**\r\n     * helper function to populate the authority based on azureCloudOptions\r\n     * @param authorityString\r\n     * @param azureCloudOptions\r\n     */\r\n    static generateAuthority(authorityString, azureCloudOptions) {\r\n        let authorityAzureCloudInstance;\r\n        if (azureCloudOptions &&\r\n            azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {\r\n            const tenant = azureCloudOptions.tenant\r\n                ? azureCloudOptions.tenant\r\n                : Constants_Constants.DEFAULT_COMMON_TENANT;\r\n            authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;\r\n        }\r\n        return authorityAzureCloudInstance\r\n            ? authorityAzureCloudInstance\r\n            : authorityString;\r\n    }\r\n    /**\r\n     * Creates cloud discovery metadata object from a given host\r\n     * @param host\r\n     */\r\n    static createCloudDiscoveryMetadataFromHost(host) {\r\n        return {\r\n            preferred_network: host,\r\n            preferred_cache: host,\r\n            aliases: [host],\r\n        };\r\n    }\r\n    /**\r\n     * helper function to generate environment from authority object\r\n     */\r\n    getPreferredCache() {\r\n        if (this.managedIdentity) {\r\n            return Constants_Constants.DEFAULT_AUTHORITY_HOST;\r\n        }\r\n        else if (this.discoveryComplete()) {\r\n            return this.metadata.preferred_cache;\r\n        }\r\n        else {\r\n            throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether or not the provided host is an alias of this authority instance\r\n     * @param host\r\n     */\r\n    isAlias(host) {\r\n        return this.metadata.aliases.indexOf(host) > -1;\r\n    }\r\n    /**\r\n     * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery\r\n     * @param host\r\n     */\r\n    isAliasOfKnownMicrosoftAuthority(host) {\r\n        return InstanceDiscoveryMetadataAliases.has(host);\r\n    }\r\n    /**\r\n     * Checks whether the provided host is that of a public cloud authority\r\n     *\r\n     * @param authority string\r\n     * @returns bool\r\n     */\r\n    static isPublicCloudAuthority(host) {\r\n        return Constants_Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\r\n    }\r\n    /**\r\n     * Rebuild the authority string with the region\r\n     *\r\n     * @param host string\r\n     * @param region string\r\n     */\r\n    static buildRegionalAuthorityString(host, region, queryString) {\r\n        // Create and validate a Url string object with the initial authority string\r\n        const authorityUrlInstance = new UrlString(host);\r\n        authorityUrlInstance.validateAsUri();\r\n        const authorityUrlParts = authorityUrlInstance.getUrlComponents();\r\n        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;\r\n        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\r\n            hostNameAndPort = `${region}.${Constants_Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;\r\n        }\r\n        // Include the query string portion of the url\r\n        const url = UrlString.constructAuthorityUriFromObject({\r\n            ...authorityUrlInstance.getUrlComponents(),\r\n            HostNameAndPort: hostNameAndPort,\r\n        }).urlString;\r\n        // Add the query string if a query string was provided\r\n        if (queryString)\r\n            return `${url}?${queryString}`;\r\n        return url;\r\n    }\r\n    /**\r\n     * Replace the endpoints in the metadata object with their regional equivalents.\r\n     *\r\n     * @param metadata OpenIdConfigResponse\r\n     * @param azureRegion string\r\n     */\r\n    static replaceWithRegionalInformation(metadata, azureRegion) {\r\n        const regionalMetadata = { ...metadata };\r\n        regionalMetadata.authorization_endpoint =\r\n            Authority_Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);\r\n        regionalMetadata.token_endpoint =\r\n            Authority_Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);\r\n        if (regionalMetadata.end_session_endpoint) {\r\n            regionalMetadata.end_session_endpoint =\r\n                Authority_Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);\r\n        }\r\n        return regionalMetadata;\r\n    }\r\n    /**\r\n     * Transform CIAM_AUTHORIY as per the below rules:\r\n     * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it\r\n     *\r\n     * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`\r\n     * `ciamlogin.com` can also change in the future and we should accommodate the same\r\n     *\r\n     * @param authority\r\n     */\r\n    static transformCIAMAuthority(authority) {\r\n        let ciamAuthority = authority;\r\n        const authorityUrl = new UrlString(authority);\r\n        const authorityUrlComponents = authorityUrl.getUrlComponents();\r\n        // check if transformation is needed\r\n        if (authorityUrlComponents.PathSegments.length === 0 &&\r\n            authorityUrlComponents.HostNameAndPort.endsWith(Constants_Constants.CIAM_AUTH_URL)) {\r\n            const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];\r\n            ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants_Constants.AAD_TENANT_DOMAIN_SUFFIX}`;\r\n        }\r\n        return ciamAuthority;\r\n    }\r\n}\r\n// Reserved tenant domain names that will not be replaced with tenant id\r\nAuthority_Authority.reservedTenantDomains = new Set([\r\n    "{tenant}",\r\n    "{tenantid}",\r\n    AADAuthorityConstants.COMMON,\r\n    AADAuthorityConstants.CONSUMERS,\r\n    AADAuthorityConstants.ORGANIZATIONS,\r\n]);\r\n/**\r\n * Extract tenantId from authority\r\n */\r\nfunction getTenantFromAuthorityString(authority) {\r\n    const authorityUrl = new UrlString(authority);\r\n    const authorityUrlComponents = authorityUrl.getUrlComponents();\r\n    /**\r\n     * For credential matching purposes, tenantId is the last path segment of the authority URL:\r\n     *  AAD Authority - domain/tenantId -> Credentials are cached with realm = tenantId\r\n     *  B2C Authority - domain/{tenantId}?/.../policy -> Credentials are cached with realm = policy\r\n     *  tenantId is downcased because B2C policies can have mixed case but tfp claim is downcased\r\n     *\r\n     * Note that we may not have any path segments in certain OIDC scenarios.\r\n     */\r\n    const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();\r\n    switch (tenantId) {\r\n        case AADAuthorityConstants.COMMON:\r\n        case AADAuthorityConstants.ORGANIZATIONS:\r\n        case AADAuthorityConstants.CONSUMERS:\r\n            return undefined;\r\n        default:\r\n            return tenantId;\r\n    }\r\n}\r\nfunction formatAuthorityUri(authorityUri) {\r\n    return authorityUri.endsWith(Constants_Constants.FORWARD_SLASH)\r\n        ? authorityUri\r\n        : `${authorityUri}${Constants_Constants.FORWARD_SLASH}`;\r\n}\r\nfunction buildStaticAuthorityOptions(authOptions) {\r\n    const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;\r\n    let cloudDiscoveryMetadata = undefined;\r\n    if (rawCloudDiscoveryMetadata) {\r\n        try {\r\n            cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);\r\n        }\r\n        catch (e) {\r\n            throw ClientConfigurationError_createClientConfigurationError(invalidCloudDiscoveryMetadata);\r\n        }\r\n    }\r\n    return {\r\n        canonicalAuthority: authOptions.authority\r\n            ? formatAuthorityUri(authOptions.authority)\r\n            : undefined,\r\n        knownAuthorities: authOptions.knownAuthorities,\r\n        cloudDiscoveryMetadata: cloudDiscoveryMetadata,\r\n    };\r\n}\n\n\n//# sourceMappingURL=Authority.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/crypto/ICrypto.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst ICrypto_DEFAULT_CRYPTO_IMPLEMENTATION = {\r\n    createNewGuid: () => {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    base64Decode: () => {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    base64Encode: () => {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    base64UrlEncode: () => {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    encodeKid: () => {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    async getPublicKeyThumbprint() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    async removeTokenBindingKey() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    async clearKeystore() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    async signJwt() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    async hashString() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n};\n\n\n//# sourceMappingURL=ICrypto.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/packageMetadata.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/* eslint-disable header/header */\r\nconst packageMetadata_name = "@azure/msal-common";\r\nconst packageMetadata_version = "15.7.0";\n\n\n//# sourceMappingURL=packageMetadata.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/request/ScopeSet.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes\r\n * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings in intersection and union functions\r\n * to ensure uniqueness of strings.\r\n */\r\nclass ScopeSet {\r\n    constructor(inputScopes) {\r\n        // Filter empty string and null/undefined array items\r\n        const scopeArr = inputScopes\r\n            ? StringUtils.trimArrayEntries([...inputScopes])\r\n            : [];\r\n        const filteredInput = scopeArr\r\n            ? StringUtils.removeEmptyStringsFromArray(scopeArr)\r\n            : [];\r\n        // Check if scopes array has at least one member\r\n        if (!filteredInput || !filteredInput.length) {\r\n            throw ClientConfigurationError_createClientConfigurationError(emptyInputScopesError);\r\n        }\r\n        this.scopes = new Set(); // Iterator in constructor not supported by IE11\r\n        filteredInput.forEach((scope) => this.scopes.add(scope));\r\n    }\r\n    /**\r\n     * Factory method to create ScopeSet from space-delimited string\r\n     * @param inputScopeString\r\n     * @param appClientId\r\n     * @param scopesRequired\r\n     */\r\n    static fromString(inputScopeString) {\r\n        const scopeString = inputScopeString || Constants_Constants.EMPTY_STRING;\r\n        const inputScopes = scopeString.split(" ");\r\n        return new ScopeSet(inputScopes);\r\n    }\r\n    /**\r\n     * Creates the set of scopes to search for in cache lookups\r\n     * @param inputScopeString\r\n     * @returns\r\n     */\r\n    static createSearchScopes(inputScopeString) {\r\n        const scopeSet = new ScopeSet(inputScopeString);\r\n        if (!scopeSet.containsOnlyOIDCScopes()) {\r\n            scopeSet.removeOIDCScopes();\r\n        }\r\n        else {\r\n            scopeSet.removeScope(Constants_Constants.OFFLINE_ACCESS_SCOPE);\r\n        }\r\n        return scopeSet;\r\n    }\r\n    /**\r\n     * Check if a given scope is present in this set of scopes.\r\n     * @param scope\r\n     */\r\n    containsScope(scope) {\r\n        const lowerCaseScopes = this.printScopesLowerCase().split(" ");\r\n        const lowerCaseScopesSet = new ScopeSet(lowerCaseScopes);\r\n        // compare lowercase scopes\r\n        return scope\r\n            ? lowerCaseScopesSet.scopes.has(scope.toLowerCase())\r\n            : false;\r\n    }\r\n    /**\r\n     * Check if a set of scopes is present in this set of scopes.\r\n     * @param scopeSet\r\n     */\r\n    containsScopeSet(scopeSet) {\r\n        if (!scopeSet || scopeSet.scopes.size <= 0) {\r\n            return false;\r\n        }\r\n        return (this.scopes.size >= scopeSet.scopes.size &&\r\n            scopeSet.asArray().every((scope) => this.containsScope(scope)));\r\n    }\r\n    /**\r\n     * Check if set of scopes contains only the defaults\r\n     */\r\n    containsOnlyOIDCScopes() {\r\n        let defaultScopeCount = 0;\r\n        OIDC_SCOPES.forEach((defaultScope) => {\r\n            if (this.containsScope(defaultScope)) {\r\n                defaultScopeCount += 1;\r\n            }\r\n        });\r\n        return this.scopes.size === defaultScopeCount;\r\n    }\r\n    /**\r\n     * Appends single scope if passed\r\n     * @param newScope\r\n     */\r\n    appendScope(newScope) {\r\n        if (newScope) {\r\n            this.scopes.add(newScope.trim());\r\n        }\r\n    }\r\n    /**\r\n     * Appends multiple scopes if passed\r\n     * @param newScopes\r\n     */\r\n    appendScopes(newScopes) {\r\n        try {\r\n            newScopes.forEach((newScope) => this.appendScope(newScope));\r\n        }\r\n        catch (e) {\r\n            throw ClientAuthError_createClientAuthError(cannotAppendScopeSet);\r\n        }\r\n    }\r\n    /**\r\n     * Removes element from set of scopes.\r\n     * @param scope\r\n     */\r\n    removeScope(scope) {\r\n        if (!scope) {\r\n            throw ClientAuthError_createClientAuthError(cannotRemoveEmptyScope);\r\n        }\r\n        this.scopes.delete(scope.trim());\r\n    }\r\n    /**\r\n     * Removes default scopes from set of scopes\r\n     * Primarily used to prevent cache misses if the default scopes are not returned from the server\r\n     */\r\n    removeOIDCScopes() {\r\n        OIDC_SCOPES.forEach((defaultScope) => {\r\n            this.scopes.delete(defaultScope);\r\n        });\r\n    }\r\n    /**\r\n     * Combines an array of scopes with the current set of scopes.\r\n     * @param otherScopes\r\n     */\r\n    unionScopeSets(otherScopes) {\r\n        if (!otherScopes) {\r\n            throw ClientAuthError_createClientAuthError(emptyInputScopeSet);\r\n        }\r\n        const unionScopes = new Set(); // Iterator in constructor not supported in IE11\r\n        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));\r\n        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));\r\n        return unionScopes;\r\n    }\r\n    /**\r\n     * Check if scopes intersect between this set and another.\r\n     * @param otherScopes\r\n     */\r\n    intersectingScopeSets(otherScopes) {\r\n        if (!otherScopes) {\r\n            throw ClientAuthError_createClientAuthError(emptyInputScopeSet);\r\n        }\r\n        // Do not allow OIDC scopes to be the only intersecting scopes\r\n        if (!otherScopes.containsOnlyOIDCScopes()) {\r\n            otherScopes.removeOIDCScopes();\r\n        }\r\n        const unionScopes = this.unionScopeSets(otherScopes);\r\n        const sizeOtherScopes = otherScopes.getScopeCount();\r\n        const sizeThisScopes = this.getScopeCount();\r\n        const sizeUnionScopes = unionScopes.size;\r\n        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;\r\n    }\r\n    /**\r\n     * Returns size of set of scopes.\r\n     */\r\n    getScopeCount() {\r\n        return this.scopes.size;\r\n    }\r\n    /**\r\n     * Returns the scopes as an array of string values\r\n     */\r\n    asArray() {\r\n        const array = [];\r\n        this.scopes.forEach((val) => array.push(val));\r\n        return array;\r\n    }\r\n    /**\r\n     * Prints scopes into a space-delimited string\r\n     */\r\n    printScopes() {\r\n        if (this.scopes) {\r\n            const scopeArr = this.asArray();\r\n            return scopeArr.join(" ");\r\n        }\r\n        return Constants_Constants.EMPTY_STRING;\r\n    }\r\n    /**\r\n     * Prints scopes into a space-delimited lower-case string (used for caching)\r\n     */\r\n    printScopesLowerCase() {\r\n        return this.printScopes().toLowerCase();\r\n    }\r\n}\n\n\n//# sourceMappingURL=ScopeSet.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/account/ClientInfo.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Function to build a client info object from server clientInfo string\r\n * @param rawClientInfo\r\n * @param crypto\r\n */\r\nfunction buildClientInfo(rawClientInfo, base64Decode) {\r\n    if (!rawClientInfo) {\r\n        throw ClientAuthError_createClientAuthError(clientInfoEmptyError);\r\n    }\r\n    try {\r\n        const decodedClientInfo = base64Decode(rawClientInfo);\r\n        return JSON.parse(decodedClientInfo);\r\n    }\r\n    catch (e) {\r\n        throw ClientAuthError_createClientAuthError(clientInfoDecodingError);\r\n    }\r\n}\r\n/**\r\n * Function to build a client info object from cached homeAccountId string\r\n * @param homeAccountId\r\n */\r\nfunction buildClientInfoFromHomeAccountId(homeAccountId) {\r\n    if (!homeAccountId) {\r\n        throw ClientAuthError_createClientAuthError(clientInfoDecodingError);\r\n    }\r\n    const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);\r\n    return {\r\n        uid: clientInfoParts[0],\r\n        utid: clientInfoParts.length < 2\r\n            ? Constants_Constants.EMPTY_STRING\r\n            : clientInfoParts[1],\r\n    };\r\n}\n\n\n//# sourceMappingURL=ClientInfo.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/account/AccountInfo.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Returns true if tenantId matches the utid portion of homeAccountId\r\n * @param tenantId\r\n * @param homeAccountId\r\n * @returns\r\n */\r\nfunction tenantIdMatchesHomeTenant(tenantId, homeAccountId) {\r\n    return (!!tenantId &&\r\n        !!homeAccountId &&\r\n        tenantId === homeAccountId.split(".")[1]);\r\n}\r\n/**\r\n * Build tenant profile\r\n * @param homeAccountId - Home account identifier for this account object\r\n * @param localAccountId - Local account identifer for this account object\r\n * @param tenantId - Full tenant or organizational id that this account belongs to\r\n * @param idTokenClaims - Claims from the ID token\r\n * @returns\r\n */\r\nfunction buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {\r\n    if (idTokenClaims) {\r\n        const { oid, sub, tid, name, tfp, acr } = idTokenClaims;\r\n        /**\r\n         * Since there is no way to determine if the authority is AAD or B2C, we exhaust all the possible claims that can serve as tenant ID with the following precedence:\r\n         * tid - TenantID claim that identifies the tenant that issued the token in AAD. Expected in all AAD ID tokens, not present in B2C ID Tokens.\r\n         * tfp - Trust Framework Policy claim that identifies the policy that was used to authenticate the user. Functions as tenant for B2C scenarios.\r\n         * acr - Authentication Context Class Reference claim used only with older B2C policies. Fallback in case tfp is not present, but likely won\'t be present anyway.\r\n         */\r\n        const tenantId = tid || tfp || acr || "";\r\n        return {\r\n            tenantId: tenantId,\r\n            localAccountId: oid || sub || "",\r\n            name: name,\r\n            isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId),\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            tenantId,\r\n            localAccountId,\r\n            isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId),\r\n        };\r\n    }\r\n}\r\n/**\r\n * Replaces account info that varies by tenant profile sourced from the ID token claims passed in with the tenant-specific account info\r\n * @param baseAccountInfo\r\n * @param idTokenClaims\r\n * @returns\r\n */\r\nfunction updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {\r\n    let updatedAccountInfo = baseAccountInfo;\r\n    // Tenant Profile overrides passed in account info\r\n    if (tenantProfile) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;\r\n        updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };\r\n    }\r\n    // ID token claims override passed in account info and tenant profile\r\n    if (idTokenClaims) {\r\n        // Ignore isHomeTenant, loginHint, and sid which are part of tenant profile but not base account info\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);\r\n        updatedAccountInfo = {\r\n            ...updatedAccountInfo,\r\n            ...claimsSourcedTenantProfile,\r\n            idTokenClaims: idTokenClaims,\r\n            idToken: idTokenSecret,\r\n        };\r\n        return updatedAccountInfo;\r\n    }\r\n    return updatedAccountInfo;\r\n}\n\n\n//# sourceMappingURL=AccountInfo.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/account/TokenClaims.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Gets tenantId from available ID token claims to set as credential realm with the following precedence:\r\n * 1. tid - if the token is acquired from an Azure AD tenant tid will be present\r\n * 2. tfp - if the token is acquired from a modern B2C tenant tfp should be present\r\n * 3. acr - if the token is acquired from a legacy B2C tenant acr should be present\r\n * Downcased to match the realm case-insensitive comparison requirements\r\n * @param idTokenClaims\r\n * @returns\r\n */\r\nfunction getTenantIdFromIdTokenClaims(idTokenClaims) {\r\n    if (idTokenClaims) {\r\n        const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;\r\n        return tenantId || null;\r\n    }\r\n    return null;\r\n}\n\n\n//# sourceMappingURL=TokenClaims.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/cache/entities/AccountEntity.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      nativeAccountId: Account identifier on the native device\r\n *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser\r\n * }\r\n * @internal\r\n */\r\nclass AccountEntity {\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    generateAccountId() {\r\n        const accountId = [this.homeAccountId, this.environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n    /**\r\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n     */\r\n    generateAccountKey() {\r\n        return AccountEntity.generateAccountCacheKey({\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId,\r\n        });\r\n    }\r\n    /**\r\n     * Returns the AccountInfo interface for this account.\r\n     */\r\n    getAccountInfo() {\r\n        return {\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId,\r\n            name: this.name,\r\n            nativeAccountId: this.nativeAccountId,\r\n            authorityType: this.authorityType,\r\n            // Deserialize tenant profiles array into a Map\r\n            tenantProfiles: new Map((this.tenantProfiles || []).map((tenantProfile) => {\r\n                return [tenantProfile.tenantId, tenantProfile];\r\n            })),\r\n        };\r\n    }\r\n    /**\r\n     * Returns true if the account entity is in single tenant format (outdated), false otherwise\r\n     */\r\n    isSingleTenant() {\r\n        return !this.tenantProfiles;\r\n    }\r\n    /**\r\n     * Generates account key from interface\r\n     * @param accountInterface\r\n     */\r\n    static generateAccountCacheKey(accountInterface) {\r\n        const homeTenantId = accountInterface.homeAccountId.split(".")[1];\r\n        const accountKey = [\r\n            accountInterface.homeAccountId,\r\n            accountInterface.environment || "",\r\n            homeTenantId || accountInterface.tenantId || "",\r\n        ];\r\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n    /**\r\n     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n     * @param accountDetails\r\n     */\r\n    static createAccount(accountDetails, authority, base64Decode) {\r\n        const account = new AccountEntity();\r\n        if (authority.authorityType === AuthorityType.Adfs) {\r\n            account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\r\n        }\r\n        else if (authority.protocolMode === ProtocolMode_ProtocolMode.OIDC) {\r\n            account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        }\r\n        else {\r\n            account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\r\n        }\r\n        let clientInfo;\r\n        if (accountDetails.clientInfo && base64Decode) {\r\n            clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);\r\n        }\r\n        account.clientInfo = accountDetails.clientInfo;\r\n        account.homeAccountId = accountDetails.homeAccountId;\r\n        account.nativeAccountId = accountDetails.nativeAccountId;\r\n        const env = accountDetails.environment ||\r\n            (authority && authority.getPreferredCache());\r\n        if (!env) {\r\n            throw ClientAuthError_createClientAuthError(invalidCacheEnvironment);\r\n        }\r\n        account.environment = env;\r\n        // non AAD scenarios can have empty realm\r\n        account.realm =\r\n            clientInfo?.utid ||\r\n                getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) ||\r\n                "";\r\n        // How do you account for MSA CID here?\r\n        account.localAccountId =\r\n            clientInfo?.uid ||\r\n                accountDetails.idTokenClaims?.oid ||\r\n                accountDetails.idTokenClaims?.sub ||\r\n                "";\r\n        /*\r\n         * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n         * In most cases it will contain a single email. This field should not be relied upon if a custom\r\n         * policy is configured to return more than 1 email.\r\n         */\r\n        const preferredUsername = accountDetails.idTokenClaims?.preferred_username ||\r\n            accountDetails.idTokenClaims?.upn;\r\n        const email = accountDetails.idTokenClaims?.emails\r\n            ? accountDetails.idTokenClaims.emails[0]\r\n            : null;\r\n        account.username = preferredUsername || email || "";\r\n        account.name = accountDetails.idTokenClaims?.name || "";\r\n        account.cloudGraphHostName = accountDetails.cloudGraphHostName;\r\n        account.msGraphHost = accountDetails.msGraphHost;\r\n        if (accountDetails.tenantProfiles) {\r\n            account.tenantProfiles = accountDetails.tenantProfiles;\r\n        }\r\n        else {\r\n            const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);\r\n            account.tenantProfiles = [tenantProfile];\r\n        }\r\n        return account;\r\n    }\r\n    /**\r\n     * Creates an AccountEntity object from AccountInfo\r\n     * @param accountInfo\r\n     * @param cloudGraphHostName\r\n     * @param msGraphHost\r\n     * @returns\r\n     */\r\n    static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {\r\n        const account = new AccountEntity();\r\n        account.authorityType =\r\n            accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        account.homeAccountId = accountInfo.homeAccountId;\r\n        account.localAccountId = accountInfo.localAccountId;\r\n        account.nativeAccountId = accountInfo.nativeAccountId;\r\n        account.realm = accountInfo.tenantId;\r\n        account.environment = accountInfo.environment;\r\n        account.username = accountInfo.username;\r\n        account.name = accountInfo.name;\r\n        account.cloudGraphHostName = cloudGraphHostName;\r\n        account.msGraphHost = msGraphHost;\r\n        // Serialize tenant profiles map into an array\r\n        account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);\r\n        return account;\r\n    }\r\n    /**\r\n     * Generate HomeAccountId from server response\r\n     * @param serverClientInfo\r\n     * @param authType\r\n     */\r\n    static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {\r\n        // since ADFS/DSTS do not have tid and does not set client_info\r\n        if (!(authType === AuthorityType.Adfs ||\r\n            authType === AuthorityType.Dsts)) {\r\n            // for cases where there is clientInfo\r\n            if (serverClientInfo) {\r\n                try {\r\n                    const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);\r\n                    if (clientInfo.uid && clientInfo.utid) {\r\n                        return `${clientInfo.uid}.${clientInfo.utid}`;\r\n                    }\r\n                }\r\n                catch (e) { }\r\n            }\r\n            logger.warning("No client info in response");\r\n        }\r\n        // default to "sub" claim\r\n        return idTokenClaims?.sub || "";\r\n    }\r\n    /**\r\n     * Validates an entity: checks for all expected params\r\n     * @param entity\r\n     */\r\n    static isAccountEntity(entity) {\r\n        if (!entity) {\r\n            return false;\r\n        }\r\n        return (entity.hasOwnProperty("homeAccountId") &&\r\n            entity.hasOwnProperty("environment") &&\r\n            entity.hasOwnProperty("realm") &&\r\n            entity.hasOwnProperty("localAccountId") &&\r\n            entity.hasOwnProperty("username") &&\r\n            entity.hasOwnProperty("authorityType"));\r\n    }\r\n    /**\r\n     * Helper function to determine whether 2 accountInfo objects represent the same account\r\n     * @param accountA\r\n     * @param accountB\r\n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n     */\r\n    static accountInfoIsEqual(accountA, accountB, compareClaims) {\r\n        if (!accountA || !accountB) {\r\n            return false;\r\n        }\r\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\r\n        if (compareClaims) {\r\n            const accountAClaims = (accountA.idTokenClaims ||\r\n                {});\r\n            const accountBClaims = (accountB.idTokenClaims ||\r\n                {});\r\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\r\n            claimsMatch =\r\n                accountAClaims.iat === accountBClaims.iat &&\r\n                    accountAClaims.nonce === accountBClaims.nonce;\r\n        }\r\n        return (accountA.homeAccountId === accountB.homeAccountId &&\r\n            accountA.localAccountId === accountB.localAccountId &&\r\n            accountA.username === accountB.username &&\r\n            accountA.tenantId === accountB.tenantId &&\r\n            accountA.environment === accountB.environment &&\r\n            accountA.nativeAccountId === accountB.nativeAccountId &&\r\n            claimsMatch);\r\n    }\r\n}\n\n\n//# sourceMappingURL=AccountEntity.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/CacheErrorCodes.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst cacheQuotaExceededErrorCode = "cache_quota_exceeded";\r\nconst cacheUnknownErrorCode = "cache_error_unknown";\n\n\n//# sourceMappingURL=CacheErrorCodes.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/CacheError.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst CacheErrorMessages = {\r\n    [cacheQuotaExceededErrorCode]: "Exceeded cache storage capacity.",\r\n    [cacheUnknownErrorCode]: "Unexpected error occurred when using cache storage.",\r\n};\r\n/**\r\n * Error thrown when there is an error with the cache\r\n */\r\nclass CacheError extends Error {\r\n    constructor(errorCode, errorMessage) {\r\n        const message = errorMessage ||\r\n            (CacheErrorMessages[errorCode]\r\n                ? CacheErrorMessages[errorCode]\r\n                : CacheErrorMessages[cacheUnknownErrorCode]);\r\n        super(`${errorCode}: ${message}`);\r\n        Object.setPrototypeOf(this, CacheError.prototype);\r\n        this.name = "CacheError";\r\n        this.errorCode = errorCode;\r\n        this.errorMessage = message;\r\n    }\r\n}\n\n\n//# sourceMappingURL=CacheError.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/cache/CacheManager.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n * @internal\r\n */\r\nclass CacheManager {\r\n    constructor(clientId, cryptoImpl, logger, staticAuthorityOptions) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n        this.commonLogger = logger.clone(packageMetadata_name, packageMetadata_version);\r\n        this.staticAuthorityOptions = staticAuthorityOptions;\r\n    }\r\n    /**\r\n     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\r\n     * @param accountFilter - (Optional) filter to narrow down the accounts returned\r\n     * @returns Array of AccountInfo objects in cache\r\n     */\r\n    getAllAccounts(accountFilter) {\r\n        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter || {}), accountFilter);\r\n    }\r\n    /**\r\n     * Gets first tenanted AccountInfo object found based on provided filters\r\n     */\r\n    getAccountInfoFilteredBy(accountFilter) {\r\n        const allAccounts = this.getAllAccounts(accountFilter);\r\n        if (allAccounts.length > 1) {\r\n            // If one or more accounts are found, prioritize accounts that have an ID token\r\n            const sortedAccounts = allAccounts.sort((account) => {\r\n                return account.idTokenClaims ? -1 : 1;\r\n            });\r\n            return sortedAccounts[0];\r\n        }\r\n        else if (allAccounts.length === 1) {\r\n            // If only one account is found, return it regardless of whether a matching ID token was found\r\n            return allAccounts[0];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a single matching\r\n     * @param accountFilter\r\n     * @returns\r\n     */\r\n    getBaseAccountInfo(accountFilter) {\r\n        const accountEntities = this.getAccountsFilteredBy(accountFilter);\r\n        if (accountEntities.length > 0) {\r\n            return accountEntities[0].getAccountInfo();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters\r\n     * and builds the account info objects from the matching ID token\'s claims\r\n     * @param cachedAccounts\r\n     * @param accountFilter\r\n     * @returns Array of AccountInfo objects that match account and tenant profile filters\r\n     */\r\n    buildTenantProfiles(cachedAccounts, accountFilter) {\r\n        return cachedAccounts.flatMap((accountEntity) => {\r\n            return this.getTenantProfilesFromAccountEntity(accountEntity, accountFilter?.tenantId, accountFilter);\r\n        });\r\n    }\r\n    getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter) {\r\n        let tenantedAccountInfo = null;\r\n        let idTokenClaims;\r\n        if (tenantProfileFilter) {\r\n            if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {\r\n                return null;\r\n            }\r\n        }\r\n        const idToken = this.getIdToken(accountInfo, tokenKeys, tenantProfile.tenantId);\r\n        if (idToken) {\r\n            idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);\r\n            if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {\r\n                // ID token sourced claims don\'t match so this tenant profile is not a match\r\n                return null;\r\n            }\r\n        }\r\n        // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims\r\n        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);\r\n        return tenantedAccountInfo;\r\n    }\r\n    getTenantProfilesFromAccountEntity(accountEntity, targetTenantId, tenantProfileFilter) {\r\n        const accountInfo = accountEntity.getAccountInfo();\r\n        let searchTenantProfiles = accountInfo.tenantProfiles || new Map();\r\n        const tokenKeys = this.getTokenKeys();\r\n        // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists\r\n        if (targetTenantId) {\r\n            const tenantProfile = searchTenantProfiles.get(targetTenantId);\r\n            if (tenantProfile) {\r\n                // Reduce search field to just this tenant profile\r\n                searchTenantProfiles = new Map([\r\n                    [targetTenantId, tenantProfile],\r\n                ]);\r\n            }\r\n            else {\r\n                // No tenant profile for search tenant ID, return empty array\r\n                return [];\r\n            }\r\n        }\r\n        const matchingTenantProfiles = [];\r\n        searchTenantProfiles.forEach((tenantProfile) => {\r\n            const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, tenantProfileFilter);\r\n            if (tenantedAccountInfo) {\r\n                matchingTenantProfiles.push(tenantedAccountInfo);\r\n            }\r\n        });\r\n        return matchingTenantProfiles;\r\n    }\r\n    tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {\r\n        if (!!tenantProfileFilter.localAccountId &&\r\n            !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {\r\n            return false;\r\n        }\r\n        if (!!tenantProfileFilter.name &&\r\n            !(tenantProfile.name === tenantProfileFilter.name)) {\r\n            return false;\r\n        }\r\n        if (tenantProfileFilter.isHomeTenant !== undefined &&\r\n            !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {\r\n        // Tenant Profile filtering\r\n        if (tenantProfileFilter) {\r\n            if (!!tenantProfileFilter.localAccountId &&\r\n                !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {\r\n                return false;\r\n            }\r\n            if (!!tenantProfileFilter.loginHint &&\r\n                !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {\r\n                return false;\r\n            }\r\n            if (!!tenantProfileFilter.username &&\r\n                !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {\r\n                return false;\r\n            }\r\n            if (!!tenantProfileFilter.name &&\r\n                !this.matchName(idTokenClaims, tenantProfileFilter.name)) {\r\n                return false;\r\n            }\r\n            if (!!tenantProfileFilter.sid &&\r\n                !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord {CacheRecord}\r\n     * @param storeInCache {?StoreInCache}\r\n     * @param correlationId {?string} correlation id\r\n     */\r\n    async saveCacheRecord(cacheRecord, correlationId, storeInCache) {\r\n        if (!cacheRecord) {\r\n            throw ClientAuthError_createClientAuthError(invalidCacheRecord);\r\n        }\r\n        try {\r\n            if (!!cacheRecord.account) {\r\n                await this.setAccount(cacheRecord.account, correlationId);\r\n            }\r\n            if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\r\n                await this.setIdTokenCredential(cacheRecord.idToken, correlationId);\r\n            }\r\n            if (!!cacheRecord.accessToken &&\r\n                storeInCache?.accessToken !== false) {\r\n                await this.saveAccessToken(cacheRecord.accessToken, correlationId);\r\n            }\r\n            if (!!cacheRecord.refreshToken &&\r\n                storeInCache?.refreshToken !== false) {\r\n                await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId);\r\n            }\r\n            if (!!cacheRecord.appMetadata) {\r\n                this.setAppMetadata(cacheRecord.appMetadata);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);\r\n            if (e instanceof Error) {\r\n                this.commonLogger?.errorPii(`CacheManager.saveCacheRecord: ${e.message}`, correlationId);\r\n                if (e.name === "QuotaExceededError" ||\r\n                    e.name === "NS_ERROR_DOM_QUOTA_REACHED" ||\r\n                    e.message.includes("exceeded the quota")) {\r\n                    this.commonLogger?.error(`CacheManager.saveCacheRecord: exceeded storage quota`, correlationId);\r\n                    throw new CacheError(cacheQuotaExceededErrorCode);\r\n                }\r\n                else {\r\n                    throw new CacheError(e.name, e.message);\r\n                }\r\n            }\r\n            else {\r\n                this.commonLogger?.errorPii(`CacheManager.saveCacheRecord: ${e}`, correlationId);\r\n                throw new CacheError(cacheUnknownErrorCode);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    async saveAccessToken(credential, correlationId) {\r\n        const accessTokenFilter = {\r\n            clientId: credential.clientId,\r\n            credentialType: credential.credentialType,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm,\r\n            tokenType: credential.tokenType,\r\n            requestedClaimsHash: credential.requestedClaimsHash,\r\n        };\r\n        const tokenKeys = this.getTokenKeys();\r\n        const currentScopes = ScopeSet.fromString(credential.target);\r\n        const removedAccessTokens = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\r\n                return;\r\n            }\r\n            const tokenEntity = this.getAccessTokenCredential(key);\r\n            if (tokenEntity &&\r\n                this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\r\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    removedAccessTokens.push(this.removeAccessToken(key));\r\n                }\r\n            }\r\n        });\r\n        await Promise.all(removedAccessTokens);\r\n        await this.setAccessTokenCredential(credential, correlationId);\r\n    }\r\n    /**\r\n     * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache\r\n     * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param accountFilter - An object containing Account properties to filter by\r\n     */\r\n    getAccountsFilteredBy(accountFilter) {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const matchingAccounts = [];\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId)) {\r\n                // Don\'t parse value if the key doesn\'t match the account filters\r\n                return;\r\n            }\r\n            const entity = this.getAccount(cacheKey, this.commonLogger);\r\n            // Match base account fields\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!accountFilter.homeAccountId &&\r\n                !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\r\n                return;\r\n            }\r\n            if (!!accountFilter.username &&\r\n                !this.matchUsername(entity.username, accountFilter.username)) {\r\n                return;\r\n            }\r\n            if (!!accountFilter.environment &&\r\n                !this.matchEnvironment(entity, accountFilter.environment)) {\r\n                return;\r\n            }\r\n            if (!!accountFilter.realm &&\r\n                !this.matchRealm(entity, accountFilter.realm)) {\r\n                return;\r\n            }\r\n            if (!!accountFilter.nativeAccountId &&\r\n                !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\r\n                return;\r\n            }\r\n            if (!!accountFilter.authorityType &&\r\n                !this.matchAuthorityType(entity, accountFilter.authorityType)) {\r\n                return;\r\n            }\r\n            // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts\r\n            const tenantProfileFilter = {\r\n                localAccountId: accountFilter?.localAccountId,\r\n                name: accountFilter?.name,\r\n            };\r\n            const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {\r\n                return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);\r\n            });\r\n            if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {\r\n                // No tenant profile for this account matches filter, don\'t add to list of matching accounts\r\n                return;\r\n            }\r\n            matchingAccounts.push(entity);\r\n        });\r\n        return matchingAccounts;\r\n    }\r\n    /**\r\n     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n     * @param key\r\n     * @param homeAccountId\r\n     * @param tenantId\r\n     * @returns\r\n     */\r\n    isAccountKey(key, homeAccountId, tenantId) {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\r\n            // Account cache keys contain 3 items separated by \'-\' (each item may also contain \'-\')\r\n            return false;\r\n        }\r\n        if (homeAccountId &&\r\n            !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\r\n            return false;\r\n        }\r\n        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\r\n            return false;\r\n        }\r\n        // Do not check environment as aliasing can cause false negatives\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns true if the given key matches our credential key schema.\r\n     * @param key\r\n     */\r\n    isCredentialKey(key) {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\r\n            // Credential cache keys contain 6 items separated by \'-\' (each item may also contain \'-\')\r\n            return false;\r\n        }\r\n        const lowerCaseKey = key.toLowerCase();\r\n        // Credential keys must indicate what credential type they represent\r\n        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) ===\r\n            -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) ===\r\n                -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) ===\r\n                -1) {\r\n            return false;\r\n        }\r\n        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) >\r\n            -1) {\r\n            // Refresh tokens must contain the client id or family id\r\n            const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 &&\r\n                lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\r\n            // Tokens must contain the clientId\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns whether or not the given credential entity matches the filter\r\n     * @param entity\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    credentialMatchesFilter(entity, filter) {\r\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\r\n            return false;\r\n        }\r\n        if (!!filter.userAssertionHash &&\r\n            !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\r\n            return false;\r\n        }\r\n        /*\r\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of ""\r\n         * because we don\'t want a client_credential request to return a cached token that has a homeAccountId\r\n         */\r\n        if (typeof filter.homeAccountId === "string" &&\r\n            !this.matchHomeAccountId(entity, filter.homeAccountId)) {\r\n            return false;\r\n        }\r\n        if (!!filter.environment &&\r\n            !this.matchEnvironment(entity, filter.environment)) {\r\n            return false;\r\n        }\r\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\r\n            return false;\r\n        }\r\n        if (!!filter.credentialType &&\r\n            !this.matchCredentialType(entity, filter.credentialType)) {\r\n            return false;\r\n        }\r\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\r\n            return false;\r\n        }\r\n        /*\r\n         * idTokens do not have "target", target specific refreshTokens do exist for some types of authentication\r\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n         */\r\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\r\n            return false;\r\n        }\r\n        // If request OR cached entity has requested Claims Hash, check if they match\r\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\r\n            // Don\'t match if either is undefined or they are different\r\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\r\n                return false;\r\n            }\r\n        }\r\n        // Access Token with Auth Scheme specific matching\r\n        if (entity.credentialType ===\r\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\r\n            if (!!filter.tokenType &&\r\n                !this.matchTokenType(entity, filter.tokenType)) {\r\n                return false;\r\n            }\r\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\r\n            if (filter.tokenType === AuthenticationScheme.SSH) {\r\n                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    getAppMetadataFilteredBy(filter) {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAppMetadata = {};\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don\'t parse any non-appMetadata type cache entities\r\n            if (!this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            const entity = this.getAppMetadata(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!filter.environment &&\r\n                !this.matchEnvironment(entity, filter.environment)) {\r\n                return;\r\n            }\r\n            if (!!filter.clientId &&\r\n                !this.matchClientId(entity, filter.clientId)) {\r\n                return;\r\n            }\r\n            matchingAppMetadata[cacheKey] = entity;\r\n        });\r\n        return matchingAppMetadata;\r\n    }\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    getAuthorityMetadataByAlias(host) {\r\n        const allCacheKeys = this.getAuthorityMetadataKeys();\r\n        let matchedEntity = null;\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don\'t parse any non-authorityMetadata type cache entities\r\n            if (!this.isAuthorityMetadata(cacheKey) ||\r\n                cacheKey.indexOf(this.clientId) === -1) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            const entity = this.getAuthorityMetadata(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n            matchedEntity = entity;\r\n        });\r\n        return matchedEntity;\r\n    }\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    async removeAllAccounts() {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const removedAccounts = [];\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            removedAccounts.push(this.removeAccount(cacheKey));\r\n        });\r\n        await Promise.all(removedAccounts);\r\n    }\r\n    /**\r\n     * Removes the account and related tokens for a given account key\r\n     * @param account\r\n     */\r\n    async removeAccount(accountKey) {\r\n        const account = this.getAccount(accountKey, this.commonLogger);\r\n        if (!account) {\r\n            return;\r\n        }\r\n        await this.removeAccountContext(account);\r\n        this.removeItem(accountKey);\r\n    }\r\n    /**\r\n     * Removes credentials associated with the provided account\r\n     * @param account\r\n     */\r\n    async removeAccountContext(account) {\r\n        const allTokenKeys = this.getTokenKeys();\r\n        const accountId = account.generateAccountId();\r\n        const removedCredentials = [];\r\n        allTokenKeys.idToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeIdToken(key);\r\n            }\r\n        });\r\n        allTokenKeys.accessToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                removedCredentials.push(this.removeAccessToken(key));\r\n            }\r\n        });\r\n        allTokenKeys.refreshToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeRefreshToken(key);\r\n            }\r\n        });\r\n        await Promise.all(removedCredentials);\r\n    }\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    async removeAccessToken(key) {\r\n        const credential = this.getAccessTokenCredential(key);\r\n        if (!credential) {\r\n            return;\r\n        }\r\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\r\n        if (credential.credentialType.toLowerCase() ===\r\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\r\n            if (credential.tokenType === AuthenticationScheme.POP) {\r\n                const accessTokenWithAuthSchemeEntity = credential;\r\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\r\n                if (kid) {\r\n                    try {\r\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\r\n                    }\r\n                    catch (error) {\r\n                        throw ClientAuthError_createClientAuthError(bindingKeyNotRemoved);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this.removeItem(key);\r\n    }\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    removeAppMetadata() {\r\n        const allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            if (this.isAppMetadata(cacheKey)) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n        return true;\r\n    }\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    readAccountFromCache(account) {\r\n        const accountKey = AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey, this.commonLogger);\r\n    }\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param account {AccountInfo}\r\n     * @param tokenKeys {?TokenKeys}\r\n     * @param targetRealm {?string}\r\n     * @param performanceClient {?IPerformanceClient}\r\n     * @param correlationId {?string}\r\n     */\r\n    getIdToken(account, tokenKeys, targetRealm, performanceClient, correlationId) {\r\n        this.commonLogger.trace("CacheManager - getIdToken called");\r\n        const idTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: this.clientId,\r\n            realm: targetRealm,\r\n        };\r\n        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\r\n        const numIdTokens = idTokenMap.size;\r\n        if (numIdTokens < 1) {\r\n            this.commonLogger.info("CacheManager:getIdToken - No token found");\r\n            return null;\r\n        }\r\n        else if (numIdTokens > 1) {\r\n            let tokensToBeRemoved = idTokenMap;\r\n            // Multiple tenant profiles and no tenant specified, pick home account\r\n            if (!targetRealm) {\r\n                const homeIdTokenMap = new Map();\r\n                idTokenMap.forEach((idToken, key) => {\r\n                    if (idToken.realm === account.tenantId) {\r\n                        homeIdTokenMap.set(key, idToken);\r\n                    }\r\n                });\r\n                const numHomeIdTokens = homeIdTokenMap.size;\r\n                if (numHomeIdTokens < 1) {\r\n                    this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");\r\n                    return idTokenMap.values().next().value;\r\n                }\r\n                else if (numHomeIdTokens === 1) {\r\n                    this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");\r\n                    return homeIdTokenMap.values().next().value;\r\n                }\r\n                else {\r\n                    // Multiple ID tokens for home tenant profile, remove all and return null\r\n                    tokensToBeRemoved = homeIdTokenMap;\r\n                }\r\n            }\r\n            // Multiple tokens for a single tenant profile, remove all and return null\r\n            this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");\r\n            tokensToBeRemoved.forEach((idToken, key) => {\r\n                this.removeIdToken(key);\r\n            });\r\n            if (performanceClient && correlationId) {\r\n                performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);\r\n            }\r\n            return null;\r\n        }\r\n        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");\r\n        return idTokenMap.values().next().value;\r\n    }\r\n    /**\r\n     * Gets all idTokens matching the given filter\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    getIdTokensByFilter(filter, tokenKeys) {\r\n        const idTokenKeys = (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;\r\n        const idTokens = new Map();\r\n        idTokenKeys.forEach((key) => {\r\n            if (!this.idTokenKeyMatchesFilter(key, {\r\n                clientId: this.clientId,\r\n                ...filter,\r\n            })) {\r\n                return;\r\n            }\r\n            const idToken = this.getIdTokenCredential(key);\r\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\r\n                idTokens.set(key, idToken);\r\n            }\r\n        });\r\n        return idTokens;\r\n    }\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    idTokenKeyMatchesFilter(inputKey, filter) {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.clientId &&\r\n            key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        if (filter.homeAccountId &&\r\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes idToken from the cache\r\n     * @param key\r\n     */\r\n    removeIdToken(key) {\r\n        this.removeItem(key);\r\n    }\r\n    /**\r\n     * Removes refresh token from the cache\r\n     * @param key\r\n     */\r\n    removeRefreshToken(key) {\r\n        this.removeItem(key);\r\n    }\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param account {AccountInfo}\r\n     * @param request {BaseAuthRequest}\r\n     * @param tokenKeys {?TokenKeys}\r\n     * @param performanceClient {?IPerformanceClient}\r\n     * @param correlationId {?string}\r\n     */\r\n    getAccessToken(account, request, tokenKeys, targetRealm, performanceClient, correlationId) {\r\n        this.commonLogger.trace("CacheManager - getAccessToken called");\r\n        const scopes = ScopeSet.createSearchScopes(request.scopes);\r\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle "bearer" from ADFS\r\n         */\r\n        const credentialType = authScheme &&\r\n            authScheme.toLowerCase() !==\r\n                AuthenticationScheme.BEARER.toLowerCase()\r\n            ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\r\n            : CredentialType.ACCESS_TOKEN;\r\n        const accessTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId: this.clientId,\r\n            realm: targetRealm || account.tenantId,\r\n            target: scopes,\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n        };\r\n        const accessTokenKeys = (tokenKeys && tokenKeys.accessToken) ||\r\n            this.getTokenKeys().accessToken;\r\n        const accessTokens = [];\r\n        accessTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\r\n                const accessToken = this.getAccessTokenCredential(key);\r\n                // Validate value\r\n                if (accessToken &&\r\n                    this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\r\n                    accessTokens.push(accessToken);\r\n                }\r\n            }\r\n        });\r\n        const numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            this.commonLogger.info("CacheManager:getAccessToken - No token found");\r\n            return null;\r\n        }\r\n        else if (numAccessTokens > 1) {\r\n            this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them");\r\n            accessTokens.forEach((accessToken) => {\r\n                void this.removeAccessToken(generateCredentialKey(accessToken));\r\n            });\r\n            if (performanceClient && correlationId) {\r\n                performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);\r\n            }\r\n            return null;\r\n        }\r\n        this.commonLogger.info("CacheManager:getAccessToken - Returning access token");\r\n        return accessTokens[0];\r\n    }\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     * @param keyMustContainAllScopes\r\n     * @returns\r\n     */\r\n    accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.clientId &&\r\n            key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        if (filter.homeAccountId &&\r\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        if (filter.requestedClaimsHash &&\r\n            key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        if (filter.target) {\r\n            const scopes = filter.target.asArray();\r\n            for (let i = 0; i < scopes.length; i++) {\r\n                if (keyMustContainAllScopes &&\r\n                    !key.includes(scopes[i].toLowerCase())) {\r\n                    // When performing a cache lookup a missing scope would be a cache miss\r\n                    return false;\r\n                }\r\n                else if (!keyMustContainAllScopes &&\r\n                    key.includes(scopes[i].toLowerCase())) {\r\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets all access tokens matching the filter\r\n     * @param filter\r\n     * @returns\r\n     */\r\n    getAccessTokensByFilter(filter) {\r\n        const tokenKeys = this.getTokenKeys();\r\n        const accessTokens = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\r\n                return;\r\n            }\r\n            const accessToken = this.getAccessTokenCredential(key);\r\n            if (accessToken &&\r\n                this.credentialMatchesFilter(accessToken, filter)) {\r\n                accessTokens.push(accessToken);\r\n            }\r\n        });\r\n        return accessTokens;\r\n    }\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param account {AccountInfo}\r\n     * @param familyRT {boolean}\r\n     * @param tokenKeys {?TokenKeys}\r\n     * @param performanceClient {?IPerformanceClient}\r\n     * @param correlationId {?string}\r\n     */\r\n    getRefreshToken(account, familyRT, tokenKeys, performanceClient, correlationId) {\r\n        this.commonLogger.trace("CacheManager - getRefreshToken called");\r\n        const id = familyRT ? THE_FAMILY_ID : undefined;\r\n        const refreshTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: this.clientId,\r\n            familyId: id,\r\n        };\r\n        const refreshTokenKeys = (tokenKeys && tokenKeys.refreshToken) ||\r\n            this.getTokenKeys().refreshToken;\r\n        const refreshTokens = [];\r\n        refreshTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\r\n                const refreshToken = this.getRefreshTokenCredential(key);\r\n                // Validate value\r\n                if (refreshToken &&\r\n                    this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\r\n                    refreshTokens.push(refreshToken);\r\n                }\r\n            }\r\n        });\r\n        const numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n        if (numRefreshTokens > 1 && performanceClient && correlationId) {\r\n            performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);\r\n        }\r\n        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");\r\n        return refreshTokens[0];\r\n    }\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     */\r\n    refreshTokenKeyMatchesFilter(inputKey, filter) {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.familyId &&\r\n            key.indexOf(filter.familyId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        // If familyId is used, clientId is not in the key\r\n        if (!filter.familyId &&\r\n            filter.clientId &&\r\n            key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        if (filter.homeAccountId &&\r\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    readAppMetadataFromCache(environment) {\r\n        const appMetadataFilter = {\r\n            environment,\r\n            clientId: this.clientId,\r\n        };\r\n        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);\r\n        const numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        }\r\n        else if (numAppMetadata > 1) {\r\n            throw ClientAuthError_createClientAuthError(multipleMatchingAppMetadata);\r\n        }\r\n        return appMetadataEntries[0];\r\n    }\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    isAppMetadataFOCI(environment) {\r\n        const appMetadata = this.readAppMetadataFromCache(environment);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    }\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    matchHomeAccountId(entity, homeAccountId) {\r\n        return !!(typeof entity.homeAccountId === "string" &&\r\n            homeAccountId === entity.homeAccountId);\r\n    }\r\n    /**\r\n     * helper to match account ids\r\n     * @param entity\r\n     * @param localAccountId\r\n     * @returns\r\n     */\r\n    matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {\r\n        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;\r\n        return localAccountId === idTokenLocalAccountId;\r\n    }\r\n    matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {\r\n        return tenantProfile.localAccountId === localAccountId;\r\n    }\r\n    /**\r\n     * helper to match names\r\n     * @param entity\r\n     * @param name\r\n     * @returns true if the downcased name properties are present and match in the filter and the entity\r\n     */\r\n    matchName(claims, name) {\r\n        return !!(name.toLowerCase() === claims.name?.toLowerCase());\r\n    }\r\n    /**\r\n     * helper to match usernames\r\n     * @param entity\r\n     * @param username\r\n     * @returns\r\n     */\r\n    matchUsername(cachedUsername, filterUsername) {\r\n        return !!(cachedUsername &&\r\n            typeof cachedUsername === "string" &&\r\n            filterUsername?.toLowerCase() === cachedUsername.toLowerCase());\r\n    }\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    matchUserAssertionHash(entity, userAssertionHash) {\r\n        return !!(entity.userAssertionHash &&\r\n            userAssertionHash === entity.userAssertionHash);\r\n    }\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    matchEnvironment(entity, environment) {\r\n        // Check static authority options first for cases where authority metadata has not been resolved and cached yet\r\n        if (this.staticAuthorityOptions) {\r\n            const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);\r\n            if (staticAliases.includes(environment) &&\r\n                staticAliases.includes(entity.environment)) {\r\n                return true;\r\n            }\r\n        }\r\n        // Query metadata cache if no static authority configuration has aliases that match enviroment\r\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (cloudMetadata &&\r\n            cloudMetadata.aliases.indexOf(entity.environment) > -1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    matchCredentialType(entity, credentialType) {\r\n        return (entity.credentialType &&\r\n            credentialType.toLowerCase() === entity.credentialType.toLowerCase());\r\n    }\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    matchClientId(entity, clientId) {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    }\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    matchFamilyId(entity, familyId) {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    }\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    matchRealm(entity, realm) {\r\n        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());\r\n    }\r\n    /**\r\n     * helper to match nativeAccountId\r\n     * @param entity\r\n     * @param nativeAccountId\r\n     * @returns boolean indicating the match result\r\n     */\r\n    matchNativeAccountId(entity, nativeAccountId) {\r\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\r\n    }\r\n    /**\r\n     * helper to match loginHint which can be either:\r\n     * 1. login_hint ID token claim\r\n     * 2. username in cached account object\r\n     * 3. upn in ID token claims\r\n     * @param entity\r\n     * @param loginHint\r\n     * @returns\r\n     */\r\n    matchLoginHintFromTokenClaims(tokenClaims, loginHint) {\r\n        if (tokenClaims.login_hint === loginHint) {\r\n            return true;\r\n        }\r\n        if (tokenClaims.preferred_username === loginHint) {\r\n            return true;\r\n        }\r\n        if (tokenClaims.upn === loginHint) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Helper to match sid\r\n     * @param entity\r\n     * @param sid\r\n     * @returns true if the sid claim is present and matches the filter\r\n     */\r\n    matchSid(idTokenClaims, sid) {\r\n        return idTokenClaims.sid === sid;\r\n    }\r\n    matchAuthorityType(entity, authorityType) {\r\n        return !!(entity.authorityType &&\r\n            authorityType.toLowerCase() === entity.authorityType.toLowerCase());\r\n    }\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity\'s scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    matchTarget(entity, target) {\r\n        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN &&\r\n            entity.credentialType !==\r\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\r\n        if (isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n        const entityScopeSet = ScopeSet.fromString(entity.target);\r\n        return entityScopeSet.containsScopeSet(target);\r\n    }\r\n    /**\r\n     * Returns true if the credential\'s tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    matchTokenType(entity, tokenType) {\r\n        return !!(entity.tokenType && entity.tokenType === tokenType);\r\n    }\r\n    /**\r\n     * Returns true if the credential\'s keyId matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param keyId\r\n     */\r\n    matchKeyId(entity, keyId) {\r\n        return !!(entity.keyId && entity.keyId === keyId);\r\n    }\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    isAppMetadata(key) {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    }\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    isAuthorityMetadata(key) {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    }\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    generateAuthorityMetadataCacheKey(authority) {\r\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\r\n    }\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    static toObject(obj, json) {\r\n        for (const propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    }\r\n}\r\n/** @internal */\r\nclass DefaultStorageClass extends CacheManager {\r\n    async setAccount() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getAccount() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    async setIdTokenCredential() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getIdTokenCredential() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    async setAccessTokenCredential() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getAccessTokenCredential() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    async setRefreshTokenCredential() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getRefreshTokenCredential() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    setAppMetadata() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getAppMetadata() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    setServerTelemetry() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getServerTelemetry() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    setAuthorityMetadata() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getAuthorityMetadata() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getAuthorityMetadataKeys() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    setThrottlingCache() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getThrottlingCache() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    removeItem() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getKeys() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getAccountKeys() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n    getTokenKeys() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    }\r\n}\n\n\n//# sourceMappingURL=CacheManager.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/config/ClientConfiguration.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst DEFAULT_SYSTEM_OPTIONS = {\r\n    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,\r\n    preventCorsPreflight: false,\r\n};\r\nconst DEFAULT_LOGGER_IMPLEMENTATION = {\r\n    loggerCallback: () => {\r\n        // allow users to not set loggerCallback\r\n    },\r\n    piiLoggingEnabled: false,\r\n    logLevel: LogLevel.Info,\r\n    correlationId: Constants_Constants.EMPTY_STRING,\r\n};\r\nconst DEFAULT_CACHE_OPTIONS = {\r\n    claimsBasedCachingEnabled: false,\r\n};\r\nconst DEFAULT_NETWORK_IMPLEMENTATION = {\r\n    async sendGetRequestAsync() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n    async sendPostRequestAsync() {\r\n        throw ClientAuthError_createClientAuthError(methodNotImplemented);\r\n    },\r\n};\r\nconst DEFAULT_LIBRARY_INFO = {\r\n    sku: Constants_Constants.SKU,\r\n    version: packageMetadata_version,\r\n    cpu: Constants_Constants.EMPTY_STRING,\r\n    os: Constants_Constants.EMPTY_STRING,\r\n};\r\nconst DEFAULT_CLIENT_CREDENTIALS = {\r\n    clientSecret: Constants_Constants.EMPTY_STRING,\r\n    clientAssertion: undefined,\r\n};\r\nconst DEFAULT_AZURE_CLOUD_OPTIONS = {\r\n    azureCloudInstance: AzureCloudInstance.None,\r\n    tenant: `${Constants_Constants.DEFAULT_COMMON_TENANT}`,\r\n};\r\nconst DEFAULT_TELEMETRY_OPTIONS = {\r\n    application: {\r\n        appName: "",\r\n        appVersion: "",\r\n    },\r\n};\r\n/**\r\n * Function that sets the default options when not explicitly configured from app developer\r\n *\r\n * @param Configuration\r\n *\r\n * @returns Configuration\r\n */\r\nfunction buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials: clientCredentials, libraryInfo: libraryInfo, telemetry: telemetry, serverTelemetryManager: serverTelemetryManager, persistencePlugin: persistencePlugin, serializableCache: serializableCache, }) {\r\n    const loggerOptions = {\r\n        ...DEFAULT_LOGGER_IMPLEMENTATION,\r\n        ...userLoggerOption,\r\n    };\r\n    return {\r\n        authOptions: buildAuthOptions(userAuthOptions),\r\n        systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },\r\n        loggerOptions: loggerOptions,\r\n        cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },\r\n        storageInterface: storageImplementation ||\r\n            new DefaultStorageClass(userAuthOptions.clientId, ICrypto_DEFAULT_CRYPTO_IMPLEMENTATION, new Logger_Logger(loggerOptions)),\r\n        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,\r\n        cryptoInterface: cryptoImplementation || ICrypto_DEFAULT_CRYPTO_IMPLEMENTATION,\r\n        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,\r\n        libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },\r\n        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },\r\n        serverTelemetryManager: serverTelemetryManager || null,\r\n        persistencePlugin: persistencePlugin || null,\r\n        serializableCache: serializableCache || null,\r\n    };\r\n}\r\n/**\r\n * Construct authoptions from the client and platform passed values\r\n * @param authOptions\r\n */\r\nfunction buildAuthOptions(authOptions) {\r\n    return {\r\n        clientCapabilities: [],\r\n        azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,\r\n        skipAuthorityMetadataCache: false,\r\n        instanceAware: false,\r\n        encodeExtraQueryParams: false,\r\n        ...authOptions,\r\n    };\r\n}\r\n/**\r\n * Returns true if config has protocolMode set to ProtocolMode.OIDC, false otherwise\r\n * @param ClientConfiguration\r\n */\r\nfunction isOidcProtocolMode(config) {\r\n    return (config.authOptions.authority.options.protocolMode === ProtocolMode_ProtocolMode.OIDC);\r\n}\n\n\n//# sourceMappingURL=ClientConfiguration.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/account/CcsCredential.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst CcsCredentialType = {\r\n    HOME_ACCOUNT_ID: "home_account_id",\r\n    UPN: "UPN",\r\n};\n\n\n//# sourceMappingURL=CcsCredential.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/request/RequestParameterBuilder.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nfunction instrumentBrokerParams(parameters, correlationId, performanceClient) {\r\n    if (!correlationId) {\r\n        return;\r\n    }\r\n    const clientId = parameters.get(CLIENT_ID);\r\n    if (clientId && parameters.has(BROKER_CLIENT_ID)) {\r\n        performanceClient?.addFields({\r\n            embeddedClientId: clientId,\r\n            embeddedRedirectUri: parameters.get(REDIRECT_URI),\r\n        }, correlationId);\r\n    }\r\n}\r\n/**\r\n * Add the given response_type\r\n * @param parameters\r\n * @param responseType\r\n */\r\nfunction addResponseType(parameters, responseType) {\r\n    parameters.set(RESPONSE_TYPE, responseType);\r\n}\r\n/**\r\n * add response_mode. defaults to query.\r\n * @param responseMode\r\n */\r\nfunction addResponseMode(parameters, responseMode) {\r\n    parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);\r\n}\r\n/**\r\n * Add flag to indicate STS should attempt to use WAM if available\r\n */\r\nfunction addNativeBroker(parameters) {\r\n    parameters.set(NATIVE_BROKER, "1");\r\n}\r\n/**\r\n * add scopes. set addOidcScopes to false to prevent default scopes in non-user scenarios\r\n * @param scopeSet\r\n * @param addOidcScopes\r\n */\r\nfunction addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {\r\n    // Always add openid to the scopes when adding OIDC scopes\r\n    if (addOidcScopes &&\r\n        !defaultScopes.includes("openid") &&\r\n        !scopes.includes("openid")) {\r\n        defaultScopes.push("openid");\r\n    }\r\n    const requestScopes = addOidcScopes\r\n        ? [...(scopes || []), ...defaultScopes]\r\n        : scopes || [];\r\n    const scopeSet = new ScopeSet(requestScopes);\r\n    parameters.set(SCOPE, scopeSet.printScopes());\r\n}\r\n/**\r\n * add clientId\r\n * @param clientId\r\n */\r\nfunction addClientId(parameters, clientId) {\r\n    parameters.set(CLIENT_ID, clientId);\r\n}\r\n/**\r\n * add redirect_uri\r\n * @param redirectUri\r\n */\r\nfunction addRedirectUri(parameters, redirectUri) {\r\n    parameters.set(REDIRECT_URI, redirectUri);\r\n}\r\n/**\r\n * add post logout redirectUri\r\n * @param redirectUri\r\n */\r\nfunction addPostLogoutRedirectUri(parameters, redirectUri) {\r\n    parameters.set(POST_LOGOUT_URI, redirectUri);\r\n}\r\n/**\r\n * add id_token_hint to logout request\r\n * @param idTokenHint\r\n */\r\nfunction addIdTokenHint(parameters, idTokenHint) {\r\n    parameters.set(ID_TOKEN_HINT, idTokenHint);\r\n}\r\n/**\r\n * add domain_hint\r\n * @param domainHint\r\n */\r\nfunction addDomainHint(parameters, domainHint) {\r\n    parameters.set(DOMAIN_HINT, domainHint);\r\n}\r\n/**\r\n * add login_hint\r\n * @param loginHint\r\n */\r\nfunction addLoginHint(parameters, loginHint) {\r\n    parameters.set(LOGIN_HINT, loginHint);\r\n}\r\n/**\r\n * Adds the CCS (Cache Credential Service) query parameter for login_hint\r\n * @param loginHint\r\n */\r\nfunction addCcsUpn(parameters, loginHint) {\r\n    parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);\r\n}\r\n/**\r\n * Adds the CCS (Cache Credential Service) query parameter for account object\r\n * @param loginHint\r\n */\r\nfunction addCcsOid(parameters, clientInfo) {\r\n    parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);\r\n}\r\n/**\r\n * add sid\r\n * @param sid\r\n */\r\nfunction addSid(parameters, sid) {\r\n    parameters.set(SID, sid);\r\n}\r\n/**\r\n * add claims\r\n * @param claims\r\n */\r\nfunction addClaims(parameters, claims, clientCapabilities) {\r\n    const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);\r\n    try {\r\n        JSON.parse(mergedClaims);\r\n    }\r\n    catch (e) {\r\n        throw ClientConfigurationError_createClientConfigurationError(invalidClaims);\r\n    }\r\n    parameters.set(CLAIMS, mergedClaims);\r\n}\r\n/**\r\n * add correlationId\r\n * @param correlationId\r\n */\r\nfunction addCorrelationId(parameters, correlationId) {\r\n    parameters.set(CLIENT_REQUEST_ID, correlationId);\r\n}\r\n/**\r\n * add library info query params\r\n * @param libraryInfo\r\n */\r\nfunction addLibraryInfo(parameters, libraryInfo) {\r\n    // Telemetry Info\r\n    parameters.set(X_CLIENT_SKU, libraryInfo.sku);\r\n    parameters.set(X_CLIENT_VER, libraryInfo.version);\r\n    if (libraryInfo.os) {\r\n        parameters.set(X_CLIENT_OS, libraryInfo.os);\r\n    }\r\n    if (libraryInfo.cpu) {\r\n        parameters.set(X_CLIENT_CPU, libraryInfo.cpu);\r\n    }\r\n}\r\n/**\r\n * Add client telemetry parameters\r\n * @param appTelemetry\r\n */\r\nfunction addApplicationTelemetry(parameters, appTelemetry) {\r\n    if (appTelemetry?.appName) {\r\n        parameters.set(X_APP_NAME, appTelemetry.appName);\r\n    }\r\n    if (appTelemetry?.appVersion) {\r\n        parameters.set(X_APP_VER, appTelemetry.appVersion);\r\n    }\r\n}\r\n/**\r\n * add prompt\r\n * @param prompt\r\n */\r\nfunction addPrompt(parameters, prompt) {\r\n    parameters.set(PROMPT, prompt);\r\n}\r\n/**\r\n * add state\r\n * @param state\r\n */\r\nfunction addState(parameters, state) {\r\n    if (state) {\r\n        parameters.set(STATE, state);\r\n    }\r\n}\r\n/**\r\n * add nonce\r\n * @param nonce\r\n */\r\nfunction addNonce(parameters, nonce) {\r\n    parameters.set(NONCE, nonce);\r\n}\r\n/**\r\n * add code_challenge and code_challenge_method\r\n * - throw if either of them are not passed\r\n * @param codeChallenge\r\n * @param codeChallengeMethod\r\n */\r\nfunction addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {\r\n    if (codeChallenge && codeChallengeMethod) {\r\n        parameters.set(CODE_CHALLENGE, codeChallenge);\r\n        parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);\r\n    }\r\n    else {\r\n        throw ClientConfigurationError_createClientConfigurationError(pkceParamsMissing);\r\n    }\r\n}\r\n/**\r\n * add the `authorization_code` passed by the user to exchange for a token\r\n * @param code\r\n */\r\nfunction addAuthorizationCode(parameters, code) {\r\n    parameters.set(CODE, code);\r\n}\r\n/**\r\n * add the `authorization_code` passed by the user to exchange for a token\r\n * @param code\r\n */\r\nfunction addDeviceCode(parameters, code) {\r\n    parameters.set(DEVICE_CODE, code);\r\n}\r\n/**\r\n * add the `refreshToken` passed by the user\r\n * @param refreshToken\r\n */\r\nfunction addRefreshToken(parameters, refreshToken) {\r\n    parameters.set(REFRESH_TOKEN, refreshToken);\r\n}\r\n/**\r\n * add the `code_verifier` passed by the user to exchange for a token\r\n * @param codeVerifier\r\n */\r\nfunction addCodeVerifier(parameters, codeVerifier) {\r\n    parameters.set(CODE_VERIFIER, codeVerifier);\r\n}\r\n/**\r\n * add client_secret\r\n * @param clientSecret\r\n */\r\nfunction addClientSecret(parameters, clientSecret) {\r\n    parameters.set(CLIENT_SECRET, clientSecret);\r\n}\r\n/**\r\n * add clientAssertion for confidential client flows\r\n * @param clientAssertion\r\n */\r\nfunction addClientAssertion(parameters, clientAssertion) {\r\n    if (clientAssertion) {\r\n        parameters.set(CLIENT_ASSERTION, clientAssertion);\r\n    }\r\n}\r\n/**\r\n * add clientAssertionType for confidential client flows\r\n * @param clientAssertionType\r\n */\r\nfunction addClientAssertionType(parameters, clientAssertionType) {\r\n    if (clientAssertionType) {\r\n        parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);\r\n    }\r\n}\r\n/**\r\n * add OBO assertion for confidential client flows\r\n * @param clientAssertion\r\n */\r\nfunction addOboAssertion(parameters, oboAssertion) {\r\n    parameters.set(OBO_ASSERTION, oboAssertion);\r\n}\r\n/**\r\n * add grant type\r\n * @param grantType\r\n */\r\nfunction addRequestTokenUse(parameters, tokenUse) {\r\n    parameters.set(REQUESTED_TOKEN_USE, tokenUse);\r\n}\r\n/**\r\n * add grant type\r\n * @param grantType\r\n */\r\nfunction addGrantType(parameters, grantType) {\r\n    parameters.set(GRANT_TYPE, grantType);\r\n}\r\n/**\r\n * add client info\r\n *\r\n */\r\nfunction addClientInfo(parameters) {\r\n    parameters.set(CLIENT_INFO, "1");\r\n}\r\nfunction addInstanceAware(parameters) {\r\n    if (!parameters.has(INSTANCE_AWARE)) {\r\n        parameters.set(INSTANCE_AWARE, "true");\r\n    }\r\n}\r\n/**\r\n * add extraQueryParams\r\n * @param eQParams\r\n */\r\nfunction addExtraQueryParameters(parameters, eQParams) {\r\n    Object.entries(eQParams).forEach(([key, value]) => {\r\n        if (!parameters.has(key) && value) {\r\n            parameters.set(key, value);\r\n        }\r\n    });\r\n}\r\nfunction addClientCapabilitiesToClaims(claims, clientCapabilities) {\r\n    let mergedClaims;\r\n    // Parse provided claims into JSON object or initialize empty object\r\n    if (!claims) {\r\n        mergedClaims = {};\r\n    }\r\n    else {\r\n        try {\r\n            mergedClaims = JSON.parse(claims);\r\n        }\r\n        catch (e) {\r\n            throw ClientConfigurationError_createClientConfigurationError(invalidClaims);\r\n        }\r\n    }\r\n    if (clientCapabilities && clientCapabilities.length > 0) {\r\n        if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {\r\n            // Add access_token key to claims object\r\n            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};\r\n        }\r\n        // Add xms_cc claim with provided clientCapabilities to access_token key\r\n        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] =\r\n            {\r\n                values: clientCapabilities,\r\n            };\r\n    }\r\n    return JSON.stringify(mergedClaims);\r\n}\r\n/**\r\n * adds `username` for Password Grant flow\r\n * @param username\r\n */\r\nfunction addUsername(parameters, username) {\r\n    parameters.set(PasswordGrantConstants.username, username);\r\n}\r\n/**\r\n * adds `password` for Password Grant flow\r\n * @param password\r\n */\r\nfunction addPassword(parameters, password) {\r\n    parameters.set(PasswordGrantConstants.password, password);\r\n}\r\n/**\r\n * add pop_jwk to query params\r\n * @param cnfString\r\n */\r\nfunction addPopToken(parameters, cnfString) {\r\n    if (cnfString) {\r\n        parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);\r\n        parameters.set(REQ_CNF, cnfString);\r\n    }\r\n}\r\n/**\r\n * add SSH JWK and key ID to query params\r\n */\r\nfunction addSshJwk(parameters, sshJwkString) {\r\n    if (sshJwkString) {\r\n        parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);\r\n        parameters.set(REQ_CNF, sshJwkString);\r\n    }\r\n}\r\n/**\r\n * add server telemetry fields\r\n * @param serverTelemetryManager\r\n */\r\nfunction addServerTelemetry(parameters, serverTelemetryManager) {\r\n    parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());\r\n    parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());\r\n}\r\n/**\r\n * Adds parameter that indicates to the server that throttling is supported\r\n */\r\nfunction addThrottling(parameters) {\r\n    parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);\r\n}\r\n/**\r\n * Adds logout_hint parameter for "silent" logout which prevent server account picker\r\n */\r\nfunction addLogoutHint(parameters, logoutHint) {\r\n    parameters.set(LOGOUT_HINT, logoutHint);\r\n}\r\nfunction addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {\r\n    if (!parameters.has(BROKER_CLIENT_ID)) {\r\n        parameters.set(BROKER_CLIENT_ID, brokerClientId);\r\n    }\r\n    if (!parameters.has(BROKER_REDIRECT_URI)) {\r\n        parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);\r\n    }\r\n}\r\n/**\r\n * Add EAR (Encrypted Authorize Response) request parameters\r\n * @param parameters\r\n * @param jwk\r\n */\r\nfunction addEARParameters(parameters, jwk) {\r\n    parameters.set(EAR_JWK, encodeURIComponent(jwk));\r\n    // ear_jwe_crypto will always have value: {"alg":"dir","enc":"A256GCM"} so we can hardcode this\r\n    const jweCryptoB64Encoded = "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0";\r\n    parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);\r\n}\n\n\n//# sourceMappingURL=RequestParameterBuilder.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/authority/AuthorityFactory.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Create an authority object of the correct type based on the url\r\n * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)\r\n *\r\n * Also performs endpoint discovery.\r\n *\r\n * @param authorityUri\r\n * @param networkClient\r\n * @param protocolMode\r\n * @internal\r\n */\r\nasync function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient) {\r\n    performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);\r\n    const authorityUriFinal = Authority_Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));\r\n    // Initialize authority and perform discovery endpoint check.\r\n    const acquireTokenAuthority = new Authority_Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient);\r\n    try {\r\n        await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger, performanceClient, correlationId)();\r\n        return acquireTokenAuthority;\r\n    }\r\n    catch (e) {\r\n        throw ClientAuthError_createClientAuthError(endpointResolutionError);\r\n    }\r\n}\n\n\n//# sourceMappingURL=AuthorityFactory.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/network/RequestThumbprint.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nfunction getRequestThumbprint(clientId, request, homeAccountId) {\r\n    return {\r\n        clientId: clientId,\r\n        authority: request.authority,\r\n        scopes: request.scopes,\r\n        homeAccountIdentifier: homeAccountId,\r\n        claims: request.claims,\r\n        authenticationScheme: request.authenticationScheme,\r\n        resourceRequestMethod: request.resourceRequestMethod,\r\n        resourceRequestUri: request.resourceRequestUri,\r\n        shrClaims: request.shrClaims,\r\n        sshKid: request.sshKid,\r\n        embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId,\r\n    };\r\n}\n\n\n//# sourceMappingURL=RequestThumbprint.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/network/ThrottlingUtils.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/** @internal */\r\nclass ThrottlingUtils {\r\n    /**\r\n     * Prepares a RequestThumbprint to be stored as a key.\r\n     * @param thumbprint\r\n     */\r\n    static generateThrottlingStorageKey(thumbprint) {\r\n        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;\r\n    }\r\n    /**\r\n     * Performs necessary throttling checks before a network request.\r\n     * @param cacheManager\r\n     * @param thumbprint\r\n     */\r\n    static preProcess(cacheManager, thumbprint) {\r\n        const key = ThrottlingUtils.generateThrottlingStorageKey(thumbprint);\r\n        const value = cacheManager.getThrottlingCache(key);\r\n        if (value) {\r\n            if (value.throttleTime < Date.now()) {\r\n                cacheManager.removeItem(key);\r\n                return;\r\n            }\r\n            throw new ServerError_ServerError(value.errorCodes?.join(" ") || Constants_Constants.EMPTY_STRING, value.errorMessage, value.subError);\r\n        }\r\n    }\r\n    /**\r\n     * Performs necessary throttling checks after a network request.\r\n     * @param cacheManager\r\n     * @param thumbprint\r\n     * @param response\r\n     */\r\n    static postProcess(cacheManager, thumbprint, response) {\r\n        if (ThrottlingUtils.checkResponseStatus(response) ||\r\n            ThrottlingUtils.checkResponseForRetryAfter(response)) {\r\n            const thumbprintValue = {\r\n                throttleTime: ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),\r\n                error: response.body.error,\r\n                errorCodes: response.body.error_codes,\r\n                errorMessage: response.body.error_description,\r\n                subError: response.body.suberror,\r\n            };\r\n            cacheManager.setThrottlingCache(ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue);\r\n        }\r\n    }\r\n    /**\r\n     * Checks a NetworkResponse object\'s status codes against 429 or 5xx\r\n     * @param response\r\n     */\r\n    static checkResponseStatus(response) {\r\n        return (response.status === 429 ||\r\n            (response.status >= 500 && response.status < 600));\r\n    }\r\n    /**\r\n     * Checks a NetworkResponse object\'s RetryAfter header\r\n     * @param response\r\n     */\r\n    static checkResponseForRetryAfter(response) {\r\n        if (response.headers) {\r\n            return (response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) &&\r\n                (response.status < 200 || response.status >= 300));\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.\r\n     * @param throttleTime\r\n     */\r\n    static calculateThrottleTime(throttleTime) {\r\n        const time = throttleTime <= 0 ? 0 : throttleTime;\r\n        const currentSeconds = Date.now() / 1000;\r\n        return Math.floor(Math.min(currentSeconds +\r\n            (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds +\r\n            ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1000);\r\n    }\r\n    static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {\r\n        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);\r\n        const key = this.generateThrottlingStorageKey(thumbprint);\r\n        cacheManager.removeItem(key);\r\n    }\r\n}\n\n\n//# sourceMappingURL=ThrottlingUtils.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/NetworkError.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Represents network related errors\r\n */\r\nclass NetworkError extends AuthError {\r\n    constructor(error, httpStatus, responseHeaders) {\r\n        super(error.errorCode, error.errorMessage, error.subError);\r\n        Object.setPrototypeOf(this, NetworkError.prototype);\r\n        this.name = "NetworkError";\r\n        this.error = error;\r\n        this.httpStatus = httpStatus;\r\n        this.responseHeaders = responseHeaders;\r\n    }\r\n}\r\n/**\r\n * Creates NetworkError object for a failed network request\r\n * @param error - Error to be thrown back to the caller\r\n * @param httpStatus - Status code of the network request\r\n * @param responseHeaders - Response headers of the network request, when available\r\n * @returns NetworkError object\r\n */\r\nfunction createNetworkError(error, httpStatus, responseHeaders, additionalError) {\r\n    error.errorMessage = `${error.errorMessage}, additionalErrorInfo: error.name:${additionalError?.name}, error.message:${additionalError?.message}`;\r\n    return new NetworkError(error, httpStatus, responseHeaders);\r\n}\n\n\n//# sourceMappingURL=NetworkError.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/client/BaseClient.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Base application class which will construct requests to send to and handle responses from the Microsoft STS using the authorization code flow.\r\n * @internal\r\n */\r\nclass BaseClient {\r\n    constructor(configuration, performanceClient) {\r\n        // Set the configuration\r\n        this.config = buildClientConfiguration(configuration);\r\n        // Initialize the logger\r\n        this.logger = new Logger_Logger(this.config.loggerOptions, packageMetadata_name, packageMetadata_version);\r\n        // Initialize crypto\r\n        this.cryptoUtils = this.config.cryptoInterface;\r\n        // Initialize storage interface\r\n        this.cacheManager = this.config.storageInterface;\r\n        // Set the network interface\r\n        this.networkClient = this.config.networkInterface;\r\n        // Set TelemetryManager\r\n        this.serverTelemetryManager = this.config.serverTelemetryManager;\r\n        // set Authority\r\n        this.authority = this.config.authOptions.authority;\r\n        // set performance telemetry client\r\n        this.performanceClient = performanceClient;\r\n    }\r\n    /**\r\n     * Creates default headers for requests to token endpoint\r\n     */\r\n    createTokenRequestHeaders(ccsCred) {\r\n        const headers = {};\r\n        headers[HeaderNames.CONTENT_TYPE] = Constants_Constants.URL_FORM_CONTENT_TYPE;\r\n        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {\r\n            switch (ccsCred.type) {\r\n                case CcsCredentialType.HOME_ACCOUNT_ID:\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\r\n                        headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;\r\n                    }\r\n                    catch (e) {\r\n                        this.logger.verbose("Could not parse home account ID for CCS Header: " +\r\n                            e);\r\n                    }\r\n                    break;\r\n                case CcsCredentialType.UPN:\r\n                    headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;\r\n                    break;\r\n            }\r\n        }\r\n        return headers;\r\n    }\r\n    /**\r\n     * Http post to token endpoint\r\n     * @param tokenEndpoint\r\n     * @param queryString\r\n     * @param headers\r\n     * @param thumbprint\r\n     */\r\n    async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {\r\n        if (queuedEvent) {\r\n            this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);\r\n        }\r\n        const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers: headers }, correlationId);\r\n        if (this.config.serverTelemetryManager &&\r\n            response.status < 500 &&\r\n            response.status !== 429) {\r\n            // Telemetry data successfully logged by server, clear Telemetry cache\r\n            this.config.serverTelemetryManager.clearTelemetryCache();\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     * Wraps sendPostRequestAsync with necessary preflight and postflight logic\r\n     * @param thumbprint - Request thumbprint for throttling\r\n     * @param tokenEndpoint - Endpoint to make the POST to\r\n     * @param options - Body and Headers to include on the POST request\r\n     * @param correlationId - CorrelationId for telemetry\r\n     */\r\n    async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {\r\n        ThrottlingUtils.preProcess(this.cacheManager, thumbprint);\r\n        let response;\r\n        try {\r\n            response = await invokeAsync((this.networkClient.sendPostRequestAsync.bind(this.networkClient)), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);\r\n            const responseHeaders = response.headers || {};\r\n            this.performanceClient?.addFields({\r\n                refreshTokenSize: response.body.refresh_token?.length || 0,\r\n                httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",\r\n                requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",\r\n            }, correlationId);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof NetworkError) {\r\n                const responseHeaders = e.responseHeaders;\r\n                if (responseHeaders) {\r\n                    this.performanceClient?.addFields({\r\n                        httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",\r\n                        requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] ||\r\n                            "",\r\n                        contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] ||\r\n                            undefined,\r\n                        contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] ||\r\n                            undefined,\r\n                        httpStatus: e.httpStatus,\r\n                    }, correlationId);\r\n                }\r\n                throw e.error;\r\n            }\r\n            if (e instanceof AuthError) {\r\n                throw e;\r\n            }\r\n            else {\r\n                throw ClientAuthError_createClientAuthError(networkError);\r\n            }\r\n        }\r\n        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);\r\n        return response;\r\n    }\r\n    /**\r\n     * Updates the authority object of the client. Endpoint discovery must be completed.\r\n     * @param updatedAuthority\r\n     */\r\n    async updateAuthority(cloudInstanceHostname, correlationId) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);\r\n        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;\r\n        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);\r\n        this.authority = cloudInstanceAuthority;\r\n    }\r\n    /**\r\n     * Creates query string for the /token request\r\n     * @param request\r\n     */\r\n    createTokenQueryParameters(request) {\r\n        const parameters = new Map();\r\n        if (request.embeddedClientId) {\r\n            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);\r\n        }\r\n        if (request.tokenQueryParameters) {\r\n            addExtraQueryParameters(parameters, request.tokenQueryParameters);\r\n        }\r\n        addCorrelationId(parameters, request.correlationId);\r\n        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);\r\n        return mapToQueryString(parameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=BaseClient.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthErrorCodes.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n// Codes defined by MSAL\r\nconst noTokensFound = "no_tokens_found";\r\nconst nativeAccountUnavailable = "native_account_unavailable";\r\nconst refreshTokenExpired = "refresh_token_expired";\r\n// Codes potentially returned by server\r\nconst interactionRequired = "interaction_required";\r\nconst consentRequired = "consent_required";\r\nconst loginRequired = "login_required";\r\nconst badToken = "bad_token";\n\n\n//# sourceMappingURL=InteractionRequiredAuthErrorCodes.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/error/InteractionRequiredAuthError.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * InteractionRequiredServerErrorMessage contains string constants used by error codes and messages returned by the server indicating interaction is required\r\n */\r\nconst InteractionRequiredServerErrorMessage = [\r\n    interactionRequired,\r\n    consentRequired,\r\n    loginRequired,\r\n    badToken,\r\n];\r\nconst InteractionRequiredAuthSubErrorMessage = [\r\n    "message_only",\r\n    "additional_action",\r\n    "basic_action",\r\n    "user_password_expired",\r\n    "consent_required",\r\n    "bad_token",\r\n];\r\nconst InteractionRequiredAuthErrorMessages = {\r\n    [noTokensFound]: "No refresh token found in the cache. Please sign-in.",\r\n    [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",\r\n    [refreshTokenExpired]: "Refresh token has expired.",\r\n    [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.",\r\n};\r\n/**\r\n * Interaction required errors defined by the SDK\r\n * @deprecated Use InteractionRequiredAuthErrorCodes instead\r\n */\r\nconst InteractionRequiredAuthErrorMessage = {\r\n    noTokensFoundError: {\r\n        code: noTokensFound,\r\n        desc: InteractionRequiredAuthErrorMessages[noTokensFound],\r\n    },\r\n    native_account_unavailable: {\r\n        code: nativeAccountUnavailable,\r\n        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable],\r\n    },\r\n    bad_token: {\r\n        code: badToken,\r\n        desc: InteractionRequiredAuthErrorMessages[badToken],\r\n    },\r\n};\r\n/**\r\n * Error thrown when user interaction is required.\r\n */\r\nclass InteractionRequiredAuthError_InteractionRequiredAuthError extends AuthError {\r\n    constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {\r\n        super(errorCode, errorMessage, subError);\r\n        Object.setPrototypeOf(this, InteractionRequiredAuthError_InteractionRequiredAuthError.prototype);\r\n        this.timestamp = timestamp || Constants_Constants.EMPTY_STRING;\r\n        this.traceId = traceId || Constants_Constants.EMPTY_STRING;\r\n        this.correlationId = correlationId || Constants_Constants.EMPTY_STRING;\r\n        this.claims = claims || Constants_Constants.EMPTY_STRING;\r\n        this.name = "InteractionRequiredAuthError";\r\n        this.errorNo = errorNo;\r\n    }\r\n}\r\n/**\r\n * Helper function used to determine if an error thrown by the server requires interaction to resolve\r\n * @param errorCode\r\n * @param errorString\r\n * @param subError\r\n */\r\nfunction InteractionRequiredAuthError_isInteractionRequiredError(errorCode, errorString, subError) {\r\n    const isInteractionRequiredErrorCode = !!errorCode &&\r\n        InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;\r\n    const isInteractionRequiredSubError = !!subError &&\r\n        InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;\r\n    const isInteractionRequiredErrorDesc = !!errorString &&\r\n        InteractionRequiredServerErrorMessage.some((irErrorCode) => {\r\n            return errorString.indexOf(irErrorCode) > -1;\r\n        });\r\n    return (isInteractionRequiredErrorCode ||\r\n        isInteractionRequiredErrorDesc ||\r\n        isInteractionRequiredSubError);\r\n}\r\n/**\r\n * Creates an InteractionRequiredAuthError\r\n */\r\nfunction createInteractionRequiredAuthError(errorCode) {\r\n    return new InteractionRequiredAuthError_InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);\r\n}\n\n\n//# sourceMappingURL=InteractionRequiredAuthError.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/utils/ProtocolUtils.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Class which provides helpers for OAuth 2.0 protocol specific values\r\n */\r\nclass ProtocolUtils {\r\n    /**\r\n     * Appends user state with random guid, or returns random guid.\r\n     * @param userState\r\n     * @param randomGuid\r\n     */\r\n    static setRequestState(cryptoObj, userState, meta) {\r\n        const libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);\r\n        return userState\r\n            ? `${libraryState}${Constants_Constants.RESOURCE_DELIM}${userState}`\r\n            : libraryState;\r\n    }\r\n    /**\r\n     * Generates the state value used by the common library.\r\n     * @param randomGuid\r\n     * @param cryptoObj\r\n     */\r\n    static generateLibraryState(cryptoObj, meta) {\r\n        if (!cryptoObj) {\r\n            throw ClientAuthError_createClientAuthError(noCryptoObject);\r\n        }\r\n        // Create a state object containing a unique id and the timestamp of the request creation\r\n        const stateObj = {\r\n            id: cryptoObj.createNewGuid(),\r\n        };\r\n        if (meta) {\r\n            stateObj.meta = meta;\r\n        }\r\n        const stateString = JSON.stringify(stateObj);\r\n        return cryptoObj.base64Encode(stateString);\r\n    }\r\n    /**\r\n     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\r\n     * @param state\r\n     * @param cryptoObj\r\n     */\r\n    static parseRequestState(cryptoObj, state) {\r\n        if (!cryptoObj) {\r\n            throw ClientAuthError_createClientAuthError(noCryptoObject);\r\n        }\r\n        if (!state) {\r\n            throw ClientAuthError_createClientAuthError(ClientAuthErrorCodes_invalidState);\r\n        }\r\n        try {\r\n            // Split the state between library state and user passed state and decode them separately\r\n            const splitState = state.split(Constants_Constants.RESOURCE_DELIM);\r\n            const libraryState = splitState[0];\r\n            const userState = splitState.length > 1\r\n                ? splitState.slice(1).join(Constants_Constants.RESOURCE_DELIM)\r\n                : Constants_Constants.EMPTY_STRING;\r\n            const libraryStateString = cryptoObj.base64Decode(libraryState);\r\n            const libraryStateObj = JSON.parse(libraryStateString);\r\n            return {\r\n                userRequestState: userState || Constants_Constants.EMPTY_STRING,\r\n                libraryState: libraryStateObj,\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw ClientAuthError_createClientAuthError(ClientAuthErrorCodes_invalidState);\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=ProtocolUtils.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/crypto/PopTokenGenerator.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst KeyLocation = {\r\n    SW: "sw",\r\n    UHW: "uhw",\r\n};\r\n/** @internal */\r\nclass PopTokenGenerator {\r\n    constructor(cryptoUtils, performanceClient) {\r\n        this.cryptoUtils = cryptoUtils;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n    /**\r\n     * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters\r\n     * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash\r\n     * @param request\r\n     * @returns\r\n     */\r\n    async generateCnf(request, logger) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\r\n        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger, this.performanceClient, request.correlationId)(request);\r\n        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));\r\n        return {\r\n            kid: reqCnf.kid,\r\n            reqCnfString,\r\n        };\r\n    }\r\n    /**\r\n     * Generates key_id for a SHR token request\r\n     * @param request\r\n     * @returns\r\n     */\r\n    async generateKid(request) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);\r\n        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);\r\n        return {\r\n            kid: kidThumbprint,\r\n            xms_ksl: KeyLocation.SW,\r\n        };\r\n    }\r\n    /**\r\n     * Signs the POP access_token with the local generated key-pair\r\n     * @param accessToken\r\n     * @param request\r\n     * @returns\r\n     */\r\n    async signPopToken(accessToken, keyId, request) {\r\n        return this.signPayload(accessToken, keyId, request);\r\n    }\r\n    /**\r\n     * Utility function to generate the signed JWT for an access_token\r\n     * @param payload\r\n     * @param kid\r\n     * @param request\r\n     * @param claims\r\n     * @returns\r\n     */\r\n    async signPayload(payload, keyId, request, claims) {\r\n        // Deconstruct request to extract SHR parameters\r\n        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions, } = request;\r\n        const resourceUrlString = resourceRequestUri\r\n            ? new UrlString(resourceRequestUri)\r\n            : undefined;\r\n        const resourceUrlComponents = resourceUrlString?.getUrlComponents();\r\n        return this.cryptoUtils.signJwt({\r\n            at: payload,\r\n            ts: nowSeconds(),\r\n            m: resourceRequestMethod?.toUpperCase(),\r\n            u: resourceUrlComponents?.HostNameAndPort,\r\n            nonce: shrNonce || this.cryptoUtils.createNewGuid(),\r\n            p: resourceUrlComponents?.AbsolutePath,\r\n            q: resourceUrlComponents?.QueryString\r\n                ? [[], resourceUrlComponents.QueryString]\r\n                : undefined,\r\n            client_claims: shrClaims || undefined,\r\n            ...claims,\r\n        }, keyId, shrOptions, request.correlationId);\r\n    }\r\n}\n\n\n//# sourceMappingURL=PopTokenGenerator.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/cache/persistence/TokenCacheContext.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class instance helps track the memory changes facilitating\r\n * decisions to read from and write to the persistent cache\r\n */ class TokenCacheContext {\r\n    constructor(tokenCache, hasChanged) {\r\n        this.cache = tokenCache;\r\n        this.hasChanged = hasChanged;\r\n    }\r\n    /**\r\n     * boolean which indicates the changes in cache\r\n     */\r\n    get cacheHasChanged() {\r\n        return this.hasChanged;\r\n    }\r\n    /**\r\n     * function to retrieve the token cache\r\n     */\r\n    get tokenCache() {\r\n        return this.cache;\r\n    }\r\n}\n\n\n//# sourceMappingURL=TokenCacheContext.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Class that handles response parsing.\r\n * @internal\r\n */\r\nclass ResponseHandler {\r\n    constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     * @param refreshAccessToken\r\n     */\r\n    validateTokenResponse(serverResponse, refreshAccessToken) {\r\n        // Check for error\r\n        if (serverResponse.error ||\r\n            serverResponse.error_description ||\r\n            serverResponse.suberror) {\r\n            const errString = `Error(s): ${serverResponse.error_codes || Constants_Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants_Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants_Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants_Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants_Constants.NOT_AVAILABLE}`;\r\n            const serverErrorNo = serverResponse.error_codes?.length\r\n                ? serverResponse.error_codes[0]\r\n                : undefined;\r\n            const serverError = new ServerError_ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);\r\n            // check if 500 error\r\n            if (refreshAccessToken &&\r\n                serverResponse.status &&\r\n                serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&\r\n                serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {\r\n                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`);\r\n                // don\'t throw an exception, but alert the user via a log that the token was unable to be refreshed\r\n                return;\r\n                // check if 400 error\r\n            }\r\n            else if (refreshAccessToken &&\r\n                serverResponse.status &&\r\n                serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&\r\n                serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {\r\n                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`);\r\n                // don\'t throw an exception, but alert the user via a log that the token was unable to be refreshed\r\n                return;\r\n            }\r\n            if (InteractionRequiredAuthError_isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError_InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants_Constants.EMPTY_STRING, serverResponse.trace_id || Constants_Constants.EMPTY_STRING, serverResponse.correlation_id || Constants_Constants.EMPTY_STRING, serverResponse.claims || Constants_Constants.EMPTY_STRING, serverErrorNo);\r\n            }\r\n            throw serverError;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\r\n        // create an idToken object (not entity)\r\n        let idTokenClaims;\r\n        if (serverTokenResponse.id_token) {\r\n            idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants_Constants.EMPTY_STRING, this.cryptoObj.base64Decode);\r\n            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n            if (authCodePayload && authCodePayload.nonce) {\r\n                if (idTokenClaims.nonce !== authCodePayload.nonce) {\r\n                    throw ClientAuthError_createClientAuthError(nonceMismatch);\r\n                }\r\n            }\r\n            // token max_age check\r\n            if (request.maxAge || request.maxAge === 0) {\r\n                const authTime = idTokenClaims.auth_time;\r\n                if (!authTime) {\r\n                    throw ClientAuthError_createClientAuthError(authTimeNotFound);\r\n                }\r\n                checkMaxAge(authTime, request.maxAge);\r\n            }\r\n        }\r\n        // generate homeAccountId\r\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants_Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\r\n        // save the response tokens\r\n        let requestStateObj;\r\n        if (!!authCodePayload && !!authCodePayload.state) {\r\n            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n        }\r\n        // Add keyId from request to serverTokenResponse if defined\r\n        serverTokenResponse.key_id =\r\n            serverTokenResponse.key_id || request.sshKid || undefined;\r\n        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistencePlugin && this.serializableCache) {\r\n                this.logger.verbose("Persistence enabled, calling beforeCacheAccess");\r\n                cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\r\n            }\r\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it\'s the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\r\n            if (handlingRefreshTokenResponse &&\r\n                !forceCacheRefreshTokenResponse &&\r\n                cacheRecord.account) {\r\n                const key = cacheRecord.account.generateAccountKey();\r\n                const account = this.cacheStorage.getAccount(key);\r\n                if (!account) {\r\n                    this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");\r\n                    return await ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);\r\n                }\r\n            }\r\n            await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, request.storeInCache);\r\n        }\r\n        finally {\r\n            if (this.persistencePlugin &&\r\n                this.serializableCache &&\r\n                cacheContext) {\r\n                this.logger.verbose("Persistence enabled, calling afterCacheAccess");\r\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);\r\n    }\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {\r\n        const env = authority.getPreferredCache();\r\n        if (!env) {\r\n            throw ClientAuthError_createClientAuthError(invalidCacheEnvironment);\r\n        }\r\n        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        let cachedIdToken;\r\n        let cachedAccount;\r\n        if (serverTokenResponse.id_token && !!idTokenClaims) {\r\n            cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");\r\n            cachedAccount = buildAccountToCache(this.cacheStorage, authority, this.homeAccountIdentifier, this.cryptoObj.base64Decode, idTokenClaims, serverTokenResponse.client_info, env, claimsTenantId, authCodePayload, undefined, // nativeAccountId\r\n            this.logger);\r\n        }\r\n        // AccessToken\r\n        let cachedAccessToken = null;\r\n        if (serverTokenResponse.access_token) {\r\n            // If scopes not returned in server response, use request scopes\r\n            const responseScopes = serverTokenResponse.scope\r\n                ? ScopeSet.fromString(serverTokenResponse.scope)\r\n                : new ScopeSet(request.scopes || []);\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            const expiresIn = (typeof serverTokenResponse.expires_in === "string"\r\n                ? parseInt(serverTokenResponse.expires_in, 10)\r\n                : serverTokenResponse.expires_in) || 0;\r\n            const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string"\r\n                ? parseInt(serverTokenResponse.ext_expires_in, 10)\r\n                : serverTokenResponse.ext_expires_in) || 0;\r\n            const refreshIn = (typeof serverTokenResponse.refresh_in === "string"\r\n                ? parseInt(serverTokenResponse.refresh_in, 10)\r\n                : serverTokenResponse.refresh_in) || undefined;\r\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            const refreshOnSeconds = refreshIn && refreshIn > 0\r\n                ? reqTimestamp + refreshIn\r\n                : undefined;\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\r\n        }\r\n        // refreshToken\r\n        let cachedRefreshToken = null;\r\n        if (serverTokenResponse.refresh_token) {\r\n            let rtExpiresOn;\r\n            if (serverTokenResponse.refresh_token_expires_in) {\r\n                const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in ===\r\n                    "string"\r\n                    ? parseInt(serverTokenResponse.refresh_token_expires_in, 10)\r\n                    : serverTokenResponse.refresh_token_expires_in;\r\n                rtExpiresOn = reqTimestamp + rtExpiresIn;\r\n            }\r\n            cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);\r\n        }\r\n        // appMetadata\r\n        let cachedAppMetadata = null;\r\n        if (serverTokenResponse.foci) {\r\n            cachedAppMetadata = {\r\n                clientId: this.clientId,\r\n                environment: env,\r\n                familyId: serverTokenResponse.foci,\r\n            };\r\n        }\r\n        return {\r\n            account: cachedAccount,\r\n            idToken: cachedIdToken,\r\n            accessToken: cachedAccessToken,\r\n            refreshToken: cachedRefreshToken,\r\n            appMetadata: cachedAppMetadata,\r\n        };\r\n    }\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {\r\n        let accessToken = Constants_Constants.EMPTY_STRING;\r\n        let responseScopes = [];\r\n        let expiresOn = null;\r\n        let extExpiresOn;\r\n        let refreshOn;\r\n        let familyId = Constants_Constants.EMPTY_STRING;\r\n        if (cacheRecord.accessToken) {\r\n            /*\r\n             * if the request object has `popKid` property, `signPopToken` will be set to false and\r\n             * the token will be returned unsigned\r\n             */\r\n            if (cacheRecord.accessToken.tokenType ===\r\n                AuthenticationScheme.POP &&\r\n                !request.popKid) {\r\n                const popTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                const { secret, keyId } = cacheRecord.accessToken;\r\n                if (!keyId) {\r\n                    throw ClientAuthError_createClientAuthError(keyIdMissing);\r\n                }\r\n                accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\r\n            }\r\n            else {\r\n                accessToken = cacheRecord.accessToken.secret;\r\n            }\r\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n            // Access token expiresOn cached in seconds, converting to Date for AuthenticationResult\r\n            expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);\r\n            extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);\r\n            if (cacheRecord.accessToken.refreshOn) {\r\n                refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);\r\n            }\r\n        }\r\n        if (cacheRecord.appMetadata) {\r\n            familyId =\r\n                cacheRecord.appMetadata.familyId === THE_FAMILY_ID\r\n                    ? THE_FAMILY_ID\r\n                    : "";\r\n        }\r\n        const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";\r\n        const tid = idTokenClaims?.tid || "";\r\n        // for hybrid + native bridge enablement, send back the native account Id\r\n        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\r\n            cacheRecord.account.nativeAccountId =\r\n                serverTokenResponse?.spa_accountid;\r\n        }\r\n        const accountInfo = cacheRecord.account\r\n            ? updateAccountTenantProfileData(cacheRecord.account.getAccountInfo(), undefined, // tenantProfile optional\r\n            idTokenClaims, cacheRecord.idToken?.secret)\r\n            : null;\r\n        return {\r\n            authority: authority.canonicalAuthority,\r\n            uniqueId: uid,\r\n            tenantId: tid,\r\n            scopes: responseScopes,\r\n            account: accountInfo,\r\n            idToken: cacheRecord?.idToken?.secret || "",\r\n            idTokenClaims: idTokenClaims || {},\r\n            accessToken: accessToken,\r\n            fromCache: fromTokenCache,\r\n            expiresOn: expiresOn,\r\n            extExpiresOn: extExpiresOn,\r\n            refreshOn: refreshOn,\r\n            correlationId: request.correlationId,\r\n            requestId: requestId || Constants_Constants.EMPTY_STRING,\r\n            familyId: familyId,\r\n            tokenType: cacheRecord.accessToken?.tokenType || Constants_Constants.EMPTY_STRING,\r\n            state: requestState\r\n                ? requestState.userRequestState\r\n                : Constants_Constants.EMPTY_STRING,\r\n            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName ||\r\n                Constants_Constants.EMPTY_STRING,\r\n            msGraphHost: cacheRecord.account?.msGraphHost || Constants_Constants.EMPTY_STRING,\r\n            code: serverTokenResponse?.spa_code,\r\n            fromNativeBroker: false,\r\n        };\r\n    }\r\n}\r\nfunction buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {\r\n    logger?.verbose("setCachedAccount called");\r\n    // Check if base account is already cached\r\n    const accountKeys = cacheStorage.getAccountKeys();\r\n    const baseAccountKey = accountKeys.find((accountKey) => {\r\n        return accountKey.startsWith(homeAccountId);\r\n    });\r\n    let cachedAccount = null;\r\n    if (baseAccountKey) {\r\n        cachedAccount = cacheStorage.getAccount(baseAccountKey);\r\n    }\r\n    const baseAccount = cachedAccount ||\r\n        AccountEntity.createAccount({\r\n            homeAccountId,\r\n            idTokenClaims,\r\n            clientInfo,\r\n            environment,\r\n            cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\r\n            msGraphHost: authCodePayload?.msgraph_host,\r\n            nativeAccountId: nativeAccountId,\r\n        }, authority, base64Decode);\r\n    const tenantProfiles = baseAccount.tenantProfiles || [];\r\n    const tenantId = claimsTenantId || baseAccount.realm;\r\n    if (tenantId &&\r\n        !tenantProfiles.find((tenantProfile) => {\r\n            return tenantProfile.tenantId === tenantId;\r\n        })) {\r\n        const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);\r\n        tenantProfiles.push(newTenantProfile);\r\n    }\r\n    baseAccount.tenantProfiles = tenantProfiles;\r\n    return baseAccount;\r\n}\n\n\n//# sourceMappingURL=ResponseHandler.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/request/RequestValidator.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Validates server consumable params from the "request" objects\r\n */\r\nclass RequestValidator {\r\n    /**\r\n     * Utility to check if the `redirectUri` in the request is a non-null value\r\n     * @param redirectUri\r\n     */\r\n    static validateRedirectUri(redirectUri) {\r\n        if (!redirectUri) {\r\n            throw ClientConfigurationError_createClientConfigurationError(redirectUriEmpty);\r\n        }\r\n    }\r\n    /**\r\n     * Utility to validate prompt sent by the user in the request\r\n     * @param prompt\r\n     */\r\n    static validatePrompt(prompt) {\r\n        const promptValues = [];\r\n        for (const value in PromptValue) {\r\n            promptValues.push(PromptValue[value]);\r\n        }\r\n        if (promptValues.indexOf(prompt) < 0) {\r\n            throw ClientConfigurationError_createClientConfigurationError(invalidPromptValue);\r\n        }\r\n    }\r\n    static validateClaims(claims) {\r\n        try {\r\n            JSON.parse(claims);\r\n        }\r\n        catch (e) {\r\n            throw ClientConfigurationError_createClientConfigurationError(invalidClaims);\r\n        }\r\n    }\r\n    /**\r\n     * Utility to validate code_challenge and code_challenge_method\r\n     * @param codeChallenge\r\n     * @param codeChallengeMethod\r\n     */\r\n    static validateCodeChallengeParams(codeChallenge, codeChallengeMethod) {\r\n        if (!codeChallenge || !codeChallengeMethod) {\r\n            throw ClientConfigurationError_createClientConfigurationError(pkceParamsMissing);\r\n        }\r\n        else {\r\n            this.validateCodeChallengeMethod(codeChallengeMethod);\r\n        }\r\n    }\r\n    /**\r\n     * Utility to validate code_challenge_method\r\n     * @param codeChallengeMethod\r\n     */\r\n    static validateCodeChallengeMethod(codeChallengeMethod) {\r\n        if ([\r\n            CodeChallengeMethodValues.PLAIN,\r\n            CodeChallengeMethodValues.S256,\r\n        ].indexOf(codeChallengeMethod) < 0) {\r\n            throw ClientConfigurationError_createClientConfigurationError(invalidCodeChallengeMethod);\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=RequestValidator.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/utils/ClientAssertionUtils.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nasync function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {\r\n    if (typeof clientAssertion === "string") {\r\n        return clientAssertion;\r\n    }\r\n    else {\r\n        const config = {\r\n            clientId: clientId,\r\n            tokenEndpoint: tokenEndpoint,\r\n        };\r\n        return clientAssertion(config);\r\n    }\r\n}\n\n\n//# sourceMappingURL=ClientAssertionUtils.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/client/AuthorizationCodeClient.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Oauth2.0 Authorization Code client\r\n * @internal\r\n */\r\nclass AuthorizationCodeClient extends BaseClient {\r\n    constructor(configuration, performanceClient) {\r\n        super(configuration, performanceClient);\r\n        // Flag to indicate if client is for hybrid spa auth code redemption\r\n        this.includeRedirectUri = true;\r\n        this.oidcDefaultScopes =\r\n            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\r\n    }\r\n    /**\r\n     * API to acquire a token in exchange of \'authorization_code` acquired by the user in the first leg of the\r\n     * authorization_code_grant\r\n     * @param request\r\n     */\r\n    async acquireToken(request, authCodePayload) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\r\n        if (!request.code) {\r\n            throw ClientAuthError_createClientAuthError(requestCannotBeMade);\r\n        }\r\n        const reqTimestamp = nowSeconds();\r\n        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);\r\n        // Retrieve requestId from response headers\r\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);\r\n        // Validate response. This function throws a server error if an error is returned by the server.\r\n        responseHandler.validateTokenResponse(response.body);\r\n        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);\r\n    }\r\n    /**\r\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     * @param authorityUri\r\n     */\r\n    getLogoutUri(logoutRequest) {\r\n        // Throw error if logoutRequest is null/undefined\r\n        if (!logoutRequest) {\r\n            throw ClientConfigurationError_createClientConfigurationError(logoutRequestEmpty);\r\n        }\r\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\r\n        // Construct logout URI\r\n        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\r\n    }\r\n    /**\r\n     * Executes POST request to token endpoint\r\n     * @param authority\r\n     * @param request\r\n     */\r\n    async executeTokenRequest(authority, request) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\r\n        const queryParametersString = this.createTokenQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);\r\n        let ccsCredential = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\r\n                ccsCredential = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\r\n                };\r\n            }\r\n            catch (e) {\r\n                this.logger.verbose("Could not parse client info for CCS Header: " + e);\r\n            }\r\n        }\r\n        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\r\n        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);\r\n        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);\r\n    }\r\n    /**\r\n     * Generates a map for all the params to be sent to the service\r\n     * @param request\r\n     */\r\n    async createTokenRequestBody(request) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\r\n        const parameters = new Map();\r\n        addClientId(parameters, request.embeddedClientId ||\r\n            request.tokenBodyParameters?.[CLIENT_ID] ||\r\n            this.config.authOptions.clientId);\r\n        /*\r\n         * For hybrid spa flow, there will be a code but no verifier\r\n         * In this scenario, don\'t include redirect uri as auth code will not be bound to redirect URI\r\n         */\r\n        if (!this.includeRedirectUri) {\r\n            // Just validate\r\n            RequestValidator.validateRedirectUri(request.redirectUri);\r\n        }\r\n        else {\r\n            // Validate and include redirect uri\r\n            addRedirectUri(parameters, request.redirectUri);\r\n        }\r\n        // Add scope array, parameter builder will add default scopes and dedupe\r\n        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);\r\n        // add code: user set, not validated\r\n        addAuthorizationCode(parameters, request.code);\r\n        // Add library metadata\r\n        addLibraryInfo(parameters, this.config.libraryInfo);\r\n        addApplicationTelemetry(parameters, this.config.telemetry.application);\r\n        addThrottling(parameters);\r\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\r\n            addServerTelemetry(parameters, this.serverTelemetryManager);\r\n        }\r\n        // add code_verifier if passed\r\n        if (request.codeVerifier) {\r\n            addCodeVerifier(parameters, request.codeVerifier);\r\n        }\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            addClientSecret(parameters, this.config.clientCredentials.clientSecret);\r\n        }\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\r\n            addClientAssertionType(parameters, clientAssertion.assertionType);\r\n        }\r\n        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);\r\n        addClientInfo(parameters);\r\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\r\n            let reqCnfData;\r\n            if (!request.popKid) {\r\n                const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\r\n                reqCnfData = generatedReqCnfData.reqCnfString;\r\n            }\r\n            else {\r\n                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\r\n            }\r\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\r\n            addPopToken(parameters, reqCnfData);\r\n        }\r\n        else if (request.authenticationScheme === AuthenticationScheme.SSH) {\r\n            if (request.sshJwk) {\r\n                addSshJwk(parameters, request.sshJwk);\r\n            }\r\n            else {\r\n                throw ClientConfigurationError_createClientConfigurationError(missingSshJwk);\r\n            }\r\n        }\r\n        if (!StringUtils.isEmptyObj(request.claims) ||\r\n            (this.config.authOptions.clientCapabilities &&\r\n                this.config.authOptions.clientCapabilities.length > 0)) {\r\n            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        let ccsCred = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\r\n                ccsCred = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\r\n                };\r\n            }\r\n            catch (e) {\r\n                this.logger.verbose("Could not parse client info for CCS Header: " + e);\r\n            }\r\n        }\r\n        else {\r\n            ccsCred = request.ccsCredential;\r\n        }\r\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\r\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\r\n            switch (ccsCred.type) {\r\n                case CcsCredentialType.HOME_ACCOUNT_ID:\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\r\n                        addCcsOid(parameters, clientInfo);\r\n                    }\r\n                    catch (e) {\r\n                        this.logger.verbose("Could not parse home account ID for CCS Header: " +\r\n                            e);\r\n                    }\r\n                    break;\r\n                case CcsCredentialType.UPN:\r\n                    addCcsUpn(parameters, ccsCred.credential);\r\n                    break;\r\n            }\r\n        }\r\n        if (request.embeddedClientId) {\r\n            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);\r\n        }\r\n        if (request.tokenBodyParameters) {\r\n            addExtraQueryParameters(parameters, request.tokenBodyParameters);\r\n        }\r\n        // Add hybrid spa parameters if not already provided\r\n        if (request.enableSpaAuthorizationCode &&\r\n            (!request.tokenBodyParameters ||\r\n                !request.tokenBodyParameters[RETURN_SPA_CODE])) {\r\n            addExtraQueryParameters(parameters, {\r\n                [RETURN_SPA_CODE]: "1",\r\n            });\r\n        }\r\n        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);\r\n        return mapToQueryString(parameters);\r\n    }\r\n    /**\r\n     * This API validates the `EndSessionRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    createLogoutUrlQueryString(request) {\r\n        const parameters = new Map();\r\n        if (request.postLogoutRedirectUri) {\r\n            addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);\r\n        }\r\n        if (request.correlationId) {\r\n            addCorrelationId(parameters, request.correlationId);\r\n        }\r\n        if (request.idTokenHint) {\r\n            addIdTokenHint(parameters, request.idTokenHint);\r\n        }\r\n        if (request.state) {\r\n            addState(parameters, request.state);\r\n        }\r\n        if (request.logoutHint) {\r\n            addLogoutHint(parameters, request.logoutHint);\r\n        }\r\n        if (request.extraQueryParameters) {\r\n            addExtraQueryParameters(parameters, request.extraQueryParameters);\r\n        }\r\n        if (this.config.authOptions.instanceAware) {\r\n            addInstanceAware(parameters);\r\n        }\r\n        return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=AuthorizationCodeClient.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/client/RefreshTokenClient.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300; // 5 Minutes\r\n/**\r\n * OAuth2.0 refresh token client\r\n * @internal\r\n */\r\nclass RefreshTokenClient extends BaseClient {\r\n    constructor(configuration, performanceClient) {\r\n        super(configuration, performanceClient);\r\n    }\r\n    async acquireToken(request) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);\r\n        const reqTimestamp = nowSeconds();\r\n        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);\r\n        // Retrieve requestId from response headers\r\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\r\n        responseHandler.validateTokenResponse(response.body);\r\n        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, undefined, undefined, true, request.forceCache, requestId);\r\n    }\r\n    /**\r\n     * Gets cached refresh token and attaches to request, then calls acquireToken API\r\n     * @param request\r\n     */\r\n    async acquireTokenByRefreshToken(request) {\r\n        // Cannot renew token if no request object is given.\r\n        if (!request) {\r\n            throw ClientConfigurationError_createClientConfigurationError(tokenRequestEmpty);\r\n        }\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);\r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw ClientAuthError_createClientAuthError(noAccountInSilentRequest);\r\n        }\r\n        // try checking if FOCI is enabled for the given application\r\n        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);\r\n        // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest\r\n        if (isFOCI) {\r\n            try {\r\n                return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);\r\n            }\r\n            catch (e) {\r\n                const noFamilyRTInCache = e instanceof InteractionRequiredAuthError_InteractionRequiredAuthError &&\r\n                    e.errorCode ===\r\n                        noTokensFound;\r\n                const clientMismatchErrorWithFamilyRT = e instanceof ServerError_ServerError &&\r\n                    e.errorCode === Errors.INVALID_GRANT_ERROR &&\r\n                    e.subError === Errors.CLIENT_MISMATCH_ERROR;\r\n                // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)\r\n                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {\r\n                    return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);\r\n                    // throw in all other cases\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        // fall back to application refresh token acquisition\r\n        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);\r\n    }\r\n    /**\r\n     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached\r\n     * @param request\r\n     */\r\n    async acquireTokenWithCachedRefreshToken(request, foci) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);\r\n        // fetches family RT or application RT based on FOCI value\r\n        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, undefined, this.performanceClient, request.correlationId);\r\n        if (!refreshToken) {\r\n            throw createInteractionRequiredAuthError(noTokensFound);\r\n        }\r\n        if (refreshToken.expiresOn &&\r\n            isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds ||\r\n                DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {\r\n            this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);\r\n            throw createInteractionRequiredAuthError(refreshTokenExpired);\r\n        }\r\n        // attach cached RT size to the current measurement\r\n        const refreshTokenRequest = {\r\n            ...request,\r\n            refreshToken: refreshToken.secret,\r\n            authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,\r\n            ccsCredential: {\r\n                credential: request.account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\r\n            },\r\n        };\r\n        try {\r\n            return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof InteractionRequiredAuthError_InteractionRequiredAuthError) {\r\n                this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);\r\n                if (e.subError === badToken) {\r\n                    // Remove bad refresh token from cache\r\n                    this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");\r\n                    const badRefreshTokenKey = generateCredentialKey(refreshToken);\r\n                    this.cacheManager.removeRefreshToken(badRefreshTokenKey);\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Constructs the network message and makes a NW call to the underlying secure token service\r\n     * @param request\r\n     * @param authority\r\n     */\r\n    async executeTokenRequest(request, authority) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);\r\n        const queryParametersString = this.createTokenQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);\r\n        const headers = this.createTokenRequestHeaders(request.ccsCredential);\r\n        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);\r\n        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);\r\n    }\r\n    /**\r\n     * Helper function to create the token request body\r\n     * @param request\r\n     */\r\n    async createTokenRequestBody(request) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);\r\n        const parameters = new Map();\r\n        addClientId(parameters, request.embeddedClientId ||\r\n            request.tokenBodyParameters?.[CLIENT_ID] ||\r\n            this.config.authOptions.clientId);\r\n        if (request.redirectUri) {\r\n            addRedirectUri(parameters, request.redirectUri);\r\n        }\r\n        addScopes(parameters, request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);\r\n        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);\r\n        addClientInfo(parameters);\r\n        addLibraryInfo(parameters, this.config.libraryInfo);\r\n        addApplicationTelemetry(parameters, this.config.telemetry.application);\r\n        addThrottling(parameters);\r\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\r\n            addServerTelemetry(parameters, this.serverTelemetryManager);\r\n        }\r\n        addRefreshToken(parameters, request.refreshToken);\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            addClientSecret(parameters, this.config.clientCredentials.clientSecret);\r\n        }\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\r\n            addClientAssertionType(parameters, clientAssertion.assertionType);\r\n        }\r\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\r\n            let reqCnfData;\r\n            if (!request.popKid) {\r\n                const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\r\n                reqCnfData = generatedReqCnfData.reqCnfString;\r\n            }\r\n            else {\r\n                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\r\n            }\r\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\r\n            addPopToken(parameters, reqCnfData);\r\n        }\r\n        else if (request.authenticationScheme === AuthenticationScheme.SSH) {\r\n            if (request.sshJwk) {\r\n                addSshJwk(parameters, request.sshJwk);\r\n            }\r\n            else {\r\n                throw ClientConfigurationError_createClientConfigurationError(missingSshJwk);\r\n            }\r\n        }\r\n        if (!StringUtils.isEmptyObj(request.claims) ||\r\n            (this.config.authOptions.clientCapabilities &&\r\n                this.config.authOptions.clientCapabilities.length > 0)) {\r\n            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        if (this.config.systemOptions.preventCorsPreflight &&\r\n            request.ccsCredential) {\r\n            switch (request.ccsCredential.type) {\r\n                case CcsCredentialType.HOME_ACCOUNT_ID:\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);\r\n                        addCcsOid(parameters, clientInfo);\r\n                    }\r\n                    catch (e) {\r\n                        this.logger.verbose("Could not parse home account ID for CCS Header: " +\r\n                            e);\r\n                    }\r\n                    break;\r\n                case CcsCredentialType.UPN:\r\n                    addCcsUpn(parameters, request.ccsCredential.credential);\r\n                    break;\r\n            }\r\n        }\r\n        if (request.embeddedClientId) {\r\n            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);\r\n        }\r\n        if (request.tokenBodyParameters) {\r\n            addExtraQueryParameters(parameters, request.tokenBodyParameters);\r\n        }\r\n        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);\r\n        return mapToQueryString(parameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=RefreshTokenClient.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/client/SilentFlowClient.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/** @internal */\r\nclass SilentFlowClient extends BaseClient {\r\n    constructor(configuration, performanceClient) {\r\n        super(configuration, performanceClient);\r\n    }\r\n    /**\r\n     * Retrieves token from cache or throws an error if it must be refreshed.\r\n     * @param request\r\n     */\r\n    async acquireCachedToken(request) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);\r\n        let lastCacheOutcome = Constants_CacheOutcome.NOT_APPLICABLE;\r\n        if (request.forceRefresh ||\r\n            (!this.config.cacheOptions.claimsBasedCachingEnabled &&\r\n                !StringUtils.isEmptyObj(request.claims))) {\r\n            // Must refresh due to present force_refresh flag.\r\n            this.setCacheOutcome(Constants_CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);\r\n            throw ClientAuthError_createClientAuthError(tokenRefreshRequired);\r\n        }\r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw ClientAuthError_createClientAuthError(noAccountInSilentRequest);\r\n        }\r\n        const requestTenantId = request.account.tenantId ||\r\n            getTenantFromAuthorityString(request.authority);\r\n        const tokenKeys = this.cacheManager.getTokenKeys();\r\n        const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId, this.performanceClient, request.correlationId);\r\n        if (!cachedAccessToken) {\r\n            // must refresh due to non-existent access_token\r\n            this.setCacheOutcome(Constants_CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);\r\n            throw ClientAuthError_createClientAuthError(tokenRefreshRequired);\r\n        }\r\n        else if (wasClockTurnedBack(cachedAccessToken.cachedAt) ||\r\n            isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\r\n            // must refresh due to the expires_in value\r\n            this.setCacheOutcome(Constants_CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);\r\n            throw ClientAuthError_createClientAuthError(tokenRefreshRequired);\r\n        }\r\n        else if (cachedAccessToken.refreshOn &&\r\n            isTokenExpired(cachedAccessToken.refreshOn, 0)) {\r\n            // must refresh (in the background) due to the refresh_in value\r\n            lastCacheOutcome = Constants_CacheOutcome.PROACTIVELY_REFRESHED;\r\n            // don\'t throw ClientAuthError.createRefreshRequiredError(), return cached token instead\r\n        }\r\n        const environment = request.authority || this.authority.getPreferredCache();\r\n        const cacheRecord = {\r\n            account: this.cacheManager.readAccountFromCache(request.account),\r\n            accessToken: cachedAccessToken,\r\n            idToken: this.cacheManager.getIdToken(request.account, tokenKeys, requestTenantId, this.performanceClient, request.correlationId),\r\n            refreshToken: null,\r\n            appMetadata: this.cacheManager.readAppMetadataFromCache(environment),\r\n        };\r\n        this.setCacheOutcome(lastCacheOutcome, request.correlationId);\r\n        if (this.config.serverTelemetryManager) {\r\n            this.config.serverTelemetryManager.incrementCacheHits();\r\n        }\r\n        return [\r\n            await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),\r\n            lastCacheOutcome,\r\n        ];\r\n    }\r\n    setCacheOutcome(cacheOutcome, correlationId) {\r\n        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);\r\n        this.performanceClient?.addFields({\r\n            cacheOutcome: cacheOutcome,\r\n        }, correlationId);\r\n        if (cacheOutcome !== Constants_CacheOutcome.NOT_APPLICABLE) {\r\n            this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);\r\n        }\r\n    }\r\n    /**\r\n     * Helper function to build response object from the CacheRecord\r\n     * @param cacheRecord\r\n     */\r\n    async generateResultFromCacheRecord(cacheRecord, request) {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);\r\n        let idTokenClaims;\r\n        if (cacheRecord.idToken) {\r\n            idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);\r\n        }\r\n        // token max_age check\r\n        if (request.maxAge || request.maxAge === 0) {\r\n            const authTime = idTokenClaims?.auth_time;\r\n            if (!authTime) {\r\n                throw ClientAuthError_createClientAuthError(authTimeNotFound);\r\n            }\r\n            checkMaxAge(authTime, request.maxAge);\r\n        }\r\n        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);\r\n    }\r\n}\n\n\n//# sourceMappingURL=SilentFlowClient.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/utils/NetworkUtils.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass NetworkUtils {\r\n    static getNetworkResponse(headers, body, statusCode) {\r\n        return {\r\n            headers: headers,\r\n            body: body,\r\n            status: statusCode,\r\n        };\r\n    }\r\n    /*\r\n     * Utility function that converts a URL object into an ordinary options object as expected by the\r\n     * http.request and https.request APIs.\r\n     * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090\r\n     */\r\n    static urlToHttpOptions(url) {\r\n        const options = {\r\n            protocol: url.protocol,\r\n            hostname: url.hostname && url.hostname.startsWith("[")\r\n                ? url.hostname.slice(1, -1)\r\n                : url.hostname,\r\n            hash: url.hash,\r\n            search: url.search,\r\n            pathname: url.pathname,\r\n            path: `${url.pathname || ""}${url.search || ""}`,\r\n            href: url.href,\r\n        };\r\n        if (url.port !== "") {\r\n            options.port = Number(url.port);\r\n        }\r\n        if (url.username || url.password) {\r\n            options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\r\n        }\r\n        return options;\r\n    }\r\n}\n\n\n//# sourceMappingURL=NetworkUtils.mjs.map\n\n// EXTERNAL MODULE: external "http"\nvar external_http_ = __webpack_require__(8611);\n// EXTERNAL MODULE: external "https"\nvar external_https_ = __webpack_require__(5692);\n;// ./node_modules/@azure/msal-node/dist/network/HttpClient.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class implements the API for network requests.\r\n */\r\nclass HttpClient_HttpClient {\r\n    constructor(proxyUrl, customAgentOptions) {\r\n        this.proxyUrl = proxyUrl || "";\r\n        this.customAgentOptions = customAgentOptions || {};\r\n    }\r\n    /**\r\n     * Http Get request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendGetRequestAsync(url, options, timeout) {\r\n        if (this.proxyUrl) {\r\n            return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.GET, options, this.customAgentOptions, timeout);\r\n        }\r\n        else {\r\n            return networkRequestViaHttps(url, HttpMethod.GET, options, this.customAgentOptions, timeout);\r\n        }\r\n    }\r\n    /**\r\n     * Http Post request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendPostRequestAsync(url, options) {\r\n        if (this.proxyUrl) {\r\n            return networkRequestViaProxy(url, this.proxyUrl, HttpMethod.POST, options, this.customAgentOptions);\r\n        }\r\n        else {\r\n            return networkRequestViaHttps(url, HttpMethod.POST, options, this.customAgentOptions);\r\n        }\r\n    }\r\n}\r\nconst networkRequestViaProxy = (destinationUrlString, proxyUrlString, httpMethod, options, agentOptions, timeout) => {\r\n    const destinationUrl = new URL(destinationUrlString);\r\n    const proxyUrl = new URL(proxyUrlString);\r\n    // "method: connect" must be used to establish a connection to the proxy\r\n    const headers = options?.headers || {};\r\n    const tunnelRequestOptions = {\r\n        host: proxyUrl.hostname,\r\n        port: proxyUrl.port,\r\n        method: "CONNECT",\r\n        path: destinationUrl.hostname,\r\n        headers: headers,\r\n    };\r\n    if (agentOptions && Object.keys(agentOptions).length) {\r\n        tunnelRequestOptions.agent = new external_http_.Agent(agentOptions);\r\n    }\r\n    // compose a request string for the socket\r\n    let postRequestStringContent = "";\r\n    if (httpMethod === HttpMethod.POST) {\r\n        const body = options?.body || "";\r\n        postRequestStringContent =\r\n            "Content-Type: application/x-www-form-urlencoded\\r\\n" +\r\n                `Content-Length: ${body.length}\\r\\n` +\r\n                `\\r\\n${body}`;\r\n    }\r\n    else {\r\n        // optional timeout is only for get requests (regionDiscovery, for example)\r\n        if (timeout) {\r\n            tunnelRequestOptions.timeout = timeout;\r\n        }\r\n    }\r\n    const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\\r\\n` +\r\n        `Host: ${destinationUrl.host}\\r\\n` +\r\n        "Connection: close\\r\\n" +\r\n        postRequestStringContent +\r\n        "\\r\\n";\r\n    return new Promise((resolve, reject) => {\r\n        const request = external_http_.request(tunnelRequestOptions);\r\n        if (timeout) {\r\n            request.on("timeout", () => {\r\n                request.destroy();\r\n                reject(new Error("Request time out"));\r\n            });\r\n        }\r\n        request.end();\r\n        // establish connection to the proxy\r\n        request.on("connect", (response, socket) => {\r\n            const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;\r\n            if (proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START ||\r\n                proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END) {\r\n                request.destroy();\r\n                socket.destroy();\r\n                reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || "Unknown"}`));\r\n            }\r\n            // make a request over an HTTP tunnel\r\n            socket.write(outgoingRequestString);\r\n            const data = [];\r\n            socket.on("data", (chunk) => {\r\n                data.push(chunk);\r\n            });\r\n            socket.on("end", () => {\r\n                // combine all received buffer streams into one buffer, and then into a string\r\n                const dataString = Buffer.concat([...data]).toString();\r\n                // separate each line into it\'s own entry in an arry\r\n                const dataStringArray = dataString.split("\\r\\n");\r\n                // the first entry will contain the statusCode and statusMessage\r\n                const httpStatusCode = parseInt(dataStringArray[0].split(" ")[1]);\r\n                // remove "HTTP/1.1" and the status code to get the status message\r\n                const statusMessage = dataStringArray[0]\r\n                    .split(" ")\r\n                    .slice(2)\r\n                    .join(" ");\r\n                // the last entry will contain the body\r\n                const body = dataStringArray[dataStringArray.length - 1];\r\n                // everything in between the first and last entries are the headers\r\n                const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);\r\n                // build an object out of all the headers\r\n                const entries = new Map();\r\n                headersArray.forEach((header) => {\r\n                    /**\r\n                     * the header might look like "Content-Length: 1531", but that is just a string\r\n                     * it needs to be converted to a key/value pair\r\n                     * split the string at the first instance of ":"\r\n                     * there may be more than one ":" if the value of the header is supposed to be a JSON object\r\n                     */\r\n                    const headerKeyValue = header.split(new RegExp(/:\\s(.*)/s));\r\n                    const headerKey = headerKeyValue[0];\r\n                    let headerValue = headerKeyValue[1];\r\n                    // check if the value of the header is supposed to be a JSON object\r\n                    try {\r\n                        const object = JSON.parse(headerValue);\r\n                        // if it is, then convert it from a string to a JSON object\r\n                        if (object && typeof object === "object") {\r\n                            headerValue = object;\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        // otherwise, leave it as a string\r\n                    }\r\n                    entries.set(headerKey, headerValue);\r\n                });\r\n                const headers = Object.fromEntries(entries);\r\n                const parsedHeaders = headers;\r\n                const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(httpStatusCode, statusMessage, parsedHeaders, body), httpStatusCode);\r\n                if ((httpStatusCode < HttpStatus.SUCCESS_RANGE_START ||\r\n                    httpStatusCode > HttpStatus.SUCCESS_RANGE_END) &&\r\n                    // do not destroy the request for the device code flow\r\n                    networkResponse.body["error"] !==\r\n                        utils_Constants_Constants.AUTHORIZATION_PENDING) {\r\n                    request.destroy();\r\n                }\r\n                resolve(networkResponse);\r\n            });\r\n            socket.on("error", (chunk) => {\r\n                request.destroy();\r\n                socket.destroy();\r\n                reject(new Error(chunk.toString()));\r\n            });\r\n        });\r\n        request.on("error", (chunk) => {\r\n            request.destroy();\r\n            reject(new Error(chunk.toString()));\r\n        });\r\n    });\r\n};\r\nconst networkRequestViaHttps = (urlString, httpMethod, options, agentOptions, timeout) => {\r\n    const isPostRequest = httpMethod === HttpMethod.POST;\r\n    const body = options?.body || "";\r\n    const url = new URL(urlString);\r\n    const headers = options?.headers || {};\r\n    const customOptions = {\r\n        method: httpMethod,\r\n        headers: headers,\r\n        ...NetworkUtils.urlToHttpOptions(url),\r\n    };\r\n    if (agentOptions && Object.keys(agentOptions).length) {\r\n        customOptions.agent = new external_https_.Agent(agentOptions);\r\n    }\r\n    if (isPostRequest) {\r\n        // needed for post request to work\r\n        customOptions.headers = {\r\n            ...customOptions.headers,\r\n            "Content-Length": body.length,\r\n        };\r\n    }\r\n    else {\r\n        // optional timeout is only for get requests (regionDiscovery, for example)\r\n        if (timeout) {\r\n            customOptions.timeout = timeout;\r\n        }\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        let request;\r\n        // managed identity sources use http instead of https\r\n        if (customOptions.protocol === "http:") {\r\n            request = external_http_.request(customOptions);\r\n        }\r\n        else {\r\n            request = external_https_.request(customOptions);\r\n        }\r\n        if (isPostRequest) {\r\n            request.write(body);\r\n        }\r\n        if (timeout) {\r\n            request.on("timeout", () => {\r\n                request.destroy();\r\n                reject(new Error("Request time out"));\r\n            });\r\n        }\r\n        request.end();\r\n        request.on("response", (response) => {\r\n            const headers = response.headers;\r\n            const statusCode = response.statusCode;\r\n            const statusMessage = response.statusMessage;\r\n            const data = [];\r\n            response.on("data", (chunk) => {\r\n                data.push(chunk);\r\n            });\r\n            response.on("end", () => {\r\n                // combine all received buffer streams into one buffer, and then into a string\r\n                const body = Buffer.concat([...data]).toString();\r\n                const parsedHeaders = headers;\r\n                const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, parseBody(statusCode, statusMessage, parsedHeaders, body), statusCode);\r\n                if ((statusCode < HttpStatus.SUCCESS_RANGE_START ||\r\n                    statusCode > HttpStatus.SUCCESS_RANGE_END) &&\r\n                    // do not destroy the request for the device code flow\r\n                    networkResponse.body["error"] !==\r\n                        utils_Constants_Constants.AUTHORIZATION_PENDING) {\r\n                    request.destroy();\r\n                }\r\n                resolve(networkResponse);\r\n            });\r\n        });\r\n        request.on("error", (chunk) => {\r\n            request.destroy();\r\n            reject(new Error(chunk.toString()));\r\n        });\r\n    });\r\n};\r\n/**\r\n * Check if extra parsing is needed on the repsonse from the server\r\n * @param statusCode {number} the status code of the response from the server\r\n * @param statusMessage {string | undefined} the status message of the response from the server\r\n * @param headers {Record<string, string>} the headers of the response from the server\r\n * @param body {string} the body from the response of the server\r\n * @returns {Object} JSON parsed body or error object\r\n */\r\nconst parseBody = (statusCode, statusMessage, headers, body) => {\r\n    /*\r\n     * Informational responses (100  199)\r\n     * Successful responses (200  299)\r\n     * Redirection messages (300  399)\r\n     * Client error responses (400  499)\r\n     * Server error responses (500  599)\r\n     */\r\n    let parsedBody;\r\n    try {\r\n        parsedBody = JSON.parse(body);\r\n    }\r\n    catch (error) {\r\n        let errorType;\r\n        let errorDescriptionHelper;\r\n        if (statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START &&\r\n            statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END) {\r\n            errorType = "client_error";\r\n            errorDescriptionHelper = "A client";\r\n        }\r\n        else if (statusCode >= HttpStatus.SERVER_ERROR_RANGE_START &&\r\n            statusCode <= HttpStatus.SERVER_ERROR_RANGE_END) {\r\n            errorType = "server_error";\r\n            errorDescriptionHelper = "A server";\r\n        }\r\n        else {\r\n            errorType = "unknown_error";\r\n            errorDescriptionHelper = "An unknown";\r\n        }\r\n        parsedBody = {\r\n            error: errorType,\r\n            error_description: `${errorDescriptionHelper} error occured.\\nHttp status code: ${statusCode}\\nHttp status message: ${statusMessage || "Unknown"}\\nHeaders: ${JSON.stringify(headers)}`,\r\n        };\r\n    }\r\n    return parsedBody;\r\n};\n\n\n//# sourceMappingURL=HttpClient.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/error/ManagedIdentityErrorCodes.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst invalidFileExtension = "invalid_file_extension";\r\nconst invalidFilePath = "invalid_file_path";\r\nconst ManagedIdentityErrorCodes_invalidManagedIdentityIdType = "invalid_managed_identity_id_type";\r\nconst invalidSecret = "invalid_secret";\r\nconst missingId = "missing_client_id";\r\nconst networkUnavailable = "network_unavailable";\r\nconst platformNotSupported = "platform_not_supported";\r\nconst unableToCreateAzureArc = "unable_to_create_azure_arc";\r\nconst unableToCreateCloudShell = "unable_to_create_cloud_shell";\r\nconst ManagedIdentityErrorCodes_unableToCreateSource = "unable_to_create_source";\r\nconst unableToReadSecretFile = "unable_to_read_secret_file";\r\nconst userAssignedNotAvailableAtRuntime = "user_assigned_not_available_at_runtime";\r\nconst wwwAuthenticateHeaderMissing = "www_authenticate_header_missing";\r\nconst wwwAuthenticateHeaderUnsupportedFormat = "www_authenticate_header_unsupported_format";\r\nconst MsiEnvironmentVariableUrlMalformedErrorCodes = {\r\n    [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]: "azure_pod_identity_authority_host_url_malformed",\r\n    [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]: "identity_endpoint_url_malformed",\r\n    [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]: "imds_endpoint_url_malformed",\r\n    [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]: "msi_endpoint_url_malformed",\r\n};\n\n\n//# sourceMappingURL=ManagedIdentityErrorCodes.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/error/ManagedIdentityError.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * ManagedIdentityErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nconst ManagedIdentityErrorMessages = {\r\n    [invalidFileExtension]: "The file path in the WWW-Authenticate header does not contain a .key file.",\r\n    [invalidFilePath]: "The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.",\r\n    [ManagedIdentityErrorCodes_invalidManagedIdentityIdType]: "More than one ManagedIdentityIdType was provided.",\r\n    [invalidSecret]: "The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.",\r\n    [platformNotSupported]: "The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.",\r\n    [missingId]: "A ManagedIdentityId id was not provided.",\r\n    [MsiEnvironmentVariableUrlMalformedErrorCodes\r\n        .AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity\'s \'${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}\' environment variable is malformed.`,\r\n    [MsiEnvironmentVariableUrlMalformedErrorCodes\r\n        .IDENTITY_ENDPOINT]: `The Managed Identity\'s \'${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}\' environment variable is malformed.`,\r\n    [MsiEnvironmentVariableUrlMalformedErrorCodes\r\n        .IMDS_ENDPOINT]: `The Managed Identity\'s \'${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}\' environment variable is malformed.`,\r\n    [MsiEnvironmentVariableUrlMalformedErrorCodes\r\n        .MSI_ENDPOINT]: `The Managed Identity\'s \'${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}\' environment variable is malformed.`,\r\n    [networkUnavailable]: "Authentication unavailable. The request to the managed identity endpoint timed out.",\r\n    [unableToCreateAzureArc]: "Azure Arc Managed Identities can only be system assigned.",\r\n    [unableToCreateCloudShell]: "Cloud Shell Managed Identities can only be system assigned.",\r\n    [ManagedIdentityErrorCodes_unableToCreateSource]: "Unable to create a Managed Identity source based on environment variables.",\r\n    [unableToReadSecretFile]: "Unable to read the secret file.",\r\n    [userAssignedNotAvailableAtRuntime]: "Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.",\r\n    [wwwAuthenticateHeaderMissing]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.",\r\n    [wwwAuthenticateHeaderUnsupportedFormat]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format.",\r\n};\r\nclass ManagedIdentityError extends AuthError {\r\n    constructor(errorCode) {\r\n        super(errorCode, ManagedIdentityErrorMessages[errorCode]);\r\n        this.name = "ManagedIdentityError";\r\n        Object.setPrototypeOf(this, ManagedIdentityError.prototype);\r\n    }\r\n}\r\nfunction ManagedIdentityError_createManagedIdentityError(errorCode) {\r\n    return new ManagedIdentityError(errorCode);\r\n}\n\n\n//# sourceMappingURL=ManagedIdentityError.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/config/ManagedIdentityId.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass ManagedIdentityId_ManagedIdentityId {\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    set id(value) {\r\n        this._id = value;\r\n    }\r\n    get idType() {\r\n        return this._idType;\r\n    }\r\n    set idType(value) {\r\n        this._idType = value;\r\n    }\r\n    constructor(managedIdentityIdParams) {\r\n        const userAssignedClientId = managedIdentityIdParams?.userAssignedClientId;\r\n        const userAssignedResourceId = managedIdentityIdParams?.userAssignedResourceId;\r\n        const userAssignedObjectId = managedIdentityIdParams?.userAssignedObjectId;\r\n        if (userAssignedClientId) {\r\n            if (userAssignedResourceId || userAssignedObjectId) {\r\n                throw createManagedIdentityError(invalidManagedIdentityIdType);\r\n            }\r\n            this.id = userAssignedClientId;\r\n            this.idType = ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID;\r\n        }\r\n        else if (userAssignedResourceId) {\r\n            if (userAssignedClientId || userAssignedObjectId) {\r\n                throw createManagedIdentityError(invalidManagedIdentityIdType);\r\n            }\r\n            this.id = userAssignedResourceId;\r\n            this.idType = ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID;\r\n        }\r\n        else if (userAssignedObjectId) {\r\n            if (userAssignedClientId || userAssignedResourceId) {\r\n                throw createManagedIdentityError(invalidManagedIdentityIdType);\r\n            }\r\n            this.id = userAssignedObjectId;\r\n            this.idType = ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID;\r\n        }\r\n        else {\r\n            this.id = DEFAULT_MANAGED_IDENTITY_ID;\r\n            this.idType = ManagedIdentityIdType.SYSTEM_ASSIGNED;\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=ManagedIdentityId.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/error/NodeAuthError.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * NodeAuthErrorMessage class containing string constants used by error codes and messages.\r\n */\r\nconst NodeAuthErrorMessage = {\r\n    invalidLoopbackAddressType: {\r\n        code: "invalid_loopback_server_address_type",\r\n        desc: "Loopback server address is not type string. This is unexpected.",\r\n    },\r\n    unableToLoadRedirectUri: {\r\n        code: "unable_to_load_redirectUrl",\r\n        desc: "Loopback server callback was invoked without a url. This is unexpected.",\r\n    },\r\n    noAuthCodeInResponse: {\r\n        code: "no_auth_code_in_response",\r\n        desc: "No auth code found in the server response. Please check your network trace to determine what happened.",\r\n    },\r\n    noLoopbackServerExists: {\r\n        code: "no_loopback_server_exists",\r\n        desc: "No loopback server exists yet.",\r\n    },\r\n    loopbackServerAlreadyExists: {\r\n        code: "loopback_server_already_exists",\r\n        desc: "Loopback server already exists. Cannot create another.",\r\n    },\r\n    loopbackServerTimeout: {\r\n        code: "loopback_server_timeout",\r\n        desc: "Timed out waiting for auth code listener to be registered.",\r\n    },\r\n    stateNotFoundError: {\r\n        code: "state_not_found",\r\n        desc: "State not found. Please verify that the request originated from msal.",\r\n    },\r\n    thumbprintMissing: {\r\n        code: "thumbprint_missing_from_client_certificate",\r\n        desc: "Client certificate does not contain a SHA-1 or SHA-256 thumbprint.",\r\n    },\r\n};\r\nclass NodeAuthError extends AuthError {\r\n    constructor(errorCode, errorMessage) {\r\n        super(errorCode, errorMessage);\r\n        this.name = "NodeAuthError";\r\n    }\r\n    /**\r\n     * Creates an error thrown if loopback server address is of type string.\r\n     */\r\n    static createInvalidLoopbackAddressTypeError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);\r\n    }\r\n    /**\r\n     * Creates an error thrown if the loopback server is unable to get a url.\r\n     */\r\n    static createUnableToLoadRedirectUrlError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);\r\n    }\r\n    /**\r\n     * Creates an error thrown if the server response does not contain an auth code.\r\n     */\r\n    static createNoAuthCodeInResponseError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);\r\n    }\r\n    /**\r\n     * Creates an error thrown if the loopback server has not been spun up yet.\r\n     */\r\n    static createNoLoopbackServerExistsError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);\r\n    }\r\n    /**\r\n     * Creates an error thrown if a loopback server already exists when attempting to create another one.\r\n     */\r\n    static createLoopbackServerAlreadyExistsError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);\r\n    }\r\n    /**\r\n     * Creates an error thrown if the loopback server times out registering the auth code listener.\r\n     */\r\n    static createLoopbackServerTimeoutError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);\r\n    }\r\n    /**\r\n     * Creates an error thrown when the state is not present.\r\n     */\r\n    static createStateNotFoundError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);\r\n    }\r\n    /**\r\n     * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided\r\n     */\r\n    static createThumbprintMissingError() {\r\n        return new NodeAuthError(NodeAuthErrorMessage.thumbprintMissing.code, NodeAuthErrorMessage.thumbprintMissing.desc);\r\n    }\r\n}\n\n\n//# sourceMappingURL=NodeAuthError.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/config/Configuration.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst DEFAULT_AUTH_OPTIONS = {\r\n    clientId: Constants_Constants.EMPTY_STRING,\r\n    authority: Constants_Constants.DEFAULT_AUTHORITY,\r\n    clientSecret: Constants_Constants.EMPTY_STRING,\r\n    clientAssertion: Constants_Constants.EMPTY_STRING,\r\n    clientCertificate: {\r\n        thumbprint: Constants_Constants.EMPTY_STRING,\r\n        thumbprintSha256: Constants_Constants.EMPTY_STRING,\r\n        privateKey: Constants_Constants.EMPTY_STRING,\r\n        x5c: Constants_Constants.EMPTY_STRING,\r\n    },\r\n    knownAuthorities: [],\r\n    cloudDiscoveryMetadata: Constants_Constants.EMPTY_STRING,\r\n    authorityMetadata: Constants_Constants.EMPTY_STRING,\r\n    clientCapabilities: [],\r\n    protocolMode: ProtocolMode_ProtocolMode.AAD,\r\n    azureCloudOptions: {\r\n        azureCloudInstance: AzureCloudInstance.None,\r\n        tenant: Constants_Constants.EMPTY_STRING,\r\n    },\r\n    skipAuthorityMetadataCache: false,\r\n    encodeExtraQueryParams: false,\r\n};\r\nconst Configuration_DEFAULT_CACHE_OPTIONS = {\r\n    claimsBasedCachingEnabled: false,\r\n};\r\nconst DEFAULT_LOGGER_OPTIONS = {\r\n    loggerCallback: () => {\r\n        // allow users to not set logger call back\r\n    },\r\n    piiLoggingEnabled: false,\r\n    logLevel: LogLevel.Info,\r\n};\r\nconst Configuration_DEFAULT_SYSTEM_OPTIONS = {\r\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\r\n    networkClient: new HttpClient_HttpClient(),\r\n    proxyUrl: Constants_Constants.EMPTY_STRING,\r\n    customAgentOptions: {},\r\n    disableInternalRetries: false,\r\n};\r\nconst Configuration_DEFAULT_TELEMETRY_OPTIONS = {\r\n    application: {\r\n        appName: Constants_Constants.EMPTY_STRING,\r\n        appVersion: Constants_Constants.EMPTY_STRING,\r\n    },\r\n};\r\n/**\r\n * Sets the default options when not explicitly configured from app developer\r\n *\r\n * @param auth - Authentication options\r\n * @param cache - Cache options\r\n * @param system - System options\r\n * @param telemetry - Telemetry options\r\n *\r\n * @returns Configuration\r\n * @internal\r\n */\r\nfunction buildAppConfiguration({ auth, broker, cache, system, telemetry, }) {\r\n    const systemOptions = {\r\n        ...Configuration_DEFAULT_SYSTEM_OPTIONS,\r\n        networkClient: new HttpClient_HttpClient(system?.proxyUrl, system?.customAgentOptions),\r\n        loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,\r\n        disableInternalRetries: system?.disableInternalRetries || false,\r\n    };\r\n    // if client certificate was provided, ensure that at least one of the SHA-1 or SHA-256 thumbprints were provided\r\n    if (!!auth.clientCertificate &&\r\n        !!!auth.clientCertificate.thumbprint &&\r\n        !!!auth.clientCertificate.thumbprintSha256) {\r\n        throw NodeAuthError.createStateNotFoundError();\r\n    }\r\n    return {\r\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\r\n        broker: { ...broker },\r\n        cache: { ...Configuration_DEFAULT_CACHE_OPTIONS, ...cache },\r\n        system: { ...systemOptions, ...system },\r\n        telemetry: { ...Configuration_DEFAULT_TELEMETRY_OPTIONS, ...telemetry },\r\n    };\r\n}\r\nfunction Configuration_buildManagedIdentityConfiguration({ clientCapabilities, managedIdentityIdParams, system, }) {\r\n    const managedIdentityId = new ManagedIdentityId(managedIdentityIdParams);\r\n    const loggerOptions = system?.loggerOptions || DEFAULT_LOGGER_OPTIONS;\r\n    let networkClient;\r\n    // use developer provided network client if passed in\r\n    if (system?.networkClient) {\r\n        networkClient = system.networkClient;\r\n        // otherwise, create a new one\r\n    }\r\n    else {\r\n        networkClient = new HttpClient(system?.proxyUrl, system?.customAgentOptions);\r\n    }\r\n    return {\r\n        clientCapabilities: clientCapabilities || [],\r\n        managedIdentityId: managedIdentityId,\r\n        system: {\r\n            loggerOptions,\r\n            networkClient,\r\n        },\r\n        disableInternalRetries: system?.disableInternalRetries || false,\r\n    };\r\n}\n\n\n//# sourceMappingURL=Configuration.mjs.map\n\n// EXTERNAL MODULE: external "crypto"\nvar external_crypto_ = __webpack_require__(6982);\nvar external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);\n;// ./node_modules/uuid/dist/esm-node/rng.js\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    external_crypto_default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}\n;// ./node_modules/uuid/dist/esm-node/regex.js\n/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n;// ./node_modules/uuid/dist/esm-node/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === \'string\' && regex.test(uuid);\n}\n\n/* harmony default export */ const esm_node_validate = (validate);\n;// ./node_modules/uuid/dist/esm-node/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It\'s been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \'-\' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \'-\' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \'-\' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \'-\' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it\'s likely due to one\n  // of the following:\n  // - One or more input array values don\'t map to a hex octet (leading to\n  // "undefined" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_node_validate(uuid)) {\n    throw TypeError(\'Stringified UUID is invalid\');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const esm_node_stringify = (stringify);\n;// ./node_modules/uuid/dist/esm-node/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_node_stringify(rnds);\n}\n\n/* harmony default export */ const esm_node_v4 = (v4);\n;// ./node_modules/@azure/msal-node/dist/crypto/GuidGenerator.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass GuidGenerator {\r\n    /**\r\n     *\r\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\r\n     * uuidv4 generates guids from cryprtographically-string random\r\n     */\r\n    generateGuid() {\r\n        return esm_node_v4();\r\n    }\r\n    /**\r\n     * verifies if a string is  GUID\r\n     * @param guid\r\n     */\r\n    isGuid(guid) {\r\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n        return regexGuid.test(guid);\r\n    }\r\n}\n\n\n//# sourceMappingURL=GuidGenerator.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/utils/EncodingUtils.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass EncodingUtils {\r\n    /**\r\n     * \'utf8\': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * \'base64\': Base64 encoding.\r\n     *\r\n     * @param str text\r\n     */\r\n    static base64Encode(str, encoding) {\r\n        return Buffer.from(str, encoding).toString(Constants_EncodingTypes.BASE64);\r\n    }\r\n    /**\r\n     * encode a URL\r\n     * @param str\r\n     */\r\n    static base64EncodeUrl(str, encoding) {\r\n        return EncodingUtils.base64Encode(str, encoding)\r\n            .replace(/=/g, Constants_Constants.EMPTY_STRING)\r\n            .replace(/\\+/g, "-")\r\n            .replace(/\\//g, "_");\r\n    }\r\n    /**\r\n     * \'utf8\': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * \'base64\': Base64 encoding.\r\n     *\r\n     * @param base64Str Base64 encoded text\r\n     */\r\n    static base64Decode(base64Str) {\r\n        return Buffer.from(base64Str, Constants_EncodingTypes.BASE64).toString("utf8");\r\n    }\r\n    /**\r\n     * @param base64Str Base64 encoded Url\r\n     */\r\n    static base64DecodeUrl(base64Str) {\r\n        let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");\r\n        while (str.length % 4) {\r\n            str += "=";\r\n        }\r\n        return EncodingUtils.base64Decode(str);\r\n    }\r\n}\n\n\n//# sourceMappingURL=EncodingUtils.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/crypto/HashUtils.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass HashUtils_HashUtils {\r\n    /**\r\n     * generate \'SHA256\' hash\r\n     * @param buffer\r\n     */\r\n    sha256(buffer) {\r\n        return external_crypto_.createHash(Hash.SHA256).update(buffer).digest();\r\n    }\r\n}\n\n\n//# sourceMappingURL=HashUtils.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/crypto/PkceGenerator.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * https://tools.ietf.org/html/rfc7636#page-8\r\n */\r\nclass PkceGenerator {\r\n    constructor() {\r\n        this.hashUtils = new HashUtils_HashUtils();\r\n    }\r\n    /**\r\n     * generates the codeVerfier and the challenge from the codeVerfier\r\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\r\n     */\r\n    async generatePkceCodes() {\r\n        const verifier = this.generateCodeVerifier();\r\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\r\n        return { verifier, challenge };\r\n    }\r\n    /**\r\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     */\r\n    generateCodeVerifier() {\r\n        const charArr = [];\r\n        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);\r\n        while (charArr.length <= RANDOM_OCTET_SIZE) {\r\n            const byte = external_crypto_.randomBytes(1)[0];\r\n            if (byte >= maxNumber) {\r\n                /*\r\n                 * Ignore this number to maintain randomness.\r\n                 * Including it would result in an unequal distribution of characters after doing the modulo\r\n                 */\r\n                continue;\r\n            }\r\n            const index = byte % CharSet.CV_CHARSET.length;\r\n            charArr.push(CharSet.CV_CHARSET[index]);\r\n        }\r\n        const verifier = charArr.join(Constants_Constants.EMPTY_STRING);\r\n        return EncodingUtils.base64EncodeUrl(verifier);\r\n    }\r\n    /**\r\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\r\n     * @param codeVerifier\r\n     */\r\n    generateCodeChallengeFromVerifier(codeVerifier) {\r\n        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString(Constants_EncodingTypes.BASE64), Constants_EncodingTypes.BASE64);\r\n    }\r\n}\n\n\n//# sourceMappingURL=PkceGenerator.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/crypto/CryptoProvider.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class implements MSAL node\'s crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n * @public\r\n */\r\nclass CryptoProvider_CryptoProvider {\r\n    constructor() {\r\n        // Browser crypto needs to be validated first before any other classes can be set.\r\n        this.pkceGenerator = new PkceGenerator();\r\n        this.guidGenerator = new GuidGenerator();\r\n        this.hashUtils = new HashUtils_HashUtils();\r\n    }\r\n    /**\r\n     * base64 URL safe encoded string\r\n     */\r\n    base64UrlEncode() {\r\n        throw new Error("Method not implemented.");\r\n    }\r\n    /**\r\n     * Stringifies and base64Url encodes input public key\r\n     * @param inputKid - public key id\r\n     * @returns Base64Url encoded public key\r\n     */\r\n    encodeKid() {\r\n        throw new Error("Method not implemented.");\r\n    }\r\n    /**\r\n     * Creates a new random GUID - used to populate state and nonce.\r\n     * @returns string (GUID)\r\n     */\r\n    createNewGuid() {\r\n        return this.guidGenerator.generateGuid();\r\n    }\r\n    /**\r\n     * Encodes input string to base64.\r\n     * @param input - string to be encoded\r\n     */\r\n    base64Encode(input) {\r\n        return EncodingUtils.base64Encode(input);\r\n    }\r\n    /**\r\n     * Decodes input string from base64.\r\n     * @param input - string to be decoded\r\n     */\r\n    base64Decode(input) {\r\n        return EncodingUtils.base64Decode(input);\r\n    }\r\n    /**\r\n     * Generates PKCE codes used in Authorization Code Flow.\r\n     */\r\n    generatePkceCodes() {\r\n        return this.pkceGenerator.generatePkceCodes();\r\n    }\r\n    /**\r\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\r\n     */\r\n    getPublicKeyThumbprint() {\r\n        throw new Error("Method not implemented.");\r\n    }\r\n    /**\r\n     * Removes cryptographic keypair from key store matching the keyId passed in\r\n     * @param kid - public key id\r\n     */\r\n    removeTokenBindingKey() {\r\n        throw new Error("Method not implemented.");\r\n    }\r\n    /**\r\n     * Removes all cryptographic keys from Keystore\r\n     */\r\n    clearKeystore() {\r\n        throw new Error("Method not implemented.");\r\n    }\r\n    /**\r\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\r\n     */\r\n    signJwt() {\r\n        throw new Error("Method not implemented.");\r\n    }\r\n    /**\r\n     * Returns the SHA-256 hash of an input string\r\n     */\r\n    async hashString(plainText) {\r\n        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString(Constants_EncodingTypes.BASE64), Constants_EncodingTypes.BASE64);\r\n    }\r\n}\n\n\n//# sourceMappingURL=CryptoProvider.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/cache/serializer/Deserializer.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class deserializes cache entities read from the file into in-memory object types defined internally\r\n * @internal\r\n */\r\nclass Deserializer {\r\n    /**\r\n     * Parse the JSON blob in memory and deserialize the content\r\n     * @param cachedJson - JSON blob cache\r\n     */\r\n    static deserializeJSONBlob(jsonFile) {\r\n        const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);\r\n        return deserializedCache;\r\n    }\r\n    /**\r\n     * Deserializes accounts to AccountEntity objects\r\n     * @param accounts - accounts of type SerializedAccountEntity\r\n     */\r\n    static deserializeAccounts(accounts) {\r\n        const accountObjects = {};\r\n        if (accounts) {\r\n            Object.keys(accounts).map(function (key) {\r\n                const serializedAcc = accounts[key];\r\n                const mappedAcc = {\r\n                    homeAccountId: serializedAcc.home_account_id,\r\n                    environment: serializedAcc.environment,\r\n                    realm: serializedAcc.realm,\r\n                    localAccountId: serializedAcc.local_account_id,\r\n                    username: serializedAcc.username,\r\n                    authorityType: serializedAcc.authority_type,\r\n                    name: serializedAcc.name,\r\n                    clientInfo: serializedAcc.client_info,\r\n                    lastModificationTime: serializedAcc.last_modification_time,\r\n                    lastModificationApp: serializedAcc.last_modification_app,\r\n                    tenantProfiles: serializedAcc.tenantProfiles?.map((serializedTenantProfile) => {\r\n                        return JSON.parse(serializedTenantProfile);\r\n                    }),\r\n                };\r\n                const account = new AccountEntity();\r\n                CacheManager.toObject(account, mappedAcc);\r\n                accountObjects[key] = account;\r\n            });\r\n        }\r\n        return accountObjects;\r\n    }\r\n    /**\r\n     * Deserializes id tokens to IdTokenEntity objects\r\n     * @param idTokens - credentials of type SerializedIdTokenEntity\r\n     */\r\n    static deserializeIdTokens(idTokens) {\r\n        const idObjects = {};\r\n        if (idTokens) {\r\n            Object.keys(idTokens).map(function (key) {\r\n                const serializedIdT = idTokens[key];\r\n                const idToken = {\r\n                    homeAccountId: serializedIdT.home_account_id,\r\n                    environment: serializedIdT.environment,\r\n                    credentialType: serializedIdT.credential_type,\r\n                    clientId: serializedIdT.client_id,\r\n                    secret: serializedIdT.secret,\r\n                    realm: serializedIdT.realm,\r\n                };\r\n                idObjects[key] = idToken;\r\n            });\r\n        }\r\n        return idObjects;\r\n    }\r\n    /**\r\n     * Deserializes access tokens to AccessTokenEntity objects\r\n     * @param accessTokens - access tokens of type SerializedAccessTokenEntity\r\n     */\r\n    static deserializeAccessTokens(accessTokens) {\r\n        const atObjects = {};\r\n        if (accessTokens) {\r\n            Object.keys(accessTokens).map(function (key) {\r\n                const serializedAT = accessTokens[key];\r\n                const accessToken = {\r\n                    homeAccountId: serializedAT.home_account_id,\r\n                    environment: serializedAT.environment,\r\n                    credentialType: serializedAT.credential_type,\r\n                    clientId: serializedAT.client_id,\r\n                    secret: serializedAT.secret,\r\n                    realm: serializedAT.realm,\r\n                    target: serializedAT.target,\r\n                    cachedAt: serializedAT.cached_at,\r\n                    expiresOn: serializedAT.expires_on,\r\n                    extendedExpiresOn: serializedAT.extended_expires_on,\r\n                    refreshOn: serializedAT.refresh_on,\r\n                    keyId: serializedAT.key_id,\r\n                    tokenType: serializedAT.token_type,\r\n                    requestedClaims: serializedAT.requestedClaims,\r\n                    requestedClaimsHash: serializedAT.requestedClaimsHash,\r\n                    userAssertionHash: serializedAT.userAssertionHash,\r\n                };\r\n                atObjects[key] = accessToken;\r\n            });\r\n        }\r\n        return atObjects;\r\n    }\r\n    /**\r\n     * Deserializes refresh tokens to RefreshTokenEntity objects\r\n     * @param refreshTokens - refresh tokens of type SerializedRefreshTokenEntity\r\n     */\r\n    static deserializeRefreshTokens(refreshTokens) {\r\n        const rtObjects = {};\r\n        if (refreshTokens) {\r\n            Object.keys(refreshTokens).map(function (key) {\r\n                const serializedRT = refreshTokens[key];\r\n                const refreshToken = {\r\n                    homeAccountId: serializedRT.home_account_id,\r\n                    environment: serializedRT.environment,\r\n                    credentialType: serializedRT.credential_type,\r\n                    clientId: serializedRT.client_id,\r\n                    secret: serializedRT.secret,\r\n                    familyId: serializedRT.family_id,\r\n                    target: serializedRT.target,\r\n                    realm: serializedRT.realm,\r\n                };\r\n                rtObjects[key] = refreshToken;\r\n            });\r\n        }\r\n        return rtObjects;\r\n    }\r\n    /**\r\n     * Deserializes appMetadata to AppMetaData objects\r\n     * @param appMetadata - app metadata of type SerializedAppMetadataEntity\r\n     */\r\n    static deserializeAppMetadata(appMetadata) {\r\n        const appMetadataObjects = {};\r\n        if (appMetadata) {\r\n            Object.keys(appMetadata).map(function (key) {\r\n                const serializedAmdt = appMetadata[key];\r\n                appMetadataObjects[key] = {\r\n                    clientId: serializedAmdt.client_id,\r\n                    environment: serializedAmdt.environment,\r\n                    familyId: serializedAmdt.family_id,\r\n                };\r\n            });\r\n        }\r\n        return appMetadataObjects;\r\n    }\r\n    /**\r\n     * Deserialize an inMemory Cache\r\n     * @param jsonCache - JSON blob cache\r\n     */\r\n    static deserializeAllCache(jsonCache) {\r\n        return {\r\n            accounts: jsonCache.Account\r\n                ? this.deserializeAccounts(jsonCache.Account)\r\n                : {},\r\n            idTokens: jsonCache.IdToken\r\n                ? this.deserializeIdTokens(jsonCache.IdToken)\r\n                : {},\r\n            accessTokens: jsonCache.AccessToken\r\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\r\n                : {},\r\n            refreshTokens: jsonCache.RefreshToken\r\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\r\n                : {},\r\n            appMetadata: jsonCache.AppMetadata\r\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\r\n                : {},\r\n        };\r\n    }\r\n}\n\n\n//# sourceMappingURL=Deserializer.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/cache/serializer/Serializer.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class serializes cache entities to be saved into in-memory object types defined internally\r\n * @internal\r\n */\r\nclass Serializer {\r\n    /**\r\n     * serialize the JSON blob\r\n     * @param data - JSON blob cache\r\n     */\r\n    static serializeJSONBlob(data) {\r\n        return JSON.stringify(data);\r\n    }\r\n    /**\r\n     * Serialize Accounts\r\n     * @param accCache - cache of accounts\r\n     */\r\n    static serializeAccounts(accCache) {\r\n        const accounts = {};\r\n        Object.keys(accCache).map(function (key) {\r\n            const accountEntity = accCache[key];\r\n            accounts[key] = {\r\n                home_account_id: accountEntity.homeAccountId,\r\n                environment: accountEntity.environment,\r\n                realm: accountEntity.realm,\r\n                local_account_id: accountEntity.localAccountId,\r\n                username: accountEntity.username,\r\n                authority_type: accountEntity.authorityType,\r\n                name: accountEntity.name,\r\n                client_info: accountEntity.clientInfo,\r\n                last_modification_time: accountEntity.lastModificationTime,\r\n                last_modification_app: accountEntity.lastModificationApp,\r\n                tenantProfiles: accountEntity.tenantProfiles?.map((tenantProfile) => {\r\n                    return JSON.stringify(tenantProfile);\r\n                }),\r\n            };\r\n        });\r\n        return accounts;\r\n    }\r\n    /**\r\n     * Serialize IdTokens\r\n     * @param idTCache - cache of ID tokens\r\n     */\r\n    static serializeIdTokens(idTCache) {\r\n        const idTokens = {};\r\n        Object.keys(idTCache).map(function (key) {\r\n            const idTEntity = idTCache[key];\r\n            idTokens[key] = {\r\n                home_account_id: idTEntity.homeAccountId,\r\n                environment: idTEntity.environment,\r\n                credential_type: idTEntity.credentialType,\r\n                client_id: idTEntity.clientId,\r\n                secret: idTEntity.secret,\r\n                realm: idTEntity.realm,\r\n            };\r\n        });\r\n        return idTokens;\r\n    }\r\n    /**\r\n     * Serializes AccessTokens\r\n     * @param atCache - cache of access tokens\r\n     */\r\n    static serializeAccessTokens(atCache) {\r\n        const accessTokens = {};\r\n        Object.keys(atCache).map(function (key) {\r\n            const atEntity = atCache[key];\r\n            accessTokens[key] = {\r\n                home_account_id: atEntity.homeAccountId,\r\n                environment: atEntity.environment,\r\n                credential_type: atEntity.credentialType,\r\n                client_id: atEntity.clientId,\r\n                secret: atEntity.secret,\r\n                realm: atEntity.realm,\r\n                target: atEntity.target,\r\n                cached_at: atEntity.cachedAt,\r\n                expires_on: atEntity.expiresOn,\r\n                extended_expires_on: atEntity.extendedExpiresOn,\r\n                refresh_on: atEntity.refreshOn,\r\n                key_id: atEntity.keyId,\r\n                token_type: atEntity.tokenType,\r\n                requestedClaims: atEntity.requestedClaims,\r\n                requestedClaimsHash: atEntity.requestedClaimsHash,\r\n                userAssertionHash: atEntity.userAssertionHash,\r\n            };\r\n        });\r\n        return accessTokens;\r\n    }\r\n    /**\r\n     * Serialize refreshTokens\r\n     * @param rtCache - cache of refresh tokens\r\n     */\r\n    static serializeRefreshTokens(rtCache) {\r\n        const refreshTokens = {};\r\n        Object.keys(rtCache).map(function (key) {\r\n            const rtEntity = rtCache[key];\r\n            refreshTokens[key] = {\r\n                home_account_id: rtEntity.homeAccountId,\r\n                environment: rtEntity.environment,\r\n                credential_type: rtEntity.credentialType,\r\n                client_id: rtEntity.clientId,\r\n                secret: rtEntity.secret,\r\n                family_id: rtEntity.familyId,\r\n                target: rtEntity.target,\r\n                realm: rtEntity.realm,\r\n            };\r\n        });\r\n        return refreshTokens;\r\n    }\r\n    /**\r\n     * Serialize amdtCache\r\n     * @param amdtCache - cache of app metadata\r\n     */\r\n    static serializeAppMetadata(amdtCache) {\r\n        const appMetadata = {};\r\n        Object.keys(amdtCache).map(function (key) {\r\n            const amdtEntity = amdtCache[key];\r\n            appMetadata[key] = {\r\n                client_id: amdtEntity.clientId,\r\n                environment: amdtEntity.environment,\r\n                family_id: amdtEntity.familyId,\r\n            };\r\n        });\r\n        return appMetadata;\r\n    }\r\n    /**\r\n     * Serialize the cache\r\n     * @param inMemCache - itemised cache read from the JSON\r\n     */\r\n    static serializeAllCache(inMemCache) {\r\n        return {\r\n            Account: this.serializeAccounts(inMemCache.accounts),\r\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\r\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\r\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\r\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\r\n        };\r\n    }\r\n}\n\n\n//# sourceMappingURL=Serializer.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/cache/NodeStorage.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\r\n * @public\r\n */\r\nclass NodeStorage_NodeStorage extends CacheManager {\r\n    constructor(logger, clientId, cryptoImpl, staticAuthorityOptions) {\r\n        super(clientId, cryptoImpl, logger, staticAuthorityOptions);\r\n        this.cache = {};\r\n        this.changeEmitters = [];\r\n        this.logger = logger;\r\n    }\r\n    /**\r\n     * Queue up callbacks\r\n     * @param func - a callback function for cache change indication\r\n     */\r\n    registerChangeEmitter(func) {\r\n        this.changeEmitters.push(func);\r\n    }\r\n    /**\r\n     * Invoke the callback when cache changes\r\n     */\r\n    emitChange() {\r\n        this.changeEmitters.forEach((func) => func.call(null));\r\n    }\r\n    /**\r\n     * Converts cacheKVStore to InMemoryCache\r\n     * @param cache - key value store\r\n     */\r\n    cacheToInMemoryCache(cache) {\r\n        const inMemoryCache = {\r\n            accounts: {},\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {},\r\n            appMetadata: {},\r\n        };\r\n        for (const key in cache) {\r\n            const value = cache[key];\r\n            if (typeof value !== "object") {\r\n                continue;\r\n            }\r\n            if (value instanceof AccountEntity) {\r\n                inMemoryCache.accounts[key] = value;\r\n            }\r\n            else if (isIdTokenEntity(value)) {\r\n                inMemoryCache.idTokens[key] = value;\r\n            }\r\n            else if (isAccessTokenEntity(value)) {\r\n                inMemoryCache.accessTokens[key] = value;\r\n            }\r\n            else if (isRefreshTokenEntity(value)) {\r\n                inMemoryCache.refreshTokens[key] = value;\r\n            }\r\n            else if (isAppMetadataEntity(key, value)) {\r\n                inMemoryCache.appMetadata[key] = value;\r\n            }\r\n            else {\r\n                continue;\r\n            }\r\n        }\r\n        return inMemoryCache;\r\n    }\r\n    /**\r\n     * converts inMemoryCache to CacheKVStore\r\n     * @param inMemoryCache - kvstore map for inmemory\r\n     */\r\n    inMemoryCacheToCache(inMemoryCache) {\r\n        // convert in memory cache to a flat Key-Value map\r\n        let cache = this.getCache();\r\n        cache = {\r\n            ...cache,\r\n            ...inMemoryCache.accounts,\r\n            ...inMemoryCache.idTokens,\r\n            ...inMemoryCache.accessTokens,\r\n            ...inMemoryCache.refreshTokens,\r\n            ...inMemoryCache.appMetadata,\r\n        };\r\n        // convert in memory cache to a flat Key-Value map\r\n        return cache;\r\n    }\r\n    /**\r\n     * gets the current in memory cache for the client\r\n     */\r\n    getInMemoryCache() {\r\n        this.logger.trace("Getting in-memory cache");\r\n        // convert the cache key value store to inMemoryCache\r\n        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());\r\n        return inMemoryCache;\r\n    }\r\n    /**\r\n     * sets the current in memory cache for the client\r\n     * @param inMemoryCache - key value map in memory\r\n     */\r\n    setInMemoryCache(inMemoryCache) {\r\n        this.logger.trace("Setting in-memory cache");\r\n        // convert and append the inMemoryCache to cacheKVStore\r\n        const cache = this.inMemoryCacheToCache(inMemoryCache);\r\n        this.setCache(cache);\r\n        this.emitChange();\r\n    }\r\n    /**\r\n     * get the current cache key-value store\r\n     */\r\n    getCache() {\r\n        this.logger.trace("Getting cache key-value store");\r\n        return this.cache;\r\n    }\r\n    /**\r\n     * sets the current cache (key value store)\r\n     * @param cacheMap - key value map\r\n     */\r\n    setCache(cache) {\r\n        this.logger.trace("Setting cache key value store");\r\n        this.cache = cache;\r\n        // mark change in cache\r\n        this.emitChange();\r\n    }\r\n    /**\r\n     * Gets cache item with given key.\r\n     * @param key - lookup key for the cache entry\r\n     */\r\n    getItem(key) {\r\n        this.logger.tracePii(`Item key: ${key}`);\r\n        // read cache\r\n        const cache = this.getCache();\r\n        return cache[key];\r\n    }\r\n    /**\r\n     * Gets cache item with given key-value\r\n     * @param key - lookup key for the cache entry\r\n     * @param value - value of the cache entry\r\n     */\r\n    setItem(key, value) {\r\n        this.logger.tracePii(`Item key: ${key}`);\r\n        // read cache\r\n        const cache = this.getCache();\r\n        cache[key] = value;\r\n        // write to cache\r\n        this.setCache(cache);\r\n    }\r\n    getAccountKeys() {\r\n        const inMemoryCache = this.getInMemoryCache();\r\n        const accountKeys = Object.keys(inMemoryCache.accounts);\r\n        return accountKeys;\r\n    }\r\n    getTokenKeys() {\r\n        const inMemoryCache = this.getInMemoryCache();\r\n        const tokenKeys = {\r\n            idToken: Object.keys(inMemoryCache.idTokens),\r\n            accessToken: Object.keys(inMemoryCache.accessTokens),\r\n            refreshToken: Object.keys(inMemoryCache.refreshTokens),\r\n        };\r\n        return tokenKeys;\r\n    }\r\n    /**\r\n     * Reads account from cache, builds it into an account entity and returns it.\r\n     * @param accountKey - lookup key to fetch cache type AccountEntity\r\n     * @returns\r\n     */\r\n    getAccount(accountKey) {\r\n        const cachedAccount = this.getItem(accountKey);\r\n        return cachedAccount\r\n            ? Object.assign(new AccountEntity(), this.getItem(accountKey))\r\n            : null;\r\n    }\r\n    /**\r\n     * set account entity\r\n     * @param account - cache value to be set of type AccountEntity\r\n     */\r\n    async setAccount(account) {\r\n        const accountKey = account.generateAccountKey();\r\n        this.setItem(accountKey, account);\r\n    }\r\n    /**\r\n     * fetch the idToken credential\r\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\r\n     */\r\n    getIdTokenCredential(idTokenKey) {\r\n        const idToken = this.getItem(idTokenKey);\r\n        if (isIdTokenEntity(idToken)) {\r\n            return idToken;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * set idToken credential\r\n     * @param idToken - cache value to be set of type IdTokenEntity\r\n     */\r\n    async setIdTokenCredential(idToken) {\r\n        const idTokenKey = generateCredentialKey(idToken);\r\n        this.setItem(idTokenKey, idToken);\r\n    }\r\n    /**\r\n     * fetch the accessToken credential\r\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\r\n     */\r\n    getAccessTokenCredential(accessTokenKey) {\r\n        const accessToken = this.getItem(accessTokenKey);\r\n        if (isAccessTokenEntity(accessToken)) {\r\n            return accessToken;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * set accessToken credential\r\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\r\n     */\r\n    async setAccessTokenCredential(accessToken) {\r\n        const accessTokenKey = generateCredentialKey(accessToken);\r\n        this.setItem(accessTokenKey, accessToken);\r\n    }\r\n    /**\r\n     * fetch the refreshToken credential\r\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\r\n     */\r\n    getRefreshTokenCredential(refreshTokenKey) {\r\n        const refreshToken = this.getItem(refreshTokenKey);\r\n        if (isRefreshTokenEntity(refreshToken)) {\r\n            return refreshToken;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * set refreshToken credential\r\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\r\n     */\r\n    async setRefreshTokenCredential(refreshToken) {\r\n        const refreshTokenKey = generateCredentialKey(refreshToken);\r\n        this.setItem(refreshTokenKey, refreshToken);\r\n    }\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\r\n     */\r\n    getAppMetadata(appMetadataKey) {\r\n        const appMetadata = this.getItem(appMetadataKey);\r\n        if (isAppMetadataEntity(appMetadataKey, appMetadata)) {\r\n            return appMetadata;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\r\n     */\r\n    setAppMetadata(appMetadata) {\r\n        const appMetadataKey = generateAppMetadataKey(appMetadata);\r\n        this.setItem(appMetadataKey, appMetadata);\r\n    }\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\r\n     */\r\n    getServerTelemetry(serverTelemetrykey) {\r\n        const serverTelemetryEntity = this.getItem(serverTelemetrykey);\r\n        if (serverTelemetryEntity &&\r\n            isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {\r\n            return serverTelemetryEntity;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\r\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\r\n     */\r\n    setServerTelemetry(serverTelemetryKey, serverTelemetry) {\r\n        this.setItem(serverTelemetryKey, serverTelemetry);\r\n    }\r\n    /**\r\n     * fetch authority metadata entity from the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     */\r\n    getAuthorityMetadata(key) {\r\n        const authorityMetadataEntity = this.getItem(key);\r\n        if (authorityMetadataEntity &&\r\n            isAuthorityMetadataEntity(key, authorityMetadataEntity)) {\r\n            return authorityMetadataEntity;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get all authority metadata keys\r\n     */\r\n    getAuthorityMetadataKeys() {\r\n        return this.getKeys().filter((key) => {\r\n            return this.isAuthorityMetadata(key);\r\n        });\r\n    }\r\n    /**\r\n     * set authority metadata entity to the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\r\n     */\r\n    setAuthorityMetadata(key, metadata) {\r\n        this.setItem(key, metadata);\r\n    }\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     */\r\n    getThrottlingCache(throttlingCacheKey) {\r\n        const throttlingCache = this.getItem(throttlingCacheKey);\r\n        if (throttlingCache &&\r\n            isThrottlingEntity(throttlingCacheKey, throttlingCache)) {\r\n            return throttlingCache;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\r\n     */\r\n    setThrottlingCache(throttlingCacheKey, throttlingCache) {\r\n        this.setItem(throttlingCacheKey, throttlingCache);\r\n    }\r\n    /**\r\n     * Removes the cache item from memory with the given key.\r\n     * @param key - lookup key to remove a cache entity\r\n     * @param inMemory - key value map of the cache\r\n     */\r\n    removeItem(key) {\r\n        this.logger.tracePii(`Item key: ${key}`);\r\n        // read inMemoryCache\r\n        let result = false;\r\n        const cache = this.getCache();\r\n        if (!!cache[key]) {\r\n            delete cache[key];\r\n            result = true;\r\n        }\r\n        // write to the cache after removal\r\n        if (result) {\r\n            this.setCache(cache);\r\n            this.emitChange();\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Remove account entity from the platform cache if it\'s outdated\r\n     * @param accountKey - lookup key to fetch cache type AccountEntity\r\n     */\r\n    removeOutdatedAccount(accountKey) {\r\n        this.removeItem(accountKey);\r\n    }\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key - look up key for a cache entity\r\n     */\r\n    containsKey(key) {\r\n        return this.getKeys().includes(key);\r\n    }\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys() {\r\n        this.logger.trace("Retrieving all cache keys");\r\n        // read cache\r\n        const cache = this.getCache();\r\n        return [...Object.keys(cache)];\r\n    }\r\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\r\n    clear() {\r\n        this.logger.trace("Clearing cache entries created by MSAL");\r\n        // read inMemoryCache\r\n        const cacheKeys = this.getKeys();\r\n        // delete each element\r\n        cacheKeys.forEach((key) => {\r\n            this.removeItem(key);\r\n        });\r\n        this.emitChange();\r\n    }\r\n    /**\r\n     * Initialize in memory cache from an exisiting cache vault\r\n     * @param cache - blob formatted cache (JSON)\r\n     */\r\n    static generateInMemoryCache(cache) {\r\n        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));\r\n    }\r\n    /**\r\n     * retrieves the final JSON\r\n     * @param inMemoryCache - itemised cache read from the JSON\r\n     */\r\n    static generateJsonCache(inMemoryCache) {\r\n        return Serializer.serializeAllCache(inMemoryCache);\r\n    }\r\n    /**\r\n     * Updates a credential\'s cache key if the current cache key is outdated\r\n     */\r\n    updateCredentialCacheKey(currentCacheKey, credential) {\r\n        const updatedCacheKey = generateCredentialKey(credential);\r\n        if (currentCacheKey !== updatedCacheKey) {\r\n            const cacheItem = this.getItem(currentCacheKey);\r\n            if (cacheItem) {\r\n                this.removeItem(currentCacheKey);\r\n                this.setItem(updatedCacheKey, cacheItem);\r\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\r\n                return updatedCacheKey;\r\n            }\r\n            else {\r\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\r\n            }\r\n        }\r\n        return currentCacheKey;\r\n    }\r\n}\n\n\n//# sourceMappingURL=NodeStorage.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/cache/TokenCache.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst defaultSerializedCache = {\r\n    Account: {},\r\n    IdToken: {},\r\n    AccessToken: {},\r\n    RefreshToken: {},\r\n    AppMetadata: {},\r\n};\r\n/**\r\n * In-memory token cache manager\r\n * @public\r\n */\r\nclass TokenCache {\r\n    constructor(storage, logger, cachePlugin) {\r\n        this.cacheHasChanged = false;\r\n        this.storage = storage;\r\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\r\n        if (cachePlugin) {\r\n            this.persistence = cachePlugin;\r\n        }\r\n        this.logger = logger;\r\n    }\r\n    /**\r\n     * Set to true if cache state has changed since last time serialize or writeToPersistence was called\r\n     */\r\n    hasChanged() {\r\n        return this.cacheHasChanged;\r\n    }\r\n    /**\r\n     * Serializes in memory cache to JSON\r\n     */\r\n    serialize() {\r\n        this.logger.trace("Serializing in-memory cache");\r\n        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());\r\n        // if cacheSnapshot not null or empty, merge\r\n        if (this.cacheSnapshot) {\r\n            this.logger.trace("Reading cache snapshot from disk");\r\n            finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);\r\n        }\r\n        else {\r\n            this.logger.trace("No cache snapshot to merge");\r\n        }\r\n        this.cacheHasChanged = false;\r\n        return JSON.stringify(finalState);\r\n    }\r\n    /**\r\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\r\n     * @param cache - blob formatted cache\r\n     */\r\n    deserialize(cache) {\r\n        this.logger.trace("Deserializing JSON to in-memory cache");\r\n        this.cacheSnapshot = cache;\r\n        if (this.cacheSnapshot) {\r\n            this.logger.trace("Reading cache snapshot from disk");\r\n            const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));\r\n            this.storage.setInMemoryCache(deserializedCache);\r\n        }\r\n        else {\r\n            this.logger.trace("No cache snapshot to deserialize");\r\n        }\r\n    }\r\n    /**\r\n     * Fetches the cache key-value map\r\n     */\r\n    getKVStore() {\r\n        return this.storage.getCache();\r\n    }\r\n    /**\r\n     * Gets cache snapshot in CacheKVStore format\r\n     */\r\n    getCacheSnapshot() {\r\n        const deserializedPersistentStorage = NodeStorage_NodeStorage.generateInMemoryCache(this.cacheSnapshot);\r\n        return this.storage.inMemoryCacheToCache(deserializedPersistentStorage);\r\n    }\r\n    /**\r\n     * API that retrieves all accounts currently in cache to the user\r\n     */\r\n    async getAllAccounts() {\r\n        this.logger.trace("getAllAccounts called");\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistence) {\r\n                cacheContext = new TokenCacheContext(this, false);\r\n                await this.persistence.beforeCacheAccess(cacheContext);\r\n            }\r\n            return this.storage.getAllAccounts();\r\n        }\r\n        finally {\r\n            if (this.persistence && cacheContext) {\r\n                await this.persistence.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the signed in account matching homeAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param homeAccountId - unique identifier for an account (uid.utid)\r\n     */\r\n    async getAccountByHomeId(homeAccountId) {\r\n        const allAccounts = await this.getAllAccounts();\r\n        if (homeAccountId && allAccounts && allAccounts.length) {\r\n            return (allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the signed in account matching localAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\r\n     */\r\n    async getAccountByLocalId(localAccountId) {\r\n        const allAccounts = await this.getAllAccounts();\r\n        if (localAccountId && allAccounts && allAccounts.length) {\r\n            return (allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * API to remove a specific account and the relevant data from cache\r\n     * @param account - AccountInfo passed by the user\r\n     */\r\n    async removeAccount(account) {\r\n        this.logger.trace("removeAccount called");\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistence) {\r\n                cacheContext = new TokenCacheContext(this, true);\r\n                await this.persistence.beforeCacheAccess(cacheContext);\r\n            }\r\n            await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));\r\n        }\r\n        finally {\r\n            if (this.persistence && cacheContext) {\r\n                await this.persistence.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Overwrites in-memory cache with persistent cache\r\n     */\r\n    async overwriteCache() {\r\n        if (!this.persistence) {\r\n            this.logger.info("No persistence layer specified, cache cannot be overwritten");\r\n            return;\r\n        }\r\n        this.logger.info("Overwriting in-memory cache with persistent cache");\r\n        this.storage.clear();\r\n        const cacheContext = new TokenCacheContext(this, false);\r\n        await this.persistence.beforeCacheAccess(cacheContext);\r\n        const cacheSnapshot = this.getCacheSnapshot();\r\n        this.storage.setCache(cacheSnapshot);\r\n        await this.persistence.afterCacheAccess(cacheContext);\r\n    }\r\n    /**\r\n     * Called when the cache has changed state.\r\n     */\r\n    handleChangeEvent() {\r\n        this.cacheHasChanged = true;\r\n    }\r\n    /**\r\n     * Merge in memory cache with the cache snapshot.\r\n     * @param oldState - cache before changes\r\n     * @param currentState - current cache state in the library\r\n     */\r\n    mergeState(oldState, currentState) {\r\n        this.logger.trace("Merging in-memory cache with cache snapshot");\r\n        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);\r\n        return this.mergeUpdates(stateAfterRemoval, currentState);\r\n    }\r\n    /**\r\n     * Deep update of oldState based on newState values\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    mergeUpdates(oldState, newState) {\r\n        Object.keys(newState).forEach((newKey) => {\r\n            const newValue = newState[newKey];\r\n            // if oldState does not contain value but newValue does, add it\r\n            if (!oldState.hasOwnProperty(newKey)) {\r\n                if (newValue !== null) {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            }\r\n            else {\r\n                // both oldState and newState contain the key, do deep update\r\n                const newValueNotNull = newValue !== null;\r\n                const newValueIsObject = typeof newValue === "object";\r\n                const newValueIsNotArray = !Array.isArray(newValue);\r\n                const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" &&\r\n                    oldState[newKey] !== null;\r\n                if (newValueNotNull &&\r\n                    newValueIsObject &&\r\n                    newValueIsNotArray &&\r\n                    oldStateNotUndefinedOrNull) {\r\n                    this.mergeUpdates(oldState[newKey], newValue);\r\n                }\r\n                else {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            }\r\n        });\r\n        return oldState;\r\n    }\r\n    /**\r\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\r\n     * oldState that are not recognized, they are left untouched.\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    mergeRemovals(oldState, newState) {\r\n        this.logger.trace("Remove updated entries in cache");\r\n        const accounts = oldState.Account\r\n            ? this.mergeRemovalsDict(oldState.Account, newState.Account)\r\n            : oldState.Account;\r\n        const accessTokens = oldState.AccessToken\r\n            ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken)\r\n            : oldState.AccessToken;\r\n        const refreshTokens = oldState.RefreshToken\r\n            ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken)\r\n            : oldState.RefreshToken;\r\n        const idTokens = oldState.IdToken\r\n            ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken)\r\n            : oldState.IdToken;\r\n        const appMetadata = oldState.AppMetadata\r\n            ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata)\r\n            : oldState.AppMetadata;\r\n        return {\r\n            ...oldState,\r\n            Account: accounts,\r\n            AccessToken: accessTokens,\r\n            RefreshToken: refreshTokens,\r\n            IdToken: idTokens,\r\n            AppMetadata: appMetadata,\r\n        };\r\n    }\r\n    /**\r\n     * Helper to merge new cache with the old one\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    mergeRemovalsDict(oldState, newState) {\r\n        const finalState = { ...oldState };\r\n        Object.keys(oldState).forEach((oldKey) => {\r\n            if (!newState || !newState.hasOwnProperty(oldKey)) {\r\n                delete finalState[oldKey];\r\n            }\r\n        });\r\n        return finalState;\r\n    }\r\n    /**\r\n     * Helper to overlay as a part of cache merge\r\n     * @param passedInCache - cache read from the blob\r\n     */\r\n    overlayDefaults(passedInCache) {\r\n        this.logger.trace("Overlaying input cache with the default cache");\r\n        return {\r\n            Account: {\r\n                ...defaultSerializedCache.Account,\r\n                ...passedInCache.Account,\r\n            },\r\n            IdToken: {\r\n                ...defaultSerializedCache.IdToken,\r\n                ...passedInCache.IdToken,\r\n            },\r\n            AccessToken: {\r\n                ...defaultSerializedCache.AccessToken,\r\n                ...passedInCache.AccessToken,\r\n            },\r\n            RefreshToken: {\r\n                ...defaultSerializedCache.RefreshToken,\r\n                ...passedInCache.RefreshToken,\r\n            },\r\n            AppMetadata: {\r\n                ...defaultSerializedCache.AppMetadata,\r\n                ...passedInCache.AppMetadata,\r\n            },\r\n        };\r\n    }\r\n}\n\n\n//# sourceMappingURL=TokenCache.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/jsonwebtoken/index.js\nvar jsonwebtoken = __webpack_require__(4040);\n;// ./node_modules/@azure/msal-node/dist/client/ClientAssertion.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Client assertion of type jwt-bearer used in confidential client flows\r\n * @public\r\n */\r\nclass ClientAssertion {\r\n    /**\r\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\r\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\r\n     */\r\n    static fromAssertion(assertion) {\r\n        const clientAssertion = new ClientAssertion();\r\n        clientAssertion.jwt = assertion;\r\n        return clientAssertion;\r\n    }\r\n    /**\r\n     * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint\r\n     * Initialize the ClientAssertion class from the certificate passed by the user\r\n     * @param thumbprint - identifier of a certificate\r\n     * @param privateKey - secret key\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\r\n    static fromCertificate(thumbprint, privateKey, publicCertificate) {\r\n        const clientAssertion = new ClientAssertion();\r\n        clientAssertion.privateKey = privateKey;\r\n        clientAssertion.thumbprint = thumbprint;\r\n        clientAssertion.useSha256 = false;\r\n        if (publicCertificate) {\r\n            clientAssertion.publicCertificate =\r\n                this.parseCertificate(publicCertificate);\r\n        }\r\n        return clientAssertion;\r\n    }\r\n    /**\r\n     * Initialize the ClientAssertion class from the certificate passed by the user\r\n     * @param thumbprint - identifier of a certificate\r\n     * @param privateKey - secret key\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\r\n    static fromCertificateWithSha256Thumbprint(thumbprint, privateKey, publicCertificate) {\r\n        const clientAssertion = new ClientAssertion();\r\n        clientAssertion.privateKey = privateKey;\r\n        clientAssertion.thumbprint = thumbprint;\r\n        clientAssertion.useSha256 = true;\r\n        if (publicCertificate) {\r\n            clientAssertion.publicCertificate =\r\n                this.parseCertificate(publicCertificate);\r\n        }\r\n        return clientAssertion;\r\n    }\r\n    /**\r\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\r\n     * @param cryptoProvider - library\'s crypto helper\r\n     * @param issuer - iss claim\r\n     * @param jwtAudience - aud claim\r\n     */\r\n    getJwt(cryptoProvider, issuer, jwtAudience) {\r\n        // if assertion was created from certificate, check if jwt is expired and create new one.\r\n        if (this.privateKey && this.thumbprint) {\r\n            if (this.jwt &&\r\n                !this.isExpired() &&\r\n                issuer === this.issuer &&\r\n                jwtAudience === this.jwtAudience) {\r\n                return this.jwt;\r\n            }\r\n            return this.createJwt(cryptoProvider, issuer, jwtAudience);\r\n        }\r\n        /*\r\n         * if assertion was created by caller, then we just append it. It is up to the caller to\r\n         * ensure that it contains necessary claims and that it is not expired.\r\n         */\r\n        if (this.jwt) {\r\n            return this.jwt;\r\n        }\r\n        throw ClientAuthError_createClientAuthError(invalidAssertion);\r\n    }\r\n    /**\r\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\r\n     */\r\n    createJwt(cryptoProvider, issuer, jwtAudience) {\r\n        this.issuer = issuer;\r\n        this.jwtAudience = jwtAudience;\r\n        const issuedAt = nowSeconds();\r\n        this.expirationTime = issuedAt + 600;\r\n        const algorithm = this.useSha256\r\n            ? JwtConstants.PSS_256\r\n            : JwtConstants.RSA_256;\r\n        const header = {\r\n            alg: algorithm,\r\n        };\r\n        const thumbprintHeader = this.useSha256\r\n            ? JwtConstants.X5T_256\r\n            : JwtConstants.X5T;\r\n        Object.assign(header, {\r\n            [thumbprintHeader]: EncodingUtils.base64EncodeUrl(this.thumbprint, Constants_EncodingTypes.HEX),\r\n        });\r\n        if (this.publicCertificate) {\r\n            Object.assign(header, {\r\n                [JwtConstants.X5C]: this.publicCertificate,\r\n            });\r\n        }\r\n        const payload = {\r\n            [JwtConstants.AUDIENCE]: this.jwtAudience,\r\n            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,\r\n            [JwtConstants.ISSUER]: this.issuer,\r\n            [JwtConstants.SUBJECT]: this.issuer,\r\n            [JwtConstants.NOT_BEFORE]: issuedAt,\r\n            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid(),\r\n        };\r\n        this.jwt = jsonwebtoken.sign(payload, this.privateKey, { header });\r\n        return this.jwt;\r\n    }\r\n    /**\r\n     * Utility API to check expiration\r\n     */\r\n    isExpired() {\r\n        return this.expirationTime < nowSeconds();\r\n    }\r\n    /**\r\n     * Extracts the raw certs from a given certificate string and returns them in an array.\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\r\n    static parseCertificate(publicCertificate) {\r\n        /**\r\n         * This is regex to identify the certs in a given certificate string.\r\n         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\r\n         * The information in parens "(.+?)" is the capture group to represent the cert we want isolated.\r\n         * "." means any string character, "+" means match 1 or more times, and "?" means the shortest match.\r\n         * The "g" at the end of the regex means search the string globally, and the "s" enables the "." to match newlines.\r\n         */\r\n        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\\r*\\n(.+?)\\r*\\n-----END CERTIFICATE-----/gs;\r\n        const certs = [];\r\n        let matches;\r\n        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\r\n            // matches[1] represents the first parens capture group in the regex.\r\n            certs.push(matches[1].replace(/\\r*\\n/g, Constants_Constants.EMPTY_STRING));\r\n        }\r\n        return certs;\r\n    }\r\n}\n\n\n//# sourceMappingURL=ClientAssertion.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/packageMetadata.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n/* eslint-disable header/header */\r\nconst dist_packageMetadata_name = "@azure/msal-node";\r\nconst dist_packageMetadata_version = "3.6.0";\n\n\n//# sourceMappingURL=packageMetadata.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/UsernamePasswordClient.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Oauth2.0 Password grant client\r\n * Note: We are only supporting public clients for password grant and for purely testing purposes\r\n * @public\r\n * @deprecated - Use a more secure flow instead\r\n */\r\nclass UsernamePasswordClient extends BaseClient {\r\n    constructor(configuration) {\r\n        super(configuration);\r\n    }\r\n    /**\r\n     * API to acquire a token by passing the username and password to the service in exchage of credentials\r\n     * password_grant\r\n     * @param request - CommonUsernamePasswordRequest\r\n     */\r\n    async acquireToken(request) {\r\n        this.logger.info("in acquireToken call in username-password client");\r\n        const reqTimestamp = nowSeconds();\r\n        const response = await this.executeTokenRequest(this.authority, request);\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\r\n        // Validate response. This function throws a server error if an error is returned by the server.\r\n        responseHandler.validateTokenResponse(response.body);\r\n        const tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request);\r\n        return tokenResponse;\r\n    }\r\n    /**\r\n     * Executes POST request to token endpoint\r\n     * @param authority - authority object\r\n     * @param request - CommonUsernamePasswordRequest provided by the developer\r\n     */\r\n    async executeTokenRequest(authority, request) {\r\n        const queryParametersString = this.createTokenQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n        const requestBody = await this.createTokenRequestBody(request);\r\n        const headers = this.createTokenRequestHeaders({\r\n            credential: request.username,\r\n            type: CcsCredentialType.UPN,\r\n        });\r\n        const thumbprint = {\r\n            clientId: this.config.authOptions.clientId,\r\n            authority: authority.canonicalAuthority,\r\n            scopes: request.scopes,\r\n            claims: request.claims,\r\n            authenticationScheme: request.authenticationScheme,\r\n            resourceRequestMethod: request.resourceRequestMethod,\r\n            resourceRequestUri: request.resourceRequestUri,\r\n            shrClaims: request.shrClaims,\r\n            sshKid: request.sshKid,\r\n        };\r\n        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);\r\n    }\r\n    /**\r\n     * Generates a map for all the params to be sent to the service\r\n     * @param request - CommonUsernamePasswordRequest provided by the developer\r\n     */\r\n    async createTokenRequestBody(request) {\r\n        const parameters = new Map();\r\n        addClientId(parameters, this.config.authOptions.clientId);\r\n        addUsername(parameters, request.username);\r\n        addPassword(parameters, request.password);\r\n        addScopes(parameters, request.scopes);\r\n        addResponseType(parameters, OAuthResponseType.IDTOKEN_TOKEN);\r\n        addGrantType(parameters, GrantType.RESOURCE_OWNER_PASSWORD_GRANT);\r\n        addClientInfo(parameters);\r\n        addLibraryInfo(parameters, this.config.libraryInfo);\r\n        addApplicationTelemetry(parameters, this.config.telemetry.application);\r\n        addThrottling(parameters);\r\n        if (this.serverTelemetryManager) {\r\n            addServerTelemetry(parameters, this.serverTelemetryManager);\r\n        }\r\n        const correlationId = request.correlationId ||\r\n            this.config.cryptoInterface.createNewGuid();\r\n        addCorrelationId(parameters, correlationId);\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            addClientSecret(parameters, this.config.clientCredentials.clientSecret);\r\n        }\r\n        const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n        if (clientAssertion) {\r\n            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\r\n            addClientAssertionType(parameters, clientAssertion.assertionType);\r\n        }\r\n        if (!StringUtils.isEmptyObj(request.claims) ||\r\n            (this.config.authOptions.clientCapabilities &&\r\n                this.config.authOptions.clientCapabilities.length > 0)) {\r\n            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        if (this.config.systemOptions.preventCorsPreflight &&\r\n            request.username) {\r\n            addCcsUpn(parameters, request.username);\r\n        }\r\n        return mapToQueryString(parameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=UsernamePasswordClient.mjs.map\n\n;// ./node_modules/@azure/msal-common/dist/protocol/Authorize.mjs\n/*! @azure/msal-common v15.7.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Returns map of parameters that are applicable to all calls to /authorize whether using PKCE or EAR\r\n * @param config\r\n * @param request\r\n * @param logger\r\n * @param performanceClient\r\n * @returns\r\n */\r\nfunction getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {\r\n    // generate the correlationId if not set by the user and add\r\n    const correlationId = request.correlationId;\r\n    const parameters = new Map();\r\n    addClientId(parameters, request.embeddedClientId ||\r\n        request.extraQueryParameters?.[CLIENT_ID] ||\r\n        authOptions.clientId);\r\n    const requestScopes = [\r\n        ...(request.scopes || []),\r\n        ...(request.extraScopesToConsent || []),\r\n    ];\r\n    addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);\r\n    addRedirectUri(parameters, request.redirectUri);\r\n    addCorrelationId(parameters, correlationId);\r\n    // add response_mode. If not passed in it defaults to query.\r\n    addResponseMode(parameters, request.responseMode);\r\n    // add client_info=1\r\n    addClientInfo(parameters);\r\n    if (request.prompt) {\r\n        addPrompt(parameters, request.prompt);\r\n        performanceClient?.addFields({ prompt: request.prompt }, correlationId);\r\n    }\r\n    if (request.domainHint) {\r\n        addDomainHint(parameters, request.domainHint);\r\n        performanceClient?.addFields({ domainHintFromRequest: true }, correlationId);\r\n    }\r\n    // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\r\n    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\r\n        // AAD will throw if prompt=select_account is passed with an account hint\r\n        if (request.sid && request.prompt === PromptValue.NONE) {\r\n            // SessionID is only used in silent calls\r\n            logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");\r\n            addSid(parameters, request.sid);\r\n            performanceClient?.addFields({ sidFromRequest: true }, correlationId);\r\n        }\r\n        else if (request.account) {\r\n            const accountSid = extractAccountSid(request.account);\r\n            let accountLoginHintClaim = extractLoginHint(request.account);\r\n            if (accountLoginHintClaim && request.domainHint) {\r\n                logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);\r\n                accountLoginHintClaim = null;\r\n            }\r\n            // If login_hint claim is present, use it over sid/username\r\n            if (accountLoginHintClaim) {\r\n                logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");\r\n                addLoginHint(parameters, accountLoginHintClaim);\r\n                performanceClient?.addFields({ loginHintFromClaim: true }, correlationId);\r\n                try {\r\n                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                    addCcsOid(parameters, clientInfo);\r\n                }\r\n                catch (e) {\r\n                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");\r\n                }\r\n            }\r\n            else if (accountSid && request.prompt === PromptValue.NONE) {\r\n                /*\r\n                 * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n                 * SessionId is only used in silent calls\r\n                 */\r\n                logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");\r\n                addSid(parameters, accountSid);\r\n                performanceClient?.addFields({ sidFromClaim: true }, correlationId);\r\n                try {\r\n                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                    addCcsOid(parameters, clientInfo);\r\n                }\r\n                catch (e) {\r\n                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");\r\n                }\r\n            }\r\n            else if (request.loginHint) {\r\n                logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");\r\n                addLoginHint(parameters, request.loginHint);\r\n                addCcsUpn(parameters, request.loginHint);\r\n                performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);\r\n            }\r\n            else if (request.account.username) {\r\n                // Fallback to account username if provided\r\n                logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");\r\n                addLoginHint(parameters, request.account.username);\r\n                performanceClient?.addFields({ loginHintFromUpn: true }, correlationId);\r\n                try {\r\n                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                    addCcsOid(parameters, clientInfo);\r\n                }\r\n                catch (e) {\r\n                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");\r\n                }\r\n            }\r\n        }\r\n        else if (request.loginHint) {\r\n            logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");\r\n            addLoginHint(parameters, request.loginHint);\r\n            addCcsUpn(parameters, request.loginHint);\r\n            performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);\r\n        }\r\n    }\r\n    else {\r\n        logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");\r\n    }\r\n    if (request.nonce) {\r\n        addNonce(parameters, request.nonce);\r\n    }\r\n    if (request.state) {\r\n        addState(parameters, request.state);\r\n    }\r\n    if (request.claims ||\r\n        (authOptions.clientCapabilities &&\r\n            authOptions.clientCapabilities.length > 0)) {\r\n        addClaims(parameters, request.claims, authOptions.clientCapabilities);\r\n    }\r\n    if (request.embeddedClientId) {\r\n        addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);\r\n    }\r\n    // If extraQueryParameters includes instance_aware its value will be added when extraQueryParameters are added\r\n    if (authOptions.instanceAware &&\r\n        (!request.extraQueryParameters ||\r\n            !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {\r\n        addInstanceAware(parameters);\r\n    }\r\n    return parameters;\r\n}\r\n/**\r\n * Returns authorize endpoint with given request parameters in the query string\r\n * @param authority\r\n * @param requestParameters\r\n * @returns\r\n */\r\nfunction getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {\r\n    const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);\r\n    return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);\r\n}\r\n/**\r\n * Handles the hash fragment response from public client code request. Returns a code response used by\r\n * the client to exchange for a token in acquireToken.\r\n * @param serverParams\r\n * @param cachedState\r\n */\r\nfunction getAuthorizationCodePayload(serverParams, cachedState) {\r\n    // Get code response\r\n    validateAuthorizationResponse(serverParams, cachedState);\r\n    // throw when there is no auth code in the response\r\n    if (!serverParams.code) {\r\n        throw createClientAuthError(authorizationCodeMissingFromServerResponse);\r\n    }\r\n    return serverParams;\r\n}\r\n/**\r\n * Function which validates server authorization code response.\r\n * @param serverResponseHash\r\n * @param requestState\r\n */\r\nfunction validateAuthorizationResponse(serverResponse, requestState) {\r\n    if (!serverResponse.state || !requestState) {\r\n        throw serverResponse.state\r\n            ? createClientAuthError(stateNotFound, "Cached State")\r\n            : createClientAuthError(stateNotFound, "Server State");\r\n    }\r\n    let decodedServerResponseState;\r\n    let decodedRequestState;\r\n    try {\r\n        decodedServerResponseState = decodeURIComponent(serverResponse.state);\r\n    }\r\n    catch (e) {\r\n        throw createClientAuthError(invalidState, serverResponse.state);\r\n    }\r\n    try {\r\n        decodedRequestState = decodeURIComponent(requestState);\r\n    }\r\n    catch (e) {\r\n        throw createClientAuthError(invalidState, serverResponse.state);\r\n    }\r\n    if (decodedServerResponseState !== decodedRequestState) {\r\n        throw createClientAuthError(stateMismatch);\r\n    }\r\n    // Check for error\r\n    if (serverResponse.error ||\r\n        serverResponse.error_description ||\r\n        serverResponse.suberror) {\r\n        const serverErrorNo = parseServerErrorNo(serverResponse);\r\n        if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n            throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);\r\n        }\r\n        throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);\r\n    }\r\n}\r\n/**\r\n * Get server error No from the error_uri\r\n * @param serverResponse\r\n * @returns\r\n */\r\nfunction parseServerErrorNo(serverResponse) {\r\n    const errorCodePrefix = "code=";\r\n    const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);\r\n    return errorCodePrefixIndex && errorCodePrefixIndex >= 0\r\n        ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length)\r\n        : undefined;\r\n}\r\n/**\r\n * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n * @param account\r\n */\r\nfunction extractAccountSid(account) {\r\n    return account.idTokenClaims?.sid || null;\r\n}\r\nfunction extractLoginHint(account) {\r\n    return account.idTokenClaims?.login_hint || null;\r\n}\n\n\n//# sourceMappingURL=Authorize.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/protocol/Authorize.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Constructs the full /authorize URL with request parameters\r\n * @param config\r\n * @param authority\r\n * @param request\r\n * @param logger\r\n * @returns\r\n */\r\nfunction getAuthCodeRequestUrl(config, authority, request, logger) {\r\n    const parameters = getStandardAuthorizeRequestParameters({\r\n        ...config.auth,\r\n        authority: authority,\r\n        redirectUri: request.redirectUri || "",\r\n    }, request, logger);\r\n    addLibraryInfo(parameters, {\r\n        sku: utils_Constants_Constants.MSAL_SKU,\r\n        version: dist_packageMetadata_version,\r\n        cpu: process.arch || "",\r\n        os: process.platform || "",\r\n    });\r\n    if (config.auth.protocolMode !== ProtocolMode_ProtocolMode.OIDC) {\r\n        addApplicationTelemetry(parameters, config.telemetry.application);\r\n    }\r\n    addResponseType(parameters, OAuthResponseType.CODE);\r\n    if (request.codeChallenge && request.codeChallengeMethod) {\r\n        addCodeChallengeParams(parameters, request.codeChallenge, request.codeChallengeMethod);\r\n    }\r\n    addExtraQueryParameters(parameters, request.extraQueryParameters || {});\r\n    return getAuthorizeUrl(authority, parameters, config.auth.encodeExtraQueryParams, request.extraQueryParameters);\r\n}\n\n\n//# sourceMappingURL=Authorize.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ClientApplication.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Base abstract class for all ClientApplications - public and confidential\r\n * @public\r\n */\r\nclass ClientApplication {\r\n    /**\r\n     * Constructor for the ClientApplication\r\n     */\r\n    constructor(configuration) {\r\n        this.config = buildAppConfiguration(configuration);\r\n        this.cryptoProvider = new CryptoProvider_CryptoProvider();\r\n        this.logger = new Logger_Logger(this.config.system.loggerOptions, dist_packageMetadata_name, dist_packageMetadata_version);\r\n        this.storage = new NodeStorage_NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider, buildStaticAuthorityOptions(this.config.auth));\r\n        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);\r\n    }\r\n    /**\r\n     * Creates the URL of the authorization request, letting the user input credentials and consent to the\r\n     * application. The URL targets the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * `acquireTokenByCode(AuthorizationCodeRequest)`.\r\n     */\r\n    async getAuthCodeUrl(request) {\r\n        this.logger.info("getAuthCodeUrl called", request.correlationId);\r\n        const validRequest = {\r\n            ...request,\r\n            ...(await this.initializeBaseRequest(request)),\r\n            responseMode: request.responseMode || ResponseMode.QUERY,\r\n            authenticationScheme: AuthenticationScheme.BEARER,\r\n            state: request.state || "",\r\n            nonce: request.nonce || "",\r\n        };\r\n        const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);\r\n        return getAuthCodeRequestUrl(this.config, discoveredAuthority, validRequest, this.logger);\r\n    }\r\n    /**\r\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\r\n     * Authorization Code flow.\r\n     *\r\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\r\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\r\n     * AuthorizationCodeRequest are the same.\r\n     */\r\n    async acquireTokenByCode(request, authCodePayLoad) {\r\n        this.logger.info("acquireTokenByCode called");\r\n        if (request.state && authCodePayLoad) {\r\n            this.logger.info("acquireTokenByCode - validating state");\r\n            this.validateState(request.state, authCodePayLoad.state || "");\r\n            // eslint-disable-next-line no-param-reassign\r\n            authCodePayLoad = { ...authCodePayLoad, state: "" };\r\n        }\r\n        const validRequest = {\r\n            ...request,\r\n            ...(await this.initializeBaseRequest(request)),\r\n            authenticationScheme: AuthenticationScheme.BEARER,\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);\r\n        try {\r\n            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);\r\n            const authClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri, serverTelemetryManager);\r\n            const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);\r\n            this.logger.verbose("Auth code client created", validRequest.correlationId);\r\n            return await authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\r\n     *\r\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\r\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\r\n     * handle the caching and refreshing of tokens automatically.\r\n     */\r\n    async acquireTokenByRefreshToken(request) {\r\n        this.logger.info("acquireTokenByRefreshToken called", request.correlationId);\r\n        const validRequest = {\r\n            ...request,\r\n            ...(await this.initializeBaseRequest(request)),\r\n            authenticationScheme: AuthenticationScheme.BEARER,\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);\r\n        try {\r\n            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);\r\n            const refreshTokenClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);\r\n            const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);\r\n            this.logger.verbose("Refresh token client created", validRequest.correlationId);\r\n            return await refreshTokenClient.acquireToken(validRequest);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Acquires a token silently when a user specifies the account the token is requested for.\r\n     *\r\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\r\n     * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.\r\n     * In case the refresh_token is expired or not found, an error is thrown\r\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\r\n     */\r\n    async acquireTokenSilent(request) {\r\n        const validRequest = {\r\n            ...request,\r\n            ...(await this.initializeBaseRequest(request)),\r\n            forceRefresh: request.forceRefresh || false,\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);\r\n        try {\r\n            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);\r\n            const clientConfiguration = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);\r\n            const silentFlowClient = new SilentFlowClient(clientConfiguration);\r\n            this.logger.verbose("Silent flow client created", validRequest.correlationId);\r\n            try {\r\n                // always overwrite the in-memory cache with the persistence cache (if it exists) before a cache lookup\r\n                await this.tokenCache.overwriteCache();\r\n                return await this.acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration);\r\n            }\r\n            catch (error) {\r\n                if (error instanceof ClientAuthError &&\r\n                    error.errorCode ===\r\n                        tokenRefreshRequired) {\r\n                    const refreshTokenClient = new RefreshTokenClient(clientConfiguration);\r\n                    return refreshTokenClient.acquireTokenByRefreshToken(validRequest);\r\n                }\r\n                throw error;\r\n            }\r\n        }\r\n        catch (error) {\r\n            if (error instanceof AuthError) {\r\n                error.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(error);\r\n            throw error;\r\n        }\r\n    }\r\n    async acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration) {\r\n        const [authResponse, cacheOutcome] = await silentFlowClient.acquireCachedToken({\r\n            ...validRequest,\r\n            scopes: validRequest.scopes?.length\r\n                ? validRequest.scopes\r\n                : [...OIDC_DEFAULT_SCOPES],\r\n        });\r\n        if (cacheOutcome === Constants_CacheOutcome.PROACTIVELY_REFRESHED) {\r\n            this.logger.info("ClientApplication:acquireCachedTokenSilent - Cached access token\'s refreshOn property has been exceeded\'. It\'s not expired, but must be refreshed.");\r\n            // refresh the access token in the background\r\n            const refreshTokenClient = new RefreshTokenClient(clientConfiguration);\r\n            try {\r\n                await refreshTokenClient.acquireTokenByRefreshToken(validRequest);\r\n            }\r\n            catch {\r\n                // do nothing, this is running in the background and no action is to be taken upon success or failure\r\n            }\r\n        }\r\n        // return the cached token\r\n        return authResponse;\r\n    }\r\n    /**\r\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\r\n     *\r\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\r\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\r\n     * Microsoft\'s documentation and recommendations are at:\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\r\n     *\r\n     * @param request - UsenamePasswordRequest\r\n     * @deprecated - Use a more secure flow instead\r\n     */\r\n    async acquireTokenByUsernamePassword(request) {\r\n        this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);\r\n        const validRequest = {\r\n            ...request,\r\n            ...(await this.initializeBaseRequest(request)),\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);\r\n        try {\r\n            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);\r\n            const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);\r\n            const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);\r\n            this.logger.verbose("Username password client created", validRequest.correlationId);\r\n            return await usernamePasswordClient.acquireToken(validRequest);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Gets the token cache for the application.\r\n     */\r\n    getTokenCache() {\r\n        this.logger.info("getTokenCache called");\r\n        return this.tokenCache;\r\n    }\r\n    /**\r\n     * Validates OIDC state by comparing the user cached state with the state received from the server.\r\n     *\r\n     * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against\r\n     * CSRF attacks.\r\n     * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.\r\n     * @param state - Unique GUID generated by the user that is cached by the user and sent to the server during the first leg of the flow\r\n     * @param cachedState - This string is sent back by the server with the authorization code\r\n     */\r\n    validateState(state, cachedState) {\r\n        if (!state) {\r\n            throw NodeAuthError.createStateNotFoundError();\r\n        }\r\n        if (state !== cachedState) {\r\n            throw ClientAuthError_createClientAuthError(ClientAuthErrorCodes_stateMismatch);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the logger instance\r\n     */\r\n    getLogger() {\r\n        return this.logger;\r\n    }\r\n    /**\r\n     * Replaces the default logger set in configurations with new Logger with new configurations\r\n     * @param logger - Logger instance\r\n     */\r\n    setLogger(logger) {\r\n        this.logger = logger;\r\n    }\r\n    /**\r\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\r\n     * @param authority - user passed authority in configuration\r\n     * @param serverTelemetryManager - initializes servertelemetry if passed\r\n     */\r\n    async buildOauthClientConfiguration(discoveredAuthority, requestCorrelationId, redirectUri, serverTelemetryManager) {\r\n        this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);\r\n        this.logger.info(`Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`, requestCorrelationId);\r\n        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);\r\n        const clientConfiguration = {\r\n            authOptions: {\r\n                clientId: this.config.auth.clientId,\r\n                authority: discoveredAuthority,\r\n                clientCapabilities: this.config.auth.clientCapabilities,\r\n                redirectUri,\r\n            },\r\n            loggerOptions: {\r\n                logLevel: this.config.system.loggerOptions.logLevel,\r\n                loggerCallback: this.config.system.loggerOptions.loggerCallback,\r\n                piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,\r\n                correlationId: requestCorrelationId,\r\n            },\r\n            cacheOptions: {\r\n                claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled,\r\n            },\r\n            cryptoInterface: this.cryptoProvider,\r\n            networkInterface: this.config.system.networkClient,\r\n            storageInterface: this.storage,\r\n            serverTelemetryManager: serverTelemetryManager,\r\n            clientCredentials: {\r\n                clientSecret: this.clientSecret,\r\n                clientAssertion: await this.getClientAssertion(discoveredAuthority),\r\n            },\r\n            libraryInfo: {\r\n                sku: utils_Constants_Constants.MSAL_SKU,\r\n                version: dist_packageMetadata_version,\r\n                cpu: process.arch || Constants_Constants.EMPTY_STRING,\r\n                os: process.platform || Constants_Constants.EMPTY_STRING,\r\n            },\r\n            telemetry: this.config.telemetry,\r\n            persistencePlugin: this.config.cache.cachePlugin,\r\n            serializableCache: this.tokenCache,\r\n        };\r\n        return clientConfiguration;\r\n    }\r\n    async getClientAssertion(authority) {\r\n        if (this.developerProvidedClientAssertion) {\r\n            this.clientAssertion = ClientAssertion.fromAssertion(await getClientAssertion(this.developerProvidedClientAssertion, this.config.auth.clientId, authority.tokenEndpoint));\r\n        }\r\n        return (this.clientAssertion && {\r\n            assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),\r\n            assertionType: utils_Constants_Constants.JWT_BEARER_ASSERTION_TYPE,\r\n        });\r\n    }\r\n    /**\r\n     * Generates a request with the default scopes & generates a correlationId.\r\n     * @param authRequest - BaseAuthRequest for initialization\r\n     */\r\n    async initializeBaseRequest(authRequest) {\r\n        this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);\r\n        // Default authenticationScheme to Bearer, log that POP isn\'t supported yet\r\n        if (authRequest.authenticationScheme &&\r\n            authRequest.authenticationScheme === AuthenticationScheme.POP) {\r\n            this.logger.verbose("Authentication Scheme \'pop\' is not supported yet, setting Authentication Scheme to \'Bearer\' for request", authRequest.correlationId);\r\n        }\r\n        authRequest.authenticationScheme = AuthenticationScheme.BEARER;\r\n        // Set requested claims hash if claims-based caching is enabled and claims were requested\r\n        if (this.config.cache.claimsBasedCachingEnabled &&\r\n            authRequest.claims &&\r\n            // Checks for empty stringified object "{}" which doesn\'t qualify as requested claims\r\n            !StringUtils.isEmptyObj(authRequest.claims)) {\r\n            authRequest.requestedClaimsHash =\r\n                await this.cryptoProvider.hashString(authRequest.claims);\r\n        }\r\n        return {\r\n            ...authRequest,\r\n            scopes: [\r\n                ...((authRequest && authRequest.scopes) || []),\r\n                ...OIDC_DEFAULT_SCOPES,\r\n            ],\r\n            correlationId: (authRequest && authRequest.correlationId) ||\r\n                this.cryptoProvider.createNewGuid(),\r\n            authority: authRequest.authority || this.config.auth.authority,\r\n        };\r\n    }\r\n    /**\r\n     * Initializes the server telemetry payload\r\n     * @param apiId - Id for a specific request\r\n     * @param correlationId - GUID\r\n     * @param forceRefresh - boolean to indicate network call\r\n     */\r\n    initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {\r\n        const telemetryPayload = {\r\n            clientId: this.config.auth.clientId,\r\n            correlationId: correlationId,\r\n            apiId: apiId,\r\n            forceRefresh: forceRefresh || false,\r\n        };\r\n        return new ServerTelemetryManager(telemetryPayload, this.storage);\r\n    }\r\n    /**\r\n     * Create authority instance. If authority not passed in request, default to authority set on the application\r\n     * object. If no authority set in application object, then default to common authority.\r\n     * @param authorityString - authority from user configuration\r\n     */\r\n    async createAuthority(authorityString, requestCorrelationId, azureRegionConfiguration, azureCloudOptions) {\r\n        this.logger.verbose("createAuthority called", requestCorrelationId);\r\n        // build authority string based on auth params - azureCloudInstance is prioritized if provided\r\n        const authorityUrl = Authority_Authority.generateAuthority(authorityString, azureCloudOptions || this.config.auth.azureCloudOptions);\r\n        const authorityOptions = {\r\n            protocolMode: this.config.auth.protocolMode,\r\n            knownAuthorities: this.config.auth.knownAuthorities,\r\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\r\n            authorityMetadata: this.config.auth.authorityMetadata,\r\n            azureRegionConfiguration,\r\n            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache,\r\n        };\r\n        return createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, requestCorrelationId);\r\n    }\r\n    /**\r\n     * Clear the cache\r\n     */\r\n    clearCache() {\r\n        this.storage.clear();\r\n    }\r\n}\n\n\n//# sourceMappingURL=ClientApplication.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/network/LoopbackClient.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass LoopbackClient {\r\n    /**\r\n     * Spins up a loopback server which returns the server response when the localhost redirectUri is hit\r\n     * @param successTemplate\r\n     * @param errorTemplate\r\n     * @returns\r\n     */\r\n    async listenForAuthCode(successTemplate, errorTemplate) {\r\n        if (this.server) {\r\n            throw NodeAuthError.createLoopbackServerAlreadyExistsError();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            this.server = external_http_.createServer((req, res) => {\r\n                const url = req.url;\r\n                if (!url) {\r\n                    res.end(errorTemplate ||\r\n                        "Error occurred loading redirectUrl");\r\n                    reject(NodeAuthError.createUnableToLoadRedirectUrlError());\r\n                    return;\r\n                }\r\n                else if (url === Constants_Constants.FORWARD_SLASH) {\r\n                    res.end(successTemplate ||\r\n                        "Auth code was successfully acquired. You can close this window now.");\r\n                    return;\r\n                }\r\n                const redirectUri = this.getRedirectUri();\r\n                const parsedUrl = new URL(url, redirectUri);\r\n                const authCodeResponse = getDeserializedResponse(parsedUrl.search) ||\r\n                    {};\r\n                if (authCodeResponse.code) {\r\n                    res.writeHead(HttpStatus.REDIRECT, {\r\n                        location: redirectUri,\r\n                    }); // Prevent auth code from being saved in the browser history\r\n                    res.end();\r\n                }\r\n                if (authCodeResponse.error) {\r\n                    res.end(errorTemplate ||\r\n                        `Error occurred: ${authCodeResponse.error}`);\r\n                }\r\n                resolve(authCodeResponse);\r\n            });\r\n            this.server.listen(0, "127.0.0.1"); // Listen on any available port\r\n        });\r\n    }\r\n    /**\r\n     * Get the port that the loopback server is running on\r\n     * @returns\r\n     */\r\n    getRedirectUri() {\r\n        if (!this.server || !this.server.listening) {\r\n            throw NodeAuthError.createNoLoopbackServerExistsError();\r\n        }\r\n        const address = this.server.address();\r\n        if (!address || typeof address === "string" || !address.port) {\r\n            this.closeServer();\r\n            throw NodeAuthError.createInvalidLoopbackAddressTypeError();\r\n        }\r\n        const port = address && address.port;\r\n        return `${utils_Constants_Constants.HTTP_PROTOCOL}${utils_Constants_Constants.LOCALHOST}:${port}`;\r\n    }\r\n    /**\r\n     * Close the loopback server\r\n     */\r\n    closeServer() {\r\n        if (this.server) {\r\n            // Only stops accepting new connections, server will close once open/idle connections are closed.\r\n            this.server.close();\r\n            if (typeof this.server.closeAllConnections === "function") {\r\n                /*\r\n                 * Close open/idle connections. This API is available in Node versions 18.2 and higher\r\n                 */\r\n                this.server.closeAllConnections();\r\n            }\r\n            this.server.unref();\r\n            this.server = undefined;\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=LoopbackClient.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/DeviceCodeClient.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * OAuth2.0 Device code client\r\n * @public\r\n */\r\nclass DeviceCodeClient extends BaseClient {\r\n    constructor(configuration) {\r\n        super(configuration);\r\n    }\r\n    /**\r\n     * Gets device code from device code endpoint, calls back to with device code response, and\r\n     * polls token endpoint to exchange device code for tokens\r\n     * @param request - developer provided CommonDeviceCodeRequest\r\n     */\r\n    async acquireToken(request) {\r\n        const deviceCodeResponse = await this.getDeviceCode(request);\r\n        request.deviceCodeCallback(deviceCodeResponse);\r\n        const reqTimestamp = nowSeconds();\r\n        const response = await this.acquireTokenWithDeviceCode(request, deviceCodeResponse);\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\r\n        // Validate response. This function throws a server error if an error is returned by the server.\r\n        responseHandler.validateTokenResponse(response);\r\n        return responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request);\r\n    }\r\n    /**\r\n     * Creates device code request and executes http GET\r\n     * @param request - developer provided CommonDeviceCodeRequest\r\n     */\r\n    async getDeviceCode(request) {\r\n        const queryParametersString = this.createExtraQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(this.authority.deviceCodeEndpoint, queryParametersString);\r\n        const queryString = this.createQueryString(request);\r\n        const headers = this.createTokenRequestHeaders();\r\n        const thumbprint = {\r\n            clientId: this.config.authOptions.clientId,\r\n            authority: request.authority,\r\n            scopes: request.scopes,\r\n            claims: request.claims,\r\n            authenticationScheme: request.authenticationScheme,\r\n            resourceRequestMethod: request.resourceRequestMethod,\r\n            resourceRequestUri: request.resourceRequestUri,\r\n            shrClaims: request.shrClaims,\r\n            sshKid: request.sshKid,\r\n        };\r\n        return this.executePostRequestToDeviceCodeEndpoint(endpoint, queryString, headers, thumbprint, request.correlationId);\r\n    }\r\n    /**\r\n     * Creates query string for the device code request\r\n     * @param request - developer provided CommonDeviceCodeRequest\r\n     */\r\n    createExtraQueryParameters(request) {\r\n        const parameters = new Map();\r\n        if (request.extraQueryParameters) {\r\n            addExtraQueryParameters(parameters, request.extraQueryParameters);\r\n        }\r\n        return mapToQueryString(parameters);\r\n    }\r\n    /**\r\n     * Executes POST request to device code endpoint\r\n     * @param deviceCodeEndpoint - token endpoint\r\n     * @param queryString - string to be used in the body of the request\r\n     * @param headers - headers for the request\r\n     * @param thumbprint - unique request thumbprint\r\n     * @param correlationId - correlation id to be used in the request\r\n     */\r\n    async executePostRequestToDeviceCodeEndpoint(deviceCodeEndpoint, queryString, headers, thumbprint, correlationId) {\r\n        const { body: { user_code: userCode, device_code: deviceCode, verification_uri: verificationUri, expires_in: expiresIn, interval, message, }, } = await this.sendPostRequest(thumbprint, deviceCodeEndpoint, {\r\n            body: queryString,\r\n            headers: headers,\r\n        }, correlationId);\r\n        return {\r\n            userCode,\r\n            deviceCode,\r\n            verificationUri,\r\n            expiresIn,\r\n            interval,\r\n            message,\r\n        };\r\n    }\r\n    /**\r\n     * Create device code endpoint query parameters and returns string\r\n     * @param request - developer provided CommonDeviceCodeRequest\r\n     */\r\n    createQueryString(request) {\r\n        const parameters = new Map();\r\n        addScopes(parameters, request.scopes);\r\n        addClientId(parameters, this.config.authOptions.clientId);\r\n        if (request.extraQueryParameters) {\r\n            addExtraQueryParameters(parameters, request.extraQueryParameters);\r\n        }\r\n        if (request.claims ||\r\n            (this.config.authOptions.clientCapabilities &&\r\n                this.config.authOptions.clientCapabilities.length > 0)) {\r\n            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        return mapToQueryString(parameters);\r\n    }\r\n    /**\r\n     * Breaks the polling with specific conditions\r\n     * @param deviceCodeExpirationTime - expiration time for the device code request\r\n     * @param userSpecifiedTimeout - developer provided timeout, to be compared against deviceCodeExpirationTime\r\n     * @param userSpecifiedCancelFlag - boolean indicating the developer would like to cancel the request\r\n     */\r\n    continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {\r\n        if (userSpecifiedCancelFlag) {\r\n            this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");\r\n            throw ClientAuthError_createClientAuthError(deviceCodePollingCancelled);\r\n        }\r\n        else if (userSpecifiedTimeout &&\r\n            userSpecifiedTimeout < deviceCodeExpirationTime &&\r\n            nowSeconds() > userSpecifiedTimeout) {\r\n            this.logger.error(`User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`);\r\n            throw ClientAuthError_createClientAuthError(userTimeoutReached);\r\n        }\r\n        else if (nowSeconds() > deviceCodeExpirationTime) {\r\n            if (userSpecifiedTimeout) {\r\n                this.logger.verbose(`User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`);\r\n            }\r\n            this.logger.error(`Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`);\r\n            throw ClientAuthError_createClientAuthError(deviceCodeExpired);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Creates token request with device code response and polls token endpoint at interval set by the device code response\r\n     * @param request - developer provided CommonDeviceCodeRequest\r\n     * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint\r\n     */\r\n    async acquireTokenWithDeviceCode(request, deviceCodeResponse) {\r\n        const queryParametersString = this.createTokenQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(this.authority.tokenEndpoint, queryParametersString);\r\n        const requestBody = this.createTokenRequestBody(request, deviceCodeResponse);\r\n        const headers = this.createTokenRequestHeaders();\r\n        const userSpecifiedTimeout = request.timeout\r\n            ? nowSeconds() + request.timeout\r\n            : undefined;\r\n        const deviceCodeExpirationTime = nowSeconds() + deviceCodeResponse.expiresIn;\r\n        const pollingIntervalMilli = deviceCodeResponse.interval * 1000;\r\n        /*\r\n         * Poll token endpoint while (device code is not expired AND operation has not been cancelled by\r\n         * setting CancellationToken.cancel = true). POST request is sent at interval set by pollingIntervalMilli\r\n         */\r\n        while (this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)) {\r\n            const thumbprint = {\r\n                clientId: this.config.authOptions.clientId,\r\n                authority: request.authority,\r\n                scopes: request.scopes,\r\n                claims: request.claims,\r\n                authenticationScheme: request.authenticationScheme,\r\n                resourceRequestMethod: request.resourceRequestMethod,\r\n                resourceRequestUri: request.resourceRequestUri,\r\n                shrClaims: request.shrClaims,\r\n                sshKid: request.sshKid,\r\n            };\r\n            const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);\r\n            if (response.body && response.body.error) {\r\n                // user authorization is pending. Sleep for polling interval and try again\r\n                if (response.body.error === Constants_Constants.AUTHORIZATION_PENDING) {\r\n                    this.logger.info("Authorization pending. Continue polling.");\r\n                    await delay(pollingIntervalMilli);\r\n                }\r\n                else {\r\n                    // for any other error, throw\r\n                    this.logger.info("Unexpected error in polling from the server");\r\n                    throw createAuthError(postRequestFailed, response.body.error);\r\n                }\r\n            }\r\n            else {\r\n                this.logger.verbose("Authorization completed successfully. Polling stopped.");\r\n                return response.body;\r\n            }\r\n        }\r\n        /*\r\n         * The above code should\'ve thrown by this point, but to satisfy TypeScript,\r\n         * and in the rare case the conditionals in continuePolling() may not catch everything...\r\n         */\r\n        this.logger.error("Polling stopped for unknown reasons.");\r\n        throw ClientAuthError_createClientAuthError(deviceCodeUnknownError);\r\n    }\r\n    /**\r\n     * Creates query parameters and converts to string.\r\n     * @param request - developer provided CommonDeviceCodeRequest\r\n     * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint\r\n     */\r\n    createTokenRequestBody(request, deviceCodeResponse) {\r\n        const parameters = new Map();\r\n        addScopes(parameters, request.scopes);\r\n        addClientId(parameters, this.config.authOptions.clientId);\r\n        addGrantType(parameters, GrantType.DEVICE_CODE_GRANT);\r\n        addDeviceCode(parameters, deviceCodeResponse.deviceCode);\r\n        const correlationId = request.correlationId ||\r\n            this.config.cryptoInterface.createNewGuid();\r\n        addCorrelationId(parameters, correlationId);\r\n        addClientInfo(parameters);\r\n        addLibraryInfo(parameters, this.config.libraryInfo);\r\n        addApplicationTelemetry(parameters, this.config.telemetry.application);\r\n        addThrottling(parameters);\r\n        if (this.serverTelemetryManager) {\r\n            addServerTelemetry(parameters, this.serverTelemetryManager);\r\n        }\r\n        if (!StringUtils.isEmptyObj(request.claims) ||\r\n            (this.config.authOptions.clientCapabilities &&\r\n                this.config.authOptions.clientCapabilities.length > 0)) {\r\n            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        return mapToQueryString(parameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=DeviceCodeClient.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/PublicClientApplication.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\r\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\r\n * @public\r\n */\r\nclass PublicClientApplication extends ClientApplication {\r\n    /**\r\n     * Important attributes in the Configuration object for auth are:\r\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\r\n     * - authority: the authority URL for your application.\r\n     *\r\n     * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n     * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.\r\n     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.\r\n     * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.\r\n     *\r\n     * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\r\n     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\r\n     * construction.\r\n     *\r\n     * ADFS authorities are of the form https://\\{instance\\}/adfs.\r\n     */\r\n    constructor(configuration) {\r\n        super(configuration);\r\n        if (this.config.broker.nativeBrokerPlugin) {\r\n            if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {\r\n                this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;\r\n                this.nativeBrokerPlugin.setLogger(this.config.system.loggerOptions);\r\n            }\r\n            else {\r\n                this.logger.warning("NativeBroker implementation was provided but the broker is unavailable.");\r\n            }\r\n        }\r\n        this.skus = ServerTelemetryManager.makeExtraSkuString({\r\n            libraryName: utils_Constants_Constants.MSAL_SKU,\r\n            libraryVersion: dist_packageMetadata_version,\r\n        });\r\n    }\r\n    /**\r\n     * Acquires a token from the authority using OAuth2.0 device code flow.\r\n     * This flow is designed for devices that do not have access to a browser or have input constraints.\r\n     * The authorization server issues a DeviceCode object with a verification code, an end-user code,\r\n     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\r\n     * instructed to use another device to navigate to the verification URI to input credentials.\r\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\r\n     * until the end-user completes input of credentials.\r\n     */\r\n    async acquireTokenByDeviceCode(request) {\r\n        this.logger.info("acquireTokenByDeviceCode called", request.correlationId);\r\n        const validRequest = Object.assign(request, await this.initializeBaseRequest(request));\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);\r\n        try {\r\n            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);\r\n            const deviceCodeConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);\r\n            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\r\n            this.logger.verbose("Device code client created", validRequest.correlationId);\r\n            return await deviceCodeClient.acquireToken(validRequest);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.\r\n     */\r\n    async acquireTokenInteractive(request) {\r\n        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();\r\n        this.logger.trace("acquireTokenInteractive called", correlationId);\r\n        const { openBrowser, successTemplate, errorTemplate, windowHandle, loopbackClient: customLoopbackClient, ...remainingProperties } = request;\r\n        if (this.nativeBrokerPlugin) {\r\n            const brokerRequest = {\r\n                ...remainingProperties,\r\n                clientId: this.config.auth.clientId,\r\n                scopes: request.scopes || OIDC_DEFAULT_SCOPES,\r\n                redirectUri: `${utils_Constants_Constants.HTTP_PROTOCOL}${utils_Constants_Constants.LOCALHOST}`,\r\n                authority: request.authority || this.config.auth.authority,\r\n                correlationId: correlationId,\r\n                extraParameters: {\r\n                    ...remainingProperties.extraQueryParameters,\r\n                    ...remainingProperties.tokenQueryParameters,\r\n                    [X_CLIENT_EXTRA_SKU]: this.skus,\r\n                },\r\n                accountId: remainingProperties.account?.nativeAccountId,\r\n            };\r\n            return this.nativeBrokerPlugin.acquireTokenInteractive(brokerRequest, windowHandle);\r\n        }\r\n        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();\r\n        const loopbackClient = customLoopbackClient || new LoopbackClient();\r\n        let authCodeResponse = {};\r\n        let authCodeListenerError = null;\r\n        try {\r\n            const authCodeListener = loopbackClient\r\n                .listenForAuthCode(successTemplate, errorTemplate)\r\n                .then((response) => {\r\n                authCodeResponse = response;\r\n            })\r\n                .catch((e) => {\r\n                // Store the promise instead of throwing so we can control when its thrown\r\n                authCodeListenerError = e;\r\n            });\r\n            // Wait for server to be listening\r\n            const redirectUri = await this.waitForRedirectUri(loopbackClient);\r\n            const validRequest = {\r\n                ...remainingProperties,\r\n                correlationId: correlationId,\r\n                scopes: request.scopes || OIDC_DEFAULT_SCOPES,\r\n                redirectUri: redirectUri,\r\n                responseMode: ResponseMode.QUERY,\r\n                codeChallenge: challenge,\r\n                codeChallengeMethod: CodeChallengeMethodValues.S256,\r\n            };\r\n            const authCodeUrl = await this.getAuthCodeUrl(validRequest);\r\n            await openBrowser(authCodeUrl);\r\n            await authCodeListener;\r\n            if (authCodeListenerError) {\r\n                throw authCodeListenerError;\r\n            }\r\n            if (authCodeResponse.error) {\r\n                throw new ServerError_ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);\r\n            }\r\n            else if (!authCodeResponse.code) {\r\n                throw NodeAuthError.createNoAuthCodeInResponseError();\r\n            }\r\n            const clientInfo = authCodeResponse.client_info;\r\n            const tokenRequest = {\r\n                code: authCodeResponse.code,\r\n                codeVerifier: verifier,\r\n                clientInfo: clientInfo || Constants_Constants.EMPTY_STRING,\r\n                ...validRequest,\r\n            };\r\n            return await this.acquireTokenByCode(tokenRequest); // Await this so the server doesn\'t close prematurely\r\n        }\r\n        finally {\r\n            loopbackClient.closeServer();\r\n        }\r\n    }\r\n    /**\r\n     * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.\r\n     * @param request - developer provided SilentFlowRequest\r\n     * @returns\r\n     */\r\n    async acquireTokenSilent(request) {\r\n        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();\r\n        this.logger.trace("acquireTokenSilent called", correlationId);\r\n        if (this.nativeBrokerPlugin) {\r\n            const brokerRequest = {\r\n                ...request,\r\n                clientId: this.config.auth.clientId,\r\n                scopes: request.scopes || OIDC_DEFAULT_SCOPES,\r\n                redirectUri: `${utils_Constants_Constants.HTTP_PROTOCOL}${utils_Constants_Constants.LOCALHOST}`,\r\n                authority: request.authority || this.config.auth.authority,\r\n                correlationId: correlationId,\r\n                extraParameters: {\r\n                    ...request.tokenQueryParameters,\r\n                    [X_CLIENT_EXTRA_SKU]: this.skus,\r\n                },\r\n                accountId: request.account.nativeAccountId,\r\n                forceRefresh: request.forceRefresh || false,\r\n            };\r\n            return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);\r\n        }\r\n        return super.acquireTokenSilent(request);\r\n    }\r\n    /**\r\n     * Removes cache artifacts associated with the given account\r\n     * @param request - developer provided SignOutRequest\r\n     * @returns\r\n     */\r\n    async signOut(request) {\r\n        if (this.nativeBrokerPlugin && request.account.nativeAccountId) {\r\n            const signoutRequest = {\r\n                clientId: this.config.auth.clientId,\r\n                accountId: request.account.nativeAccountId,\r\n                correlationId: request.correlationId ||\r\n                    this.cryptoProvider.createNewGuid(),\r\n            };\r\n            await this.nativeBrokerPlugin.signOut(signoutRequest);\r\n        }\r\n        await this.getTokenCache().removeAccount(request.account);\r\n    }\r\n    /**\r\n     * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.\r\n     * @returns\r\n     */\r\n    async getAllAccounts() {\r\n        if (this.nativeBrokerPlugin) {\r\n            const correlationId = this.cryptoProvider.createNewGuid();\r\n            return this.nativeBrokerPlugin.getAllAccounts(this.config.auth.clientId, correlationId);\r\n        }\r\n        return this.getTokenCache().getAllAccounts();\r\n    }\r\n    /**\r\n     * Attempts to retrieve the redirectUri from the loopback server. If the loopback server does not start listening for requests within the timeout this will throw.\r\n     * @param loopbackClient - developer provided custom loopback server implementation\r\n     * @returns\r\n     */\r\n    async waitForRedirectUri(loopbackClient) {\r\n        return new Promise((resolve, reject) => {\r\n            let ticks = 0;\r\n            const id = setInterval(() => {\r\n                if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS /\r\n                    LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS <\r\n                    ticks) {\r\n                    clearInterval(id);\r\n                    reject(NodeAuthError.createLoopbackServerTimeoutError());\r\n                    return;\r\n                }\r\n                try {\r\n                    const r = loopbackClient.getRedirectUri();\r\n                    clearInterval(id);\r\n                    resolve(r);\r\n                    return;\r\n                }\r\n                catch (e) {\r\n                    if (e instanceof AuthError &&\r\n                        e.errorCode ===\r\n                            NodeAuthErrorMessage.noLoopbackServerExists.code) {\r\n                        // Loopback server is not listening yet\r\n                        ticks++;\r\n                        return;\r\n                    }\r\n                    clearInterval(id);\r\n                    reject(e);\r\n                    return;\r\n                }\r\n            }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);\r\n        });\r\n    }\r\n}\n\n\n//# sourceMappingURL=PublicClientApplication.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ClientCredentialClient.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * OAuth2.0 client credential grant\r\n * @public\r\n */\r\nclass ClientCredentialClient_ClientCredentialClient extends BaseClient {\r\n    constructor(configuration, appTokenProvider) {\r\n        super(configuration);\r\n        this.appTokenProvider = appTokenProvider;\r\n    }\r\n    /**\r\n     * Public API to acquire a token with ClientCredential Flow for Confidential clients\r\n     * @param request - CommonClientCredentialRequest provided by the developer\r\n     */\r\n    async acquireToken(request) {\r\n        if (request.skipCache || request.claims) {\r\n            return this.executeTokenRequest(request, this.authority);\r\n        }\r\n        const [cachedAuthenticationResult, lastCacheOutcome] = await this.getCachedAuthenticationResult(request, this.config, this.cryptoUtils, this.authority, this.cacheManager, this.serverTelemetryManager);\r\n        if (cachedAuthenticationResult) {\r\n            // if the token is not expired but must be refreshed; get a new one in the background\r\n            if (lastCacheOutcome === Constants_CacheOutcome.PROACTIVELY_REFRESHED) {\r\n                this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token\'s refreshOn property has been exceeded\'. It\'s not expired, but must be refreshed.");\r\n                // refresh the access token in the background\r\n                const refreshAccessToken = true;\r\n                await this.executeTokenRequest(request, this.authority, refreshAccessToken);\r\n            }\r\n            // return the cached token\r\n            return cachedAuthenticationResult;\r\n        }\r\n        else {\r\n            return this.executeTokenRequest(request, this.authority);\r\n        }\r\n    }\r\n    /**\r\n     * looks up cache if the tokens are cached already\r\n     */\r\n    async getCachedAuthenticationResult(request, config, cryptoUtils, authority, cacheManager, serverTelemetryManager) {\r\n        const clientConfiguration = config;\r\n        const managedIdentityConfiguration = config;\r\n        let lastCacheOutcome = Constants_CacheOutcome.NOT_APPLICABLE;\r\n        // read the user-supplied cache into memory, if applicable\r\n        let cacheContext;\r\n        if (clientConfiguration.serializableCache &&\r\n            clientConfiguration.persistencePlugin) {\r\n            cacheContext = new TokenCacheContext(clientConfiguration.serializableCache, false);\r\n            await clientConfiguration.persistencePlugin.beforeCacheAccess(cacheContext);\r\n        }\r\n        const cachedAccessToken = this.readAccessTokenFromCache(authority, managedIdentityConfiguration.managedIdentityId?.id ||\r\n            clientConfiguration.authOptions.clientId, new ScopeSet(request.scopes || []), cacheManager);\r\n        if (clientConfiguration.serializableCache &&\r\n            clientConfiguration.persistencePlugin &&\r\n            cacheContext) {\r\n            await clientConfiguration.persistencePlugin.afterCacheAccess(cacheContext);\r\n        }\r\n        // must refresh due to non-existent access_token\r\n        if (!cachedAccessToken) {\r\n            serverTelemetryManager?.setCacheOutcome(Constants_CacheOutcome.NO_CACHED_ACCESS_TOKEN);\r\n            return [null, Constants_CacheOutcome.NO_CACHED_ACCESS_TOKEN];\r\n        }\r\n        // must refresh due to the expires_in value\r\n        if (isTokenExpired(cachedAccessToken.expiresOn, clientConfiguration.systemOptions?.tokenRenewalOffsetSeconds ||\r\n            DEFAULT_TOKEN_RENEWAL_OFFSET_SEC)) {\r\n            serverTelemetryManager?.setCacheOutcome(Constants_CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\r\n            return [null, Constants_CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED];\r\n        }\r\n        // must refresh (in the background) due to the refresh_in value\r\n        if (cachedAccessToken.refreshOn &&\r\n            isTokenExpired(cachedAccessToken.refreshOn.toString(), 0)) {\r\n            lastCacheOutcome = Constants_CacheOutcome.PROACTIVELY_REFRESHED;\r\n            serverTelemetryManager?.setCacheOutcome(Constants_CacheOutcome.PROACTIVELY_REFRESHED);\r\n        }\r\n        return [\r\n            await ResponseHandler.generateAuthenticationResult(cryptoUtils, authority, {\r\n                account: null,\r\n                idToken: null,\r\n                accessToken: cachedAccessToken,\r\n                refreshToken: null,\r\n                appMetadata: null,\r\n            }, true, request),\r\n            lastCacheOutcome,\r\n        ];\r\n    }\r\n    /**\r\n     * Reads access token from the cache\r\n     */\r\n    readAccessTokenFromCache(authority, id, scopeSet, cacheManager) {\r\n        const accessTokenFilter = {\r\n            homeAccountId: Constants_Constants.EMPTY_STRING,\r\n            environment: authority.canonicalAuthorityUrlComponents.HostNameAndPort,\r\n            credentialType: CredentialType.ACCESS_TOKEN,\r\n            clientId: id,\r\n            realm: authority.tenant,\r\n            target: ScopeSet.createSearchScopes(scopeSet.asArray()),\r\n        };\r\n        const accessTokens = cacheManager.getAccessTokensByFilter(accessTokenFilter);\r\n        if (accessTokens.length < 1) {\r\n            return null;\r\n        }\r\n        else if (accessTokens.length > 1) {\r\n            throw ClientAuthError_createClientAuthError(multipleMatchingTokens);\r\n        }\r\n        return accessTokens[0];\r\n    }\r\n    /**\r\n     * Makes a network call to request the token from the service\r\n     * @param request - CommonClientCredentialRequest provided by the developer\r\n     * @param authority - authority object\r\n     */\r\n    async executeTokenRequest(request, authority, refreshAccessToken) {\r\n        let serverTokenResponse;\r\n        let reqTimestamp;\r\n        if (this.appTokenProvider) {\r\n            this.logger.info("Using appTokenProvider extensibility.");\r\n            const appTokenPropviderParameters = {\r\n                correlationId: request.correlationId,\r\n                tenantId: this.config.authOptions.authority.tenant,\r\n                scopes: request.scopes,\r\n                claims: request.claims,\r\n            };\r\n            reqTimestamp = nowSeconds();\r\n            const appTokenProviderResult = await this.appTokenProvider(appTokenPropviderParameters);\r\n            serverTokenResponse = {\r\n                access_token: appTokenProviderResult.accessToken,\r\n                expires_in: appTokenProviderResult.expiresInSeconds,\r\n                refresh_in: appTokenProviderResult.refreshInSeconds,\r\n                token_type: AuthenticationScheme.BEARER,\r\n            };\r\n        }\r\n        else {\r\n            const queryParametersString = this.createTokenQueryParameters(request);\r\n            const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n            const requestBody = await this.createTokenRequestBody(request);\r\n            const headers = this.createTokenRequestHeaders();\r\n            const thumbprint = {\r\n                clientId: this.config.authOptions.clientId,\r\n                authority: request.authority,\r\n                scopes: request.scopes,\r\n                claims: request.claims,\r\n                authenticationScheme: request.authenticationScheme,\r\n                resourceRequestMethod: request.resourceRequestMethod,\r\n                resourceRequestUri: request.resourceRequestUri,\r\n                shrClaims: request.shrClaims,\r\n                sshKid: request.sshKid,\r\n            };\r\n            this.logger.info("Sending token request to endpoint: " + authority.tokenEndpoint);\r\n            reqTimestamp = nowSeconds();\r\n            const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);\r\n            serverTokenResponse = response.body;\r\n            serverTokenResponse.status = response.status;\r\n        }\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\r\n        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);\r\n        const tokenResponse = await responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request);\r\n        return tokenResponse;\r\n    }\r\n    /**\r\n     * generate the request to the server in the acceptable format\r\n     * @param request - CommonClientCredentialRequest provided by the developer\r\n     */\r\n    async createTokenRequestBody(request) {\r\n        const parameters = new Map();\r\n        addClientId(parameters, this.config.authOptions.clientId);\r\n        addScopes(parameters, request.scopes, false);\r\n        addGrantType(parameters, GrantType.CLIENT_CREDENTIALS_GRANT);\r\n        addLibraryInfo(parameters, this.config.libraryInfo);\r\n        addApplicationTelemetry(parameters, this.config.telemetry.application);\r\n        addThrottling(parameters);\r\n        if (this.serverTelemetryManager) {\r\n            addServerTelemetry(parameters, this.serverTelemetryManager);\r\n        }\r\n        const correlationId = request.correlationId ||\r\n            this.config.cryptoInterface.createNewGuid();\r\n        addCorrelationId(parameters, correlationId);\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            addClientSecret(parameters, this.config.clientCredentials.clientSecret);\r\n        }\r\n        // Use clientAssertion from request, fallback to client assertion in base configuration\r\n        const clientAssertion = request.clientAssertion ||\r\n            this.config.clientCredentials.clientAssertion;\r\n        if (clientAssertion) {\r\n            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\r\n            addClientAssertionType(parameters, clientAssertion.assertionType);\r\n        }\r\n        if (!StringUtils.isEmptyObj(request.claims) ||\r\n            (this.config.authOptions.clientCapabilities &&\r\n                this.config.authOptions.clientCapabilities.length > 0)) {\r\n            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        return mapToQueryString(parameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=ClientCredentialClient.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/OnBehalfOfClient.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * On-Behalf-Of client\r\n * @public\r\n */\r\nclass OnBehalfOfClient extends BaseClient {\r\n    constructor(configuration) {\r\n        super(configuration);\r\n    }\r\n    /**\r\n     * Public API to acquire tokens with on behalf of flow\r\n     * @param request - developer provided CommonOnBehalfOfRequest\r\n     */\r\n    async acquireToken(request) {\r\n        this.scopeSet = new ScopeSet(request.scopes || []);\r\n        // generate the user_assertion_hash for OBOAssertion\r\n        this.userAssertionHash = await this.cryptoUtils.hashString(request.oboAssertion);\r\n        if (request.skipCache || request.claims) {\r\n            return this.executeTokenRequest(request, this.authority, this.userAssertionHash);\r\n        }\r\n        try {\r\n            return await this.getCachedAuthenticationResult(request);\r\n        }\r\n        catch (e) {\r\n            // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT\r\n            return await this.executeTokenRequest(request, this.authority, this.userAssertionHash);\r\n        }\r\n    }\r\n    /**\r\n     * look up cache for tokens\r\n     * Find idtoken in the cache\r\n     * Find accessToken based on user assertion and account info in the cache\r\n     * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires\r\n     * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session\r\n     * @param request - developer provided CommonOnBehalfOfRequest\r\n     */\r\n    async getCachedAuthenticationResult(request) {\r\n        // look in the cache for the access_token which matches the incoming_assertion\r\n        const cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);\r\n        if (!cachedAccessToken) {\r\n            // Must refresh due to non-existent access_token.\r\n            this.serverTelemetryManager?.setCacheOutcome(Constants_CacheOutcome.NO_CACHED_ACCESS_TOKEN);\r\n            this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");\r\n            throw ClientAuthError_createClientAuthError(tokenRefreshRequired);\r\n        }\r\n        else if (isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\r\n            // Access token expired, will need to renewed\r\n            this.serverTelemetryManager?.setCacheOutcome(Constants_CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\r\n            this.logger.info(`OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);\r\n            throw ClientAuthError_createClientAuthError(tokenRefreshRequired);\r\n        }\r\n        // fetch the idToken from cache\r\n        const cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId);\r\n        let idTokenClaims;\r\n        let cachedAccount = null;\r\n        if (cachedIdToken) {\r\n            idTokenClaims = extractTokenClaims(cachedIdToken.secret, EncodingUtils.base64Decode);\r\n            const localAccountId = idTokenClaims.oid || idTokenClaims.sub;\r\n            const accountInfo = {\r\n                homeAccountId: cachedIdToken.homeAccountId,\r\n                environment: cachedIdToken.environment,\r\n                tenantId: cachedIdToken.realm,\r\n                username: Constants_Constants.EMPTY_STRING,\r\n                localAccountId: localAccountId || Constants_Constants.EMPTY_STRING,\r\n            };\r\n            cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);\r\n        }\r\n        // increment telemetry cache hit counter\r\n        if (this.config.serverTelemetryManager) {\r\n            this.config.serverTelemetryManager.incrementCacheHits();\r\n        }\r\n        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {\r\n            account: cachedAccount,\r\n            accessToken: cachedAccessToken,\r\n            idToken: cachedIdToken,\r\n            refreshToken: null,\r\n            appMetadata: null,\r\n        }, true, request, idTokenClaims);\r\n    }\r\n    /**\r\n     * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager\r\n     * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service\r\n     * @param atHomeAccountId - account id\r\n     */\r\n    readIdTokenFromCacheForOBO(atHomeAccountId) {\r\n        const idTokenFilter = {\r\n            homeAccountId: atHomeAccountId,\r\n            environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: this.config.authOptions.clientId,\r\n            realm: this.authority.tenant,\r\n        };\r\n        const idTokenMap = this.cacheManager.getIdTokensByFilter(idTokenFilter);\r\n        // When acquiring a token on behalf of an application, there might not be an id token in the cache\r\n        if (Object.values(idTokenMap).length < 1) {\r\n            return null;\r\n        }\r\n        return Object.values(idTokenMap)[0];\r\n    }\r\n    /**\r\n     * Fetches the cached access token based on incoming assertion\r\n     * @param clientId - client id\r\n     * @param request - developer provided CommonOnBehalfOfRequest\r\n     */\r\n    readAccessTokenFromCacheForOBO(clientId, request) {\r\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle "bearer" from ADFS\r\n         */\r\n        const credentialType = authScheme &&\r\n            authScheme.toLowerCase() !==\r\n                AuthenticationScheme.BEARER.toLowerCase()\r\n            ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\r\n            : CredentialType.ACCESS_TOKEN;\r\n        const accessTokenFilter = {\r\n            credentialType: credentialType,\r\n            clientId,\r\n            target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n            userAssertionHash: this.userAssertionHash,\r\n        };\r\n        const accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter);\r\n        const numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            return null;\r\n        }\r\n        else if (numAccessTokens > 1) {\r\n            throw ClientAuthError_createClientAuthError(multipleMatchingTokens);\r\n        }\r\n        return accessTokens[0];\r\n    }\r\n    /**\r\n     * Make a network call to the server requesting credentials\r\n     * @param request - developer provided CommonOnBehalfOfRequest\r\n     * @param authority - authority object\r\n     */\r\n    async executeTokenRequest(request, authority, userAssertionHash) {\r\n        const queryParametersString = this.createTokenQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n        const requestBody = await this.createTokenRequestBody(request);\r\n        const headers = this.createTokenRequestHeaders();\r\n        const thumbprint = {\r\n            clientId: this.config.authOptions.clientId,\r\n            authority: request.authority,\r\n            scopes: request.scopes,\r\n            claims: request.claims,\r\n            authenticationScheme: request.authenticationScheme,\r\n            resourceRequestMethod: request.resourceRequestMethod,\r\n            resourceRequestUri: request.resourceRequestUri,\r\n            shrClaims: request.shrClaims,\r\n            sshKid: request.sshKid,\r\n        };\r\n        const reqTimestamp = nowSeconds();\r\n        const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\r\n        responseHandler.validateTokenResponse(response.body);\r\n        const tokenResponse = await responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, userAssertionHash);\r\n        return tokenResponse;\r\n    }\r\n    /**\r\n     * generate a server request in accepable format\r\n     * @param request - developer provided CommonOnBehalfOfRequest\r\n     */\r\n    async createTokenRequestBody(request) {\r\n        const parameters = new Map();\r\n        addClientId(parameters, this.config.authOptions.clientId);\r\n        addScopes(parameters, request.scopes);\r\n        addGrantType(parameters, GrantType.JWT_BEARER);\r\n        addClientInfo(parameters);\r\n        addLibraryInfo(parameters, this.config.libraryInfo);\r\n        addApplicationTelemetry(parameters, this.config.telemetry.application);\r\n        addThrottling(parameters);\r\n        if (this.serverTelemetryManager) {\r\n            addServerTelemetry(parameters, this.serverTelemetryManager);\r\n        }\r\n        const correlationId = request.correlationId ||\r\n            this.config.cryptoInterface.createNewGuid();\r\n        addCorrelationId(parameters, correlationId);\r\n        addRequestTokenUse(parameters, ON_BEHALF_OF);\r\n        addOboAssertion(parameters, request.oboAssertion);\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            addClientSecret(parameters, this.config.clientCredentials.clientSecret);\r\n        }\r\n        const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n        if (clientAssertion) {\r\n            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\r\n            addClientAssertionType(parameters, clientAssertion.assertionType);\r\n        }\r\n        if (request.claims ||\r\n            (this.config.authOptions.clientCapabilities &&\r\n                this.config.authOptions.clientCapabilities.length > 0)) {\r\n            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        return mapToQueryString(parameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=OnBehalfOfClient.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ConfidentialClientApplication.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n// AADAuthorityConstants\r\n/**\r\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\r\n *  will configure application secrets, client certificates/assertions as applicable\r\n * @public\r\n */\r\nclass ConfidentialClientApplication extends ClientApplication {\r\n    /**\r\n     * Constructor for the ConfidentialClientApplication\r\n     *\r\n     * Required attributes in the Configuration object are:\r\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\r\n     * - authority: the authority URL for your application.\r\n     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\r\n     *\r\n     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n     * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.\r\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.\r\n     * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.\r\n     *\r\n     * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\r\n     * Full B2C functionality will be available in this library in future versions.\r\n     *\r\n     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\r\n     */\r\n    constructor(configuration) {\r\n        super(configuration);\r\n        const clientSecretNotEmpty = !!this.config.auth.clientSecret;\r\n        const clientAssertionNotEmpty = !!this.config.auth.clientAssertion;\r\n        const certificateNotEmpty = (!!this.config.auth.clientCertificate?.thumbprint ||\r\n            !!this.config.auth.clientCertificate?.thumbprintSha256) &&\r\n            !!this.config.auth.clientCertificate?.privateKey;\r\n        /*\r\n         * If app developer configures this callback, they don\'t need a credential\r\n         * i.e. AzureSDK can get token from Managed Identity without a cert / secret\r\n         */\r\n        if (this.appTokenProvider) {\r\n            return;\r\n        }\r\n        // Check that at most one credential is set on the application\r\n        if ((clientSecretNotEmpty && clientAssertionNotEmpty) ||\r\n            (clientAssertionNotEmpty && certificateNotEmpty) ||\r\n            (clientSecretNotEmpty && certificateNotEmpty)) {\r\n            throw ClientAuthError_createClientAuthError(invalidClientCredential);\r\n        }\r\n        if (this.config.auth.clientSecret) {\r\n            this.clientSecret = this.config.auth.clientSecret;\r\n            return;\r\n        }\r\n        if (this.config.auth.clientAssertion) {\r\n            this.developerProvidedClientAssertion =\r\n                this.config.auth.clientAssertion;\r\n            return;\r\n        }\r\n        if (!certificateNotEmpty) {\r\n            throw ClientAuthError_createClientAuthError(invalidClientCredential);\r\n        }\r\n        else {\r\n            this.clientAssertion = !!this.config.auth.clientCertificate\r\n                .thumbprintSha256\r\n                ? ClientAssertion.fromCertificateWithSha256Thumbprint(this.config.auth.clientCertificate.thumbprintSha256, this.config.auth.clientCertificate.privateKey, this.config.auth.clientCertificate.x5c)\r\n                : ClientAssertion.fromCertificate(\r\n                // guaranteed to be a string, due to prior error checking in this function\r\n                this.config.auth.clientCertificate.thumbprint, this.config.auth.clientCertificate.privateKey, this.config.auth.clientCertificate.x5c);\r\n        }\r\n        this.appTokenProvider = undefined;\r\n    }\r\n    /**\r\n     * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and\r\n     * is meant for Azure SDK to enhance Managed Identity support.\r\n     *\r\n     * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.\r\n     */\r\n    SetAppTokenProvider(provider) {\r\n        this.appTokenProvider = provider;\r\n    }\r\n    /**\r\n     * Acquires tokens from the authority for the application (not for an end user).\r\n     */\r\n    async acquireTokenByClientCredential(request) {\r\n        this.logger.info("acquireTokenByClientCredential called", request.correlationId);\r\n        // If there is a client assertion present in the request, it overrides the one present in the client configuration\r\n        let clientAssertion;\r\n        if (request.clientAssertion) {\r\n            clientAssertion = {\r\n                assertion: await getClientAssertion(request.clientAssertion, this.config.auth.clientId\r\n                // tokenEndpoint will be undefined. resourceRequestUri is omitted in ClientCredentialRequest\r\n                ),\r\n                assertionType: utils_Constants_Constants.JWT_BEARER_ASSERTION_TYPE,\r\n            };\r\n        }\r\n        const baseRequest = await this.initializeBaseRequest(request);\r\n        // valid base request should not contain oidc scopes in this grant type\r\n        const validBaseRequest = {\r\n            ...baseRequest,\r\n            scopes: baseRequest.scopes.filter((scope) => !OIDC_DEFAULT_SCOPES.includes(scope)),\r\n        };\r\n        const validRequest = {\r\n            ...request,\r\n            ...validBaseRequest,\r\n            clientAssertion,\r\n        };\r\n        /*\r\n         * valid request should not have "common" or "organizations" in lieu of the tenant_id in the authority in the auth configuration\r\n         * example authority: "https://login.microsoftonline.com/TenantId",\r\n         */\r\n        const authority = new UrlString(validRequest.authority);\r\n        const tenantId = authority.getUrlComponents().PathSegments[0];\r\n        if (Object.values(AADAuthorityConstants).includes(tenantId)) {\r\n            throw ClientAuthError_createClientAuthError(missingTenantIdError);\r\n        }\r\n        /*\r\n         * if this env variable is set, and the developer provided region isn\'t defined and isn\'t "DisableMsalForceRegion",\r\n         * MSAL shall opt-in to ESTS-R with the value of this variable\r\n         */\r\n        const ENV_MSAL_FORCE_REGION = process.env[MSAL_FORCE_REGION];\r\n        let region;\r\n        if (validRequest.azureRegion !== "DisableMsalForceRegion") {\r\n            if (!validRequest.azureRegion && ENV_MSAL_FORCE_REGION) {\r\n                region = ENV_MSAL_FORCE_REGION;\r\n            }\r\n            else {\r\n                region = validRequest.azureRegion;\r\n            }\r\n        }\r\n        const azureRegionConfiguration = {\r\n            azureRegion: region,\r\n            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE],\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);\r\n        try {\r\n            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, azureRegionConfiguration, request.azureCloudOptions);\r\n            const clientCredentialConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);\r\n            const clientCredentialClient = new ClientCredentialClient_ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);\r\n            this.logger.verbose("Client credential client created", validRequest.correlationId);\r\n            return await clientCredentialClient.acquireToken(validRequest);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Acquires tokens from the authority for the application.\r\n     *\r\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\r\n     * representing an end user. The current app can use the token (oboAssertion) to request another\r\n     * token to access downstream web API, on behalf of that user.\r\n     *\r\n     * The current middle-tier app has no user interaction to obtain consent.\r\n     * See how to gain consent upfront for your middle-tier app from this article.\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\r\n     */\r\n    async acquireTokenOnBehalfOf(request) {\r\n        this.logger.info("acquireTokenOnBehalfOf called", request.correlationId);\r\n        const validRequest = {\r\n            ...request,\r\n            ...(await this.initializeBaseRequest(request)),\r\n        };\r\n        try {\r\n            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);\r\n            const onBehalfOfConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", undefined);\r\n            const oboClient = new OnBehalfOfClient(onBehalfOfConfig);\r\n            this.logger.verbose("On behalf of client created", validRequest.correlationId);\r\n            return await oboClient.acquireToken(validRequest);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=ConfidentialClientApplication.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/utils/TimeUtils.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * @internal\r\n * Checks if a given date string is in ISO 8601 format.\r\n *\r\n * @param dateString - The date string to be checked.\r\n * @returns boolean - Returns true if the date string is in ISO 8601 format, otherwise false.\r\n */\r\nfunction isIso8601(dateString) {\r\n    if (typeof dateString !== "string") {\r\n        return false;\r\n    }\r\n    const date = new Date(dateString);\r\n    return !isNaN(date.getTime()) && date.toISOString() === dateString;\r\n}\n\n\n//# sourceMappingURL=TimeUtils.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/network/HttpClientWithRetries.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass HttpClientWithRetries {\r\n    constructor(httpClientNoRetries, retryPolicy, logger) {\r\n        this.httpClientNoRetries = httpClientNoRetries;\r\n        this.retryPolicy = retryPolicy;\r\n        this.logger = logger;\r\n    }\r\n    async sendNetworkRequestAsyncHelper(httpMethod, url, options) {\r\n        if (httpMethod === HttpMethod.GET) {\r\n            return this.httpClientNoRetries.sendGetRequestAsync(url, options);\r\n        }\r\n        else {\r\n            return this.httpClientNoRetries.sendPostRequestAsync(url, options);\r\n        }\r\n    }\r\n    async sendNetworkRequestAsync(httpMethod, url, options) {\r\n        // the underlying network module (custom or HttpClient) will make the call\r\n        let response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);\r\n        if ("isNewRequest" in this.retryPolicy) {\r\n            this.retryPolicy.isNewRequest = true;\r\n        }\r\n        let currentRetry = 0;\r\n        while (await this.retryPolicy.pauseForRetry(response.status, currentRetry, this.logger, response.headers[HeaderNames.RETRY_AFTER])) {\r\n            response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);\r\n            currentRetry++;\r\n        }\r\n        return response;\r\n    }\r\n    async sendGetRequestAsync(url, options) {\r\n        return this.sendNetworkRequestAsync(HttpMethod.GET, url, options);\r\n    }\r\n    async sendPostRequestAsync(url, options) {\r\n        return this.sendNetworkRequestAsync(HttpMethod.POST, url, options);\r\n    }\r\n}\n\n\n//# sourceMappingURL=HttpClientWithRetries.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/BaseManagedIdentitySource.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Managed Identity User Assigned Id Query Parameter Names\r\n */\r\nconst ManagedIdentityUserAssignedIdQueryParameterNames = {\r\n    MANAGED_IDENTITY_CLIENT_ID_2017: "clientid",\r\n    MANAGED_IDENTITY_CLIENT_ID: "client_id",\r\n    MANAGED_IDENTITY_OBJECT_ID: "object_id",\r\n    MANAGED_IDENTITY_RESOURCE_ID_IMDS: "msi_res_id",\r\n    MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS: "mi_res_id",\r\n};\r\nclass BaseManagedIdentitySource {\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {\r\n        this.logger = logger;\r\n        this.nodeStorage = nodeStorage;\r\n        this.networkClient = networkClient;\r\n        this.cryptoProvider = cryptoProvider;\r\n        this.disableInternalRetries = disableInternalRetries;\r\n    }\r\n    async getServerTokenResponseAsync(response, \r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    _networkClient, \r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    _networkRequest, \r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    _networkRequestOptions) {\r\n        return this.getServerTokenResponse(response);\r\n    }\r\n    getServerTokenResponse(response) {\r\n        let refreshIn, expiresIn;\r\n        if (response.body.expires_on) {\r\n            // if the expires_on field in the response body is a string and in ISO 8601 format, convert it to a Unix timestamp (seconds since epoch)\r\n            if (isIso8601(response.body.expires_on)) {\r\n                response.body.expires_on =\r\n                    new Date(response.body.expires_on).getTime() / 1000;\r\n            }\r\n            expiresIn = response.body.expires_on - nowSeconds();\r\n            // compute refresh_in as 1/2 of expires_in, but only if expires_in > 2h\r\n            if (expiresIn > 2 * 3600) {\r\n                refreshIn = expiresIn / 2;\r\n            }\r\n        }\r\n        const serverTokenResponse = {\r\n            status: response.status,\r\n            // success\r\n            access_token: response.body.access_token,\r\n            expires_in: expiresIn,\r\n            scope: response.body.resource,\r\n            token_type: response.body.token_type,\r\n            refresh_in: refreshIn,\r\n            // error\r\n            correlation_id: response.body.correlation_id || response.body.correlationId,\r\n            error: typeof response.body.error === "string"\r\n                ? response.body.error\r\n                : response.body.error?.code,\r\n            error_description: response.body.message ||\r\n                (typeof response.body.error === "string"\r\n                    ? response.body.error_description\r\n                    : response.body.error?.message),\r\n            error_codes: response.body.error_codes,\r\n            timestamp: response.body.timestamp,\r\n            trace_id: response.body.trace_id,\r\n        };\r\n        return serverTokenResponse;\r\n    }\r\n    async acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {\r\n        const networkRequest = this.createRequest(managedIdentityRequest.resource, managedIdentityId);\r\n        if (managedIdentityRequest.revokedTokenSha256Hash) {\r\n            this.logger.info(`[Managed Identity] The following claims are present in the request: ${managedIdentityRequest.claims}`);\r\n            networkRequest.queryParameters[ManagedIdentityQueryParameters.SHA256_TOKEN_TO_REFRESH] = managedIdentityRequest.revokedTokenSha256Hash;\r\n        }\r\n        if (managedIdentityRequest.clientCapabilities?.length) {\r\n            const clientCapabilities = managedIdentityRequest.clientCapabilities.toString();\r\n            this.logger.info(`[Managed Identity] The following client capabilities are present in the request: ${clientCapabilities}`);\r\n            networkRequest.queryParameters[ManagedIdentityQueryParameters.XMS_CC] = clientCapabilities;\r\n        }\r\n        const headers = networkRequest.headers;\r\n        headers[HeaderNames.CONTENT_TYPE] = Constants_Constants.URL_FORM_CONTENT_TYPE;\r\n        const networkRequestOptions = { headers };\r\n        if (Object.keys(networkRequest.bodyParameters).length) {\r\n            networkRequestOptions.body =\r\n                networkRequest.computeParametersBodyString();\r\n        }\r\n        /**\r\n         * Initializes the network client helper based on the retry policy configuration.\r\n         * If internal retries are disabled, it uses the provided network client directly.\r\n         * Otherwise, it wraps the network client with an HTTP client that supports retries.\r\n         */\r\n        const networkClientHelper = this.disableInternalRetries\r\n            ? this.networkClient\r\n            : new HttpClientWithRetries(this.networkClient, networkRequest.retryPolicy, this.logger);\r\n        const reqTimestamp = nowSeconds();\r\n        let response;\r\n        try {\r\n            // Sources that send POST requests: Cloud Shell\r\n            if (networkRequest.httpMethod === HttpMethod.POST) {\r\n                response =\r\n                    await networkClientHelper.sendPostRequestAsync(networkRequest.computeUri(), networkRequestOptions);\r\n                // Sources that send GET requests: App Service, Azure Arc, IMDS, Service Fabric\r\n            }\r\n            else {\r\n                response =\r\n                    await networkClientHelper.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);\r\n            }\r\n        }\r\n        catch (error) {\r\n            if (error instanceof AuthError) {\r\n                throw error;\r\n            }\r\n            else {\r\n                throw ClientAuthError_createClientAuthError(networkError);\r\n            }\r\n        }\r\n        const responseHandler = new ResponseHandler(managedIdentityId.id, this.nodeStorage, this.cryptoProvider, this.logger, null, null);\r\n        const serverTokenResponse = await this.getServerTokenResponseAsync(response, networkClientHelper, networkRequest, networkRequestOptions);\r\n        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);\r\n        // caches the token\r\n        return responseHandler.handleServerTokenResponse(serverTokenResponse, fakeAuthority, reqTimestamp, managedIdentityRequest);\r\n    }\r\n    getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityIdType, isImds, usesApi2017) {\r\n        switch (managedIdentityIdType) {\r\n            case Constants_ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:\r\n                this.logger.info(`[Managed Identity] [API version ${usesApi2017 ? "2017+" : "2019+"}] Adding user assigned client id to the request.`);\r\n                // The Machine Learning source uses the 2017-09-01 API version, which uses "clientid" instead of "client_id"\r\n                return usesApi2017\r\n                    ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017\r\n                    : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;\r\n            case Constants_ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:\r\n                this.logger.info("[Managed Identity] Adding user assigned resource id to the request.");\r\n                return isImds\r\n                    ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_IMDS\r\n                    : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS;\r\n            case Constants_ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:\r\n                this.logger.info("[Managed Identity] Adding user assigned object id to the request.");\r\n                return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;\r\n            default:\r\n                throw ManagedIdentityError_createManagedIdentityError(ManagedIdentityErrorCodes_invalidManagedIdentityIdType);\r\n        }\r\n    }\r\n}\r\nBaseManagedIdentitySource.getValidatedEnvVariableUrlString = (envVariableStringName, envVariable, sourceName, logger) => {\r\n    try {\r\n        return new UrlString(envVariable).urlString;\r\n    }\r\n    catch (error) {\r\n        logger.info(`[Managed Identity] ${sourceName} managed identity is unavailable because the \'${envVariableStringName}\' environment variable is malformed.`);\r\n        throw ManagedIdentityError_createManagedIdentityError(MsiEnvironmentVariableUrlMalformedErrorCodes[envVariableStringName]);\r\n    }\r\n};\n\n\n//# sourceMappingURL=BaseManagedIdentitySource.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/retry/LinearRetryStrategy.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass LinearRetryStrategy {\r\n    /**\r\n     * Calculates the number of milliseconds to sleep based on the `retry-after` HTTP header.\r\n     *\r\n     * @param retryHeader - The value of the `retry-after` HTTP header. This can be either a number of seconds\r\n     *                      or an HTTP date string.\r\n     * @returns The number of milliseconds to sleep before retrying the request. If the `retry-after` header is not\r\n     *          present or cannot be parsed, returns 0.\r\n     */\r\n    calculateDelay(retryHeader, minimumDelay) {\r\n        if (!retryHeader) {\r\n            return minimumDelay;\r\n        }\r\n        // retry-after header is in seconds\r\n        let millisToSleep = Math.round(parseFloat(retryHeader) * 1000);\r\n        /*\r\n         * retry-after header is in HTTP Date format\r\n         * <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\r\n         */\r\n        if (isNaN(millisToSleep)) {\r\n            // .valueOf() is needed to subtract dates in TypeScript\r\n            millisToSleep =\r\n                new Date(retryHeader).valueOf() - new Date().valueOf();\r\n        }\r\n        return Math.max(minimumDelay, millisToSleep);\r\n    }\r\n}\n\n\n//# sourceMappingURL=LinearRetryStrategy.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/retry/DefaultManagedIdentityRetryPolicy.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst DEFAULT_MANAGED_IDENTITY_MAX_RETRIES = 3; // referenced in unit test\r\nconst DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS = 1000;\r\nconst DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON = [\r\n    HttpStatus.NOT_FOUND,\r\n    HttpStatus.REQUEST_TIMEOUT,\r\n    HttpStatus.TOO_MANY_REQUESTS,\r\n    HttpStatus.SERVER_ERROR,\r\n    HttpStatus.SERVICE_UNAVAILABLE,\r\n    HttpStatus.GATEWAY_TIMEOUT,\r\n];\r\nclass DefaultManagedIdentityRetryPolicy {\r\n    constructor() {\r\n        this.linearRetryStrategy = new LinearRetryStrategy();\r\n    }\r\n    /*\r\n     * this is defined here as a static variable despite being defined as a constant outside of the\r\n     * class because it needs to be overridden in the unit tests so that the unit tests run faster\r\n     */\r\n    static get DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS() {\r\n        return DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS;\r\n    }\r\n    async pauseForRetry(httpStatusCode, currentRetry, logger, retryAfterHeader) {\r\n        if (DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON.includes(httpStatusCode) &&\r\n            currentRetry < DEFAULT_MANAGED_IDENTITY_MAX_RETRIES) {\r\n            const retryAfterDelay = this.linearRetryStrategy.calculateDelay(retryAfterHeader, DefaultManagedIdentityRetryPolicy.DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS);\r\n            logger.verbose(`Retrying request in ${retryAfterDelay}ms (retry attempt: ${currentRetry + 1})`);\r\n            // pause execution for the calculated delay\r\n            await new Promise((resolve) => {\r\n                // retryAfterHeader value of 0 evaluates to false, and DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS will be used\r\n                return setTimeout(resolve, retryAfterDelay);\r\n            });\r\n            return true;\r\n        }\r\n        // if the status code is not retriable or max retries have been reached, do not retry\r\n        return false;\r\n    }\r\n}\n\n\n//# sourceMappingURL=DefaultManagedIdentityRetryPolicy.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/config/ManagedIdentityRequestParameters.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass ManagedIdentityRequestParameters {\r\n    constructor(httpMethod, endpoint, retryPolicy) {\r\n        this.httpMethod = httpMethod;\r\n        this._baseEndpoint = endpoint;\r\n        this.headers = {};\r\n        this.bodyParameters = {};\r\n        this.queryParameters = {};\r\n        this.retryPolicy =\r\n            retryPolicy || new DefaultManagedIdentityRetryPolicy();\r\n    }\r\n    computeUri() {\r\n        const parameters = new Map();\r\n        if (this.queryParameters) {\r\n            addExtraQueryParameters(parameters, this.queryParameters);\r\n        }\r\n        const queryParametersString = mapToQueryString(parameters);\r\n        return UrlString.appendQueryString(this._baseEndpoint, queryParametersString);\r\n    }\r\n    computeParametersBodyString() {\r\n        const parameters = new Map();\r\n        if (this.bodyParameters) {\r\n            addExtraQueryParameters(parameters, this.bodyParameters);\r\n        }\r\n        return mapToQueryString(parameters);\r\n    }\r\n}\n\n\n//# sourceMappingURL=ManagedIdentityRequestParameters.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AppService.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n// MSI Constants. Docs for MSI are available here https://docs.microsoft.com/azure/app-service/overview-managed-identity\r\nconst APP_SERVICE_MSI_API_VERSION = "2019-08-01";\r\n/**\r\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AppServiceManagedIdentitySource.cs\r\n */\r\nclass AppService_AppService extends BaseManagedIdentitySource {\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader) {\r\n        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);\r\n        this.identityEndpoint = identityEndpoint;\r\n        this.identityHeader = identityHeader;\r\n    }\r\n    static getEnvironmentVariables() {\r\n        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];\r\n        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];\r\n        return [identityEndpoint, identityHeader];\r\n    }\r\n    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {\r\n        const [identityEndpoint, identityHeader] = AppService_AppService.getEnvironmentVariables();\r\n        // if either of the identity endpoint or identity header variables are undefined, this MSI provider is unavailable.\r\n        if (!identityEndpoint || !identityHeader) {\r\n            logger.info(`[Managed Identity] ${Constants_ManagedIdentitySourceNames.APP_SERVICE} managed identity is unavailable because one or both of the \'${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}\' and \'${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}\' environment variables are not defined.`);\r\n            return null;\r\n        }\r\n        const validatedIdentityEndpoint = AppService_AppService.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, Constants_ManagedIdentitySourceNames.APP_SERVICE, logger);\r\n        logger.info(`[Managed Identity] Environment variables validation passed for ${Constants_ManagedIdentitySourceNames.APP_SERVICE} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${Constants_ManagedIdentitySourceNames.APP_SERVICE} managed identity.`);\r\n        return new AppService_AppService(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader);\r\n    }\r\n    createRequest(resource, managedIdentityId) {\r\n        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);\r\n        request.headers[ManagedIdentityHeaders.APP_SERVICE_SECRET_HEADER_NAME] =\r\n            this.identityHeader;\r\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\r\n            APP_SERVICE_MSI_API_VERSION;\r\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\r\n            resource;\r\n        if (managedIdentityId.idType !== Constants_ManagedIdentityIdType.SYSTEM_ASSIGNED) {\r\n            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;\r\n        }\r\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\r\n        return request;\r\n    }\r\n}\n\n\n//# sourceMappingURL=AppService.mjs.map\n\n// EXTERNAL MODULE: external "fs"\nvar external_fs_ = __webpack_require__(9896);\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/AzureArc.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst ARC_API_VERSION = "2019-11-01";\r\nconst DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT = "http://127.0.0.1:40342/metadata/identity/oauth2/token";\r\nconst HIMDS_EXECUTABLE_HELPER_STRING = "N/A: himds executable exists";\r\nconst SUPPORTED_AZURE_ARC_PLATFORMS = {\r\n    win32: `${process.env["ProgramData"]}\\\\AzureConnectedMachineAgent\\\\Tokens\\\\`,\r\n    linux: "/var/opt/azcmagent/tokens/",\r\n};\r\nconst AZURE_ARC_FILE_DETECTION = {\r\n    win32: `${process.env["ProgramFiles"]}\\\\AzureConnectedMachineAgent\\\\himds.exe`,\r\n    linux: "/opt/azcmagent/bin/himds",\r\n};\r\n/**\r\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AzureArcManagedIdentitySource.cs\r\n */\r\nclass AzureArc_AzureArc extends BaseManagedIdentitySource {\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint) {\r\n        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);\r\n        this.identityEndpoint = identityEndpoint;\r\n    }\r\n    static getEnvironmentVariables() {\r\n        let identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];\r\n        let imdsEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT];\r\n        // if either of the identity or imds endpoints are undefined, check if the himds executable exists\r\n        if (!identityEndpoint || !imdsEndpoint) {\r\n            // get the expected Windows or Linux file path of the himds executable\r\n            const fileDetectionPath = AZURE_ARC_FILE_DETECTION[process.platform];\r\n            try {\r\n                /*\r\n                 * check if the himds executable exists and its permissions allow it to be read\r\n                 * returns undefined if true, throws an error otherwise\r\n                 */\r\n                (0,external_fs_.accessSync)(fileDetectionPath, external_fs_.constants.F_OK | external_fs_.constants.R_OK);\r\n                identityEndpoint = DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT;\r\n                imdsEndpoint = HIMDS_EXECUTABLE_HELPER_STRING;\r\n            }\r\n            catch (err) {\r\n                /*\r\n                 * do nothing\r\n                 * accessSync returns undefined on success, and throws an error on failure\r\n                 */\r\n            }\r\n        }\r\n        return [identityEndpoint, imdsEndpoint];\r\n    }\r\n    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {\r\n        const [identityEndpoint, imdsEndpoint] = AzureArc_AzureArc.getEnvironmentVariables();\r\n        // if either of the identity or imds endpoints are undefined (even after himds file detection)\r\n        if (!identityEndpoint || !imdsEndpoint) {\r\n            logger.info(`[Managed Identity] ${Constants_ManagedIdentitySourceNames.AZURE_ARC} managed identity is unavailable through environment variables because one or both of \'${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}\' and \'${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}\' are not defined. ${Constants_ManagedIdentitySourceNames.AZURE_ARC} managed identity is also unavailable through file detection.`);\r\n            return null;\r\n        }\r\n        // check if the imds endpoint is set to the default for file detection\r\n        if (imdsEndpoint === HIMDS_EXECUTABLE_HELPER_STRING) {\r\n            logger.info(`[Managed Identity] ${Constants_ManagedIdentitySourceNames.AZURE_ARC} managed identity is available through file detection. Defaulting to known ${Constants_ManagedIdentitySourceNames.AZURE_ARC} endpoint: ${DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT}. Creating ${Constants_ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);\r\n        }\r\n        else {\r\n            // otherwise, both the identity and imds endpoints are defined without file detection; validate them\r\n            const validatedIdentityEndpoint = AzureArc_AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, Constants_ManagedIdentitySourceNames.AZURE_ARC, logger);\r\n            // remove trailing slash\r\n            validatedIdentityEndpoint.endsWith("/")\r\n                ? validatedIdentityEndpoint.slice(0, -1)\r\n                : validatedIdentityEndpoint;\r\n            AzureArc_AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT, imdsEndpoint, Constants_ManagedIdentitySourceNames.AZURE_ARC, logger);\r\n            logger.info(`[Managed Identity] Environment variables validation passed for ${Constants_ManagedIdentitySourceNames.AZURE_ARC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${Constants_ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);\r\n        }\r\n        if (managedIdentityId.idType !== Constants_ManagedIdentityIdType.SYSTEM_ASSIGNED) {\r\n            throw ManagedIdentityError_createManagedIdentityError(unableToCreateAzureArc);\r\n        }\r\n        return new AzureArc_AzureArc(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint);\r\n    }\r\n    createRequest(resource) {\r\n        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint.replace("localhost", "127.0.0.1"));\r\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";\r\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\r\n            ARC_API_VERSION;\r\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\r\n            resource;\r\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\r\n        return request;\r\n    }\r\n    async getServerTokenResponseAsync(originalResponse, networkClient, networkRequest, networkRequestOptions) {\r\n        let retryResponse;\r\n        if (originalResponse.status === HttpStatus.UNAUTHORIZED) {\r\n            const wwwAuthHeader = originalResponse.headers["www-authenticate"];\r\n            if (!wwwAuthHeader) {\r\n                throw ManagedIdentityError_createManagedIdentityError(wwwAuthenticateHeaderMissing);\r\n            }\r\n            if (!wwwAuthHeader.includes("Basic realm=")) {\r\n                throw ManagedIdentityError_createManagedIdentityError(wwwAuthenticateHeaderUnsupportedFormat);\r\n            }\r\n            const secretFilePath = wwwAuthHeader.split("Basic realm=")[1];\r\n            // throw an error if the managed identity application is not being run on Windows or Linux\r\n            if (!SUPPORTED_AZURE_ARC_PLATFORMS.hasOwnProperty(process.platform)) {\r\n                throw ManagedIdentityError_createManagedIdentityError(platformNotSupported);\r\n            }\r\n            // get the expected Windows or Linux file path\r\n            const expectedSecretFilePath = SUPPORTED_AZURE_ARC_PLATFORMS[process.platform];\r\n            // throw an error if the file in the file path is not a .key file\r\n            const fileName = external_path_.basename(secretFilePath);\r\n            if (!fileName.endsWith(".key")) {\r\n                throw ManagedIdentityError_createManagedIdentityError(invalidFileExtension);\r\n            }\r\n            /*\r\n             * throw an error if the file path from the www-authenticate header does not match the\r\n             * expected file path for the platform (Windows or Linux) the managed identity application\r\n             * is running on\r\n             */\r\n            if (expectedSecretFilePath + fileName !== secretFilePath) {\r\n                throw ManagedIdentityError_createManagedIdentityError(invalidFilePath);\r\n            }\r\n            let secretFileSize;\r\n            // attempt to get the secret file\'s size, in bytes\r\n            try {\r\n                secretFileSize = await (0,external_fs_.statSync)(secretFilePath).size;\r\n            }\r\n            catch (e) {\r\n                throw ManagedIdentityError_createManagedIdentityError(unableToReadSecretFile);\r\n            }\r\n            // throw an error if the secret file\'s size is greater than 4096 bytes\r\n            if (secretFileSize > AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES) {\r\n                throw ManagedIdentityError_createManagedIdentityError(invalidSecret);\r\n            }\r\n            // attempt to read the contents of the secret file\r\n            let secret;\r\n            try {\r\n                secret = (0,external_fs_.readFileSync)(secretFilePath, Constants_EncodingTypes.UTF8);\r\n            }\r\n            catch (e) {\r\n                throw ManagedIdentityError_createManagedIdentityError(unableToReadSecretFile);\r\n            }\r\n            const authHeaderValue = `Basic ${secret}`;\r\n            this.logger.info(`[Managed Identity] Adding authorization header to the request.`);\r\n            networkRequest.headers[ManagedIdentityHeaders.AUTHORIZATION_HEADER_NAME] = authHeaderValue;\r\n            try {\r\n                retryResponse =\r\n                    await networkClient.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);\r\n            }\r\n            catch (error) {\r\n                if (error instanceof AuthError) {\r\n                    throw error;\r\n                }\r\n                else {\r\n                    throw ClientAuthError_createClientAuthError(networkError);\r\n                }\r\n            }\r\n        }\r\n        return this.getServerTokenResponse(retryResponse || originalResponse);\r\n    }\r\n}\n\n\n//# sourceMappingURL=AzureArc.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/CloudShell.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/CloudShellManagedIdentitySource.cs\r\n */\r\nclass CloudShell_CloudShell extends BaseManagedIdentitySource {\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint) {\r\n        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);\r\n        this.msiEndpoint = msiEndpoint;\r\n    }\r\n    static getEnvironmentVariables() {\r\n        const msiEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];\r\n        return [msiEndpoint];\r\n    }\r\n    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {\r\n        const [msiEndpoint] = CloudShell_CloudShell.getEnvironmentVariables();\r\n        // if the msi endpoint environment variable is undefined, this MSI provider is unavailable.\r\n        if (!msiEndpoint) {\r\n            logger.info(`[Managed Identity] ${Constants_ManagedIdentitySourceNames.CLOUD_SHELL} managed identity is unavailable because the \'${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT} environment variable is not defined.`);\r\n            return null;\r\n        }\r\n        const validatedMsiEndpoint = CloudShell_CloudShell.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT, msiEndpoint, Constants_ManagedIdentitySourceNames.CLOUD_SHELL, logger);\r\n        logger.info(`[Managed Identity] Environment variable validation passed for ${Constants_ManagedIdentitySourceNames.CLOUD_SHELL} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${Constants_ManagedIdentitySourceNames.CLOUD_SHELL} managed identity.`);\r\n        if (managedIdentityId.idType !== Constants_ManagedIdentityIdType.SYSTEM_ASSIGNED) {\r\n            throw ManagedIdentityError_createManagedIdentityError(unableToCreateCloudShell);\r\n        }\r\n        return new CloudShell_CloudShell(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint);\r\n    }\r\n    createRequest(resource) {\r\n        const request = new ManagedIdentityRequestParameters(HttpMethod.POST, this.msiEndpoint);\r\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";\r\n        request.bodyParameters[ManagedIdentityQueryParameters.RESOURCE] =\r\n            resource;\r\n        return request;\r\n    }\r\n}\n\n\n//# sourceMappingURL=CloudShell.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/retry/ExponentialRetryStrategy.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nclass ExponentialRetryStrategy {\r\n    constructor(minExponentialBackoff, maxExponentialBackoff, exponentialDeltaBackoff) {\r\n        this.minExponentialBackoff = minExponentialBackoff;\r\n        this.maxExponentialBackoff = maxExponentialBackoff;\r\n        this.exponentialDeltaBackoff = exponentialDeltaBackoff;\r\n    }\r\n    /**\r\n     * Calculates the exponential delay based on the current retry attempt.\r\n     *\r\n     * @param {number} currentRetry - The current retry attempt number.\r\n     * @returns {number} - The calculated exponential delay in milliseconds.\r\n     *\r\n     * The delay is calculated using the formula:\r\n     * - If `currentRetry` is 0, it returns the minimum backoff time.\r\n     * - Otherwise, it calculates the delay as the minimum of:\r\n     *   - `(2^(currentRetry - 1)) * deltaBackoff`\r\n     *   - `maxBackoff`\r\n     *\r\n     * This ensures that the delay increases exponentially with each retry attempt,\r\n     * but does not exceed the maximum backoff time.\r\n     */\r\n    calculateDelay(currentRetry) {\r\n        // Attempt 1\r\n        if (currentRetry === 0) {\r\n            return this.minExponentialBackoff;\r\n        }\r\n        // Attempt 2+\r\n        const exponentialDelay = Math.min(Math.pow(2, currentRetry - 1) * this.exponentialDeltaBackoff, this.maxExponentialBackoff);\r\n        return exponentialDelay;\r\n    }\r\n}\n\n\n//# sourceMappingURL=ExponentialRetryStrategy.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/retry/ImdsRetryPolicy.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY = [\r\n    HttpStatus.NOT_FOUND,\r\n    HttpStatus.REQUEST_TIMEOUT,\r\n    HttpStatus.GONE,\r\n    HttpStatus.TOO_MANY_REQUESTS,\r\n];\r\nconst EXPONENTIAL_STRATEGY_NUM_RETRIES = 3;\r\nconst LINEAR_STRATEGY_NUM_RETRIES = 7;\r\nconst MIN_EXPONENTIAL_BACKOFF_MS = 1000;\r\nconst MAX_EXPONENTIAL_BACKOFF_MS = 4000;\r\nconst EXPONENTIAL_DELTA_BACKOFF_MS = 2000;\r\nconst HTTP_STATUS_GONE_RETRY_AFTER_MS = 10 * 1000; // 10 seconds\r\nclass ImdsRetryPolicy {\r\n    constructor() {\r\n        this.exponentialRetryStrategy = new ExponentialRetryStrategy(ImdsRetryPolicy.MIN_EXPONENTIAL_BACKOFF_MS, ImdsRetryPolicy.MAX_EXPONENTIAL_BACKOFF_MS, ImdsRetryPolicy.EXPONENTIAL_DELTA_BACKOFF_MS);\r\n    }\r\n    /*\r\n     * these are defined here as static variables despite being defined as constants outside of the\r\n     * class because they need to be overridden in the unit tests so that the unit tests run faster\r\n     */\r\n    static get MIN_EXPONENTIAL_BACKOFF_MS() {\r\n        return MIN_EXPONENTIAL_BACKOFF_MS;\r\n    }\r\n    static get MAX_EXPONENTIAL_BACKOFF_MS() {\r\n        return MAX_EXPONENTIAL_BACKOFF_MS;\r\n    }\r\n    static get EXPONENTIAL_DELTA_BACKOFF_MS() {\r\n        return EXPONENTIAL_DELTA_BACKOFF_MS;\r\n    }\r\n    static get HTTP_STATUS_GONE_RETRY_AFTER_MS() {\r\n        return HTTP_STATUS_GONE_RETRY_AFTER_MS;\r\n    }\r\n    set isNewRequest(value) {\r\n        this._isNewRequest = value;\r\n    }\r\n    /**\r\n     * Pauses execution for a calculated delay before retrying a request.\r\n     *\r\n     * @param httpStatusCode - The HTTP status code of the response.\r\n     * @param currentRetry - The current retry attempt number.\r\n     * @param retryAfterHeader - The value of the "retry-after" header from the response.\r\n     * @returns A promise that resolves to a boolean indicating whether a retry should be attempted.\r\n     */\r\n    async pauseForRetry(httpStatusCode, currentRetry, logger) {\r\n        if (this._isNewRequest) {\r\n            this._isNewRequest = false;\r\n            // calculate the maxRetries based on the status code, once per request\r\n            this.maxRetries =\r\n                httpStatusCode === HttpStatus.GONE\r\n                    ? LINEAR_STRATEGY_NUM_RETRIES\r\n                    : EXPONENTIAL_STRATEGY_NUM_RETRIES;\r\n        }\r\n        /**\r\n         * (status code is one of the retriable 400 status code\r\n         * or\r\n         * status code is >= 500 and <= 599)\r\n         * and\r\n         * current count of retries is less than the max number of retries\r\n         */\r\n        if ((HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY.includes(httpStatusCode) ||\r\n            (httpStatusCode >= HttpStatus.SERVER_ERROR_RANGE_START &&\r\n                httpStatusCode <= HttpStatus.SERVER_ERROR_RANGE_END &&\r\n                currentRetry < this.maxRetries)) &&\r\n            currentRetry < this.maxRetries) {\r\n            const retryAfterDelay = httpStatusCode === HttpStatus.GONE\r\n                ? ImdsRetryPolicy.HTTP_STATUS_GONE_RETRY_AFTER_MS\r\n                : this.exponentialRetryStrategy.calculateDelay(currentRetry);\r\n            logger.verbose(`Retrying request in ${retryAfterDelay}ms (retry attempt: ${currentRetry + 1})`);\r\n            // pause execution for the calculated delay\r\n            await new Promise((resolve) => {\r\n                return setTimeout(resolve, retryAfterDelay);\r\n            });\r\n            return true;\r\n        }\r\n        // if the status code is not retriable or max retries have been reached, do not retry\r\n        return false;\r\n    }\r\n}\n\n\n//# sourceMappingURL=ImdsRetryPolicy.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/Imds.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n// Documentation for IMDS is available at https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/how-to-use-vm-token#get-a-token-using-http\r\nconst IMDS_TOKEN_PATH = "/metadata/identity/oauth2/token";\r\nconst DEFAULT_IMDS_ENDPOINT = `http://169.254.169.254${IMDS_TOKEN_PATH}`;\r\nconst IMDS_API_VERSION = "2018-02-01";\r\n/**\r\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ImdsManagedIdentitySource.cs\r\n */\r\nclass Imds_Imds extends BaseManagedIdentitySource {\r\n    /**\r\n     * Constructs an Imds instance.\r\n     * @param logger - Logger instance for logging.\r\n     * @param nodeStorage - NodeStorage instance for caching.\r\n     * @param networkClient - Network client for HTTP requests.\r\n     * @param cryptoProvider - CryptoProvider for cryptographic operations.\r\n     * @param disableInternalRetries - Whether to disable internal retry logic.\r\n     * @param identityEndpoint - The IMDS endpoint to use.\r\n     */\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint) {\r\n        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);\r\n        this.identityEndpoint = identityEndpoint;\r\n    }\r\n    /**\r\n     * Attempts to create an Imds instance by determining the correct endpoint.\r\n     * If the AZURE_POD_IDENTITY_AUTHORITY_HOST environment variable is set, it uses that as the endpoint.\r\n     * Otherwise, it falls back to the default IMDS endpoint.\r\n     *\r\n     * @param logger - Logger instance for logging.\r\n     * @param nodeStorage - NodeStorage instance for caching.\r\n     * @param networkClient - Network client for HTTP requests.\r\n     * @param cryptoProvider - CryptoProvider for cryptographic operations.\r\n     * @param disableInternalRetries - Whether to disable internal retry logic.\r\n     * @returns An instance of Imds configured with the appropriate endpoint.\r\n     */\r\n    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {\r\n        let validatedIdentityEndpoint;\r\n        if (process.env[ManagedIdentityEnvironmentVariableNames\r\n            .AZURE_POD_IDENTITY_AUTHORITY_HOST]) {\r\n            logger.info(`[Managed Identity] Environment variable ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} for ${Constants_ManagedIdentitySourceNames.IMDS} returned endpoint: ${process.env[ManagedIdentityEnvironmentVariableNames\r\n                .AZURE_POD_IDENTITY_AUTHORITY_HOST]}`);\r\n            validatedIdentityEndpoint = Imds_Imds.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST, `${process.env[ManagedIdentityEnvironmentVariableNames\r\n                .AZURE_POD_IDENTITY_AUTHORITY_HOST]}${IMDS_TOKEN_PATH}`, Constants_ManagedIdentitySourceNames.IMDS, logger);\r\n        }\r\n        else {\r\n            logger.info(`[Managed Identity] Unable to find ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} environment variable for ${Constants_ManagedIdentitySourceNames.IMDS}, using the default endpoint.`);\r\n            validatedIdentityEndpoint = DEFAULT_IMDS_ENDPOINT;\r\n        }\r\n        return new Imds_Imds(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, validatedIdentityEndpoint);\r\n    }\r\n    /**\r\n     * Creates a ManagedIdentityRequestParameters object for acquiring a token from IMDS.\r\n     * Sets the required headers and query parameters for the IMDS token request.\r\n     *\r\n     * @param resource - The resource URI for which the token is requested.\r\n     * @param managedIdentityId - The managed identity ID (system-assigned or user-assigned).\r\n     * @returns A ManagedIdentityRequestParameters object configured for IMDS.\r\n     */\r\n    createRequest(resource, managedIdentityId) {\r\n        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);\r\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";\r\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\r\n            IMDS_API_VERSION;\r\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\r\n            resource;\r\n        if (managedIdentityId.idType !== Constants_ManagedIdentityIdType.SYSTEM_ASSIGNED) {\r\n            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType, true // indicates source is IMDS\r\n            )] = managedIdentityId.id;\r\n        }\r\n        // The bodyParameters are calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity.\r\n        request.retryPolicy = new ImdsRetryPolicy();\r\n        return request;\r\n    }\r\n}\n\n\n//# sourceMappingURL=Imds.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/ServiceFabric.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst SERVICE_FABRIC_MSI_API_VERSION = "2019-07-01-preview";\r\n/**\r\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ServiceFabricManagedIdentitySource.cs\r\n */\r\nclass ServiceFabric_ServiceFabric extends BaseManagedIdentitySource {\r\n    /**\r\n     * Constructs a new ServiceFabric managed identity source.\r\n     * @param logger Logger instance for logging\r\n     * @param nodeStorage NodeStorage instance for caching\r\n     * @param networkClient Network client for HTTP requests\r\n     * @param cryptoProvider Crypto provider for cryptographic operations\r\n     * @param disableInternalRetries Whether to disable internal retry logic\r\n     * @param identityEndpoint The Service Fabric managed identity endpoint\r\n     * @param identityHeader The Service Fabric managed identity secret header\r\n     */\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader) {\r\n        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);\r\n        this.identityEndpoint = identityEndpoint;\r\n        this.identityHeader = identityHeader;\r\n    }\r\n    /**\r\n     * Retrieves the environment variables required for Service Fabric managed identity.\r\n     * @returns An array containing the identity endpoint, identity header, and identity server thumbprint.\r\n     */\r\n    static getEnvironmentVariables() {\r\n        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];\r\n        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];\r\n        const identityServerThumbprint = process.env[ManagedIdentityEnvironmentVariableNames\r\n            .IDENTITY_SERVER_THUMBPRINT];\r\n        return [identityEndpoint, identityHeader, identityServerThumbprint];\r\n    }\r\n    /**\r\n     * Attempts to create a ServiceFabric managed identity source if all required environment variables are present.\r\n     * @param logger Logger instance for logging\r\n     * @param nodeStorage NodeStorage instance for caching\r\n     * @param networkClient Network client for HTTP requests\r\n     * @param cryptoProvider Crypto provider for cryptographic operations\r\n     * @param disableInternalRetries Whether to disable internal retry logic\r\n     * @param managedIdentityId Managed identity identifier\r\n     * @returns A ServiceFabric instance if environment variables are set, otherwise null\r\n     */\r\n    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {\r\n        const [identityEndpoint, identityHeader, identityServerThumbprint] = ServiceFabric_ServiceFabric.getEnvironmentVariables();\r\n        if (!identityEndpoint || !identityHeader || !identityServerThumbprint) {\r\n            logger.info(`[Managed Identity] ${Constants_ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity is unavailable because one or all of the \'${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}\', \'${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}\' or \'${ManagedIdentityEnvironmentVariableNames.IDENTITY_SERVER_THUMBPRINT}\' environment variables are not defined.`);\r\n            return null;\r\n        }\r\n        const validatedIdentityEndpoint = ServiceFabric_ServiceFabric.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, Constants_ManagedIdentitySourceNames.SERVICE_FABRIC, logger);\r\n        logger.info(`[Managed Identity] Environment variables validation passed for ${Constants_ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${Constants_ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity.`);\r\n        if (managedIdentityId.idType !== Constants_ManagedIdentityIdType.SYSTEM_ASSIGNED) {\r\n            logger.warning(`[Managed Identity] ${Constants_ManagedIdentitySourceNames.SERVICE_FABRIC} user assigned managed identity is configured in the cluster, not during runtime. See also: https://learn.microsoft.com/en-us/azure/service-fabric/configure-existing-cluster-enable-managed-identity-token-service.`);\r\n        }\r\n        return new ServiceFabric_ServiceFabric(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader);\r\n    }\r\n    /**\r\n     * Creates the request parameters for acquiring a token from the Service Fabric cluster.\r\n     * @param resource - The resource URI for which the token is requested.\r\n     * @param managedIdentityId - The managed identity ID (system-assigned or user-assigned).\r\n     * @returns A ManagedIdentityRequestParameters object configured for Service Fabric.\r\n     */\r\n    createRequest(resource, managedIdentityId) {\r\n        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);\r\n        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] =\r\n            this.identityHeader;\r\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\r\n            SERVICE_FABRIC_MSI_API_VERSION;\r\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\r\n            resource;\r\n        if (managedIdentityId.idType !== Constants_ManagedIdentityIdType.SYSTEM_ASSIGNED) {\r\n            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;\r\n        }\r\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\r\n        return request;\r\n    }\r\n}\n\n\n//# sourceMappingURL=ServiceFabric.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentitySources/MachineLearning.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst MACHINE_LEARNING_MSI_API_VERSION = "2017-09-01";\r\nclass MachineLearning_MachineLearning extends BaseManagedIdentitySource {\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint, secret) {\r\n        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);\r\n        this.msiEndpoint = msiEndpoint;\r\n        this.secret = secret;\r\n    }\r\n    static getEnvironmentVariables() {\r\n        const msiEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];\r\n        const secret = process.env[ManagedIdentityEnvironmentVariableNames.MSI_SECRET];\r\n        return [msiEndpoint, secret];\r\n    }\r\n    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {\r\n        const [msiEndpoint, secret] = MachineLearning_MachineLearning.getEnvironmentVariables();\r\n        // if either of the MSI endpoint or MSI secret variables are undefined, this MSI provider is unavailable.\r\n        if (!msiEndpoint || !secret) {\r\n            logger.info(`[Managed Identity] ${Constants_ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity is unavailable because one or both of the \'${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}\' and \'${ManagedIdentityEnvironmentVariableNames.MSI_SECRET}\' environment variables are not defined.`);\r\n            return null;\r\n        }\r\n        const validatedMsiEndpoint = MachineLearning_MachineLearning.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT, msiEndpoint, Constants_ManagedIdentitySourceNames.MACHINE_LEARNING, logger);\r\n        logger.info(`[Managed Identity] Environment variables validation passed for ${Constants_ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${Constants_ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity.`);\r\n        return new MachineLearning_MachineLearning(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint, secret);\r\n    }\r\n    createRequest(resource, managedIdentityId) {\r\n        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.msiEndpoint);\r\n        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";\r\n        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] =\r\n            this.secret;\r\n        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =\r\n            MACHINE_LEARNING_MSI_API_VERSION;\r\n        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =\r\n            resource;\r\n        if (managedIdentityId.idType !== Constants_ManagedIdentityIdType.SYSTEM_ASSIGNED) {\r\n            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType, false, // isIMDS\r\n            true // uses2017API\r\n            )] = managedIdentityId.id;\r\n        }\r\n        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity\r\n        return request;\r\n    }\r\n}\n\n\n//# sourceMappingURL=MachineLearning.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentityClient.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/*\r\n * Class to initialize a managed identity and identify the service.\r\n * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ManagedIdentityClient.cs\r\n */\r\nclass ManagedIdentityClient_ManagedIdentityClient {\r\n    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {\r\n        this.logger = logger;\r\n        this.nodeStorage = nodeStorage;\r\n        this.networkClient = networkClient;\r\n        this.cryptoProvider = cryptoProvider;\r\n        this.disableInternalRetries = disableInternalRetries;\r\n    }\r\n    async sendManagedIdentityTokenRequest(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {\r\n        if (!ManagedIdentityClient_ManagedIdentityClient.identitySource) {\r\n            ManagedIdentityClient_ManagedIdentityClient.identitySource =\r\n                this.selectManagedIdentitySource(this.logger, this.nodeStorage, this.networkClient, this.cryptoProvider, this.disableInternalRetries, managedIdentityId);\r\n        }\r\n        return ManagedIdentityClient_ManagedIdentityClient.identitySource.acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken);\r\n    }\r\n    allEnvironmentVariablesAreDefined(environmentVariables) {\r\n        return Object.values(environmentVariables).every((environmentVariable) => {\r\n            return environmentVariable !== undefined;\r\n        });\r\n    }\r\n    /**\r\n     * Determine the Managed Identity Source based on available environment variables. This API is consumed by ManagedIdentityApplication\'s getManagedIdentitySource.\r\n     * @returns ManagedIdentitySourceNames - The Managed Identity source\'s name\r\n     */\r\n    getManagedIdentitySource() {\r\n        ManagedIdentityClient_ManagedIdentityClient.sourceName =\r\n            this.allEnvironmentVariablesAreDefined(ServiceFabric.getEnvironmentVariables())\r\n                ? ManagedIdentitySourceNames.SERVICE_FABRIC\r\n                : this.allEnvironmentVariablesAreDefined(AppService.getEnvironmentVariables())\r\n                    ? ManagedIdentitySourceNames.APP_SERVICE\r\n                    : this.allEnvironmentVariablesAreDefined(MachineLearning.getEnvironmentVariables())\r\n                        ? ManagedIdentitySourceNames.MACHINE_LEARNING\r\n                        : this.allEnvironmentVariablesAreDefined(CloudShell.getEnvironmentVariables())\r\n                            ? ManagedIdentitySourceNames.CLOUD_SHELL\r\n                            : this.allEnvironmentVariablesAreDefined(AzureArc.getEnvironmentVariables())\r\n                                ? ManagedIdentitySourceNames.AZURE_ARC\r\n                                : ManagedIdentitySourceNames.DEFAULT_TO_IMDS;\r\n        return ManagedIdentityClient_ManagedIdentityClient.sourceName;\r\n    }\r\n    /**\r\n     * Tries to create a managed identity source for all sources\r\n     * @returns the managed identity Source\r\n     */\r\n    selectManagedIdentitySource(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {\r\n        const source = ServiceFabric.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) ||\r\n            AppService.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) ||\r\n            MachineLearning.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) ||\r\n            CloudShell.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) ||\r\n            AzureArc.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) ||\r\n            Imds.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);\r\n        if (!source) {\r\n            throw createManagedIdentityError(unableToCreateSource);\r\n        }\r\n        return source;\r\n    }\r\n}\n\n\n//# sourceMappingURL=ManagedIdentityClient.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/client/ManagedIdentityApplication.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nconst SOURCES_THAT_SUPPORT_TOKEN_REVOCATION = [Constants_ManagedIdentitySourceNames.SERVICE_FABRIC];\r\n/**\r\n * Class to initialize a managed identity and identify the service\r\n * @public\r\n */\r\nclass ManagedIdentityApplication {\r\n    constructor(configuration) {\r\n        // undefined config means the managed identity is system-assigned\r\n        this.config = buildManagedIdentityConfiguration(configuration || {});\r\n        this.logger = new Logger(this.config.system.loggerOptions, name, version);\r\n        const fakeStatusAuthorityOptions = {\r\n            canonicalAuthority: Constants.DEFAULT_AUTHORITY,\r\n        };\r\n        if (!ManagedIdentityApplication.nodeStorage) {\r\n            ManagedIdentityApplication.nodeStorage = new NodeStorage(this.logger, this.config.managedIdentityId.id, DEFAULT_CRYPTO_IMPLEMENTATION, fakeStatusAuthorityOptions);\r\n        }\r\n        this.networkClient = this.config.system.networkClient;\r\n        this.cryptoProvider = new CryptoProvider();\r\n        const fakeAuthorityOptions = {\r\n            protocolMode: ProtocolMode.AAD,\r\n            knownAuthorities: [DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY],\r\n            cloudDiscoveryMetadata: "",\r\n            authorityMetadata: "",\r\n        };\r\n        this.fakeAuthority = new Authority(DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY, this.networkClient, ManagedIdentityApplication.nodeStorage, fakeAuthorityOptions, this.logger, this.cryptoProvider.createNewGuid(), // correlationID\r\n        undefined, true);\r\n        this.fakeClientCredentialClient = new ClientCredentialClient({\r\n            authOptions: {\r\n                clientId: this.config.managedIdentityId.id,\r\n                authority: this.fakeAuthority,\r\n            },\r\n        });\r\n        this.managedIdentityClient = new ManagedIdentityClient(this.logger, ManagedIdentityApplication.nodeStorage, this.networkClient, this.cryptoProvider, this.config.disableInternalRetries);\r\n        this.hashUtils = new HashUtils();\r\n    }\r\n    /**\r\n     * Acquire an access token from the cache or the managed identity\r\n     * @param managedIdentityRequest - the ManagedIdentityRequestParams object passed in by the developer\r\n     * @returns the access token\r\n     */\r\n    async acquireToken(managedIdentityRequestParams) {\r\n        if (!managedIdentityRequestParams.resource) {\r\n            throw createClientConfigurationError(ClientConfigurationErrorCodes.urlEmptyError);\r\n        }\r\n        const managedIdentityRequest = {\r\n            forceRefresh: managedIdentityRequestParams.forceRefresh,\r\n            resource: managedIdentityRequestParams.resource.replace("/.default", ""),\r\n            scopes: [\r\n                managedIdentityRequestParams.resource.replace("/.default", ""),\r\n            ],\r\n            authority: this.fakeAuthority.canonicalAuthority,\r\n            correlationId: this.cryptoProvider.createNewGuid(),\r\n            claims: managedIdentityRequestParams.claims,\r\n            clientCapabilities: this.config.clientCapabilities,\r\n        };\r\n        if (managedIdentityRequest.forceRefresh) {\r\n            return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);\r\n        }\r\n        const [cachedAuthenticationResult, lastCacheOutcome] = await this.fakeClientCredentialClient.getCachedAuthenticationResult(managedIdentityRequest, this.config, this.cryptoProvider, this.fakeAuthority, ManagedIdentityApplication.nodeStorage);\r\n        /*\r\n         * Check if claims are present in the managed identity request.\r\n         * If so, the cached token will not be used.\r\n         */\r\n        if (managedIdentityRequest.claims) {\r\n            const sourceName = this.managedIdentityClient.getManagedIdentitySource();\r\n            /*\r\n             * Check if there is a cached token and if the Managed Identity source supports token revocation.\r\n             * If so, hash the cached access token and add it to the request.\r\n             */\r\n            if (cachedAuthenticationResult &&\r\n                SOURCES_THAT_SUPPORT_TOKEN_REVOCATION.includes(sourceName)) {\r\n                const revokedTokenSha256Hash = this.hashUtils\r\n                    .sha256(cachedAuthenticationResult.accessToken)\r\n                    .toString(EncodingTypes.HEX);\r\n                managedIdentityRequest.revokedTokenSha256Hash =\r\n                    revokedTokenSha256Hash;\r\n            }\r\n            return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);\r\n        }\r\n        if (cachedAuthenticationResult) {\r\n            // if the token is not expired but must be refreshed; get a new one in the background\r\n            if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {\r\n                this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token\'s refreshOn property has been exceeded\'. It\'s not expired, but must be refreshed.");\r\n                // force refresh; will run in the background\r\n                const refreshAccessToken = true;\r\n                await this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority, refreshAccessToken);\r\n            }\r\n            return cachedAuthenticationResult;\r\n        }\r\n        else {\r\n            return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);\r\n        }\r\n    }\r\n    /**\r\n     * Acquires a token from a managed identity endpoint.\r\n     *\r\n     * @param managedIdentityRequest - The request object containing parameters for the managed identity token request.\r\n     * @param managedIdentityId - The identifier for the managed identity (e.g., client ID or resource ID).\r\n     * @param fakeAuthority - A placeholder authority used for the token request.\r\n     * @param refreshAccessToken - Optional flag indicating whether to force a refresh of the access token.\r\n     * @returns A promise that resolves to an AuthenticationResult containing the acquired token and related information.\r\n     */\r\n    async acquireTokenFromManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {\r\n        // make a network call to the managed identity\r\n        return this.managedIdentityClient.sendManagedIdentityTokenRequest(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken);\r\n    }\r\n    /**\r\n     * Determine the Managed Identity Source based on available environment variables. This API is consumed by Azure Identity SDK.\r\n     * @returns ManagedIdentitySourceNames - The Managed Identity source\'s name\r\n     */\r\n    getManagedIdentitySource() {\r\n        return (ManagedIdentityClient.sourceName ||\r\n            this.managedIdentityClient.getManagedIdentitySource());\r\n    }\r\n}\n\n\n//# sourceMappingURL=ManagedIdentityApplication.mjs.map\n\n;// ./node_modules/@azure/msal-node/dist/index.mjs\n/*! @azure/msal-node v3.6.0 2025-05-30 */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/index.js + 42 modules\nvar src = __webpack_require__(8703);\n;// ./src/auth/AuthService.ts\n// Authentication service using MSAL for Electron\n\n\nclass AuthService {\n    constructor() {\n        // Use Microsoft Graph PowerShell public client ID for interactive login\n        // This allows users to authenticate without requiring their own App Registration\n        const clientId = process.env.MSAL_CLIENT_ID && process.env.MSAL_CLIENT_ID.trim() !== \'\'\n            ? process.env.MSAL_CLIENT_ID\n            : \'14d82eec-204b-4c2f-b7e8-296a70dab67e\'; // Microsoft Graph PowerShell\n        const authority = process.env.MSAL_TENANT_ID && process.env.MSAL_TENANT_ID.trim() !== \'\'\n            ? `https://login.microsoftonline.com/${process.env.MSAL_TENANT_ID}`\n            : \'https://login.microsoftonline.com/common\';\n        console.log(`Using MSAL Client ID: ${clientId}`);\n        console.log(`Using Authority: ${authority}`);\n        this.config = {\n            auth: {\n                clientId,\n                authority,\n            },\n            system: {\n                loggerOptions: {\n                    loggerCallback: (level, message, containsPii) => {\n                        if (containsPii)\n                            return;\n                        console.log(`[MSAL ${level}]: ${message}`);\n                    },\n                    piiLoggingEnabled: false,\n                    logLevel: LogLevel.Info,\n                },\n            },\n        };\n        this.msalClient = new PublicClientApplication(this.config);\n    }\n    async login(useRedirectFlow = false) {\n        try {\n            // Start with minimal permissions that most users should have\n            const authRequest = {\n                scopes: [\n                    \'User.Read\', // Read current user\'s profile - basic permission\n                ],\n                openBrowser: async (url) => {\n                    // In Electron, we can use shell.openExternal to open the browser\n                    const { shell } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 1288, 23));\n                    await shell.openExternal(url);\n                },\n                // Use system browser for redirect flow\n                // This is more compatible with mobile authentication flows\n                redirectUri: useRedirectFlow ? \'https://login.microsoftonline.com/common/oauth2/nativeclient\' : undefined,\n                successTemplate: `\r\n          <html>\r\n            <head><title>Authentication Successful</title></head>\r\n            <body>\r\n              <h1>Authentication Successful!</h1>\r\n              <p>You can now close this window and return to EntraPulse Lite.</p>\r\n              <script>window.close();<\/script>\r\n            </body>\r\n          </html>\r\n        `,\n                errorTemplate: `\r\n          <html>\r\n            <head><title>Authentication Failed</title></head>\r\n            <body>\r\n              <h1>Authentication Failed</h1>\r\n              <p>Please try again. You can close this window and return to EntraPulse Lite.</p>\r\n              <script>window.close();<\/script>\r\n            </body>\r\n          </html>\r\n        `\n            };\n            console.log(\'Starting authentication with minimal permissions...\');\n            const response = await this.msalClient.acquireTokenInteractive(authRequest);\n            console.log(\'Authentication successful with basic permissions!\');\n            return this.mapToAuthToken(response);\n        }\n        catch (error) {\n            console.error(\'Authentication failed:\', error);\n            throw new Error(`Authentication failed: ${error instanceof Error ? error.message : \'Unknown error\'}`);\n        }\n    }\n    async requestAdditionalPermissions(permissions) {\n        try {\n            const accounts = await this.msalClient.getTokenCache().getAllAccounts();\n            if (accounts.length === 0) {\n                throw new Error(\'No authenticated account found. Please log in first.\');\n            }\n            const authRequest = {\n                scopes: permissions,\n                account: accounts[0],\n                forceRefresh: false,\n            };\n            console.log(`Requesting additional permissions: ${permissions.join(\', \')}`);\n            // Try silent request first\n            try {\n                const response = await this.msalClient.acquireTokenSilent(authRequest);\n                console.log(\'Additional permissions granted silently\');\n                return this.mapToAuthToken(response);\n            }\n            catch (silentError) {\n                console.log(\'Silent request failed, requiring interactive consent\');\n                // If silent fails, request interactively\n                const interactiveRequest = {\n                    ...authRequest,\n                    openBrowser: async (url) => {\n                        const { shell } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 1288, 23));\n                        await shell.openExternal(url);\n                    },\n                    prompt: \'consent\', // Force consent to show permissions\n                };\n                const response = await this.msalClient.acquireTokenInteractive(interactiveRequest);\n                console.log(\'Additional permissions granted interactively\');\n                return this.mapToAuthToken(response);\n            }\n        }\n        catch (error) {\n            console.error(\'Failed to request additional permissions:\', error);\n            return null;\n        }\n    }\n    async getTokenWithPermissions(permissions) {\n        try {\n            const accounts = await this.msalClient.getTokenCache().getAllAccounts();\n            if (accounts.length === 0) {\n                return null;\n            }\n            const authRequest = {\n                scopes: permissions,\n                account: accounts[0],\n            };\n            const response = await this.msalClient.acquireTokenSilent(authRequest);\n            return this.mapToAuthToken(response);\n        }\n        catch (error) {\n            console.log(`Token with permissions [${permissions.join(\', \')}] not available silently`);\n            return null;\n        }\n    }\n    async logout() {\n        try {\n            const accounts = await this.msalClient.getTokenCache().getAllAccounts();\n            for (const account of accounts) {\n                await this.msalClient.getTokenCache().removeAccount(account);\n            }\n        }\n        catch (error) {\n            console.error(\'Logout failed:\', error);\n            throw new Error(\'Logout failed\');\n        }\n    }\n    async getToken() {\n        try {\n            const accounts = await this.msalClient.getTokenCache().getAllAccounts();\n            if (accounts.length === 0) {\n                return null;\n            }\n            const authRequest = {\n                scopes: [\'User.Read\'],\n                account: accounts[0],\n            };\n            const response = await this.msalClient.acquireTokenSilent(authRequest);\n            return this.mapToAuthToken(response);\n        }\n        catch (error) {\n            console.error(\'Token retrieval failed:\', error);\n            return null;\n        }\n    }\n    async getCurrentUser() {\n        try {\n            const token = await this.getToken();\n            if (!token)\n                return null;\n            // Create a temporary Graph client to make the API call\n            const client = src.Client.init({\n                authProvider: async (done) => {\n                    done(null, token.accessToken);\n                }\n            });\n            // Call Microsoft Graph API to get user profile\n            const response = await client.api(\'/me\').get();\n            return {\n                id: response.id,\n                displayName: response.displayName,\n                mail: response.mail || response.userPrincipalName,\n                userPrincipalName: response.userPrincipalName,\n                jobTitle: response.jobTitle,\n                department: response.department,\n            };\n        }\n        catch (error) {\n            console.error(\'Failed to get current user:\', error);\n            return null;\n        }\n    }\n    mapToAuthToken(response) {\n        return {\n            accessToken: response.accessToken,\n            idToken: response.idToken || \'\',\n            expiresOn: response.expiresOn || new Date(),\n            scopes: response.scopes || [],\n        };\n    }\n}\n\n;// ./src/shared/ProfilePhotoService.ts\n/**\n * Improved method for fetching user profile photos from Microsoft Graph,\n * with multiple fallback mechanisms for better reliability\n */\nclass ProfilePhotoService {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Get a user\'s profile photo with multiple fallback mechanisms\n     * @param userId User ID or email address\n     * @returns Base64-encoded photo data URI or null if no photo available\n     */\n    async getUserPhoto(userId = \'me\') {\n        try {\n            // Import the ResponseType enum from the Microsoft Graph client\n            const { ResponseType } = __webpack_require__(8703);\n            // If userId is an email, we need to get the user\'s ID first\n            let userIdToUse = userId;\n            let userEmail = userId; // Store email for Outlook fallback\n            if (userId !== \'me\' && userId.includes(\'@\')) {\n                try {\n                    console.log(`Getting user ID for email: ${userId}`);\n                    const userResponse = await this.client\n                        .api(`/users/${userId}`)\n                        .select(\'id\')\n                        .get();\n                    if (userResponse && userResponse.id) {\n                        userIdToUse = userResponse.id;\n                        userEmail = userId; // Keep the email for fallbacks\n                        console.log(`Resolved email ${userId} to user ID: ${userIdToUse}`);\n                    }\n                }\n                catch (error) {\n                    console.log(`Failed to resolve email to ID: ${error.message || \'Unknown error\'}`);\n                    // Continue with the email as the userId\n                }\n            }\n            // Attempt 1: Try beta endpoint\n            try {\n                console.log(`Trying to get photo for user ${userIdToUse} using beta endpoint`);\n                const photoResponse = await this.client\n                    .api(`/beta/users/${userIdToUse}/photo/$value`)\n                    .responseType(ResponseType.ARRAYBUFFER)\n                    .get();\n                // Convert the array buffer to a base64 string\n                const base64 = Buffer.from(photoResponse).toString(\'base64\');\n                console.log(\'Photo obtained via beta endpoint\');\n                return `data:image/jpeg;base64,${base64}`;\n            }\n            catch (betaError) {\n                console.log(`Beta endpoint photo fetch failed: ${betaError.message || \'Unknown error\'}`);\n            }\n            // Attempt 2: Try v1.0 endpoint\n            try {\n                console.log(\'Trying standard v1.0 endpoint as fallback\');\n                const photoResponse = await this.client\n                    .api(`/users/${userIdToUse}/photo/$value`)\n                    .responseType(ResponseType.ARRAYBUFFER)\n                    .get();\n                // Convert the array buffer to a base64 string\n                const base64 = Buffer.from(photoResponse).toString(\'base64\');\n                console.log(\'Photo obtained via v1.0 endpoint\');\n                return `data:image/jpeg;base64,${base64}`;\n            }\n            catch (standardError) {\n                console.log(`Standard endpoint photo fetch failed: ${standardError.message || \'Unknown error\'}`);\n            }\n            // Attempt 3: Try direct profile photo from Exchange/Outlook\n            // This often works when Graph API fails\n            if (userId.includes(\'@\') || userEmail.includes(\'@\')) {\n                const emailToUse = userId.includes(\'@\') ? userId : userEmail;\n                try {\n                    console.log(`Trying Exchange/Outlook endpoint for ${emailToUse}`);\n                    const photoResponse = await fetch(`https://outlook.office365.com/owa/service.svc/s/GetPersonaPhoto?email=${encodeURIComponent(emailToUse)}&UA=0&size=HR64x64`);\n                    if (photoResponse.ok) {\n                        const photoBlob = await photoResponse.blob();\n                        const arrayBuffer = await photoBlob.arrayBuffer();\n                        const base64 = Buffer.from(arrayBuffer).toString(\'base64\');\n                        console.log(\'Photo obtained via Exchange/Outlook endpoint\');\n                        return `data:image/jpeg;base64,${base64}`;\n                    }\n                    else {\n                        console.log(`Exchange endpoint returned status: ${photoResponse.status}`);\n                    }\n                }\n                catch (outlookError) {\n                    console.log(`Exchange/Outlook endpoint failed: ${outlookError.message || \'Unknown error\'}`);\n                }\n            }\n            // All attempts failed\n            console.log(`No photo available for user ${userId} after trying all methods`);\n            return null;\n        }\n        catch (error) {\n            console.error(`Failed to get user photo: ${error.message || \'Unknown error\'}`);\n            return null;\n        }\n    }\n}\n\n;// ./src/shared/GraphService.ts\n// Microsoft Graph API service with progressive permissions\n\n\n// Define permission tiers for different operations\nconst PERMISSION_TIERS = {\n    BASIC: [\'User.Read\'],\n    USER_MANAGEMENT: [\'User.Read\', \'User.ReadBasic.All\'],\n    DIRECTORY_READ: [\'User.Read\', \'User.ReadBasic.All\', \'Directory.Read.All\'],\n    GROUP_MANAGEMENT: [\'User.Read\', \'User.ReadBasic.All\', \'Directory.Read.All\', \'Group.Read.All\'],\n    APPLICATION_READ: [\'User.Read\', \'User.ReadBasic.All\', \'Directory.Read.All\', \'Group.Read.All\', \'Application.Read.All\'],\n};\nclass GraphService {\n    constructor(authService) {\n        this.currentPermissions = [\'User.Read\']; // Start with basic permissions\n        this.authService = authService;\n        this.client = src.Client.init({\n            authProvider: async (done) => {\n                try {\n                    const token = await this.authService.getToken();\n                    if (token) {\n                        done(null, token.accessToken);\n                    }\n                    else {\n                        done(new Error(\'No valid token available\'), null);\n                    }\n                }\n                catch (error) {\n                    done(error, null);\n                }\n            },\n        });\n        // Initialize the profile photo service\n        this.profilePhotoService = new ProfilePhotoService(this.client);\n    }\n    async ensurePermissions(requiredPermissions) {\n        try {\n            // Check if we already have the required permissions\n            const hasAllPermissions = requiredPermissions.every(permission => this.currentPermissions.includes(permission));\n            if (hasAllPermissions) {\n                return true;\n            }\n            // Try to get token with required permissions silently first\n            const token = await this.authService.getTokenWithPermissions(requiredPermissions);\n            if (token) {\n                this.currentPermissions = [...new Set([...this.currentPermissions, ...requiredPermissions])];\n                return true;\n            }\n            // If silent request fails, request permissions interactively\n            const newToken = await this.authService.requestAdditionalPermissions(requiredPermissions);\n            if (newToken) {\n                this.currentPermissions = [...new Set([...this.currentPermissions, ...requiredPermissions])];\n                return true;\n            }\n            return false;\n        }\n        catch (error) {\n            console.error(\'Failed to ensure permissions:\', error);\n            return false;\n        }\n    }\n    async query(endpoint, method = \'GET\', data) {\n        const startTime = Date.now();\n        let response;\n        let error;\n        let status = 200;\n        try {\n            // Determine required permissions based on endpoint\n            const requiredPermissions = this.getRequiredPermissions(endpoint, method);\n            // Ensure we have the required permissions\n            const hasPermissions = await this.ensurePermissions(requiredPermissions);\n            if (!hasPermissions) {\n                throw new Error(`Insufficient permissions for ${endpoint}. Required: ${requiredPermissions.join(\', \')}`);\n            }\n            const request = this.client.api(endpoint);\n            switch (method.toUpperCase()) {\n                case \'GET\':\n                    response = await request.get();\n                    break;\n                case \'POST\':\n                    response = await request.post(data);\n                    break;\n                case \'PUT\':\n                    response = await request.put(data);\n                    break;\n                case \'PATCH\':\n                    response = await request.patch(data);\n                    break;\n                case \'DELETE\':\n                    response = await request.delete();\n                    break;\n                default:\n                    throw new Error(`Unsupported HTTP method: ${method}`);\n            }\n        }\n        catch (err) {\n            error = err.message || \'Unknown error\';\n            status = err.code || 500;\n            console.error(`Graph API call failed: ${endpoint}`, err);\n        }\n        const endTime = Date.now();\n        const duration = endTime - startTime; // Log the API call for debugging\n        const apiCall = {\n            endpoint,\n            method: method.toUpperCase(),\n            timestamp: new Date(),\n            duration,\n            status,\n            error,\n        };\n        this.logApiCall(apiCall);\n        if (error) {\n            throw new Error(error);\n        }\n        return response;\n    }\n    getRequiredPermissions(endpoint, method) {\n        // Map endpoints to required permissions\n        const endpointLower = endpoint.toLowerCase();\n        // Basic user info - minimal permissions\n        if (endpointLower.includes(\'/me\') && method === \'GET\') {\n            return PERMISSION_TIERS.BASIC;\n        }\n        // User queries - need user read permissions\n        if (endpointLower.includes(\'/users\') && method === \'GET\') {\n            return PERMISSION_TIERS.USER_MANAGEMENT;\n        }\n        // Group queries - need group read permissions\n        if (endpointLower.includes(\'/groups\') && method === \'GET\') {\n            return PERMISSION_TIERS.GROUP_MANAGEMENT;\n        }\n        // Application queries - need application read permissions\n        if (endpointLower.includes(\'/applications\') || endpointLower.includes(\'/servicePrincipals\')) {\n            return PERMISSION_TIERS.APPLICATION_READ;\n        }\n        // Directory queries - need directory read permissions\n        if (endpointLower.includes(\'/directory\') || endpointLower.includes(\'/organization\')) {\n            return PERMISSION_TIERS.DIRECTORY_READ;\n        }\n        // Default to basic permissions for unknown endpoints\n        return PERMISSION_TIERS.BASIC;\n    }\n    async getMe() {\n        return this.query(\'/me\');\n    }\n    async getUserPhoto(userId = \'me\') {\n        // Use the dedicated ProfilePhotoService for better photo retrieval\n        return this.profilePhotoService.getUserPhoto(userId);\n    }\n    async getUsers(filter) {\n        const endpoint = filter ? `/users?$filter=${encodeURIComponent(filter)}` : \'/users\';\n        return this.query(endpoint);\n    }\n    async getGroups() {\n        return this.query(\'/groups\');\n    }\n    async getApplications() {\n        return this.query(\'/applications\');\n    }\n    async getServicePrincipals() {\n        return this.query(\'/servicePrincipals\');\n    }\n    logApiCall(apiCall) {\n        // This could be enhanced to send to a logging service or store in local storage\n        console.log(\'Graph API Call:\', {\n            endpoint: apiCall.endpoint,\n            method: apiCall.method,\n            duration: `${apiCall.duration}ms`,\n            status: apiCall.status,\n            error: apiCall.error,\n        });\n        // Emit event for UI tracing\n        if (typeof window !== \'undefined\' && window.electronAPI) {\n            // Could emit to main process for UI updates\n        }\n    }\n}\n\n;// ./node_modules/axios/lib/helpers/bind.js\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n\n;// ./node_modules/axios/lib/utils.js\n\n\n\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString: utils_toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\nconst {iterator, toStringTag} = Symbol;\n\nconst kindOf = (cache => thing => {\n    const str = utils_toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest(\'undefined\');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest(\'ArrayBuffer\');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== \'undefined\') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest(\'string\');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest(\'function\');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest(\'number\');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === \'object\';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== \'object\') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest(\'Date\');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest(\'File\');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest(\'Blob\');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest(\'FileList\');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === \'function\' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === \'formdata\' ||\n        // detect form-data instance\n        (kind === \'object\' && isFunction(thing.toString) && thing.toString() === \'[object FormData]\')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest(\'URLSearchParams\');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = [\'ReadableStream\', \'Request\', \'Response\', \'Headers\'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \'\');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If \'obj\' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don\'t bother if no value provided\n  if (obj === null || typeof obj === \'undefined\') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== \'object\') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== "undefined") return globalThis;\n  return typeof self !== "undefined" ? self : (typeof window !== \'undefined\' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, \'super\', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== \'undefined\' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[iterator];\n\n  const _iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = _iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest(\'HTMLFormElement\');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest(\'RegExp\');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && [\'arguments\', \'caller\', \'callee\'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if (\'writable\' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error(\'Can not rewrite read-only method \\\'\' + name + \'\\\'\');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[toStringTag] === \'FormData\' && thing[iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!(\'toJSON\' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest(\'AsyncFunction\');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener("message", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, "*");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === \'function\',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== \'undefined\' ?\n  queueMicrotask.bind(_global) : ( typeof process !== \'undefined\' && process.nextTick || _setImmediate);\n\n// *********************\n\n\nconst isIterable = (thing) => thing != null && isFunction(thing[iterator]);\n\n\n/* harmony default export */ const utils = ({\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty: utils_hasOwnProperty,\n  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap,\n  isIterable\n});\n\n;// ./node_modules/axios/lib/core/AxiosError.js\n\n\n\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, \'ECONNABORTED\').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = \'AxiosError\';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst AxiosError_prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  \'ERR_BAD_OPTION_VALUE\',\n  \'ERR_BAD_OPTION\',\n  \'ECONNABORTED\',\n  \'ETIMEDOUT\',\n  \'ERR_NETWORK\',\n  \'ERR_FR_TOO_MANY_REDIRECTS\',\n  \'ERR_DEPRECATED\',\n  \'ERR_BAD_RESPONSE\',\n  \'ERR_BAD_REQUEST\',\n  \'ERR_CANCELED\',\n  \'ERR_NOT_SUPPORT\',\n  \'ERR_INVALID_URL\'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(AxiosError_prototype, \'isAxiosError\', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(AxiosError_prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== \'isAxiosError\';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n/* harmony default export */ const core_AxiosError = (AxiosError);\n\n// EXTERNAL MODULE: ./node_modules/form-data/lib/form_data.js\nvar form_data = __webpack_require__(737);\n;// ./node_modules/axios/lib/platform/node/classes/FormData.js\n\n\n/* harmony default export */ const classes_FormData = (form_data);\n\n;// ./node_modules/axios/lib/helpers/toFormData.js\n\n\n\n\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\n\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, \'[]\') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? \'[\' + token + \']\' : token;\n  }).join(dots ? \'.\' : \'\');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it\'s a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError(\'target must be an object\');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (classes_FormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== \'undefined\' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError(\'visitor must be a function\');\n  }\n\n  function convertValue(value) {\n    if (value === null) return \'\';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new core_AxiosError(\'Blob is not supported. Use a Buffer instead.\');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === \'function\' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === \'object\') {\n      if (utils.endsWith(key, \'{}\')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        ((utils.isFileList(value) || utils.endsWith(key, \'[]\')) && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + \'[]\'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error(\'Circular reference detected in \' + path.join(\'.\'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError(\'data must be an object\');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/* harmony default export */ const helpers_toFormData = (toFormData);\n\n;// ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js\n\n\n\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    \'!\': \'%21\',\n    "\'": \'%27\',\n    \'(\': \'%28\',\n    \')\': \'%29\',\n    \'~\': \'%7E\',\n    \'%20\': \'+\',\n    \'%00\': \'\\x00\'\n  };\n  return encodeURIComponent(str).replace(/[!\'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && helpers_toFormData(params, this, options);\n}\n\nconst AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;\n\nAxiosURLSearchParams_prototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nAxiosURLSearchParams_prototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + \'=\' + _encode(pair[1]);\n  }, \'\').join(\'&\');\n};\n\n/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);\n\n;// ./node_modules/axios/lib/helpers/buildURL.js\n\n\n\n\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction buildURL_encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, \':\').\n    replace(/%24/g, \'$\').\n    replace(/%2C/gi, \',\').\n    replace(/%20/g, \'+\').\n    replace(/%5B/gi, \'[\').\n    replace(/%5D/gi, \']\');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || buildURL_encode;\n\n  if (utils.isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new helpers_AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf("#");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf(\'?\') === -1 ? \'?\' : \'&\') + serializedParams;\n  }\n\n  return url;\n}\n\n;// ./node_modules/axios/lib/core/InterceptorManager.js\n\n\n\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\n/* harmony default export */ const core_InterceptorManager = (InterceptorManager);\n\n;// ./node_modules/axios/lib/defaults/transitional.js\n\n\n/* harmony default export */ const defaults_transitional = ({\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n});\n\n// EXTERNAL MODULE: external "url"\nvar external_url_ = __webpack_require__(7016);\n;// ./node_modules/axios/lib/platform/node/classes/URLSearchParams.js\n\n\n\n/* harmony default export */ const classes_URLSearchParams = (external_url_.URLSearchParams);\n\n;// ./node_modules/axios/lib/platform/node/index.js\n\n\n\n\nconst ALPHA = \'abcdefghijklmnopqrstuvwxyz\'\n\nconst DIGIT = \'0123456789\';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n}\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = \'\';\n  const {length} = alphabet;\n  const randomValues = new Uint32Array(size);\n  external_crypto_.randomFillSync(randomValues);\n  for (let i = 0; i < size; i++) {\n    str += alphabet[randomValues[i] % length];\n  }\n\n  return str;\n}\n\n\n/* harmony default export */ const node = ({\n  isNode: true,\n  classes: {\n    URLSearchParams: classes_URLSearchParams,\n    FormData: classes_FormData,\n    Blob: typeof Blob !== \'undefined\' && Blob || null\n  },\n  ALPHABET,\n  generateString,\n  protocols: [ \'http\', \'https\', \'file\', \'data\' ]\n});\n\n;// ./node_modules/axios/lib/platform/common/utils.js\nconst hasBrowserEnv = typeof window !== \'undefined\' && typeof document !== \'undefined\';\n\nconst _navigator = typeof navigator === \'object\' && navigator || undefined;\n\n/**\n * Determine if we\'re running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> \'ReactNative\'\n * nativescript\n *  navigator.product -> \'NativeScript\' or \'NS\'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || [\'ReactNative\', \'NativeScript\', \'NS\'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we\'re running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== \'undefined\' && typeof document !== \'undefined\'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== \'undefined\' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === \'function\'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || \'http://localhost\';\n\n\n\n;// ./node_modules/axios/lib/platform/index.js\n\n\n\n/* harmony default export */ const platform = ({\n  ...common_utils_namespaceObject,\n  ...node\n});\n\n;// ./node_modules/axios/lib/helpers/toURLEncodedForm.js\n\n\n\n\n\n\nfunction toURLEncodedForm(data, options) {\n  return helpers_toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString(\'base64\'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n\n;// ./node_modules/axios/lib/helpers/formDataToJSON.js\n\n\n\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `[\'foo\', \'x\', \'y\', \'z\']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === \'[]\' ? \'\' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === \'__proto__\') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);\n\n;// ./node_modules/axios/lib/defaults/index.js\n\n\n\n\n\n\n\n\n\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== \'SyntaxError\') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: defaults_transitional,\n\n  adapter: [\'xhr\', \'http\', \'fetch\'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || \'\';\n    const hasJSONContentType = contentType.indexOf(\'application/json\') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data) ||\n      utils.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType(\'application/x-www-form-urlencoded;charset=utf-8\', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf(\'application/x-www-form-urlencoded\') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf(\'multipart/form-data\') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return helpers_toFormData(\n          isFileList ? {\'files[]\': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType(\'application/json\', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === \'json\';\n\n    if (utils.isResponse(data) || utils.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === \'SyntaxError\') {\n            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: \'XSRF-TOKEN\',\n  xsrfHeaderName: \'X-XSRF-TOKEN\',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      \'Accept\': \'application/json, text/plain, */*\',\n      \'Content-Type\': undefined\n    }\n  }\n};\n\nutils.forEach([\'delete\', \'get\', \'head\', \'post\', \'put\', \'patch\'], (method) => {\n  defaults.headers[method] = {};\n});\n\n/* harmony default export */ const lib_defaults = (defaults);\n\n;// ./node_modules/axios/lib/helpers/parseHeaders.js\n\n\n\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  \'age\', \'authorization\', \'content-length\', \'content-type\', \'etag\',\n  \'expires\', \'from\', \'host\', \'if-modified-since\', \'if-unmodified-since\',\n  \'last-modified\', \'location\', \'max-forwards\', \'proxy-authorization\',\n  \'referer\', \'retry-after\', \'user-agent\'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\n/* harmony default export */ const parseHeaders = (rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split(\'\\n\').forEach(function parser(line) {\n    i = line.indexOf(\':\');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === \'set-cookie\') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + \', \' + val : val;\n    }\n  });\n\n  return parsed;\n});\n\n;// ./node_modules/axios/lib/core/AxiosHeaders.js\n\n\n\n\n\nconst $internals = Symbol(\'internals\');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&\'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(\' \' + header);\n\n  [\'get\', \'set\', \'has\'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error(\'header name must be a non-empty string\');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils.isObject(header) && utils.isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!utils.isArray(entry)) {\n          throw TypeError(\'Object iterator must return a key-value pair\');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite)\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError(\'parser must be boolean|regexp|function\');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(\', \') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + \': \' + value).join(\'\\n\');\n  }\n\n  getSetCookie() {\n    return this.get("set-cookie") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return \'AxiosHeaders\';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor([\'Content-Type\', \'Content-Length\', \'Accept\', \'Accept-Encoding\', \'User-Agent\', \'Authorization\']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\n/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);\n\n;// ./node_modules/axios/lib/core/transformData.js\n\n\n\n\n\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || lib_defaults;\n  const context = response || config;\n  const headers = core_AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n\n;// ./node_modules/axios/lib/cancel/isCancel.js\n\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\n;// ./node_modules/axios/lib/cancel/CanceledError.js\n\n\n\n\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  core_AxiosError.call(this, message == null ? \'canceled\' : message, core_AxiosError.ERR_CANCELED, config, request);\n  this.name = \'CanceledError\';\n}\n\nutils.inherits(CanceledError, core_AxiosError, {\n  __CANCEL__: true\n});\n\n/* harmony default export */ const cancel_CanceledError = (CanceledError);\n\n;// ./node_modules/axios/lib/core/settle.js\n\n\n\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new core_AxiosError(\n      \'Request failed with status code \' + response.status,\n      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n\n;// ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\n;// ./node_modules/axios/lib/helpers/combineURLs.js\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, \'\') + \'/\' + relativeURL.replace(/^\\/+/, \'\')\n    : baseURL;\n}\n\n;// ./node_modules/axios/lib/core/buildFullPath.js\n\n\n\n\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {\n  let isRelativeUrl = !isAbsoluteURL(requestedURL);\n  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\n// EXTERNAL MODULE: ./node_modules/proxy-from-env/index.js\nvar proxy_from_env = __webpack_require__(6504);\n// EXTERNAL MODULE: external "util"\nvar external_util_ = __webpack_require__(9023);\n// EXTERNAL MODULE: ./node_modules/follow-redirects/index.js\nvar follow_redirects = __webpack_require__(3164);\n;// external "zlib"\nconst external_zlib_namespaceObject = require("zlib");\n;// ./node_modules/axios/lib/env/data.js\nconst VERSION = "1.9.0";\n;// ./node_modules/axios/lib/helpers/parseProtocol.js\n\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || \'\';\n}\n\n;// ./node_modules/axios/lib/helpers/fromDataURI.js\n\n\n\n\n\n\nconst DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\\s\\S]*)$/;\n\n/**\n * Parse data uri to a Buffer or Blob\n *\n * @param {String} uri\n * @param {?Boolean} asBlob\n * @param {?Object} options\n * @param {?Function} options.Blob\n *\n * @returns {Buffer|Blob}\n */\nfunction fromDataURI(uri, asBlob, options) {\n  const _Blob = options && options.Blob || platform.classes.Blob;\n  const protocol = parseProtocol(uri);\n\n  if (asBlob === undefined && _Blob) {\n    asBlob = true;\n  }\n\n  if (protocol === \'data\') {\n    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;\n\n    const match = DATA_URL_PATTERN.exec(uri);\n\n    if (!match) {\n      throw new core_AxiosError(\'Invalid URL\', core_AxiosError.ERR_INVALID_URL);\n    }\n\n    const mime = match[1];\n    const isBase64 = match[2];\n    const body = match[3];\n    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? \'base64\' : \'utf8\');\n\n    if (asBlob) {\n      if (!_Blob) {\n        throw new core_AxiosError(\'Blob is not supported\', core_AxiosError.ERR_NOT_SUPPORT);\n      }\n\n      return new _Blob([buffer], {type: mime});\n    }\n\n    return buffer;\n  }\n\n  throw new core_AxiosError(\'Unsupported protocol \' + protocol, core_AxiosError.ERR_NOT_SUPPORT);\n}\n\n// EXTERNAL MODULE: external "stream"\nvar external_stream_ = __webpack_require__(2203);\n;// ./node_modules/axios/lib/helpers/AxiosTransformStream.js\n\n\n\n\n\nconst kInternals = Symbol(\'internals\');\n\nclass AxiosTransformStream extends external_stream_.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    this.on(\'newListener\', event => {\n      if (event === \'progress\') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      internals.isCaptured && this.emit(\'progress\', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n}\n\n/* harmony default export */ const helpers_AxiosTransformStream = (AxiosTransformStream);\n\n;// external "events"\nconst external_events_namespaceObject = require("events");\n;// ./node_modules/axios/lib/helpers/readBlob.js\nconst {asyncIterator} = Symbol;\n\nconst readBlob = async function* (blob) {\n  if (blob.stream) {\n    yield* blob.stream()\n  } else if (blob.arrayBuffer) {\n    yield await blob.arrayBuffer()\n  } else if (blob[asyncIterator]) {\n    yield* blob[asyncIterator]();\n  } else {\n    yield blob;\n  }\n}\n\n/* harmony default export */ const helpers_readBlob = (readBlob);\n\n;// ./node_modules/axios/lib/helpers/formDataToStream.js\n\n\n\n\n\n\nconst BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + \'-_\';\n\nconst textEncoder = typeof TextEncoder === \'function\' ? new TextEncoder() : new external_util_.TextEncoder();\n\nconst CRLF = \'\\r\\n\';\nconst CRLF_BYTES = textEncoder.encode(CRLF);\nconst CRLF_BYTES_COUNT = 2;\n\nclass FormDataPart {\n  constructor(name, value) {\n    const {escapeName} = this.constructor;\n    const isStringValue = utils.isString(value);\n\n    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${\n      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : \'\'\n    }${CRLF}`;\n\n    if (isStringValue) {\n      value = textEncoder.encode(String(value).replace(/\\r?\\n|\\r\\n?/g, CRLF));\n    } else {\n      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`\n    }\n\n    this.headers = textEncoder.encode(headers + CRLF);\n\n    this.contentLength = isStringValue ? value.byteLength : value.size;\n\n    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;\n\n    this.name = name;\n    this.value = value;\n  }\n\n  async *encode(){\n    yield this.headers;\n\n    const {value} = this;\n\n    if(utils.isTypedArray(value)) {\n      yield value;\n    } else {\n      yield* helpers_readBlob(value);\n    }\n\n    yield CRLF_BYTES;\n  }\n\n  static escapeName(name) {\n      return String(name).replace(/[\\r\\n"]/g, (match) => ({\n        \'\\r\' : \'%0D\',\n        \'\\n\' : \'%0A\',\n        \'"\' : \'%22\',\n      }[match]));\n  }\n}\n\nconst formDataToStream = (form, headersHandler, options) => {\n  const {\n    tag = \'form-data-boundary\',\n    size = 25,\n    boundary = tag + \'-\' + platform.generateString(size, BOUNDARY_ALPHABET)\n  } = options || {};\n\n  if(!utils.isFormData(form)) {\n    throw TypeError(\'FormData instance required\');\n  }\n\n  if (boundary.length < 1 || boundary.length > 70) {\n    throw Error(\'boundary must be 10-70 characters long\')\n  }\n\n  const boundaryBytes = textEncoder.encode(\'--\' + boundary + CRLF);\n  const footerBytes = textEncoder.encode(\'--\' + boundary + \'--\' + CRLF);\n  let contentLength = footerBytes.byteLength;\n\n  const parts = Array.from(form.entries()).map(([name, value]) => {\n    const part = new FormDataPart(name, value);\n    contentLength += part.size;\n    return part;\n  });\n\n  contentLength += boundaryBytes.byteLength * parts.length;\n\n  contentLength = utils.toFiniteNumber(contentLength);\n\n  const computedHeaders = {\n    \'Content-Type\': `multipart/form-data; boundary=${boundary}`\n  }\n\n  if (Number.isFinite(contentLength)) {\n    computedHeaders[\'Content-Length\'] = contentLength;\n  }\n\n  headersHandler && headersHandler(computedHeaders);\n\n  return external_stream_.Readable.from((async function *() {\n    for(const part of parts) {\n      yield boundaryBytes;\n      yield* part.encode();\n    }\n\n    yield footerBytes;\n  })());\n};\n\n/* harmony default export */ const helpers_formDataToStream = (formDataToStream);\n\n;// ./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js\n\n\n\n\nclass ZlibHeaderTransformStream extends external_stream_.Transform {\n  __transform(chunk, encoding, callback) {\n    this.push(chunk);\n    callback();\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (chunk.length !== 0) {\n      this._transform = this.__transform;\n\n      // Add Default Compression headers if no zlib headers are present\n      if (chunk[0] !== 120) { // Hex: 78\n        const header = Buffer.alloc(2);\n        header[0] = 120; // Hex: 78\n        header[1] = 156; // Hex: 9C \n        this.push(header, encoding);\n      }\n    }\n\n    this.__transform(chunk, encoding, callback);\n  }\n}\n\n/* harmony default export */ const helpers_ZlibHeaderTransformStream = (ZlibHeaderTransformStream);\n\n;// ./node_modules/axios/lib/helpers/callbackify.js\n\n\nconst callbackify = (fn, reducer) => {\n  return utils.isAsyncFn(fn) ? function (...args) {\n    const cb = args.pop();\n    fn.apply(this, args).then((value) => {\n      try {\n        reducer ? cb(null, ...reducer(value)) : cb(null, value);\n      } catch (err) {\n        cb(err);\n      }\n    }, cb);\n  } : fn;\n}\n\n/* harmony default export */ const helpers_callbackify = (callbackify);\n\n;// ./node_modules/axios/lib/helpers/speedometer.js\n\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/* harmony default export */ const helpers_speedometer = (speedometer);\n\n;// ./node_modules/axios/lib/helpers/throttle.js\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn.apply(null, args);\n  }\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs)\n        }, threshold - passed);\n      }\n    }\n  }\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\n/* harmony default export */ const helpers_throttle = (throttle);\n\n;// ./node_modules/axios/lib/helpers/progressEventReducer.js\n\n\n\n\nconst progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = helpers_speedometer(50, 250);\n\n  return helpers_throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? \'download\' : \'upload\']: true\n    };\n\n    listener(data);\n  }, freq);\n}\n\nconst progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n}\n\nconst asyncDecorator = (fn) => (...args) => utils.asap(() => fn(...args));\n\n;// ./node_modules/axios/lib/adapters/http.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst zlibOptions = {\n  flush: external_zlib_namespaceObject.constants.Z_SYNC_FLUSH,\n  finishFlush: external_zlib_namespaceObject.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: external_zlib_namespaceObject.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: external_zlib_namespaceObject.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(external_zlib_namespaceObject.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = follow_redirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + \':\';\n});\n\nconst flushOnFinish = (stream, [throttled, flush]) => {\n  stream\n    .on(\'end\', flush)\n    .on(\'error\', flush);\n\n  return throttled;\n}\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options, responseDetails);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxy_from_env.getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || \'\') + \':\' + (proxy.password || \'\');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || \'\') + \':\' + (proxy.auth.password || \'\');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, \'utf8\')\n        .toString(\'base64\');\n      options.headers[\'Proxy-Authorization\'] = \'Basic \' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? \':\' + options.port : \'\');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace \'host\' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(\':\') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== \'undefined\' && utils.kindOf(process) === \'process\';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\nconst resolveFamily = ({address, family}) => {\n  if (!utils.isString(address)) {\n    throw TypeError(\'address must be a string\');\n  }\n  return ({\n    address,\n    family: family || (address.indexOf(\'.\') < 0 ? 6 : 4)\n  });\n}\n\nconst buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});\n\n/*eslint consistent-return:0*/\n/* harmony default export */ const http = (isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data, lookup, family} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup) {\n      const _lookup = helpers_callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);\n      // hotfix to support opt.all option which is required for node 20.x\n      lookup = (hostname, opt, cb) => {\n        _lookup(hostname, opt, (err, arg0, arg1) => {\n          if (err) {\n            return cb(err);\n          }\n\n          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];\n\n          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n        });\n      }\n    }\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new external_events_namespaceObject.EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener(\'abort\', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    onDone((value, isRejected) => {\n      isDone = true;\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit(\'abort\', !reason || reason.type ? new cancel_CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once(\'abort\', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener(\'abort\', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === \'data:\') {\n      let convertedData;\n\n      if (method !== \'GET\') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: \'method not allowed\',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === \'blob\', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw core_AxiosError.from(err, core_AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === \'text\') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === \'utf8\') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === \'stream\') {\n        convertedData = external_stream_.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: \'OK\',\n        headers: new core_AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new core_AxiosError(\n        \'Unsupported protocol \' + protocol,\n        core_AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = core_AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn\'t been set in config\n    headers.set(\'User-Agent\', \'axios/\' + VERSION, false);\n\n    const {onUploadProgress, onDownloadProgress} = config;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = helpers_formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await external_util_.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data) || utils.isFile(data)) {\n      data.size && headers.setContentType(data.type || \'application/octet-stream\');\n      headers.setContentLength(data.size || 0);\n      data = external_stream_.Readable.from(helpers_readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, \'utf-8\');\n      } else {\n        return reject(new core_AxiosError(\n          \'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream\',\n          core_AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new core_AxiosError(\n          \'Request body larger than maxBodyLength limit\',\n          core_AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = external_stream_.Readable.from(data, {objectMode: false});\n      }\n\n      data = external_stream_.pipeline([data, new helpers_AxiosTransformStream({\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on(\'progress\', flushOnFinish(\n        data,\n        progressEventDecorator(\n          contentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)\n        )\n      ));\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || \'\';\n      const password = config.auth.password || \'\';\n      auth = username + \':\' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + \':\' + urlPassword;\n    }\n\n    auth && headers.delete(\'authorization\');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, \'\');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      \'Accept-Encoding\',\n      \'gzip, compress, deflate\' + (isBrotliSupported ? \', br\' : \'\'), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      family,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    // cacheable-lookup integration hotfix\n    !utils.isUndefined(lookup) && (options.lookup = lookup);\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + \'//\' + parsed.hostname + (parsed.port ? \':\' + parsed.port : \'\') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? external_https_ : external_http_;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n\n      const streams = [res];\n\n      const responseLength = +res.headers[\'content-length\'];\n\n      if (onDownloadProgress || maxDownloadRate) {\n        const transformStream = new helpers_AxiosTransformStream({\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n\n        onDownloadProgress && transformStream.on(\'progress\', flushOnFinish(\n          transformStream,\n          progressEventDecorator(\n            responseLength,\n            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)\n          )\n        ));\n\n        streams.push(transformStream);\n      }\n\n      // decompress the response body transparently if required\n      let responseStream = res;\n\n      // return the last request in case of redirects\n      const lastRequest = res.req || req;\n\n      // if decompress disabled we should not decompress\n      if (config.decompress !== false && res.headers[\'content-encoding\']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === \'HEAD\' || res.statusCode === 204) {\n          delete res.headers[\'content-encoding\'];\n        }\n\n        switch ((res.headers[\'content-encoding\'] || \'\').toLowerCase()) {\n        /*eslint default-case:0*/\n        case \'gzip\':\n        case \'x-gzip\':\n        case \'compress\':\n        case \'x-compress\':\n          // add the unzipper to the body stream processing pipeline\n          streams.push(external_zlib_namespaceObject.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers[\'content-encoding\'];\n          break;\n        case \'deflate\':\n          streams.push(new helpers_ZlibHeaderTransformStream());\n\n          // add the unzipper to the body stream processing pipeline\n          streams.push(external_zlib_namespaceObject.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers[\'content-encoding\'];\n          break;\n        case \'br\':\n          if (isBrotliSupported) {\n            streams.push(external_zlib_namespaceObject.createBrotliDecompress(brotliOptions));\n            delete res.headers[\'content-encoding\'];\n          }\n        }\n      }\n\n      responseStream = streams.length > 1 ? external_stream_.pipeline(streams, utils.noop) : streams[0];\n\n      const offListeners = external_stream_.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new core_AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === \'stream\') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n\n        responseStream.on(\'data\', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new core_AxiosError(\'maxContentLength size of \' + config.maxContentLength + \' exceeded\',\n              core_AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        responseStream.on(\'aborted\', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new core_AxiosError(\n            \'stream has been aborted\',\n            core_AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          );\n          responseStream.destroy(err);\n          reject(err);\n        });\n\n        responseStream.on(\'error\', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(core_AxiosError.from(err, null, config, lastRequest));\n        });\n\n        responseStream.on(\'end\', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (responseType !== \'arraybuffer\') {\n              responseData = responseData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === \'utf8\') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            return reject(core_AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once(\'abort\', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit(\'error\', err);\n          responseStream.destroy();\n        }\n      });\n    });\n\n    emitter.once(\'abort\', err => {\n      reject(err);\n      req.destroy(err);\n    });\n\n    // Handle errors\n    req.on(\'error\', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(core_AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on(\'socket\', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn\'t handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (Number.isNaN(timeout)) {\n        reject(new core_AxiosError(\n          \'error trying to parse `config.timeout` to int\',\n          core_AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? \'timeout of \' + config.timeout + \'ms exceeded\' : \'timeout exceeded\';\n        const transitional = config.transitional || defaults_transitional;\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n        reject(new core_AxiosError(\n          timeoutErrorMessage,\n          transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n        abort();\n      });\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n\n      data.on(\'end\', () => {\n        ended = true;\n      });\n\n      data.once(\'error\', err => {\n        errored = true;\n        req.destroy(err);\n      });\n\n      data.on(\'close\', () => {\n        if (!ended && !errored) {\n          abort(new cancel_CanceledError(\'Request stream has been aborted\', config, req));\n        }\n      });\n\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n});\n\nconst __setProxy = (/* unused pure expression or super */ null && (setProxy));\n\n;// ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n\n\n/* harmony default export */ const isURLSameOrigin = (platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, platform.origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(platform.origin),\n  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)\n) : () => true);\n\n;// ./node_modules/axios/lib/helpers/cookies.js\n\n\n\n/* harmony default export */ const cookies = (platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + \'=\' + encodeURIComponent(value)];\n\n      utils.isNumber(expires) && cookie.push(\'expires=\' + new Date(expires).toGMTString());\n\n      utils.isString(path) && cookie.push(\'path=\' + path);\n\n      utils.isString(domain) && cookie.push(\'domain=\' + domain);\n\n      secure === true && cookie.push(\'secure\');\n\n      document.cookie = cookie.join(\'; \');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp(\'(^|;\\\\s*)(\' + name + \')=([^;]*)\'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, \'\', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  });\n\n\n;// ./node_modules/axios/lib/core/mergeConfig.js\n\n\n\n\n\nconst headersToObject = (thing) => thing instanceof core_AxiosHeaders ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n\n;// ./node_modules/axios/lib/helpers/resolveConfig.js\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const resolveConfig = ((config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;\n\n  newConfig.headers = headers = core_AxiosHeaders.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set(\'Authorization\', \'Basic \' +\n      btoa((auth.username || \'\') + \':\' + (auth.password ? unescape(encodeURIComponent(auth.password)) : \'\'))\n    );\n  }\n\n  let contentType;\n\n  if (utils.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // Let the browser set it\n    } else if ((contentType = headers.getContentType()) !== false) {\n      // fix semicolon duplication issue for ReactNative FormData implementation\n      const [type, ...tokens] = contentType ? contentType.split(\';\').map(token => token.trim()).filter(Boolean) : [];\n      headers.setContentType([type || \'multipart/form-data\', ...tokens].join(\'; \'));\n    }\n  }\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we\'re in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n});\n\n\n;// ./node_modules/axios/lib/adapters/xhr.js\n\n\n\n\n\n\n\n\n\n\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== \'undefined\';\n\n/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = core_AxiosHeaders.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener(\'abort\', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = core_AxiosHeaders.from(\n        \'getAllResponseHeaders\' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === \'text\' || responseType === \'json\' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if (\'onloadend\' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn\'t get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it\'s a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf(\'file:\') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next \'tick\'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new core_AxiosError(\'Request aborted\', core_AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it\'s a network error\n      reject(new core_AxiosError(\'Network Error\', core_AxiosError.ERR_NETWORK, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? \'timeout of \' + _config.timeout + \'ms exceeded\' : \'timeout exceeded\';\n      const transitional = _config.transitional || defaults_transitional;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new core_AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if (\'setRequestHeader\' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== \'json\') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener(\'progress\', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener(\'progress\', uploadThrottled);\n\n      request.upload.addEventListener(\'loadend\', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener(\'abort\', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new core_AxiosError(\'Unsupported protocol \' + protocol + \':\', core_AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n});\n\n;// ./node_modules/axios/lib/helpers/composeSignals.js\n\n\n\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof core_AxiosError ? err : new cancel_CanceledError(err instanceof Error ? err.message : err));\n      }\n    }\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new core_AxiosError(`timeout ${timeout} of ms exceeded`, core_AxiosError.ETIMEDOUT))\n    }, timeout)\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener(\'abort\', onabort);\n        });\n        signals = null;\n      }\n    }\n\n    signals.forEach((signal) => signal.addEventListener(\'abort\', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => utils.asap(unsubscribe);\n\n    return signal;\n  }\n}\n\n/* harmony default export */ const helpers_composeSignals = (composeSignals);\n\n;// ./node_modules/axios/lib/helpers/trackStream.js\n\nconst streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nconst readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nconst trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n\n;// ./node_modules/axios/lib/adapters/fetch.js\n\n\n\n\n\n\n\n\n\n\nconst isFetchSupported = typeof fetch === \'function\' && typeof Request === \'function\' && typeof Response === \'function\';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === \'function\';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === \'function\' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst supportsRequestStream = isReadableStreamSupported && test(() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: \'POST\',\n    get duplex() {\n      duplexAccessed = true;\n      return \'half\';\n    },\n  }).headers.has(\'Content-Type\');\n\n  return duplexAccessed && !hasContentType;\n});\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported &&\n  test(() => utils.isReadableStream(new Response(\'\').body));\n\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  [\'text\', \'arrayBuffer\', \'blob\', \'formData\', \'stream\'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new core_AxiosError(`Response type \'${type}\' is not supported`, core_AxiosError.ERR_NOT_SUPPORT, config);\n      })\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils.isSpecCompliantForm(body)) {\n    const _request = new Request(platform.origin, {\n      method: \'POST\',\n      body,\n    });\n    return (await _request.arrayBuffer()).byteLength;\n  }\n\n  if(utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n    return body.byteLength;\n  }\n\n  if(utils.isURLSearchParams(body)) {\n    body = body + \'\';\n  }\n\n  if(utils.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n}\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n}\n\n/* harmony default export */ const adapters_fetch = (isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = \'same-origin\',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + \'\').toLowerCase() : \'text\';\n\n  let composedSignal = helpers_composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n  let request;\n\n  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n  });\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== \'get\' && method !== \'head\' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: \'POST\',\n        body: data,\n        duplex: "half"\n      });\n\n      let contentTypeHeader;\n\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get(\'content-type\'))) {\n        headers.setContentType(contentTypeHeader)\n      }\n\n      if (_request.body) {\n        const [onProgress, flush] = progressEventDecorator(\n          requestContentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress))\n        );\n\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n      }\n    }\n\n    if (!utils.isString(withCredentials)) {\n      withCredentials = withCredentials ? \'include\' : \'omit\';\n    }\n\n    // Cloudflare Workers throws when credentials are defined\n    // see https://github.com/cloudflare/workerd/issues/902\n    const isCredentialsSupported = "credentials" in Request.prototype;\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: "half",\n      credentials: isCredentialsSupported ? withCredentials : undefined\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === \'stream\' || responseType === \'response\');\n\n    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n      const options = {};\n\n      [\'status\', \'statusText\', \'headers\'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils.toFiniteNumber(response.headers.get(\'content-length\'));\n\n      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n        responseContentLength,\n        progressEventReducer(asyncDecorator(onDownloadProgress), true)\n      ) || [];\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }),\n        options\n      );\n    }\n\n    responseType = responseType || \'text\';\n\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || \'text\'](response, config);\n\n    !isStreamResponse && unsubscribe && unsubscribe();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: core_AxiosHeaders.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      })\n    })\n  } catch (err) {\n    unsubscribe && unsubscribe();\n\n    if (err && err.name === \'TypeError\' && /Load failed|fetch/i.test(err.message)) {\n      throw Object.assign(\n        new core_AxiosError(\'Network Error\', core_AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw core_AxiosError.from(err, err && err.code, config, request);\n  }\n}));\n\n\n\n;// ./node_modules/axios/lib/adapters/adapters.js\n\n\n\n\n\n\nconst knownAdapters = {\n  http: http,\n  xhr: xhr,\n  fetch: adapters_fetch\n}\n\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, \'name\', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, \'adapterName\', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\n\n/* harmony default export */ const adapters = ({\n  getAdapter: (adapters) => {\n    adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new core_AxiosError(`Unknown adapter \'${id}\'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || \'#\' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? \'is not supported by the environment\' : \'is not available in the build\')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? \'since :\\n\' + reasons.map(renderReason).join(\'\\n\') : \' \' + renderReason(reasons[0])) :\n        \'as no adapter specified\';\n\n      throw new core_AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        \'ERR_NOT_SUPPORT\'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n});\n\n;// ./node_modules/axios/lib/core/dispatchRequest.js\n\n\n\n\n\n\n\n\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new cancel_CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = core_AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if ([\'post\', \'put\', \'patch\'].indexOf(config.method) !== -1) {\n    config.headers.setContentType(\'application/x-www-form-urlencoded\', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = core_AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n\n;// ./node_modules/axios/lib/helpers/validator.js\n\n\n\n\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n[\'object\', \'boolean\', \'number\', \'function\', \'string\', \'symbol\'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || \'a\' + (i < 1 ? \'n \' : \' \') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return \'[Axios v\' + VERSION + \'] Transitional option \\\'\' + opt + \'\\\'\' + desc + (message ? \'. \' + message : \'\');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new core_AxiosError(\n        formatMessage(opt, \' has been removed\' + (version ? \' in \' + version : \'\')),\n        core_AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          \' has been deprecated since v\' + version + \' and will be removed in the near future\'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object\'s properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== \'object\') {\n    throw new core_AxiosError(\'options must be an object\', core_AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new core_AxiosError(\'option \' + opt + \' must be \' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new core_AxiosError(\'Unknown option \' + opt, core_AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\n/* harmony default export */ const validator = ({\n  assertOptions,\n  validators\n});\n\n;// ./node_modules/axios/lib/core/Axios.js\n\n\n\n\n\n\n\n\n\n\n\nconst Axios_validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig || {};\n    this.interceptors = {\n      request: new core_InterceptorManager(),\n      response: new core_InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, \'\') : \'\';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, \'\'))) {\n            err.stack += \'\\n\' + stack\n          }\n        } catch (e) {\n          // ignore the case where "stack" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios(\'example/url\'[, config]) a la fetch API\n    if (typeof configOrUrl === \'string\') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),\n        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: Axios_validators.function,\n          serialize: Axios_validators.function\n        }, true);\n      }\n    }\n\n    // Set config.allowAbsoluteUrls\n    if (config.allowAbsoluteUrls !== undefined) {\n      // do nothing\n    } else if (this.defaults.allowAbsoluteUrls !== undefined) {\n      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;\n    } else {\n      config.allowAbsoluteUrls = true;\n    }\n\n    validator.assertOptions(config, {\n      baseUrl: Axios_validators.spelling(\'baseURL\'),\n      withXsrfToken: Axios_validators.spelling(\'withXSRFToken\')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || \'get\').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils.forEach(\n      [\'delete\', \'get\', \'head\', \'post\', \'put\', \'patch\', \'common\'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === \'function\' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach([\'delete\', \'get\', \'head\', \'options\'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach([\'post\', \'put\', \'patch\'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          \'Content-Type\': \'multipart/form-data\'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + \'Form\'] = generateHTTPMethod(true);\n});\n\n/* harmony default export */ const core_Axios = (Axios);\n\n;// ./node_modules/axios/lib/cancel/CancelToken.js\n\n\n\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== \'function\') {\n      throw new TypeError(\'executor must be a function.\');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new cancel_CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\n/* harmony default export */ const cancel_CancelToken = (CancelToken);\n\n;// ./node_modules/axios/lib/helpers/spread.js\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n\n;// ./node_modules/axios/lib/helpers/isAxiosError.js\n\n\n\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n\n;// ./node_modules/axios/lib/helpers/HttpStatusCode.js\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\n/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);\n\n;// ./node_modules/axios/lib/axios.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new core_Axios(defaultConfig);\n  const instance = bind(core_Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(lib_defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = core_Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = cancel_CanceledError;\naxios.CancelToken = cancel_CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = helpers_toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = core_AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = core_AxiosHeaders;\n\naxios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = helpers_HttpStatusCode;\n\naxios.default = axios;\n\n// this module should only have a default export\n/* harmony default export */ const lib_axios = (axios);\n\n;// ./src/llm/LLMService.ts\n// Local LLM service for Ollama/LM Studio integration\n\nclass LLMService {\n    constructor(config) {\n        this.config = config;\n    }\n    async chat(messages) {\n        try {\n            if (this.config.provider === \'ollama\') {\n                return this.chatWithOllama(messages);\n            }\n            else if (this.config.provider === \'lmstudio\') {\n                return this.chatWithLMStudio(messages);\n            }\n            else {\n                throw new Error(`Unsupported LLM provider: ${this.config.provider}`);\n            }\n        }\n        catch (error) {\n            console.error(\'LLM chat failed:\', error);\n            throw new Error(\'Failed to communicate with local LLM\');\n        }\n    }\n    async isAvailable() {\n        try {\n            if (this.config.provider === \'ollama\') {\n                const response = await lib_axios.get(`${this.config.baseUrl}/api/tags`, {\n                    timeout: 5000,\n                });\n                return response.status === 200;\n            }\n            else if (this.config.provider === \'lmstudio\') {\n                const response = await lib_axios.get(`${this.config.baseUrl}/v1/models`, {\n                    timeout: 5000,\n                });\n                return response.status === 200;\n            }\n            return false;\n        }\n        catch (error) {\n            // Don\'t log connection refused errors as they\'re expected when LLM is not running\n            if (error && typeof error === \'object\' && \'code\' in error && error.code === \'ECONNREFUSED\') {\n                console.log(`${this.config.provider} is not running at ${this.config.baseUrl}`);\n            }\n            else {\n                const errorMessage = error instanceof Error ? error.message : \'Unknown error\';\n                console.error(\'LLM availability check failed:\', errorMessage);\n            }\n            return false;\n        }\n    }\n    async chatWithOllama(messages) {\n        const ollamaMessages = messages.map(msg => ({\n            role: msg.role,\n            content: msg.content,\n        }));\n        const systemPrompt = `You are an expert Microsoft Entra (Azure AD) and Microsoft Graph API assistant integrated into EntraPulse Lite. \r\n\r\nYou have access to Microsoft Graph APIs through built-in MCP servers and can help users:\r\n- Query user accounts, groups, applications, and service principals\r\n- Understand Microsoft Entra concepts and best practices\r\n- Analyze permissions and security configurations\r\n- Provide natural language explanations of complex directory structures\r\n\r\nWhen users ask questions, you can:\r\n1. Query Microsoft Graph APIs directly using the available MCP tools\r\n2. Explain Microsoft Entra concepts clearly\r\n3. Provide actionable insights about identity and access management\r\n4. Help with troubleshooting and security analysis\r\n\r\nAlways be helpful, accurate, and security-conscious in your responses.`;\n        const fullMessages = [\n            { role: \'system\', content: systemPrompt },\n            ...ollamaMessages\n        ];\n        const response = await lib_axios.post(`${this.config.baseUrl}/api/chat`, {\n            model: this.config.model,\n            messages: fullMessages,\n            stream: false,\n            options: {\n                temperature: this.config.temperature || 0.7,\n                num_predict: this.config.maxTokens || 2048,\n            },\n        });\n        return response.data.message.content;\n    }\n    async chatWithLMStudio(messages) {\n        const openaiMessages = messages.map(msg => ({\n            role: msg.role,\n            content: msg.content,\n        }));\n        const systemPrompt = `You are an expert Microsoft Entra (Azure AD) and Microsoft Graph API assistant integrated into EntraPulse Lite. \r\n\r\nYou have access to Microsoft Graph APIs through built-in MCP servers and can help users:\r\n- Query user accounts, groups, applications, and service principals\r\n- Understand Microsoft Entra concepts and best practices\r\n- Analyze permissions and security configurations\r\n- Provide natural language explanations of complex directory structures\r\n\r\nWhen users ask questions, you can:\r\n1. Query Microsoft Graph APIs directly using the available MCP tools\r\n2. Explain Microsoft Entra concepts clearly\r\n3. Provide actionable insights about identity and access management\r\n4. Help with troubleshooting and security analysis\r\n\r\nAlways be helpful, accurate, and security-conscious in your responses.`;\n        const fullMessages = [\n            { role: \'system\', content: systemPrompt },\n            ...openaiMessages\n        ];\n        const response = await lib_axios.post(`${this.config.baseUrl}/v1/chat/completions`, {\n            model: this.config.model,\n            messages: fullMessages,\n            temperature: this.config.temperature || 0.7,\n            max_tokens: this.config.maxTokens || 2048,\n        });\n        return response.data.choices[0].message.content;\n    }\n    async getAvailableModels() {\n        try {\n            if (this.config.provider === \'ollama\') {\n                const response = await lib_axios.get(`${this.config.baseUrl}/api/tags`);\n                return response.data.models?.map((model) => model.name) || [];\n            }\n            else if (this.config.provider === \'lmstudio\') {\n                const response = await lib_axios.get(`${this.config.baseUrl}/v1/models`);\n                return response.data.data?.map((model) => model.id) || [];\n            }\n            return [];\n        }\n        catch (error) {\n            console.error(\'Failed to get available models:\', error);\n            return [];\n        }\n    }\n}\n\n;// ./src/mcp/mock/mock-mcp-sdk.ts\n/**\n * Mock MCP SDK types as a fallback until we can install the real package\n */\nclass mock_mcp_sdk_MCPClient {\n    constructor(config) {\n        this.config = config;\n    }\n    async listTools() {\n        // Mock implementation\n        return [\n            {\n                name: \'sample_tool\',\n                description: \'Sample tool description\',\n                schema: {\n                    type: \'object\',\n                    properties: {\n                        input: {\n                            type: \'string\'\n                        }\n                    }\n                }\n            }\n        ];\n    }\n    async callTool(toolName, arguments_) {\n        // Mock implementation\n        return {\n            content: [\n                {\n                    type: \'text\',\n                    text: `Response from tool ${toolName} with args ${JSON.stringify(arguments_)}`\n                }\n            ]\n        };\n    }\n}\n\n;// ./src/mcp/clients/MCPSDKClient.ts\n// MCPClient.ts - SDK Implementation\n// MCP Client using the MCP TypeScript SDK\n// Import from mock for now, replace with actual SDK when available\n\nclass MCPClient {\n    constructor(serverConfigs, authService) {\n        this.clients = new Map();\n        this.serverConfigs = new Map();\n        this.authService = authService;\n        // Store server configs for later reference\n        serverConfigs.forEach(config => {\n            if (config.enabled) {\n                this.serverConfigs.set(config.name, config);\n            }\n        });\n    }\n    /**\n     * Initialize the client for a specific server\n     * @param serverName Name of the MCP server\n     * @returns SDK MCP client for the server\n     */\n    async initializeClient(serverName) {\n        // Check if client already exists\n        if (this.clients.has(serverName)) {\n            return this.clients.get(serverName);\n        }\n        const serverConfig = this.serverConfigs.get(serverName);\n        if (!serverConfig) {\n            throw new Error(`MCP server \'${serverName}\' not found or disabled`);\n        }\n        // Get authentication headers for this server type\n        const authHeaders = await this.authService.getAuthHeaders(serverConfig.type);\n        // Configure the SDK client\n        const clientConfig = {\n            endpoint: serverConfig.url || `http://localhost:${serverConfig.port}`,\n            headers: authHeaders,\n            apiKey: serverConfig.apiKey\n        };\n        // Create the SDK client\n        const client = new mock_mcp_sdk_MCPClient(clientConfig);\n        // Store the client for reuse\n        this.clients.set(serverName, client);\n        return client;\n    }\n    /**\n     * Get a list of available servers\n     * @returns List of enabled server names\n     */\n    getAvailableServers() {\n        return Array.from(this.serverConfigs.keys());\n    }\n    /**\n     * Get a specific server configuration\n     * @param serverName Name of the MCP server\n     * @returns Server configuration\n     */\n    getServerConfig(serverName) {\n        return this.serverConfigs.get(serverName);\n    }\n    /**\n     * List available tools on an MCP server\n     * @param serverName Name of the MCP server\n     * @returns List of available tools\n     */\n    async listTools(serverName) {\n        try {\n            const client = await this.initializeClient(serverName);\n            return await client.listTools();\n        }\n        catch (error) {\n            console.error(`Failed to list tools for server ${serverName}:`, error);\n            throw error;\n        }\n    }\n    /**\n     * Call a tool on an MCP server\n     * @param serverName Name of the MCP server\n     * @param toolName Name of the tool to call\n     * @param arguments_ Arguments to pass to the tool\n     * @returns Tool response\n     */\n    async callTool(serverName, toolName, arguments_) {\n        try {\n            const client = await this.initializeClient(serverName);\n            const response = await client.callTool(toolName, arguments_);\n            return response;\n        }\n        catch (error) {\n            console.error(`Failed to call tool ${toolName} on server ${serverName}:`, error);\n            throw new Error(`Failed to call tool ${toolName}: ${error.message}`);\n        }\n    }\n}\n\n;// ./src/mcp/auth/MCPAuthService.ts\n// MCPAuthService.ts\n// Authentication service for MCP servers\nclass MCPAuthService {\n    constructor(authService) {\n        this.authService = authService;\n    }\n    /**\n     * Get an authentication provider for Microsoft Graph API\n     * @returns AuthenticationProvider for Microsoft Graph\n     */\n    async getGraphAuthProvider() {\n        // Create a custom authentication provider for Microsoft Graph\n        return {\n            getAccessToken: async () => {\n                try {\n                    const token = await this.authService.getToken();\n                    if (!token) {\n                        throw new Error(\'Failed to get authentication token\');\n                    }\n                    return token.accessToken;\n                }\n                catch (error) {\n                    console.error(\'Failed to acquire graph token:\', error);\n                    // Pass the original error so it can be properly inspected\n                    const errorMessage = error.message || \'Authentication failed for Microsoft Graph API\';\n                    throw new Error(`Graph authentication error: ${errorMessage}`);\n                }\n            }\n        };\n    }\n    /**\n     * Get headers for authentication to MCP servers\n     * @param serverType Type of MCP server\n     * @returns Authentication headers\n     * @throws Error if authentication fails\n     */\n    async getAuthHeaders(serverType) {\n        // Different servers may require different authentication headers\n        try {\n            switch (serverType) {\n                case \'lokka\':\n                    const token = await this.authService.getToken();\n                    if (!token) {\n                        throw new Error(\'No authentication token available\');\n                    }\n                    return {\n                        \'Authorization\': `Bearer ${token.accessToken}`,\n                        \'Content-Type\': \'application/json\'\n                    };\n                case \'fetch\':\n                    // Fetch server doesn\'t need auth headers by default\n                    return {\n                        \'User-Agent\': \'EntraPulseLite/1.0\',\n                        \'Content-Type\': \'application/json\'\n                    };\n                default:\n                    console.warn(`Unknown server type: ${serverType}, returning default headers`);\n                    return {\n                        \'Content-Type\': \'application/json\'\n                    };\n            }\n        }\n        catch (error) {\n            console.error(`Error getting authentication headers for ${serverType} server:`, error);\n            const errorMessage = error.message || \'Unknown authentication error\';\n            throw new Error(`Failed to get authentication headers for ${serverType} server: ${errorMessage}`);\n        }\n    }\n    /**\n     * Get the current authentication token\n     * @returns The current auth token or null if not authenticated\n     */\n    async getToken() {\n        try {\n            return await this.authService.getToken();\n        }\n        catch (error) {\n            console.error(\'Error getting token:\', error);\n            return null;\n        }\n    }\n}\n\n;// ./src/mcp/utils/ErrorHandler.ts\n// MCP Error Handler utility for improved error handling and reporting\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode["BAD_REQUEST"] = 400] = "BAD_REQUEST";\n    ErrorCode[ErrorCode["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";\n    ErrorCode[ErrorCode["FORBIDDEN"] = 403] = "FORBIDDEN";\n    ErrorCode[ErrorCode["NOT_FOUND"] = 404] = "NOT_FOUND";\n    ErrorCode[ErrorCode["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";\n    ErrorCode[ErrorCode["CONFLICT"] = 409] = "CONFLICT";\n    ErrorCode[ErrorCode["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";\n    ErrorCode[ErrorCode["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";\n})(ErrorCode || (ErrorCode = {}));\nclass MCPErrorHandler {\n    /**\n     * Create a standardized MCP error object\n     * @param code Error code\n     * @param message Error message\n     * @param data Additional error data\n     * @returns MCP error object\n     */\n    static createError(code, message, data) {\n        return {\n            code,\n            message,\n            data\n        };\n    }\n    /**\n     * Handle and log an error\n     * @param error Error object\n     * @param context Context information for logging\n     * @returns Standardized MCP error\n     */\n    static handleError(error, context) {\n        // Log the error with context\n        console.error(`Error in ${context}:`, error);\n        // If it\'s already an MCPError, return it\n        if (error && typeof error === \'object\' && \'code\' in error && \'message\' in error) {\n            return error;\n        }\n        // Default to internal server error\n        let code = ErrorCode.INTERNAL_SERVER_ERROR;\n        let message = error?.message || \'An unknown error occurred\';\n        // Try to determine the appropriate error code\n        if (error?.message) {\n            const msg = error.message.toLowerCase();\n            if (msg.includes(\'not found\') || msg.includes(\'does not exist\')) {\n                code = ErrorCode.NOT_FOUND;\n            }\n            else if (msg.includes(\'permission\') || msg.includes(\'access\') || msg.includes(\'forbidden\')) {\n                code = ErrorCode.FORBIDDEN;\n            }\n            else if (msg.includes(\'unauthorized\') || msg.includes(\'unauthenticated\') || msg.includes(\'token\')) {\n                code = ErrorCode.UNAUTHORIZED;\n            }\n            else if (msg.includes(\'invalid\') || msg.includes(\'required\') || msg.includes(\'missing\')) {\n                code = ErrorCode.BAD_REQUEST;\n            }\n        }\n        return {\n            code,\n            message,\n            data: {\n                context,\n                stack: error?.stack,\n                originalError: error\n            }\n        };\n    }\n}\n/* harmony default export */ const ErrorHandler = (MCPErrorHandler);\n\n;// ./src/mcp/utils/index.ts\n\n\n\n;// ./src/main/main.ts\n// Main Electron process for EntraPulse Lite\n\n\n\n\n\n\n\n\n// Set app ID for Windows taskbar integration\nif (process.platform === \'win32\') {\n    external_electron_.app.setAppUserModelId(\'com.increment.entrapulselite\');\n}\n// Load environment variables\n(__webpack_require__(998).config)();\nclass EntraPulseLiteApp {\n    constructor() {\n        this.mainWindow = null;\n        this.initializeServices();\n        this.setupEventHandlers();\n    }\n    initializeServices() {\n        // Initialize configuration\n        this.config = {\n            auth: {\n                clientId: process.env.MSAL_CLIENT_ID && process.env.MSAL_CLIENT_ID.trim() !== \'\'\n                    ? process.env.MSAL_CLIENT_ID\n                    : \'14d82eec-204b-4c2f-b7e8-296a70dab67e\', // Microsoft Graph PowerShell fallback\n                tenantId: process.env.MSAL_TENANT_ID && process.env.MSAL_TENANT_ID.trim() !== \'\'\n                    ? process.env.MSAL_TENANT_ID\n                    : \'common\',\n                scopes: [\'User.Read\', \'User.ReadBasic.All\', \'Directory.Read.All\', \'Group.Read.All\'],\n            },\n            llm: {\n                provider: process.env.LLM_PROVIDER || \'ollama\',\n                baseUrl: process.env.LLM_PROVIDER === \'lmstudio\'\n                    ? process.env.LMSTUDIO_BASE_URL || \'http://localhost:1234\'\n                    : process.env.OLLAMA_BASE_URL || \'http://localhost:11434\',\n                model: \'llama2\', // Default model\n            },\n            mcpServers: [\n                {\n                    name: \'lokka\',\n                    type: \'lokka\',\n                    port: parseInt(process.env.MCP_LOKKA_PORT || \'3001\'),\n                    enabled: true,\n                },\n                {\n                    name: \'fetch\',\n                    type: \'fetch\',\n                    port: parseInt(process.env.MCP_DOCS_PORT || \'3002\'),\n                    enabled: true,\n                },\n            ],\n            features: {\n                enablePremiumFeatures: process.env.ENABLE_PREMIUM_FEATURES === \'true\',\n                enableTelemetry: process.env.ENABLE_TELEMETRY === \'true\',\n            },\n        }; // Update MCP server configs with auth configuration\n        this.config.mcpServers.forEach(server => {\n            if (server.type === \'lokka\') {\n                // Add authentication config for Graph API\n                server.authConfig = {\n                    type: \'msal\',\n                    scopes: this.config.auth.scopes,\n                    clientId: this.config.auth.clientId,\n                    tenantId: this.config.auth.tenantId\n                };\n            }\n        });\n        // Initialize services\n        this.authService = new AuthService();\n        this.graphService = new GraphService(this.authService);\n        this.llmService = new LLMService(this.config.llm);\n        // Initialize MCP services\n        const mcpAuthService = new MCPAuthService(this.authService);\n        this.mcpClient = new MCPClient(this.config.mcpServers, mcpAuthService);\n    }\n    setupEventHandlers() {\n        // Set application ID for Windows taskbar\n        if (process.platform === \'win32\') {\n            external_electron_.app.setAppUserModelId(\'com.increment.entrapulselite\');\n        }\n        external_electron_.app.whenReady().then(() => {\n            this.createWindow();\n            this.setupMenu();\n            this.setupIpcHandlers();\n            external_electron_.app.on(\'activate\', () => {\n                if (external_electron_.BrowserWindow.getAllWindows().length === 0)\n                    this.createWindow();\n            });\n        });\n        external_electron_.app.on(\'window-all-closed\', () => {\n            if (process.platform !== \'darwin\')\n                external_electron_.app.quit();\n        });\n    }\n    createWindow() {\n        this.mainWindow = new external_electron_.BrowserWindow({ width: 1280,\n            height: 900,\n            minWidth: 900,\n            minHeight: 700,\n            icon: process.platform === \'win32\'\n                ? external_path_.resolve(external_electron_.app.getAppPath(), \'assets\', \'icon.ico\')\n                : external_path_.resolve(external_electron_.app.getAppPath(), \'assets\', \'EntraPulseLiteLogo.png\'),\n            webPreferences: {\n                nodeIntegration: false,\n                contextIsolation: true,\n                preload: external_path_.join(__dirname, \'preload.js\'),\n            },\n            titleBarStyle: \'default\',\n            show: false, // Don\'t show until ready\n        });\n        // Load the index.html from the dist directory\n        this.mainWindow.loadFile(external_path_.join(__dirname, \'index.html\'));\n        // Show window when ready\n        this.mainWindow.once(\'ready-to-show\', () => {\n            this.mainWindow?.show();\n        });\n        // Open DevTools in development\n        if (false) // removed by dead control flow\n{}\n    }\n    setupMenu() {\n        const template = [\n            {\n                label: \'File\',\n                submenu: [\n                    {\n                        label: \'Settings\',\n                        accelerator: \'CmdOrCtrl+,\',\n                        click: () => {\n                            // Open settings window\n                        },\n                    },\n                    { type: \'separator\' },\n                    {\n                        label: \'Quit\',\n                        accelerator: process.platform === \'darwin\' ? \'Cmd+Q\' : \'Ctrl+Q\',\n                        click: () => {\n                            external_electron_.app.quit();\n                        },\n                    },\n                ],\n            },\n            {\n                label: \'Edit\',\n                submenu: [\n                    { role: \'undo\' },\n                    { role: \'redo\' },\n                    { type: \'separator\' },\n                    { role: \'cut\' },\n                    { role: \'copy\' },\n                    { role: \'paste\' },\n                ],\n            },\n            {\n                label: \'View\',\n                submenu: [\n                    { role: \'reload\' },\n                    { role: \'forceReload\' },\n                    { role: \'toggleDevTools\' },\n                    { type: \'separator\' },\n                    { role: \'resetZoom\' },\n                    { role: \'zoomIn\' },\n                    { role: \'zoomOut\' },\n                    { type: \'separator\' },\n                    { role: \'togglefullscreen\' },\n                ],\n            },\n            {\n                label: \'Help\',\n                submenu: [\n                    {\n                        label: \'About EntraPulse Lite\',\n                        click: () => {\n                            // Show about dialog\n                        },\n                    },\n                ],\n            },\n        ];\n        const menu = external_electron_.Menu.buildFromTemplate(template);\n        external_electron_.Menu.setApplicationMenu(menu);\n    }\n    setupIpcHandlers() {\n        // Asset path handler\n        external_electron_.ipcMain.handle(\'app:getAssetPath\', (event, assetName) => {\n            const assetPath = external_path_.join(external_electron_.app.getAppPath(), \'assets\', assetName);\n            return assetPath;\n        });\n        // Authentication handlers\n        external_electron_.ipcMain.handle(\'auth:login\', async (_, useRedirectFlow = false) => {\n            try {\n                return await this.authService.login(useRedirectFlow);\n            }\n            catch (error) {\n                console.error(\'Login failed:\', error);\n                throw error;\n            }\n        });\n        external_electron_.ipcMain.handle(\'auth:logout\', async () => {\n            try {\n                await this.authService.logout();\n            }\n            catch (error) {\n                console.error(\'Logout failed:\', error);\n                throw error;\n            }\n        });\n        external_electron_.ipcMain.handle(\'auth:getToken\', async () => {\n            try {\n                return await this.authService.getToken();\n            }\n            catch (error) {\n                console.error(\'Get token failed:\', error);\n                return null;\n            }\n        });\n        external_electron_.ipcMain.handle(\'auth:getCurrentUser\', async () => {\n            try {\n                return await this.authService.getCurrentUser();\n            }\n            catch (error) {\n                console.error(\'Get current user failed:\', error);\n                return null;\n            }\n        });\n        // Progressive permission handlers\n        external_electron_.ipcMain.handle(\'auth:requestPermissions\', async (event, permissions) => {\n            try {\n                return await this.authService.requestAdditionalPermissions(permissions);\n            }\n            catch (error) {\n                console.error(\'Request permissions failed:\', error);\n                return null;\n            }\n        });\n        external_electron_.ipcMain.handle(\'auth:getTokenWithPermissions\', async (event, permissions) => {\n            try {\n                return await this.authService.getTokenWithPermissions(permissions);\n            }\n            catch (error) {\n                console.error(\'Get token with permissions failed:\', error);\n                return null;\n            }\n        }); // Microsoft Graph handlers\n        external_electron_.ipcMain.handle(\'graph:query\', async (event, endpoint, method, data) => {\n            try {\n                return await this.graphService.query(endpoint, method, data);\n            }\n            catch (error) {\n                console.error(\'Graph query failed:\', error);\n                throw error;\n            }\n        });\n        external_electron_.ipcMain.handle(\'graph:getUserPhoto\', async (event, userId) => {\n            try {\n                return await this.graphService.getUserPhoto(userId);\n            }\n            catch (error) {\n                console.error(\'Get user photo failed:\', error);\n                return null;\n            }\n        });\n        // LLM handlers\n        external_electron_.ipcMain.handle(\'llm:chat\', async (event, messages) => {\n            try {\n                return await this.llmService.chat(messages);\n            }\n            catch (error) {\n                console.error(\'LLM chat failed:\', error);\n                throw error;\n            }\n        });\n        external_electron_.ipcMain.handle(\'llm:isAvailable\', async () => {\n            try {\n                return await this.llmService.isAvailable();\n            }\n            catch (error) {\n                console.error(\'LLM availability check failed:\', error);\n                return false;\n            }\n        }); // MCP handlers\n        external_electron_.ipcMain.handle(\'mcp:call\', async (event, server, toolName, arguments_) => {\n            try {\n                return await this.mcpClient.callTool(server, toolName, arguments_);\n            }\n            catch (error) {\n                const mcpError = ErrorHandler.handleError(error, `mcp:call(${server}, ${toolName})`);\n                console.error(\'MCP tool call failed:\', mcpError);\n                // Return the error in a consistent format that the renderer can handle\n                return {\n                    error: {\n                        code: mcpError.code,\n                        message: mcpError.message\n                    }\n                };\n            }\n        });\n        external_electron_.ipcMain.handle(\'mcp:listServers\', async () => {\n            try {\n                return this.mcpClient.getAvailableServers();\n            }\n            catch (error) {\n                const mcpError = ErrorHandler.handleError(error, \'mcp:listServers\');\n                console.error(\'MCP list servers failed:\', mcpError);\n                return [];\n            }\n        });\n        external_electron_.ipcMain.handle(\'mcp:listTools\', async (event, server) => {\n            try {\n                return await this.mcpClient.listTools(server);\n            }\n            catch (error) {\n                const mcpError = ErrorHandler.handleError(error, `mcp:listTools(${server})`);\n                console.error(`MCP list tools for server ${server} failed:`, mcpError);\n                return [];\n            }\n        });\n        // Configuration handlers\n        external_electron_.ipcMain.handle(\'config:get\', async () => {\n            return this.config;\n        });\n        external_electron_.ipcMain.handle(\'config:update\', async (event, newConfig) => {\n            try {\n                this.config = { ...this.config, ...newConfig };\n                // In a real implementation, save to file\n                return this.config;\n            }\n            catch (error) {\n                console.error(\'Config update failed:\', error);\n                throw error;\n            }\n        });\n    }\n}\n// Create and start the application\nnew EntraPulseLiteApp();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE0MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUJBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUJBQVM7QUFDYixJQUFJLG1CQUFTO0FBQ2IsSUFBSSxtQkFBUztBQUNiO0FBQ0EsNkNBQTZDLG1CQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzQkFBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUJBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRXNvQjtBQUN0b0I7OztBQ3JVQTtBQUNhO0FBQ3dDOztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCOzs7QUNsTUE7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6Qjs7O0FDakJBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0M7QUFDbEM7OztBQ2RBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRDtBQUNqRDs7O0FDWkE7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0Y7QUFDL0Y7OztBQ25nQkE7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUUrQjtBQUMvQjs7O0FDbEdBO0FBQ2E7QUFDMEU7QUFDTDtBQUN0Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVcsb0NBQW9DLGlCQUFpQiw0RkFBNEYsbUJBQVM7QUFDNU4sd0RBQXdELFVBQVU7QUFDbEU7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFLHFEQUFxRCxXQUFXLG9DQUFvQyxpQkFBaUI7QUFDckg7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBLDZEQUE2RCxXQUFXLG9DQUFvQyxpQkFBaUI7QUFDN0gsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLDREQUE0RCxtQkFBUyxlQUFlLGVBQWUsUUFBUSx3QkFBd0IsbUJBQVM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0EsZ0ZBQWdGLG1CQUFTLGVBQWU7QUFDeEc7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFMkI7QUFDM0I7OztBQy9HQTtBQUNhO0FBQ3dEO0FBQ3FDOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQixDQUFDLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQixDQUFDLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFCLENBQUMsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsY0FBYyxxQ0FBcUIsQ0FBQyxnQkFBZ0I7QUFDcEQ7QUFDQTs7QUFFMEQ7QUFDMUQ7OztBQ2pFQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVHO0FBQ3ZHOzs7QUNqRUE7QUFDYTtBQUNvRDtBQUNPO0FBQzhHO0FBQy9IO0FBQ21DOztBQUUxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQSwwQkFBMEIscUNBQXFCLENBQUMsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixRQUFRLDRCQUE0QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7O0FBRTZhO0FBQzdhOzs7QUM5VUE7QUFDYTtBQUN1QztBQUNnQjtBQUNuQjtBQUNvQjtBQUN1RDtBQUM2RDtBQUNsRztBQUNyQztBQUNVO0FBQzRCO0FBQ1U7QUFDMUM7QUFDTDtBQUMrQjtBQUN0QjtBQUNvSDtBQUNqRDtBQUNVOztBQUV6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbUJBQVM7QUFDM0QsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQVM7QUFDOUIsMkJBQTJCLGFBQWE7QUFDeEMscUJBQXFCLG1CQUFTO0FBQzlCLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQixDQUFDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUIsQ0FBQyx1QkFBdUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFCLENBQUMsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUIsQ0FBQyw4QkFBOEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFCLENBQUMsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQixDQUFDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUIsQ0FBQyx1QkFBdUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQVM7QUFDdEIsb0RBQW9ELGFBQWE7QUFDakUsa0NBQWtDLHlCQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPLEVBQUUsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFlBQVksVUFBVSxTQUFTO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsUUFBUSxZQUFZO0FBQy9FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRCxtQ0FBbUMseUJBQVk7QUFDL0M7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0EsMkNBQTJDLFdBQVcsK0NBQStDLGlCQUFpQjtBQUN0SDtBQUNBLHFDQUFxQyxXQUFXLHlDQUF5QyxpQkFBaUI7QUFDMUc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVELCtDQUErQyx1QkFBdUI7QUFDdEU7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxXQUFXLHdEQUF3RCxpQkFBaUI7QUFDNUksd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsaURBQWlELGlCQUFpQjtBQUMxRztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVyx3REFBd0QsaUJBQWlCO0FBQ3JIO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0MsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFCLENBQUMsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUE4QixDQUFDLHdCQUF3QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILDRCQUE0QjtBQUNqSjtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQVM7QUFDekI7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVM7QUFDaEM7QUFDQSxpREFBaUQsV0FBVywrREFBK0QsaUJBQWlCO0FBQzVJO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLHVCQUF1QixtQkFBUztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLHVEQUF1RCxpQkFBaUI7QUFDbEg7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QyxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQSxjQUFjLHVEQUE4QixDQUFDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsWUFBWSxtQkFBUyxnQkFBZ0I7QUFDckMsc0RBQXNEO0FBQ3RELFlBQVksbUJBQVMsZ0JBQWdCO0FBQ3JDLHVEQUF1RCxzQ0FBc0MsbUJBQVMsZ0JBQWdCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQSxtQkFBbUIsbUJBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQThCLENBQUMsNkJBQTZCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRSw2Q0FBNkMsbUJBQVMsOEJBQThCLEVBQUUsd0JBQXdCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsNENBQTRDO0FBQ3BIO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRCwwSkFBMEosZ0JBQWdCO0FBQzFLO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHdCQUF3QjtBQUNoSCxvR0FBb0csb0NBQW9DO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQTRDO0FBQ2hFO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQyxzSUFBc0ksZ0JBQWdCLHVCQUF1QixtQkFBbUI7QUFDaE07QUFDQTtBQUNBO0FBQ0EsMElBQTBJLGdCQUFnQix1QkFBdUIsbUJBQW1CO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFTO0FBQzNCLDZDQUE2QyxxQ0FBcUMsR0FBRyxPQUFPO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFxQixDQUFDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLEdBQUcsa0NBQWtDO0FBQzdFO0FBQ0EsaUNBQWlDLE9BQU8sR0FBRyxtQkFBUyxtQ0FBbUM7QUFDdkY7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQixJQUFJLEdBQUcsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxZQUFZLG1CQUFTO0FBQ3JCO0FBQ0EsWUFBWSxtQkFBUztBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQSw0REFBNEQsbUJBQVM7QUFDckU7QUFDQSwrQkFBK0IsY0FBYyxFQUFFLGlCQUFpQixFQUFFLG1CQUFTLDBCQUEwQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQVM7QUFDVCxNQUFNLE9BQU87QUFDYixNQUFNLFNBQVM7QUFDZixJQUFJLHFCQUFxQjtBQUN6QixJQUFJLHFCQUFxQjtBQUN6QixJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQVM7QUFDMUM7QUFDQSxhQUFhLGFBQWEsRUFBRSxtQkFBUyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1REFBOEIsQ0FBQyw2QkFBNkI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9HO0FBQ3BHOzs7QUMzMUJBO0FBQ2E7QUFDd0Q7QUFDSTs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFDQUE2QjtBQUNuQztBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGNBQWMscUNBQXFCLENBQUMsb0JBQW9CO0FBQ3hELEtBQUs7QUFDTDs7QUFFeUM7QUFDekM7OztBQzNDQTtBQUNhO0FBQ2I7QUFDQSxNQUFNLG9CQUFJO0FBQ1YsTUFBTSx1QkFBTzs7QUFFWTtBQUN6Qjs7O0FDUEE7QUFDYTtBQUMwRTtBQUNoQztBQUNjO0FBQ0w7QUFDbUI7QUFDa0M7O0FBRXJIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUE4QixDQUFDLHFCQUFxQjtBQUN0RTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUIsQ0FBQyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUIsQ0FBQyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUIsQ0FBQyxrQkFBa0I7QUFDMUQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFCLENBQUMsa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEI7OztBQ3ZNQTtBQUNhO0FBQ3dEO0FBQ047QUFDbUM7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQixDQUFDLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQixDQUFDLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUIsQ0FBQyx1QkFBdUI7QUFDM0Q7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFNkQ7QUFDN0Q7OztBQzdDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5RjtBQUN6Rjs7O0FDakZBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QztBQUN4Qzs7O0FDeEJBO0FBQ2E7QUFDNEQ7QUFDVjtBQUNJO0FBQ0s7QUFDTjtBQUNXO0FBQ2I7QUFDZTs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRCxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0EsNENBQTRDLHlCQUFZO0FBQ3hELG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFCLENBQUMsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEMseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQSxrQ0FBa0MsZUFBZSxHQUFHLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCOzs7QUM3UEE7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEQ7QUFDOUQ7OztBQ1ZBO0FBQ2E7QUFDOEU7QUFDbEM7QUFDOUI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJCQUEyQjtBQUNoQyxLQUFLLHFCQUFxQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFELGlCQUFpQixVQUFVLElBQUksUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBDO0FBQzFDOzs7QUNoQ0E7QUFDYTtBQUN3STtBQUNwRjtBQUNkO0FBQ1U7QUFDUTtBQUNPO0FBQ2Q7QUFDUDtBQUMwQjtBQUM1QjtBQUMyRjtBQUM5Qzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFJLEVBQUUsdUJBQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qiw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFCLENBQUMsa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVLENBQUMsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsRUFBRTtBQUMvRSwwQkFBMEIsVUFBVSxDQUFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0EsMENBQTBDLGNBQWMsZUFBZSxFQUFFLFVBQVUscUJBQXFCLEVBQUUsY0FBYyxFQUFFLFVBQVUscUJBQXFCO0FBQ3pKLDBDQUEwQyxjQUFjLGVBQWUsRUFBRSxVQUFVLHFCQUFxQixFQUFFLGFBQWEsQ0FBQyxFQUFFLFVBQVUscUJBQXFCO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVzQjtBQUN0Qjs7Ozs7QUN6U0E7QUFDYTtBQUNrQjtBQUM0RjtBQUNoRTtBQUNMOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsV0FBVyxjQUFjO0FBQzVCLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7OztBQUdBLDRDQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjLG9CQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7QUN2dUJXOztBQUVtQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxNQUFNLG9CQUFTO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLENBQUM7O0FBRUQ7QUFDQSxzQkFBc0Isb0JBQVMsbUJBQW1CLFlBQVk7O0FBRTlEO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQVM7O0FBRTVDLEVBQUUsS0FBSztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNEQUFlLFVBQVUsRUFBQzs7Ozs7QUN0R087O0FBRWpDLHVEQUFlLFNBQVEsRUFBQzs7O0FDRlg7O0FBRW1CO0FBQ2U7QUFDL0M7QUFDb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUyxLQUFLLHlCQUF5QixLQUFLO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDs7QUFFQSxtQkFBbUIsS0FBSyxjQUFjLEtBQUssSUFBSTtBQUMvQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sS0FBSztBQUNaO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsZ0JBQWdCOztBQUU5QztBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZLEtBQUs7QUFDakIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSzs7QUFFaEMsT0FBTyxLQUFLO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsS0FBSztBQUNiO0FBQ0E7O0FBRUEsb0JBQW9CLEtBQUs7QUFDekIsZ0JBQWdCLGVBQVU7QUFDMUI7O0FBRUEsUUFBUSxLQUFLLHlCQUF5QixLQUFLO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsc0JBQXNCO0FBQ25DLFlBQVk7QUFDWjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLEtBQUssa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFNBQVMsS0FBSztBQUNkLFVBQVUsS0FBSyxzQkFBc0IsS0FBSyxnQ0FBZ0MsS0FBSztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFFBQVEsS0FBSzs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSSxLQUFLO0FBQ1QsdUJBQXVCLEtBQUs7QUFDNUIsc0JBQXNCLEtBQUs7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLE9BQU8sS0FBSztBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5REFBZSxVQUFVLEVBQUM7OztBQzFOYjs7QUFFNEI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFVO0FBQ3RCOztBQUVBLE1BQU0sOEJBQVM7O0FBRWYsOEJBQVM7QUFDVDtBQUNBOztBQUVBLDhCQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxtRUFBZSxvQkFBb0IsRUFBQzs7O0FDekR2Qjs7QUFFbUI7QUFDc0M7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsU0FBUyxlQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQU07O0FBRXJELE1BQU0sS0FBSztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCLEtBQUs7QUFDNUI7QUFDQSxVQUFVLDRCQUFvQjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDcEVhOztBQUVxQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLElBQUksS0FBSztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDhEQUFlLGtCQUFrQixFQUFDOzs7QUN0RXJCOztBQUViLDREQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7OztBQ05XOztBQUVTO0FBQ3RCLDhEQUFlLDZCQUFtQixFQUFDOzs7QUNIUDtBQUM4QjtBQUNkOztBQUU1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQSxFQUFFLCtCQUFxQjtBQUN2QixrQkFBa0IsVUFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLDJDQUFlO0FBQ2Y7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixZQUFZO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7QUNyQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBUUM7OztBQ2xEc0M7QUFDSTs7QUFFM0MsK0NBQWU7QUFDZixLQUFLLDRCQUFLO0FBQ1YsS0FBSyxJQUFRO0FBQ2IsQ0FBQzs7O0FDTlk7O0FBRW1CO0FBQ1M7QUFDRzs7QUFFN0I7QUFDZixTQUFTLGtCQUFVLFdBQVcsUUFBUTtBQUN0QztBQUNBLFVBQVUsUUFBUSxXQUFXLEtBQUs7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQ2pCYTs7QUFFbUI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSzs7QUFFekI7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSxLQUFLLHlCQUF5QixLQUFLO0FBQ3pDOztBQUVBLElBQUksS0FBSztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkRBQWUsY0FBYyxFQUFDOzs7QUM5RmpCOztBQUVtQjtBQUNlO0FBQ007QUFDSDtBQUNZO0FBQ2xCO0FBQ2M7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLE1BQU0sS0FBSztBQUNYO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IscUJBQW9COztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSzs7QUFFakMsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTs7QUFFQSx1QkFBdUIsS0FBSzs7QUFFNUI7QUFDQSxpREFBaUQsc0JBQWM7QUFDL0Q7O0FBRUEsUUFBUSxLQUFLO0FBQ2IsTUFBTSxLQUFLO0FBQ1gsTUFBTSxLQUFLO0FBQ1gsTUFBTSxLQUFLO0FBQ1gsTUFBTSxLQUFLO0FBQ1gsTUFBTSxLQUFLO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLO0FBQ2I7QUFDQTtBQUNBLFFBQVEsS0FBSztBQUNiLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjs7QUFFQSx3QkFBd0IsS0FBSztBQUM3Qjs7QUFFQSxlQUFlLGtCQUFVO0FBQ3pCLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxLQUFLLHFCQUFxQixLQUFLO0FBQ3ZDO0FBQ0E7O0FBRUEsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxrQkFBa0IsZUFBVSxTQUFTLGVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEIsVUFBVSxRQUFRO0FBQ2xCLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRCxtREFBZSxRQUFRLEVBQUM7OztBQ2hLWDs7QUFFcUI7O0FBRWxDO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsbURBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDLEVBQUM7OztBQ3REVzs7QUFFbUI7QUFDc0I7O0FBRXREOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLEtBQUs7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU0sS0FBSztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU8sS0FBSzs7QUFFWixNQUFNLEtBQUs7QUFDWDtBQUNBOztBQUVBLE1BQU0sS0FBSztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVCQUF1QixLQUFLOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsS0FBSzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLEtBQUs7O0FBRVgsUUFBUSxLQUFLO0FBQ2I7QUFDQSxNQUFNLFFBQVEsS0FBSztBQUNuQixpQkFBaUIsWUFBWTtBQUM3QixNQUFNLFNBQVMsS0FBSyxxQkFBcUIsS0FBSztBQUM5QyxrQkFBa0I7QUFDbEI7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixLQUFLOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7O0FBRUEsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixLQUFLOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsS0FBSzs7QUFFekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFLO0FBQ1Qsa0JBQWtCLEtBQUs7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksS0FBSztBQUNULHNFQUFzRSxLQUFLO0FBQzNFLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksS0FBSzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLLDZDQUE2QyxNQUFNO0FBQ3hELG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELEtBQUs7O0FBRUwsd0RBQWUsWUFBWSxFQUFDOzs7QUN6VGY7O0FBRXFCO0FBQ1U7QUFDTzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ2U7QUFDZix5QkFBeUIsWUFBUTtBQUNqQztBQUNBLGtCQUFrQixpQkFBWTtBQUM5Qjs7QUFFQSxFQUFFLEtBQUs7QUFDUDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7O0FDM0JhOztBQUVFO0FBQ2Y7QUFDQTs7O0FDSmE7O0FBRWtDO0FBQ2Y7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBVSxvREFBb0QsZUFBVTtBQUMxRTtBQUNBOztBQUVBLEtBQUsseUJBQXlCLGVBQVU7QUFDeEM7QUFDQSxDQUFDOztBQUVELDJEQUFlLGFBQWEsRUFBQzs7O0FDeEJoQjs7QUFFNEI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZSxlQUFVO0FBQ3pCO0FBQ0EsT0FBTyxlQUFVLGtCQUFrQixlQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7OztBQ2RhOztBQUUyQztBQUNKOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNlO0FBQ2YsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNyQkEsTUFBTSw2QkFBNEIsbUI7O0FDQTNCLHdCOztBQ0FNOztBQUVFO0FBQ2YsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTs7O0FDTGE7O0FBRWtDO0FBQ0E7QUFDSDs7QUFFNUMsa0NBQWtDLElBQUksUUFBUSxHQUFHOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixXQUFXLFdBQVc7QUFDdEI7QUFDQSxhQUFhO0FBQ2I7QUFDZTtBQUNmLDJDQUEyQyxRQUFRO0FBQ25ELG1CQUFtQixhQUFhOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixlQUFVLGdCQUFnQixlQUFVO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBVSwwQkFBMEIsZUFBVTtBQUNoRTs7QUFFQSxrQ0FBa0MsV0FBVztBQUM3Qzs7QUFFQTtBQUNBOztBQUVBLFlBQVksZUFBVSxxQ0FBcUMsZUFBVTtBQUNyRTs7Ozs7QUNwRGE7O0FBRWU7QUFDSTs7QUFFaEM7O0FBRUEsbUNBQW1DLDBCQUFnQjtBQUNuRDtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxLQUFLO0FBQ25CLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1FQUFlLG9CQUFvQixFQUFDOzs7QUM5SXBDLE1BQU0sK0JBQTRCLHFCOztBQ0FsQyxPQUFPLGVBQWU7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsdURBQWUsUUFBUSxFQUFDOzs7QUNkQTtBQUNRO0FBQ0E7QUFDSztBQUNPOztBQUU1QywwQkFBMEIsUUFBUTs7QUFFbEMsZ0ZBQWdGLDBCQUFnQjs7QUFFaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsMEJBQTBCLEtBQUs7O0FBRS9CLG1EQUFtRCxRQUFRLGlCQUFpQjtBQUM1RSx3Q0FBd0MsWUFBWSx1QkFBdUI7QUFDM0UsS0FBSyxFQUFFLEtBQUs7O0FBRVo7QUFDQTtBQUNBLE1BQU07QUFDTixrQ0FBa0MseUNBQXlDLEVBQUUsS0FBSztBQUNsRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLE9BQU87O0FBRWxCLE9BQU8sS0FBSztBQUNaO0FBQ0EsTUFBTTtBQUNOLGFBQWEsZ0JBQVE7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQyxJQUFJOztBQUVKLE1BQU0sS0FBSztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsa0JBQWtCLEtBQUs7O0FBRXZCO0FBQ0EsMENBQTBDLFdBQVcsU0FBUztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyx5QkFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwrREFBZSxnQkFBZ0IsRUFBQzs7O0FDL0duQjs7QUFFZTs7QUFFNUIsd0NBQXdDLDBCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0VBQWUseUJBQXlCLEVBQUM7OztBQzNCVDs7QUFFaEM7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQSwwREFBZSxXQUFXLEVBQUM7OztBQ2ZkOztBQUViO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwREFBZSxXQUFXLEVBQUM7OztBQ3REM0I7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVEQUFlLFFBQVEsRUFBQzs7O0FDM0NtQjtBQUNOO0FBQ0w7O0FBRXpCO0FBQ1A7QUFDQSx1QkFBdUIsbUJBQVc7O0FBRWxDLFNBQVMsZ0JBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU8sNENBQTRDLEtBQUs7OztBQzNDM0M7O0FBRXFCO0FBQ087QUFDWTtBQUNMO0FBQ047QUFDbEI7QUFDRTtBQUNGO0FBQ3VCO0FBQ3ZCO0FBQ2U7QUFDd0I7QUFDaEI7QUFDUTtBQUNYO0FBQ1E7QUFDeEI7QUFDdUI7QUFDbUI7QUFDbEM7QUFDMEI7QUFDaEI7QUFDa0M7QUFDNUI7QUFDNEQ7O0FBRWhIO0FBQ0EsU0FBUyx1Q0FBYztBQUN2QixlQUFlLHVDQUFjO0FBQzdCOztBQUVBO0FBQ0EsU0FBUyx1Q0FBYztBQUN2QixlQUFlLHVDQUFjO0FBQzdCOztBQUVBLDBCQUEwQixLQUFLLFlBQVksb0RBQTJCOztBQUV0RSxPQUFPLHNDQUFzQyxFQUFFLGdCQUFlOztBQUU5RDs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFLEtBQUs7O0FBRXRFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QyxPQUFPLEtBQUs7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDZEQUE2RCxLQUFLLGdDQUFnQyxnQkFBZ0I7O0FBRWxIO0FBQ0EsMkNBQWU7QUFDZjtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG1CQUFXLG9CQUFvQixLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsS0FBSzs7QUFFakM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw0Q0FBWTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlEQUF5RCxvQkFBYTtBQUN0RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxxQ0FBcUMsUUFBUSxpQkFBaUIsUUFBUTtBQUN0RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsY0FBYyxlQUFVLFdBQVcsZUFBVTtBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLHlCQUFlO0FBQ3ZDOztBQUVBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQVk7QUFDakM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSx3QkFBd0IsZUFBVTtBQUNsQztBQUNBLFFBQVEsZUFBVTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFZOztBQUVoQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EseUNBQXlDLE9BQU87O0FBRWhELFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBSztBQUNiLHNFQUFzRSxNQUFNOztBQUU1RSxhQUFhLHdCQUFnQjtBQUM3QjtBQUNBLE9BQU87QUFDUCxzQkFBc0IsT0FBTyxDQUFDO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTSxTQUFTLEtBQUsscUJBQXFCLEtBQUs7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyx3QkFBYztBQUNsRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNLFNBQVMsS0FBSyxpQkFBaUIsS0FBSztBQUMxQztBQUNBO0FBQ0EsYUFBYSx5QkFBZSxNQUFNLGdCQUFRO0FBQzFDLE1BQU0sa0JBQWtCLEtBQUs7QUFDN0I7QUFDQTtBQUNBLFFBQVEsU0FBUyxLQUFLO0FBQ3RCO0FBQ0EsUUFBUSxTQUFTLEtBQUs7QUFDdEI7QUFDQSxRQUFRO0FBQ1IsMEJBQTBCLGVBQVU7QUFDcEM7QUFDQSxVQUFVLGVBQVU7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBVTtBQUNwQztBQUNBLFVBQVUsZUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsS0FBSzs7QUFFL0IsUUFBUSxLQUFLO0FBQ2I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGVBQWUseUJBQWUsYUFBYSxrQkFBa0I7QUFDN0Q7O0FBRUEsYUFBYSx5QkFBZSxZQUFZLDRCQUFvQjtBQUM1RCxpQkFBaUIsS0FBSztBQUN0QixPQUFPLElBQUksS0FBSzs7QUFFaEI7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0EsVUFBVSxvQkFBb0IsQ0FBQyxjQUFjO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxLQUFLOztBQUVWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQ0FBbUMsZUFBSyxHQUFHLGNBQUk7QUFDL0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyw0QkFBb0I7QUFDeEQsbUJBQW1CLEtBQUs7QUFDeEIsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQSxZQUFZLG9CQUFvQixDQUFDLGNBQWM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBZ0I7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUF5Qjs7QUFFcEQ7QUFDQSx1QkFBdUIseUNBQWdCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMseUJBQWUsVUFBVSxLQUFLOztBQUUxRSwyQkFBMkIseUJBQWU7QUFDMUM7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFZO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBVTtBQUNqQyxjQUFjLGVBQVU7QUFDeEI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixlQUFVO0FBQ3BDO0FBQ0EsWUFBWSxlQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxpQkFBaUIsZUFBVTtBQUMzQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwwQkFBMEIsZUFBVTtBQUNwQztBQUNBLFVBQVUsTUFBTTtBQUNoQixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQVU7QUFDdkIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBVTtBQUM3QjtBQUNBLFVBQVUsZUFBVTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBVTtBQUM3QjtBQUNBLDZDQUE2QyxlQUFVLGFBQWEsZUFBVTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQSxRQUFRLEtBQUs7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLG9CQUFvQixvQkFBYTtBQUNqQztBQUNBLE9BQU87O0FBRVA7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVNLG1CQUFtQix3REFBUTs7O0FDdHJCVTs7QUFFNUMsc0RBQWUsUUFBUTtBQUN2QixxQkFBcUIsUUFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLFFBQVE7QUFDbEIsRUFBRSxRQUFRLHFDQUFxQyxRQUFRO0FBQ3ZELGNBQWMsRUFBQzs7O0FDYm1CO0FBQ1U7O0FBRTVDLDhDQUFlLFFBQVE7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBSzs7QUFFWCxNQUFNLEtBQUs7O0FBRVgsTUFBTSxLQUFLOztBQUVYOztBQUVBLHVDQUF1QztBQUN2QyxLQUFLOztBQUVMO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxFQUFDOzs7O0FDeENTOztBQUVtQjtBQUNhOztBQUU3QyxvREFBb0QsaUJBQVksS0FBSyxXQUFXOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBSywwQkFBMEIsS0FBSztBQUM1QyxhQUFhLEtBQUssYUFBYSxTQUFTO0FBQ3hDLE1BQU0sU0FBUyxLQUFLO0FBQ3BCLGFBQWEsS0FBSyxTQUFTO0FBQzNCLE1BQU0sU0FBUyxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBLE1BQU0sVUFBVSxLQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBLE1BQU0sVUFBVSxLQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxLQUFLLHFDQUFxQztBQUM1QztBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1YsR0FBRzs7QUFFSDtBQUNBOzs7QUN6RzRDO0FBQ1o7QUFDbUI7QUFDaEI7QUFDa0I7QUFDSjtBQUNFO0FBQ2Q7O0FBRXJDLG9EQUFlO0FBQ2Ysb0JBQW9CLFdBQVcsR0FBRzs7QUFFbEMsT0FBTyxvRUFBb0U7O0FBRTNFLGdDQUFnQyxpQkFBWTs7QUFFNUMsa0JBQWtCLFFBQVEsQ0FBQyxhQUFhOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUFLO0FBQ1gsUUFBUSxRQUFRLDBCQUEwQixRQUFRO0FBQ2xELHlDQUF5QztBQUN6QyxNQUFNO0FBQ047QUFDQSxrRUFBa0U7QUFDbEUsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sUUFBUTtBQUNkLHFCQUFxQixLQUFLOztBQUUxQixxREFBcUQsZUFBZTtBQUNwRTtBQUNBLDREQUE0RCxPQUFPOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7OztBQ3ZEaUM7QUFDTztBQUNzQjtBQUNoQjtBQUNRO0FBQ0M7QUFDWjtBQUNPO0FBQ3FCO0FBQ2hCOztBQUV4RDs7QUFFQSwwQ0FBZTtBQUNmO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSwyQkFBMkIsaUJBQVk7QUFDdkMsU0FBUyxvREFBb0Q7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFVLG9CQUFvQixlQUFVOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBVSxrQkFBa0IsZUFBVTs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxQkFBb0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQVU7QUFDM0I7QUFDQSwyQ0FBMkMsZUFBVSxhQUFhLGVBQVU7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFLO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7O0FBRTVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQWE7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLG9CQUFvQixRQUFRO0FBQzVCLGlCQUFpQixlQUFVLDJDQUEyQyxlQUFVO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7O0FDcE1zRDtBQUNSO0FBQ2Y7O0FBRWhDO0FBQ0EsU0FBUyxRQUFROztBQUVqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBVSxhQUFhLG9CQUFhO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFVLFlBQVksU0FBUyxpQkFBaUIsZUFBVTtBQUM1RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyxRQUFROztBQUVuQiwrQkFBK0IsS0FBSzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBLDZEQUFlLGNBQWMsRUFBQzs7OztBQzlDdkI7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOzs7QUN0RjRDO0FBQ1o7QUFDZTtBQUNXO0FBQ0o7QUFDSDtBQUM2RDtBQUN4RDtBQUNqQjs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EsYUFBYSxLQUFLOzs7QUFHbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBLGtCQUFrQixlQUFVLG1CQUFtQixLQUFLLHFCQUFxQixlQUFVO0FBQ25GLE9BQU87QUFDUCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLEtBQUs7QUFDVjtBQUNBOztBQUVBLEtBQUssS0FBSztBQUNWLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLLEtBQUssNEJBQTRCLEtBQUs7QUFDM0M7QUFDQTs7QUFFQSxLQUFLLEtBQUs7QUFDVjtBQUNBOztBQUVBLEtBQUssS0FBSztBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixLQUFLOztBQUV0QjtBQUNBOztBQUVBLHFEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsYUFBYTs7QUFFbkI7O0FBRUEsdUJBQXVCLHNCQUFjOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBLFVBQVUsS0FBSztBQUNmO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0EsVUFBVSxvQkFBb0IsQ0FBQyxjQUFjO0FBQzdDOztBQUVBLGVBQWUsV0FBVztBQUMxQjtBQUNBOztBQUVBLFNBQVMsS0FBSztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxvQ0FBb0MsS0FBSzs7QUFFekMsd0RBQXdELHNCQUFzQjtBQUM5RTtBQUNBLFFBQVEsb0JBQW9CLENBQUMsY0FBYztBQUMzQzs7QUFFQTtBQUNBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsS0FBSzs7QUFFNUM7O0FBRUE7QUFDQSxNQUFNLE1BQU07QUFDWjtBQUNBLGlCQUFpQixpQkFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGVBQVUsa0JBQWtCLGVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGVBQVU7QUFDcEI7QUFDQSxDQUFDLENBQUMsRUFBQzs7Ozs7QUNsTzZCO0FBQ0k7QUFDRjtBQUNJO0FBQ1M7O0FBRS9DO0FBQ0EsUUFBUSxJQUFXO0FBQ25CLE9BQU8sR0FBVTtBQUNqQixTQUFTLGNBQVk7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQyxNQUFNO0FBQ047QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0EsQ0FBQzs7QUFFRCxzQ0FBc0MsT0FBTzs7QUFFN0Msc0NBQXNDLEtBQUs7O0FBRTNDLCtDQUFlO0FBQ2Y7QUFDQSxlQUFlLEtBQUs7O0FBRXBCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFVLHFCQUFxQixHQUFHO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQzlFWTs7QUFFa0M7QUFDRjtBQUNEO0FBQ1c7QUFDSjtBQUNKOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0JBQWE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDZTtBQUNmOztBQUVBLG1CQUFtQixpQkFBWTs7QUFFL0I7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixRQUFRLDhCQUE4QixZQUFROztBQUVoRTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFZOztBQUVuQztBQUNBLEdBQUc7QUFDSCxTQUFTLFFBQVE7QUFDakI7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFZO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQ2hGYTs7QUFFMEI7QUFDUTs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBVTtBQUMxQjtBQUNBLFFBQVEsZUFBVTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyw2QkFBNkIsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxlQUFVLDhCQUE4QixlQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQVUseUNBQXlDLGVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBVSwwQkFBMEIsZUFBVTtBQUM5RDtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWU7QUFDZjtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7QUNsR1c7O0FBRXFCO0FBQ1k7QUFDVztBQUNOO0FBQ1I7QUFDSTtBQUNDO0FBQ0g7O0FBRTdDLE1BQU0sZ0JBQVUsR0FBRyxTQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBa0I7QUFDckMsb0JBQW9CLHVCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGFBQWEsV0FBVzs7QUFFeEIsV0FBVyx5Q0FBeUM7O0FBRXBEO0FBQ0EsTUFBTSxTQUFTO0FBQ2YsMkJBQTJCLGdCQUFVLGNBQWMsZ0JBQVU7QUFDN0QsMkJBQTJCLGdCQUFVLGNBQWMsZ0JBQVU7QUFDN0QsNkJBQTZCLGdCQUFVLGNBQWMsZ0JBQVU7QUFDL0QsT0FBTztBQUNQOztBQUVBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVEsU0FBUztBQUNqQixrQkFBa0IsZ0JBQVU7QUFDNUIscUJBQXFCLGdCQUFVO0FBQy9CLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLElBQUksU0FBUztBQUNiLGVBQWUsZ0JBQVU7QUFDekIscUJBQXFCLGdCQUFVO0FBQy9CLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQVk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVztBQUN4QixxQkFBcUIsYUFBYTtBQUNsQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLFdBQVcsYUFBYTtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsaURBQWUsS0FBSyxFQUFDOzs7QUNqUFI7O0FBRWtDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG9CQUFhO0FBQ3RDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUFlLFdBQVcsRUFBQzs7O0FDdElkOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7OztBQzNCYTs7QUFFcUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ2U7QUFDZixTQUFTLEtBQUs7QUFDZDs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCw2REFBZSxjQUFjLEVBQUM7OztBQ3RFakI7O0FBRWtCO0FBQ007QUFDRDtBQUNZO0FBQ0w7QUFDYztBQUNIO0FBQ0o7QUFDTjtBQUNOO0FBQ1c7QUFDSDtBQUNMO0FBQ1k7QUFDSDtBQUNKO0FBQ1c7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCLFVBQUs7QUFDM0IsbUJBQW1CLElBQUksQ0FBQyxVQUFLOztBQUU3QjtBQUNBLEVBQUUsS0FBSyxrQkFBa0IsVUFBSyxzQkFBc0IsaUJBQWlCOztBQUVyRTtBQUNBLEVBQUUsS0FBSyxrQ0FBa0MsaUJBQWlCOztBQUUxRDtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixZQUFROztBQUVyQztBQUNBLGNBQWMsVUFBSzs7QUFFbkI7QUFDQSxzQkFBc0Isb0JBQWE7QUFDbkMsb0JBQW9CLGtCQUFXO0FBQy9CLGlCQUFpQixRQUFRO0FBQ3pCLGdCQUFnQixPQUFPO0FBQ3ZCLG1CQUFtQixrQkFBVTs7QUFFN0I7QUFDQSxtQkFBbUIsZUFBVTs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQU07O0FBRXJCO0FBQ0EscUJBQXFCLFlBQVk7O0FBRWpDO0FBQ0Esb0JBQW9CLFdBQVc7O0FBRS9CLHFCQUFxQixpQkFBWTs7QUFFakMsNEJBQTRCLHNCQUFjLENBQUMsS0FBSzs7QUFFaEQsbUJBQW1CLFFBQVE7O0FBRTNCLHVCQUF1QixzQkFBYzs7QUFFckM7O0FBRUE7QUFDQSxnREFBZSxLQUFLOzs7QUN4RnBCO0FBQzBCO0FBQ25CO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHFCQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFLLFFBQVEsb0JBQW9CO0FBQ3hFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFLLFFBQVEsb0JBQW9CO0FBQ3hFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQixvQkFBb0Isb0JBQW9CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQSwrQkFBK0IsU0FBSyxTQUFTLG9CQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQSwrQkFBK0IsU0FBSyxTQUFTLG9CQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQUssUUFBUSxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQUssUUFBUSxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHNCQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxZQUFZLDJCQUEyQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ29EO0FBQzdDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVLFlBQVksV0FBVztBQUNsRixtREFBbUQsU0FBUyxJQUFJLGNBQWM7QUFDOUU7QUFDQTtBQUNBOzs7QUM1RkE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsWUFBWTtBQUNsRjtBQUNBLHdFQUF3RSxZQUFZLFVBQVUsYUFBYTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakZBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUN4QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBZSxlQUFlLEVBQUM7OztBQ3RFQTtBQUM2Qjs7O0FDRDVEO0FBQzZEO0FBQ2hDO0FBQ3FCO0FBQ0k7QUFDUDtBQUNTO0FBQ0k7QUFDYjtBQUMvQztBQUNBO0FBQ0EsSUFBSSxzQkFBRztBQUNQO0FBQ0E7QUFDQSxpQ0FBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUMsZ0NBQWdDLFlBQVk7QUFDNUMsOEJBQThCLFVBQVU7QUFDeEM7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQUc7QUFDZjtBQUNBLFFBQVEsc0JBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFHO0FBQ2Ysb0JBQW9CLGdDQUFhO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxRQUFRLHNCQUFHO0FBQ1g7QUFDQSxnQkFBZ0Isc0JBQUc7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsZ0NBQWEsR0FBRztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBWSxDQUFDLHNCQUFHO0FBQ2xDLGtCQUFrQixzQkFBWSxDQUFDLHNCQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBUztBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQyxtQkFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZLEtBQXNDLEVBQUU7QUFBQSxFQUUzQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQUc7QUFDL0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQyxzQkFBc0IsY0FBYztBQUNwQyxzQkFBc0IsbUJBQW1CO0FBQ3pDLHNCQUFzQixhQUFhO0FBQ25DLHNCQUFzQixjQUFjO0FBQ3BDLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEMsc0JBQXNCLHFCQUFxQjtBQUMzQyxzQkFBc0Isd0JBQXdCO0FBQzlDLHNCQUFzQixtQkFBbUI7QUFDekMsc0JBQXNCLG1CQUFtQjtBQUN6QyxzQkFBc0IsZ0JBQWdCO0FBQ3RDLHNCQUFzQixpQkFBaUI7QUFDdkMsc0JBQXNCLG1CQUFtQjtBQUN6QyxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQix1QkFBSTtBQUN6QixRQUFRLHVCQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBTztBQUNmLDhCQUE4QixtQkFBUyxDQUFDLHNCQUFHO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUSwwQkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsMEJBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRLDBCQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSwwQkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUSwwQkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsMEJBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaLFFBQVEsMEJBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRLDBCQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRLDBCQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSwwQkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1osUUFBUSwwQkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQWUsZ0NBQWdDLE9BQU8sSUFBSSxTQUFTO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRLDBCQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSwwQkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQWUscUNBQXFDLE9BQU87QUFDNUYsMkRBQTJELFFBQVE7QUFDbkU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVEsMEJBQU87QUFDZjtBQUNBLFNBQVM7QUFDVCxRQUFRLDBCQUFPO0FBQ2Y7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC91dGlscy9Db25zdGFudHMubWpzP2FkZjgiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L3V0aWxzL0NvbnN0YW50cy5tanM/MmJjMSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9lcnJvci9BdXRoRXJyb3JDb2Rlcy5tanM/MTVlMyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9lcnJvci9BdXRoRXJyb3IubWpzPzY2MTMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvdGVsZW1ldHJ5L3NlcnZlci9TZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLm1qcz80MGYxIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2NvbnN0YW50cy9BQURTZXJ2ZXJQYXJhbUtleXMubWpzP2MzOWUiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvZXJyb3IvU2VydmVyRXJyb3IubWpzP2YyZWQiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvbG9nZ2VyL0xvZ2dlci5tanM/M2JkYyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9hdXRob3JpdHkvQXV0aG9yaXR5VHlwZS5tanM/NzFmMyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9hdXRob3JpdHkvT3BlbklkQ29uZmlnUmVzcG9uc2UubWpzP2FiYzkiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWpzPzFhZjgiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yLm1qcz9jYTg3Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L3V0aWxzL1N0cmluZ1V0aWxzLm1qcz84ZWZiIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2Vycm9yL0NsaWVudEF1dGhFcnJvckNvZGVzLm1qcz8zOTU1Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanM/ZTNkNyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC91dGlscy9VcmxVdGlscy5tanM/MmY2YyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC91cmwvVXJsU3RyaW5nLm1qcz9kNzhmIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2F1dGhvcml0eS9BdXRob3JpdHlNZXRhZGF0YS5tanM/MjhlNyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9hdXRob3JpdHkvUHJvdG9jb2xNb2RlLm1qcz84YjkzIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2F1dGhvcml0eS9BdXRob3JpdHlPcHRpb25zLm1qcz9iMzM2Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2F1dGhvcml0eS9DbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2UubWpzP2UzZmYiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvYXV0aG9yaXR5L0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlLm1qcz9iNzg0Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9QZXJmb3JtYW5jZUV2ZW50Lm1qcz81NzEwIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L3V0aWxzL0Z1bmN0aW9uV3JhcHBlcnMubWpzPzg4Y2UiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvYXV0aG9yaXR5L1JlZ2lvbkRpc2NvdmVyeS5tanM/MDJhYiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9hY2NvdW50L0F1dGhUb2tlbi5tanM/NTg5YSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC91dGlscy9UaW1lVXRpbHMubWpzP2I3YmEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvY2FjaGUvdXRpbHMvQ2FjaGVIZWxwZXJzLm1qcz8wMzBjIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2F1dGhvcml0eS9BdXRob3JpdHkubWpzPzMxNmIiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvY3J5cHRvL0lDcnlwdG8ubWpzPzcxNmMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvcGFja2FnZU1ldGFkYXRhLm1qcz8zNDhkIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L3JlcXVlc3QvU2NvcGVTZXQubWpzP2I0Y2IiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvYWNjb3VudC9DbGllbnRJbmZvLm1qcz9mODAzIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2FjY291bnQvQWNjb3VudEluZm8ubWpzPzRjNTciLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvYWNjb3VudC9Ub2tlbkNsYWltcy5tanM/ZGQ5NCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9jYWNoZS9lbnRpdGllcy9BY2NvdW50RW50aXR5Lm1qcz85MThlIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2Vycm9yL0NhY2hlRXJyb3JDb2Rlcy5tanM/NmZmOCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9lcnJvci9DYWNoZUVycm9yLm1qcz9kMDdhIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2NhY2hlL0NhY2hlTWFuYWdlci5tanM/NDk4NiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9jb25maWcvQ2xpZW50Q29uZmlndXJhdGlvbi5tanM/NzhmNyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9hY2NvdW50L0Njc0NyZWRlbnRpYWwubWpzPzJmMjYiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvcmVxdWVzdC9SZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5tanM/ZDQ0MSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9hdXRob3JpdHkvQXV0aG9yaXR5RmFjdG9yeS5tanM/MGE1NSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9uZXR3b3JrL1JlcXVlc3RUaHVtYnByaW50Lm1qcz82ZmMyIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L25ldHdvcmsvVGhyb3R0bGluZ1V0aWxzLm1qcz8yMzFiIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2Vycm9yL05ldHdvcmtFcnJvci5tanM/MmVjMiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9jbGllbnQvQmFzZUNsaWVudC5tanM/NjJjYSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9lcnJvci9JbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMubWpzPzk2ZTciLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvZXJyb3IvSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci5tanM/NDUyOSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC91dGlscy9Qcm90b2NvbFV0aWxzLm1qcz8wMDdhIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2NyeXB0by9Qb3BUb2tlbkdlbmVyYXRvci5tanM/YWU4ZSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9jYWNoZS9wZXJzaXN0ZW5jZS9Ub2tlbkNhY2hlQ29udGV4dC5tanM/Yjc2ZCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9yZXNwb25zZS9SZXNwb25zZUhhbmRsZXIubWpzP2QwMWIiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtY29tbW9uL2Rpc3QvcmVxdWVzdC9SZXF1ZXN0VmFsaWRhdG9yLm1qcz9hYmYxIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L3V0aWxzL0NsaWVudEFzc2VydGlvblV0aWxzLm1qcz85NTQ4Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2NsaWVudC9BdXRob3JpemF0aW9uQ29kZUNsaWVudC5tanM/N2IwOCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1jb21tb24vZGlzdC9jbGllbnQvUmVmcmVzaFRva2VuQ2xpZW50Lm1qcz9iNjM0Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L2NsaWVudC9TaWxlbnRGbG93Q2xpZW50Lm1qcz81NzZhIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC91dGlscy9OZXR3b3JrVXRpbHMubWpzP2M2OTYiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L25ldHdvcmsvSHR0cENsaWVudC5tanM/MmI1ZCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvZXJyb3IvTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5tanM/NTQ5ZSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvZXJyb3IvTWFuYWdlZElkZW50aXR5RXJyb3IubWpzPzc2ZDMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NvbmZpZy9NYW5hZ2VkSWRlbnRpdHlJZC5tanM/N2I4NCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvZXJyb3IvTm9kZUF1dGhFcnJvci5tanM/NTAxMSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvY29uZmlnL0NvbmZpZ3VyYXRpb24ubWpzP2MwOGMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcz8wMGJhIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcz8zODhiIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcz8yNTRiIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanM/ZjE4MSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanM/OTBmNSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvY3J5cHRvL0d1aWRHZW5lcmF0b3IubWpzPzlhMjkiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L3V0aWxzL0VuY29kaW5nVXRpbHMubWpzPzI2OGEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NyeXB0by9IYXNoVXRpbHMubWpzPzU5MTQiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NyeXB0by9Qa2NlR2VuZXJhdG9yLm1qcz80ZDA5Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jcnlwdG8vQ3J5cHRvUHJvdmlkZXIubWpzPzY1ZGEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NhY2hlL3NlcmlhbGl6ZXIvRGVzZXJpYWxpemVyLm1qcz85YThlIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jYWNoZS9zZXJpYWxpemVyL1NlcmlhbGl6ZXIubWpzPzc3MzAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NhY2hlL05vZGVTdG9yYWdlLm1qcz9iMTE4Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jYWNoZS9Ub2tlbkNhY2hlLm1qcz9hZjgwIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvQ2xpZW50QXNzZXJ0aW9uLm1qcz80OTIyIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9wYWNrYWdlTWV0YWRhdGEubWpzP2U1YWYiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NsaWVudC9Vc2VybmFtZVBhc3N3b3JkQ2xpZW50Lm1qcz9iYjAwIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLWNvbW1vbi9kaXN0L3Byb3RvY29sL0F1dGhvcml6ZS5tanM/MGU4NCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvcHJvdG9jb2wvQXV0aG9yaXplLm1qcz82NjlhIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvQ2xpZW50QXBwbGljYXRpb24ubWpzPzJkNDMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L25ldHdvcmsvTG9vcGJhY2tDbGllbnQubWpzPzU0NmUiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NsaWVudC9EZXZpY2VDb2RlQ2xpZW50Lm1qcz80MDRhIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvUHVibGljQ2xpZW50QXBwbGljYXRpb24ubWpzP2Q5ZDgiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NsaWVudC9DbGllbnRDcmVkZW50aWFsQ2xpZW50Lm1qcz8yMmE2Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvT25CZWhhbGZPZkNsaWVudC5tanM/MTQxOSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvY2xpZW50L0NvbmZpZGVudGlhbENsaWVudEFwcGxpY2F0aW9uLm1qcz8zMjg1Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC91dGlscy9UaW1lVXRpbHMubWpzP2Q5NWEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L25ldHdvcmsvSHR0cENsaWVudFdpdGhSZXRyaWVzLm1qcz81Njc4Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvTWFuYWdlZElkZW50aXR5U291cmNlcy9CYXNlTWFuYWdlZElkZW50aXR5U291cmNlLm1qcz8wZGViIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9yZXRyeS9MaW5lYXJSZXRyeVN0cmF0ZWd5Lm1qcz9hOTY3Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9yZXRyeS9EZWZhdWx0TWFuYWdlZElkZW50aXR5UmV0cnlQb2xpY3kubWpzPzU2NTMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NvbmZpZy9NYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycy5tanM/ZmIzOCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvY2xpZW50L01hbmFnZWRJZGVudGl0eVNvdXJjZXMvQXBwU2VydmljZS5tanM/NDkwNSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvY2xpZW50L01hbmFnZWRJZGVudGl0eVNvdXJjZXMvQXp1cmVBcmMubWpzPzljYWUiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NsaWVudC9NYW5hZ2VkSWRlbnRpdHlTb3VyY2VzL0Nsb3VkU2hlbGwubWpzPzEwMmIiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L3JldHJ5L0V4cG9uZW50aWFsUmV0cnlTdHJhdGVneS5tanM/NzhjMSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvcmV0cnkvSW1kc1JldHJ5UG9saWN5Lm1qcz81ZmMyIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvTWFuYWdlZElkZW50aXR5U291cmNlcy9JbWRzLm1qcz9jMmU3Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvTWFuYWdlZElkZW50aXR5U291cmNlcy9TZXJ2aWNlRmFicmljLm1qcz8yMDBjIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BhenVyZS9tc2FsLW5vZGUvZGlzdC9jbGllbnQvTWFuYWdlZElkZW50aXR5U291cmNlcy9NYWNoaW5lTGVhcm5pbmcubWpzPzgzYTAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NsaWVudC9NYW5hZ2VkSWRlbnRpdHlDbGllbnQubWpzPzljZTAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQGF6dXJlL21zYWwtbm9kZS9kaXN0L2NsaWVudC9NYW5hZ2VkSWRlbnRpdHlBcHBsaWNhdGlvbi5tanM/YWJiOCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AYXp1cmUvbXNhbC1ub2RlL2Rpc3QvaW5kZXgubWpzPzA1NDMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9zcmMvYXV0aC9BdXRoU2VydmljZS50cz8zYmQzIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vc3JjL3NoYXJlZC9Qcm9maWxlUGhvdG9TZXJ2aWNlLnRzPzBhNGMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9zcmMvc2hhcmVkL0dyYXBoU2VydmljZS50cz83OWVlIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanM/OWQ1ZiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanM/ZDhlZSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzP2M4MTAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL25vZGUvY2xhc3Nlcy9Gb3JtRGF0YS5qcz9iYjZmIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanM/YmY3OCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcz9jMmQ1Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzPzBjNmMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzP2Y4MGQiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcz9kZjNjIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzP2IwMTIiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL25vZGUvaW5kZXguanM/MzJkYyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vY29tbW9uL3V0aWxzLmpzPzNmOWIiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3BsYXRmb3JtL2luZGV4LmpzPzFkMTUiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcz9hMGI1Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzP2NkN2UiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzPzBiYWEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzP2QxMWMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NIZWFkZXJzLmpzPzEzYjciLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcz80OTQ4Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanM/ZjkxZSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanM/MjEzYSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanM/MGFlMiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzPzBhOTAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanM/OGY4ZSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzP2ViY2IiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInpsaWJcIj8xZWNjIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qcz8zOTc2Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanM/YTUyYiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9mcm9tRGF0YVVSSS5qcz8zMTM2Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL0F4aW9zVHJhbnNmb3JtU3RyZWFtLmpzPzc4YTAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImV2ZW50c1wiP2Q5MmMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcmVhZEJsb2IuanM/YThkOCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9mb3JtRGF0YVRvU3RyZWFtLmpzP2RiNmEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvWmxpYkhlYWRlclRyYW5zZm9ybVN0cmVhbS5qcz8wYWNmIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NhbGxiYWNraWZ5LmpzPzU2N2IiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanM/Yjc3ZSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy90aHJvdHRsZS5qcz9hYWQ1Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzP2Y4NWYiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL2h0dHAuanM/YTRlYyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanM/ODkwNSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzP2Y2MmEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanM/MGJhNyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzPzVlOTAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz85YzA3Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbXBvc2VTaWduYWxzLmpzP2FlYzAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdHJhY2tTdHJlYW0uanM/OGQzOSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMvZmV0Y2guanM/MzA4YyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMvYWRhcHRlcnMuanM/Yzc4YyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanM/ODU2NSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanM/NDY4MCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcz9mZTJjIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanM/NjAwNiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanM/OTM2NCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanM/ZWRiZSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcz9mOGJjIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcz9hYTZkIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vc3JjL2xsbS9MTE1TZXJ2aWNlLnRzPzllOGMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9zcmMvbWNwL21vY2svbW9jay1tY3Atc2RrLnRzPzBmNzkiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9zcmMvbWNwL2NsaWVudHMvTUNQU0RLQ2xpZW50LnRzPzczYzgiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9zcmMvbWNwL2F1dGgvTUNQQXV0aFNlcnZpY2UudHM/NDRjOCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL3NyYy9tY3AvdXRpbHMvRXJyb3JIYW5kbGVyLnRzPzcxMmUiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9zcmMvbWNwL3V0aWxzL2luZGV4LnRzP2FkNzkiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9zcmMvbWFpbi9tYWluLnRzPzI4MTciXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBDb25zdGFudHMgPSB7XHJcbiAgICBMSUJSQVJZX05BTUU6IFwiTVNBTC5KU1wiLFxyXG4gICAgU0tVOiBcIm1zYWwuanMuY29tbW9uXCIsXHJcbiAgICAvLyBQcmVmaXggZm9yIGFsbCBsaWJyYXJ5IGNhY2hlIGVudHJpZXNcclxuICAgIENBQ0hFX1BSRUZJWDogXCJtc2FsXCIsXHJcbiAgICAvLyBkZWZhdWx0IGF1dGhvcml0eVxyXG4gICAgREVGQVVMVF9BVVRIT1JJVFk6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi9cIixcclxuICAgIERFRkFVTFRfQVVUSE9SSVRZX0hPU1Q6IFwibG9naW4ubWljcm9zb2Z0b25saW5lLmNvbVwiLFxyXG4gICAgREVGQVVMVF9DT01NT05fVEVOQU5UOiBcImNvbW1vblwiLFxyXG4gICAgLy8gQURGUyBTdHJpbmdcclxuICAgIEFERlM6IFwiYWRmc1wiLFxyXG4gICAgRFNUUzogXCJkc3RzdjJcIixcclxuICAgIC8vIERlZmF1bHQgQUFEIEluc3RhbmNlIERpc2NvdmVyeSBFbmRwb2ludFxyXG4gICAgQUFEX0lOU1RBTkNFX0RJU0NPVkVSWV9FTkRQVDogXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vY29tbW9uL2Rpc2NvdmVyeS9pbnN0YW5jZT9hcGktdmVyc2lvbj0xLjEmYXV0aG9yaXphdGlvbl9lbmRwb2ludD1cIixcclxuICAgIC8vIENJQU0gVVJMXHJcbiAgICBDSUFNX0FVVEhfVVJMOiBcIi5jaWFtbG9naW4uY29tXCIsXHJcbiAgICBBQURfVEVOQU5UX0RPTUFJTl9TVUZGSVg6IFwiLm9ubWljcm9zb2Z0LmNvbVwiLFxyXG4gICAgLy8gUmVzb3VyY2UgZGVsaW1pdGVyIC0gdXNlZCBmb3IgY2VydGFpbiBjYWNoZSBlbnRyaWVzXHJcbiAgICBSRVNPVVJDRV9ERUxJTTogXCJ8XCIsXHJcbiAgICAvLyBQbGFjZWhvbGRlciBmb3Igbm9uLWV4aXN0ZW50IGFjY291bnQgaWRzL29iamVjdHNcclxuICAgIE5PX0FDQ09VTlQ6IFwiTk9fQUNDT1VOVFwiLFxyXG4gICAgLy8gQ2xhaW1zXHJcbiAgICBDTEFJTVM6IFwiY2xhaW1zXCIsXHJcbiAgICAvLyBDb25zdW1lciBVVElEXHJcbiAgICBDT05TVU1FUl9VVElEOiBcIjkxODgwNDBkLTZjNjctNGM1Yi1iMTEyLTM2YTMwNGI2NmRhZFwiLFxyXG4gICAgLy8gRGVmYXVsdCBzY29wZXNcclxuICAgIE9QRU5JRF9TQ09QRTogXCJvcGVuaWRcIixcclxuICAgIFBST0ZJTEVfU0NPUEU6IFwicHJvZmlsZVwiLFxyXG4gICAgT0ZGTElORV9BQ0NFU1NfU0NPUEU6IFwib2ZmbGluZV9hY2Nlc3NcIixcclxuICAgIEVNQUlMX1NDT1BFOiBcImVtYWlsXCIsXHJcbiAgICBDT0RFX0dSQU5UX1RZUEU6IFwiYXV0aG9yaXphdGlvbl9jb2RlXCIsXHJcbiAgICBSVF9HUkFOVF9UWVBFOiBcInJlZnJlc2hfdG9rZW5cIixcclxuICAgIFMyNTZfQ09ERV9DSEFMTEVOR0VfTUVUSE9EOiBcIlMyNTZcIixcclxuICAgIFVSTF9GT1JNX0NPTlRFTlRfVFlQRTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOFwiLFxyXG4gICAgQVVUSE9SSVpBVElPTl9QRU5ESU5HOiBcImF1dGhvcml6YXRpb25fcGVuZGluZ1wiLFxyXG4gICAgTk9UX0RFRklORUQ6IFwibm90X2RlZmluZWRcIixcclxuICAgIEVNUFRZX1NUUklORzogXCJcIixcclxuICAgIE5PVF9BUFBMSUNBQkxFOiBcIk4vQVwiLFxyXG4gICAgTk9UX0FWQUlMQUJMRTogXCJOb3QgQXZhaWxhYmxlXCIsXHJcbiAgICBGT1JXQVJEX1NMQVNIOiBcIi9cIixcclxuICAgIElNRFNfRU5EUE9JTlQ6IFwiaHR0cDovLzE2OS4yNTQuMTY5LjI1NC9tZXRhZGF0YS9pbnN0YW5jZS9jb21wdXRlL2xvY2F0aW9uXCIsXHJcbiAgICBJTURTX1ZFUlNJT046IFwiMjAyMC0wNi0wMVwiLFxyXG4gICAgSU1EU19USU1FT1VUOiAyMDAwLFxyXG4gICAgQVpVUkVfUkVHSU9OX0FVVE9fRElTQ09WRVJfRkxBRzogXCJUcnlBdXRvRGV0ZWN0XCIsXHJcbiAgICBSRUdJT05BTF9BVVRIX1BVQkxJQ19DTE9VRF9TVUZGSVg6IFwibG9naW4ubWljcm9zb2Z0LmNvbVwiLFxyXG4gICAgS05PV05fUFVCTElDX0NMT1VEUzogW1xyXG4gICAgICAgIFwibG9naW4ubWljcm9zb2Z0b25saW5lLmNvbVwiLFxyXG4gICAgICAgIFwibG9naW4ud2luZG93cy5uZXRcIixcclxuICAgICAgICBcImxvZ2luLm1pY3Jvc29mdC5jb21cIixcclxuICAgICAgICBcInN0cy53aW5kb3dzLm5ldFwiLFxyXG4gICAgXSxcclxuICAgIFNIUl9OT05DRV9WQUxJRElUWTogMjQwLFxyXG4gICAgSU5WQUxJRF9JTlNUQU5DRTogXCJpbnZhbGlkX2luc3RhbmNlXCIsXHJcbn07XHJcbmNvbnN0IEh0dHBTdGF0dXMgPSB7XHJcbiAgICBTVUNDRVNTOiAyMDAsXHJcbiAgICBTVUNDRVNTX1JBTkdFX1NUQVJUOiAyMDAsXHJcbiAgICBTVUNDRVNTX1JBTkdFX0VORDogMjk5LFxyXG4gICAgUkVESVJFQ1Q6IDMwMixcclxuICAgIENMSUVOVF9FUlJPUjogNDAwLFxyXG4gICAgQ0xJRU5UX0VSUk9SX1JBTkdFX1NUQVJUOiA0MDAsXHJcbiAgICBCQURfUkVRVUVTVDogNDAwLFxyXG4gICAgVU5BVVRIT1JJWkVEOiA0MDEsXHJcbiAgICBOT1RfRk9VTkQ6IDQwNCxcclxuICAgIFJFUVVFU1RfVElNRU9VVDogNDA4LFxyXG4gICAgR09ORTogNDEwLFxyXG4gICAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcclxuICAgIENMSUVOVF9FUlJPUl9SQU5HRV9FTkQ6IDQ5OSxcclxuICAgIFNFUlZFUl9FUlJPUjogNTAwLFxyXG4gICAgU0VSVkVSX0VSUk9SX1JBTkdFX1NUQVJUOiA1MDAsXHJcbiAgICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXHJcbiAgICBHQVRFV0FZX1RJTUVPVVQ6IDUwNCxcclxuICAgIFNFUlZFUl9FUlJPUl9SQU5HRV9FTkQ6IDU5OSxcclxuICAgIE1VTFRJX1NJREVEX0VSUk9SOiA2MDAsXHJcbn07XHJcbmNvbnN0IE9JRENfREVGQVVMVF9TQ09QRVMgPSBbXHJcbiAgICBDb25zdGFudHMuT1BFTklEX1NDT1BFLFxyXG4gICAgQ29uc3RhbnRzLlBST0ZJTEVfU0NPUEUsXHJcbiAgICBDb25zdGFudHMuT0ZGTElORV9BQ0NFU1NfU0NPUEUsXHJcbl07XHJcbmNvbnN0IE9JRENfU0NPUEVTID0gWy4uLk9JRENfREVGQVVMVF9TQ09QRVMsIENvbnN0YW50cy5FTUFJTF9TQ09QRV07XHJcbi8qKlxyXG4gKiBSZXF1ZXN0IGhlYWRlciBuYW1lc1xyXG4gKi9cclxuY29uc3QgSGVhZGVyTmFtZXMgPSB7XHJcbiAgICBDT05URU5UX1RZUEU6IFwiQ29udGVudC1UeXBlXCIsXHJcbiAgICBDT05URU5UX0xFTkdUSDogXCJDb250ZW50LUxlbmd0aFwiLFxyXG4gICAgUkVUUllfQUZURVI6IFwiUmV0cnktQWZ0ZXJcIixcclxuICAgIENDU19IRUFERVI6IFwiWC1BbmNob3JNYWlsYm94XCIsXHJcbiAgICBXV1dBdXRoZW50aWNhdGU6IFwiV1dXLUF1dGhlbnRpY2F0ZVwiLFxyXG4gICAgQXV0aGVudGljYXRpb25JbmZvOiBcIkF1dGhlbnRpY2F0aW9uLUluZm9cIixcclxuICAgIFhfTVNfUkVRVUVTVF9JRDogXCJ4LW1zLXJlcXVlc3QtaWRcIixcclxuICAgIFhfTVNfSFRUUF9WRVJTSU9OOiBcIngtbXMtaHR0cHZlclwiLFxyXG59O1xyXG4vKipcclxuICogUGVyc2lzdGVudCBjYWNoZSBrZXlzIE1TQUwgd2hpY2ggc3RheSB3aGlsZSB1c2VyIGlzIGxvZ2dlZCBpbi5cclxuICovXHJcbmNvbnN0IFBlcnNpc3RlbnRDYWNoZUtleXMgPSB7XHJcbiAgICBBQ1RJVkVfQUNDT1VOVF9GSUxURVJTOiBcImFjdGl2ZS1hY2NvdW50LWZpbHRlcnNcIiwgLy8gbmV3IGNhY2hlIGVudHJ5IGZvciBhY3RpdmVfYWNjb3VudCBmb3IgYSBtb3JlIHJvYnVzdCB2ZXJzaW9uIGZvciBicm93c2VyXHJcbn07XHJcbi8qKlxyXG4gKiBTdHJpbmcgY29uc3RhbnRzIHJlbGF0ZWQgdG8gQUFEIEF1dGhvcml0eVxyXG4gKi9cclxuY29uc3QgQUFEQXV0aG9yaXR5Q29uc3RhbnRzID0ge1xyXG4gICAgQ09NTU9OOiBcImNvbW1vblwiLFxyXG4gICAgT1JHQU5JWkFUSU9OUzogXCJvcmdhbml6YXRpb25zXCIsXHJcbiAgICBDT05TVU1FUlM6IFwiY29uc3VtZXJzXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBDbGFpbXMgcmVxdWVzdCBrZXlzXHJcbiAqL1xyXG5jb25zdCBDbGFpbXNSZXF1ZXN0S2V5cyA9IHtcclxuICAgIEFDQ0VTU19UT0tFTjogXCJhY2Nlc3NfdG9rZW5cIixcclxuICAgIFhNU19DQzogXCJ4bXNfY2NcIixcclxufTtcclxuLyoqXHJcbiAqIHdlIGNvbnNpZGVyZWQgbWFraW5nIHRoaXMgXCJlbnVtXCIgaW4gdGhlIHJlcXVlc3QgaW5zdGVhZCBvZiBzdHJpbmcsIGhvd2V2ZXIgaXQgbG9va3MgbGlrZSB0aGUgYWxsb3dlZCBsaXN0IG9mXHJcbiAqIHByb21wdCB2YWx1ZXMga2VwdCBjaGFuZ2luZyBvdmVyIHBhc3QgY291cGxlIG9mIHllYXJzLiBUaGVyZSBhcmUgc29tZSB1bmRvY3VtZW50ZWQgcHJvbXB0IHZhbHVlcyBmb3Igc29tZVxyXG4gKiBpbnRlcm5hbCBwYXJ0bmVycyB0b28sIGhlbmNlIHRoZSBjaG9pY2Ugb2YgZ2VuZXJpYyBcInN0cmluZ1wiIHR5cGUgaW5zdGVhZCBvZiB0aGUgXCJlbnVtXCJcclxuICovXHJcbmNvbnN0IFByb21wdFZhbHVlID0ge1xyXG4gICAgTE9HSU46IFwibG9naW5cIixcclxuICAgIFNFTEVDVF9BQ0NPVU5UOiBcInNlbGVjdF9hY2NvdW50XCIsXHJcbiAgICBDT05TRU5UOiBcImNvbnNlbnRcIixcclxuICAgIE5PTkU6IFwibm9uZVwiLFxyXG4gICAgQ1JFQVRFOiBcImNyZWF0ZVwiLFxyXG4gICAgTk9fU0VTU0lPTjogXCJub19zZXNzaW9uXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBhbGxvd2VkIHZhbHVlcyBmb3IgY29kZVZlcmlmaWVyXHJcbiAqL1xyXG5jb25zdCBDb2RlQ2hhbGxlbmdlTWV0aG9kVmFsdWVzID0ge1xyXG4gICAgUExBSU46IFwicGxhaW5cIixcclxuICAgIFMyNTY6IFwiUzI1NlwiLFxyXG59O1xyXG4vKipcclxuICogQWxsb3dlZCB2YWx1ZXMgZm9yIHJlc3BvbnNlX3R5cGVcclxuICovXHJcbmNvbnN0IE9BdXRoUmVzcG9uc2VUeXBlID0ge1xyXG4gICAgQ09ERTogXCJjb2RlXCIsXHJcbiAgICBJRFRPS0VOX1RPS0VOOiBcImlkX3Rva2VuIHRva2VuXCIsXHJcbiAgICBJRFRPS0VOX1RPS0VOX1JFRlJFU0hUT0tFTjogXCJpZF90b2tlbiB0b2tlbiByZWZyZXNoX3Rva2VuXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBhbGxvd2VkIHZhbHVlcyBmb3Igc2VydmVyIHJlc3BvbnNlIHR5cGVcclxuICogQGRlcHJlY2F0ZWQgVXNlIFJlc3BvbnNlTW9kZSBpbnN0ZWFkXHJcbiAqL1xyXG5jb25zdCBTZXJ2ZXJSZXNwb25zZVR5cGUgPSB7XHJcbiAgICBRVUVSWTogXCJxdWVyeVwiLFxyXG4gICAgRlJBR01FTlQ6IFwiZnJhZ21lbnRcIixcclxufTtcclxuLyoqXHJcbiAqIGFsbG93ZWQgdmFsdWVzIGZvciByZXNwb25zZV9tb2RlXHJcbiAqL1xyXG5jb25zdCBSZXNwb25zZU1vZGUgPSB7XHJcbiAgICBRVUVSWTogXCJxdWVyeVwiLFxyXG4gICAgRlJBR01FTlQ6IFwiZnJhZ21lbnRcIixcclxuICAgIEZPUk1fUE9TVDogXCJmb3JtX3Bvc3RcIixcclxufTtcclxuLyoqXHJcbiAqIGFsbG93ZWQgZ3JhbnRfdHlwZVxyXG4gKi9cclxuY29uc3QgR3JhbnRUeXBlID0ge1xyXG4gICAgSU1QTElDSVRfR1JBTlQ6IFwiaW1wbGljaXRcIixcclxuICAgIEFVVEhPUklaQVRJT05fQ09ERV9HUkFOVDogXCJhdXRob3JpemF0aW9uX2NvZGVcIixcclxuICAgIENMSUVOVF9DUkVERU5USUFMU19HUkFOVDogXCJjbGllbnRfY3JlZGVudGlhbHNcIixcclxuICAgIFJFU09VUkNFX09XTkVSX1BBU1NXT1JEX0dSQU5UOiBcInBhc3N3b3JkXCIsXHJcbiAgICBSRUZSRVNIX1RPS0VOX0dSQU5UOiBcInJlZnJlc2hfdG9rZW5cIixcclxuICAgIERFVklDRV9DT0RFX0dSQU5UOiBcImRldmljZV9jb2RlXCIsXHJcbiAgICBKV1RfQkVBUkVSOiBcInVybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmp3dC1iZWFyZXJcIixcclxufTtcclxuLyoqXHJcbiAqIEFjY291bnQgdHlwZXMgaW4gQ2FjaGVcclxuICovXHJcbmNvbnN0IENhY2hlQWNjb3VudFR5cGUgPSB7XHJcbiAgICBNU1NUU19BQ0NPVU5UX1RZUEU6IFwiTVNTVFNcIixcclxuICAgIEFERlNfQUNDT1VOVF9UWVBFOiBcIkFERlNcIixcclxuICAgIE1TQVYxX0FDQ09VTlRfVFlQRTogXCJNU0FcIixcclxuICAgIEdFTkVSSUNfQUNDT1VOVF9UWVBFOiBcIkdlbmVyaWNcIiwgLy8gTlRMTSwgS2VyYmVyb3MsIEZCQSwgQmFzaWMgZXRjXHJcbn07XHJcbi8qKlxyXG4gKiBTZXBhcmF0b3JzIHVzZWQgaW4gY2FjaGVcclxuICovXHJcbmNvbnN0IFNlcGFyYXRvcnMgPSB7XHJcbiAgICBDQUNIRV9LRVlfU0VQQVJBVE9SOiBcIi1cIixcclxuICAgIENMSUVOVF9JTkZPX1NFUEFSQVRPUjogXCIuXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBDcmVkZW50aWFsIFR5cGUgc3RvcmVkIGluIHRoZSBjYWNoZVxyXG4gKi9cclxuY29uc3QgQ3JlZGVudGlhbFR5cGUgPSB7XHJcbiAgICBJRF9UT0tFTjogXCJJZFRva2VuXCIsXHJcbiAgICBBQ0NFU1NfVE9LRU46IFwiQWNjZXNzVG9rZW5cIixcclxuICAgIEFDQ0VTU19UT0tFTl9XSVRIX0FVVEhfU0NIRU1FOiBcIkFjY2Vzc1Rva2VuX1dpdGhfQXV0aFNjaGVtZVwiLFxyXG4gICAgUkVGUkVTSF9UT0tFTjogXCJSZWZyZXNoVG9rZW5cIixcclxufTtcclxuLyoqXHJcbiAqIENvbWJpbmUgYWxsIGNhY2hlIHR5cGVzXHJcbiAqL1xyXG5jb25zdCBDYWNoZVR5cGUgPSB7XHJcbiAgICBBREZTOiAxMDAxLFxyXG4gICAgTVNBOiAxMDAyLFxyXG4gICAgTVNTVFM6IDEwMDMsXHJcbiAgICBHRU5FUklDOiAxMDA0LFxyXG4gICAgQUNDRVNTX1RPS0VOOiAyMDAxLFxyXG4gICAgUkVGUkVTSF9UT0tFTjogMjAwMixcclxuICAgIElEX1RPS0VOOiAyMDAzLFxyXG4gICAgQVBQX01FVEFEQVRBOiAzMDAxLFxyXG4gICAgVU5ERUZJTkVEOiA5OTk5LFxyXG59O1xyXG4vKipcclxuICogTW9yZSBDYWNoZSByZWxhdGVkIGNvbnN0YW50c1xyXG4gKi9cclxuY29uc3QgQVBQX01FVEFEQVRBID0gXCJhcHBtZXRhZGF0YVwiO1xyXG5jb25zdCBDTElFTlRfSU5GTyA9IFwiY2xpZW50X2luZm9cIjtcclxuY29uc3QgVEhFX0ZBTUlMWV9JRCA9IFwiMVwiO1xyXG5jb25zdCBBVVRIT1JJVFlfTUVUQURBVEFfQ09OU1RBTlRTID0ge1xyXG4gICAgQ0FDSEVfS0VZOiBcImF1dGhvcml0eS1tZXRhZGF0YVwiLFxyXG4gICAgUkVGUkVTSF9USU1FX1NFQ09ORFM6IDM2MDAgKiAyNCwgLy8gMjQgSG91cnNcclxufTtcclxuY29uc3QgQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UgPSB7XHJcbiAgICBDT05GSUc6IFwiY29uZmlnXCIsXHJcbiAgICBDQUNIRTogXCJjYWNoZVwiLFxyXG4gICAgTkVUV09SSzogXCJuZXR3b3JrXCIsXHJcbiAgICBIQVJEQ09ERURfVkFMVUVTOiBcImhhcmRjb2RlZF92YWx1ZXNcIixcclxufTtcclxuY29uc3QgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUyA9IHtcclxuICAgIFNDSEVNQV9WRVJTSU9OOiA1LFxyXG4gICAgTUFYX0NVUl9IRUFERVJfQllURVM6IDgwLFxyXG4gICAgTUFYX0xBU1RfSEVBREVSX0JZVEVTOiAzMzAsXHJcbiAgICBNQVhfQ0FDSEVEX0VSUk9SUzogNTAsXHJcbiAgICBDQUNIRV9LRVk6IFwic2VydmVyLXRlbGVtZXRyeVwiLFxyXG4gICAgQ0FURUdPUllfU0VQQVJBVE9SOiBcInxcIixcclxuICAgIFZBTFVFX1NFUEFSQVRPUjogXCIsXCIsXHJcbiAgICBPVkVSRkxPV19UUlVFOiBcIjFcIixcclxuICAgIE9WRVJGTE9XX0ZBTFNFOiBcIjBcIixcclxuICAgIFVOS05PV05fRVJST1I6IFwidW5rbm93bl9lcnJvclwiLFxyXG59O1xyXG4vKipcclxuICogVHlwZSBvZiB0aGUgYXV0aGVudGljYXRpb24gcmVxdWVzdFxyXG4gKi9cclxuY29uc3QgQXV0aGVudGljYXRpb25TY2hlbWUgPSB7XHJcbiAgICBCRUFSRVI6IFwiQmVhcmVyXCIsXHJcbiAgICBQT1A6IFwicG9wXCIsXHJcbiAgICBTU0g6IFwic3NoLWNlcnRcIixcclxufTtcclxuLyoqXHJcbiAqIENvbnN0YW50cyByZWxhdGVkIHRvIHRocm90dGxpbmdcclxuICovXHJcbmNvbnN0IFRocm90dGxpbmdDb25zdGFudHMgPSB7XHJcbiAgICAvLyBEZWZhdWx0IHRpbWUgdG8gdGhyb3R0bGUgUmVxdWVzdFRodW1icHJpbnQgaW4gc2Vjb25kc1xyXG4gICAgREVGQVVMVF9USFJPVFRMRV9USU1FX1NFQ09ORFM6IDYwLFxyXG4gICAgLy8gRGVmYXVsdCBtYXhpbXVtIHRpbWUgdG8gdGhyb3R0bGUgaW4gc2Vjb25kcywgb3ZlcnJpZGVzIHdoYXQgdGhlIHNlcnZlciBzZW5kcyBiYWNrXHJcbiAgICBERUZBVUxUX01BWF9USFJPVFRMRV9USU1FX1NFQ09ORFM6IDM2MDAsXHJcbiAgICAvLyBQcmVmaXggZm9yIHN0b3JpbmcgdGhyb3R0bGluZyBlbnRyaWVzXHJcbiAgICBUSFJPVFRMSU5HX1BSRUZJWDogXCJ0aHJvdHRsaW5nXCIsXHJcbiAgICAvLyBWYWx1ZSBhc3NpZ25lZCB0byB0aGUgeC1tcy1saWItY2FwYWJpbGl0eSBoZWFkZXIgdG8gaW5kaWNhdGUgdG8gdGhlIHNlcnZlciB0aGUgbGlicmFyeSBzdXBwb3J0cyB0aHJvdHRsaW5nXHJcbiAgICBYX01TX0xJQl9DQVBBQklMSVRZX1ZBTFVFOiBcInJldHJ5LWFmdGVyLCBoNDI5XCIsXHJcbn07XHJcbmNvbnN0IEVycm9ycyA9IHtcclxuICAgIElOVkFMSURfR1JBTlRfRVJST1I6IFwiaW52YWxpZF9ncmFudFwiLFxyXG4gICAgQ0xJRU5UX01JU01BVENIX0VSUk9SOiBcImNsaWVudF9taXNtYXRjaFwiLFxyXG59O1xyXG4vKipcclxuICogUGFzc3dvcmQgZ3JhbnQgcGFyYW1ldGVyc1xyXG4gKi9cclxuY29uc3QgUGFzc3dvcmRHcmFudENvbnN0YW50cyA9IHtcclxuICAgIHVzZXJuYW1lOiBcInVzZXJuYW1lXCIsXHJcbiAgICBwYXNzd29yZDogXCJwYXNzd29yZFwiLFxyXG59O1xyXG4vKipcclxuICogUmVnaW9uIERpc2NvdmVyeSBTb3VyY2VzXHJcbiAqL1xyXG5jb25zdCBSZWdpb25EaXNjb3ZlcnlTb3VyY2VzID0ge1xyXG4gICAgRkFJTEVEX0FVVE9fREVURUNUSU9OOiBcIjFcIixcclxuICAgIElOVEVSTkFMX0NBQ0hFOiBcIjJcIixcclxuICAgIEVOVklST05NRU5UX1ZBUklBQkxFOiBcIjNcIixcclxuICAgIElNRFM6IFwiNFwiLFxyXG59O1xyXG4vKipcclxuICogUmVnaW9uIERpc2NvdmVyeSBPdXRjb21lc1xyXG4gKi9cclxuY29uc3QgUmVnaW9uRGlzY292ZXJ5T3V0Y29tZXMgPSB7XHJcbiAgICBDT05GSUdVUkVEX01BVENIRVNfREVURUNURUQ6IFwiMVwiLFxyXG4gICAgQ09ORklHVVJFRF9OT19BVVRPX0RFVEVDVElPTjogXCIyXCIsXHJcbiAgICBDT05GSUdVUkVEX05PVF9ERVRFQ1RFRDogXCIzXCIsXHJcbiAgICBBVVRPX0RFVEVDVElPTl9SRVFVRVNURURfU1VDQ0VTU0ZVTDogXCI0XCIsXHJcbiAgICBBVVRPX0RFVEVDVElPTl9SRVFVRVNURURfRkFJTEVEOiBcIjVcIixcclxufTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyB0aGUgcmVhc29uIGZvciBmZXRjaGluZyB0aGUgYWNjZXNzIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyXHJcbiAqL1xyXG5jb25zdCBDYWNoZU91dGNvbWUgPSB7XHJcbiAgICAvLyBXaGVuIGEgdG9rZW4gaXMgZm91bmQgaW4gdGhlIGNhY2hlIG9yIHRoZSBjYWNoZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgaGl0IHdoZW4gbWFraW5nIHRoZSByZXF1ZXN0XHJcbiAgICBOT1RfQVBQTElDQUJMRTogXCIwXCIsXHJcbiAgICAvLyBXaGVuIHRoZSB0b2tlbiByZXF1ZXN0IGdvZXMgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVyIGJlY2F1c2UgZm9yY2VfcmVmcmVzaCB3YXMgc2V0IHRvIHRydWUuIEFsc28gb2NjdXJzIGlmIGNsYWltcyB3ZXJlIHJlcXVlc3RlZFxyXG4gICAgRk9SQ0VfUkVGUkVTSF9PUl9DTEFJTVM6IFwiMVwiLFxyXG4gICAgLy8gV2hlbiB0aGUgdG9rZW4gcmVxdWVzdCBnb2VzIHRvIHRoZSBpZGVudGl0eSBwcm92aWRlciBiZWNhdXNlIG5vIGNhY2hlZCBhY2Nlc3MgdG9rZW4gZXhpc3RzXHJcbiAgICBOT19DQUNIRURfQUNDRVNTX1RPS0VOOiBcIjJcIixcclxuICAgIC8vIFdoZW4gdGhlIHRva2VuIHJlcXVlc3QgZ29lcyB0byB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgYmVjYXVzZSBjYWNoZWQgYWNjZXNzIHRva2VuIGV4cGlyZWRcclxuICAgIENBQ0hFRF9BQ0NFU1NfVE9LRU5fRVhQSVJFRDogXCIzXCIsXHJcbiAgICAvLyBXaGVuIHRoZSB0b2tlbiByZXF1ZXN0IGdvZXMgdG8gdGhlIGlkZW50aXR5IHByb3ZpZGVyIGJlY2F1c2UgcmVmcmVzaF9pbiB3YXMgdXNlZCBhbmQgdGhlIGV4aXN0aW5nIHRva2VuIG5lZWRzIHRvIGJlIHJlZnJlc2hlZFxyXG4gICAgUFJPQUNUSVZFTFlfUkVGUkVTSEVEOiBcIjRcIixcclxufTtcclxuY29uc3QgSnNvbldlYlRva2VuVHlwZXMgPSB7XHJcbiAgICBKd3Q6IFwiSldUXCIsXHJcbiAgICBKd2s6IFwiSldLXCIsXHJcbiAgICBQb3A6IFwicG9wXCIsXHJcbn07XHJcbmNvbnN0IE9ORV9EQVlfSU5fTVMgPSA4NjQwMDAwMDtcclxuLy8gVG9rZW4gcmVuZXdhbCBvZmZzZXQgZGVmYXVsdCBpbiBzZWNvbmRzXHJcbmNvbnN0IERFRkFVTFRfVE9LRU5fUkVORVdBTF9PRkZTRVRfU0VDID0gMzAwO1xyXG5jb25zdCBFbmNvZGluZ1R5cGVzID0ge1xyXG4gICAgQkFTRTY0OiBcImJhc2U2NFwiLFxyXG4gICAgSEVYOiBcImhleFwiLFxyXG4gICAgVVRGODogXCJ1dGYtOFwiLFxyXG59O1xuXG5leHBvcnQgeyBBQURBdXRob3JpdHlDb25zdGFudHMsIEFQUF9NRVRBREFUQSwgQVVUSE9SSVRZX01FVEFEQVRBX0NPTlNUQU5UUywgQXV0aGVudGljYXRpb25TY2hlbWUsIEF1dGhvcml0eU1ldGFkYXRhU291cmNlLCBDTElFTlRfSU5GTywgQ2FjaGVBY2NvdW50VHlwZSwgQ2FjaGVPdXRjb21lLCBDYWNoZVR5cGUsIENsYWltc1JlcXVlc3RLZXlzLCBDb2RlQ2hhbGxlbmdlTWV0aG9kVmFsdWVzLCBDb25zdGFudHMsIENyZWRlbnRpYWxUeXBlLCBERUZBVUxUX1RPS0VOX1JFTkVXQUxfT0ZGU0VUX1NFQywgRW5jb2RpbmdUeXBlcywgRXJyb3JzLCBHcmFudFR5cGUsIEhlYWRlck5hbWVzLCBIdHRwU3RhdHVzLCBKc29uV2ViVG9rZW5UeXBlcywgT0F1dGhSZXNwb25zZVR5cGUsIE9JRENfREVGQVVMVF9TQ09QRVMsIE9JRENfU0NPUEVTLCBPTkVfREFZX0lOX01TLCBQYXNzd29yZEdyYW50Q29uc3RhbnRzLCBQZXJzaXN0ZW50Q2FjaGVLZXlzLCBQcm9tcHRWYWx1ZSwgUmVnaW9uRGlzY292ZXJ5T3V0Y29tZXMsIFJlZ2lvbkRpc2NvdmVyeVNvdXJjZXMsIFJlc3BvbnNlTW9kZSwgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUywgU2VwYXJhdG9ycywgU2VydmVyUmVzcG9uc2VUeXBlLCBUSEVfRkFNSUxZX0lELCBUaHJvdHRsaW5nQ29uc3RhbnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25zdGFudHMubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEh0dHBTdGF0dXMgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBNU0kgQ29uc3RhbnRzLiBEb2NzIGZvciBNU0kgYXJlIGF2YWlsYWJsZSBoZXJlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2F6dXJlL2FwcC1zZXJ2aWNlL292ZXJ2aWV3LW1hbmFnZWQtaWRlbnRpdHlcclxuY29uc3QgREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX0lEID0gXCJzeXN0ZW1fYXNzaWduZWRfbWFuYWdlZF9pZGVudGl0eVwiO1xyXG5jb25zdCBNQU5BR0VEX0lERU5USVRZX0RFRkFVTFRfVEVOQU5UID0gXCJtYW5hZ2VkX2lkZW50aXR5XCI7XHJcbmNvbnN0IERFRkFVTFRfQVVUSE9SSVRZX0ZPUl9NQU5BR0VEX0lERU5USVRZID0gYGh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS8ke01BTkFHRURfSURFTlRJVFlfREVGQVVMVF9URU5BTlR9L2A7XHJcbi8qKlxyXG4gKiBNYW5hZ2VkIElkZW50aXR5IEhlYWRlcnMgLSB1c2VkIGluIG5ldHdvcmsgcmVxdWVzdHNcclxuICovXHJcbmNvbnN0IE1hbmFnZWRJZGVudGl0eUhlYWRlcnMgPSB7XHJcbiAgICBBVVRIT1JJWkFUSU9OX0hFQURFUl9OQU1FOiBcIkF1dGhvcml6YXRpb25cIixcclxuICAgIE1FVEFEQVRBX0hFQURFUl9OQU1FOiBcIk1ldGFkYXRhXCIsXHJcbiAgICBBUFBfU0VSVklDRV9TRUNSRVRfSEVBREVSX05BTUU6IFwiWC1JREVOVElUWS1IRUFERVJcIixcclxuICAgIE1MX0FORF9TRl9TRUNSRVRfSEVBREVSX05BTUU6IFwic2VjcmV0XCIsXHJcbn07XHJcbi8qKlxyXG4gKiBNYW5hZ2VkIElkZW50aXR5IFF1ZXJ5IFBhcmFtZXRlcnMgLSB1c2VkIGluIG5ldHdvcmsgcmVxdWVzdHNcclxuICovXHJcbmNvbnN0IE1hbmFnZWRJZGVudGl0eVF1ZXJ5UGFyYW1ldGVycyA9IHtcclxuICAgIEFQSV9WRVJTSU9OOiBcImFwaS12ZXJzaW9uXCIsXHJcbiAgICBSRVNPVVJDRTogXCJyZXNvdXJjZVwiLFxyXG4gICAgU0hBMjU2X1RPS0VOX1RPX1JFRlJFU0g6IFwidG9rZW5fc2hhMjU2X3RvX3JlZnJlc2hcIixcclxuICAgIFhNU19DQzogXCJ4bXNfY2NcIixcclxufTtcclxuLyoqXHJcbiAqIE1hbmFnZWQgSWRlbnRpdHkgRW52aXJvbm1lbnQgVmFyaWFibGUgTmFtZXNcclxuICovXHJcbmNvbnN0IE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcyA9IHtcclxuICAgIEFaVVJFX1BPRF9JREVOVElUWV9BVVRIT1JJVFlfSE9TVDogXCJBWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RcIixcclxuICAgIElERU5USVRZX0VORFBPSU5UOiBcIklERU5USVRZX0VORFBPSU5UXCIsXHJcbiAgICBJREVOVElUWV9IRUFERVI6IFwiSURFTlRJVFlfSEVBREVSXCIsXHJcbiAgICBJREVOVElUWV9TRVJWRVJfVEhVTUJQUklOVDogXCJJREVOVElUWV9TRVJWRVJfVEhVTUJQUklOVFwiLFxyXG4gICAgSU1EU19FTkRQT0lOVDogXCJJTURTX0VORFBPSU5UXCIsXHJcbiAgICBNU0lfRU5EUE9JTlQ6IFwiTVNJX0VORFBPSU5UXCIsXHJcbiAgICBNU0lfU0VDUkVUOiBcIk1TSV9TRUNSRVRcIixcclxufTtcclxuLyoqXHJcbiAqIE1hbmFnZWQgSWRlbnRpdHkgU291cmNlIE5hbWVzXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzID0ge1xyXG4gICAgQVBQX1NFUlZJQ0U6IFwiQXBwU2VydmljZVwiLFxyXG4gICAgQVpVUkVfQVJDOiBcIkF6dXJlQXJjXCIsXHJcbiAgICBDTE9VRF9TSEVMTDogXCJDbG91ZFNoZWxsXCIsXHJcbiAgICBERUZBVUxUX1RPX0lNRFM6IFwiRGVmYXVsdFRvSW1kc1wiLFxyXG4gICAgSU1EUzogXCJJbWRzXCIsXHJcbiAgICBNQUNISU5FX0xFQVJOSU5HOiBcIk1hY2hpbmVMZWFybmluZ1wiLFxyXG4gICAgU0VSVklDRV9GQUJSSUM6IFwiU2VydmljZUZhYnJpY1wiLFxyXG59O1xyXG4vKipcclxuICogTWFuYWdlZCBJZGVudGl0eSBJZHNcclxuICovXHJcbmNvbnN0IE1hbmFnZWRJZGVudGl0eUlkVHlwZSA9IHtcclxuICAgIFNZU1RFTV9BU1NJR05FRDogXCJzeXN0ZW0tYXNzaWduZWRcIixcclxuICAgIFVTRVJfQVNTSUdORURfQ0xJRU5UX0lEOiBcInVzZXItYXNzaWduZWQtY2xpZW50LWlkXCIsXHJcbiAgICBVU0VSX0FTU0lHTkVEX1JFU09VUkNFX0lEOiBcInVzZXItYXNzaWduZWQtcmVzb3VyY2UtaWRcIixcclxuICAgIFVTRVJfQVNTSUdORURfT0JKRUNUX0lEOiBcInVzZXItYXNzaWduZWQtb2JqZWN0LWlkXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBodHRwIG1ldGhvZHNcclxuICovXHJcbmNvbnN0IEh0dHBNZXRob2QgPSB7XHJcbiAgICBHRVQ6IFwiZ2V0XCIsXHJcbiAgICBQT1NUOiBcInBvc3RcIixcclxufTtcclxuY29uc3QgUHJveHlTdGF0dXMgPSB7XHJcbiAgICBTVUNDRVNTOiBIdHRwU3RhdHVzLlNVQ0NFU1MsXHJcbiAgICBTVUNDRVNTX1JBTkdFX1NUQVJUOiBIdHRwU3RhdHVzLlNVQ0NFU1NfUkFOR0VfU1RBUlQsXHJcbiAgICBTVUNDRVNTX1JBTkdFX0VORDogSHR0cFN0YXR1cy5TVUNDRVNTX1JBTkdFX0VORCxcclxuICAgIFNFUlZFUl9FUlJPUjogSHR0cFN0YXR1cy5TRVJWRVJfRVJST1IsXHJcbn07XHJcbi8qKlxyXG4gKiBDb25zdGFudHMgdXNlZCBmb3IgcmVnaW9uIGRpc2NvdmVyeVxyXG4gKi9cclxuY29uc3QgUkVHSU9OX0VOVklST05NRU5UX1ZBUklBQkxFID0gXCJSRUdJT05fTkFNRVwiO1xyXG5jb25zdCBNU0FMX0ZPUkNFX1JFR0lPTiA9IFwiTVNBTF9GT1JDRV9SRUdJT05cIjtcclxuLyoqXHJcbiAqIENvbnN0YW50IHVzZWQgZm9yIFBLQ0VcclxuICovXHJcbmNvbnN0IFJBTkRPTV9PQ1RFVF9TSVpFID0gMzI7XHJcbi8qKlxyXG4gKiBDb25zdGFudHMgdXNlZCBpbiBQS0NFXHJcbiAqL1xyXG5jb25zdCBIYXNoID0ge1xyXG4gICAgU0hBMjU2OiBcInNoYTI1NlwiLFxyXG59O1xyXG4vKipcclxuICogQ29uc3RhbnRzIGZvciBlbmNvZGluZyBzY2hlbWVzXHJcbiAqL1xyXG5jb25zdCBDaGFyU2V0ID0ge1xyXG4gICAgQ1ZfQ0hBUlNFVDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS0uX35cIixcclxufTtcclxuLyoqXHJcbiAqIENvbnN0YW50c1xyXG4gKi9cclxuY29uc3QgQ29uc3RhbnRzID0ge1xyXG4gICAgTVNBTF9TS1U6IFwibXNhbC5qcy5ub2RlXCIsXHJcbiAgICBKV1RfQkVBUkVSX0FTU0VSVElPTl9UWVBFOiBcInVybjppZXRmOnBhcmFtczpvYXV0aDpjbGllbnQtYXNzZXJ0aW9uLXR5cGU6and0LWJlYXJlclwiLFxyXG4gICAgQVVUSE9SSVpBVElPTl9QRU5ESU5HOiBcImF1dGhvcml6YXRpb25fcGVuZGluZ1wiLFxyXG4gICAgSFRUUF9QUk9UT0NPTDogXCJodHRwOi8vXCIsXHJcbiAgICBMT0NBTEhPU1Q6IFwibG9jYWxob3N0XCIsXHJcbn07XHJcbi8qKlxyXG4gKiBBUEkgQ29kZXMgZm9yIFRlbGVtZXRyeSBwdXJwb3Nlcy5cclxuICogQmVmb3JlIGFkZGluZyBhIG5ldyBjb2RlIHlvdSBtdXN0IGNsYWltIGl0IGluIHRoZSBNU0FMIFRlbGVtZXRyeSB0cmFja2VyIGFzIHRoZXNlIG51bWJlciBzcGFjZXMgYXJlIHNoYXJlZCBhY3Jvc3MgYWxsIE1TQUxzXHJcbiAqIDAtOTkgU2lsZW50IEZsb3dcclxuICogNjAwLTY5OSBEZXZpY2UgQ29kZSBGbG93XHJcbiAqIDgwMC04OTkgQXV0aCBDb2RlIEZsb3dcclxuICovXHJcbmNvbnN0IEFwaUlkID0ge1xyXG4gICAgYWNxdWlyZVRva2VuU2lsZW50OiA2MixcclxuICAgIGFjcXVpcmVUb2tlbkJ5VXNlcm5hbWVQYXNzd29yZDogMzcxLFxyXG4gICAgYWNxdWlyZVRva2VuQnlEZXZpY2VDb2RlOiA2NzEsXHJcbiAgICBhY3F1aXJlVG9rZW5CeUNsaWVudENyZWRlbnRpYWw6IDc3MSxcclxuICAgIGFjcXVpcmVUb2tlbkJ5Q29kZTogODcxLFxyXG4gICAgYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW46IDg3MixcclxufTtcclxuLyoqXHJcbiAqIEpXVCAgY29uc3RhbnRzXHJcbiAqL1xyXG5jb25zdCBKd3RDb25zdGFudHMgPSB7XHJcbiAgICBBTEdPUklUSE06IFwiYWxnXCIsXHJcbiAgICBSU0FfMjU2OiBcIlJTMjU2XCIsXHJcbiAgICBQU1NfMjU2OiBcIlBTMjU2XCIsXHJcbiAgICBYNVRfMjU2OiBcIng1dCNTMjU2XCIsXHJcbiAgICBYNVQ6IFwieDV0XCIsXHJcbiAgICBYNUM6IFwieDVjXCIsXHJcbiAgICBBVURJRU5DRTogXCJhdWRcIixcclxuICAgIEVYUElSQVRJT05fVElNRTogXCJleHBcIixcclxuICAgIElTU1VFUjogXCJpc3NcIixcclxuICAgIFNVQkpFQ1Q6IFwic3ViXCIsXHJcbiAgICBOT1RfQkVGT1JFOiBcIm5iZlwiLFxyXG4gICAgSldUX0lEOiBcImp0aVwiLFxyXG59O1xyXG5jb25zdCBMT09QQkFDS19TRVJWRVJfQ09OU1RBTlRTID0ge1xyXG4gICAgSU5URVJWQUxfTVM6IDEwMCxcclxuICAgIFRJTUVPVVRfTVM6IDUwMDAsXHJcbn07XHJcbmNvbnN0IEFaVVJFX0FSQ19TRUNSRVRfRklMRV9NQVhfU0laRV9CWVRFUyA9IDQwOTY7IC8vIDQgS0JcblxuZXhwb3J0IHsgQVpVUkVfQVJDX1NFQ1JFVF9GSUxFX01BWF9TSVpFX0JZVEVTLCBBcGlJZCwgQ2hhclNldCwgQ29uc3RhbnRzLCBERUZBVUxUX0FVVEhPUklUWV9GT1JfTUFOQUdFRF9JREVOVElUWSwgREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX0lELCBIYXNoLCBIdHRwTWV0aG9kLCBKd3RDb25zdGFudHMsIExPT1BCQUNLX1NFUlZFUl9DT05TVEFOVFMsIE1BTkFHRURfSURFTlRJVFlfREVGQVVMVF9URU5BTlQsIE1TQUxfRk9SQ0VfUkVHSU9OLCBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMsIE1hbmFnZWRJZGVudGl0eUhlYWRlcnMsIE1hbmFnZWRJZGVudGl0eUlkVHlwZSwgTWFuYWdlZElkZW50aXR5UXVlcnlQYXJhbWV0ZXJzLCBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcywgUHJveHlTdGF0dXMsIFJBTkRPTV9PQ1RFVF9TSVpFLCBSRUdJT05fRU5WSVJPTk1FTlRfVkFSSUFCTEUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnN0YW50cy5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBdXRoRXJyb3JNZXNzYWdlIGNsYXNzIGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyB1c2VkIGJ5IGVycm9yIGNvZGVzIGFuZCBtZXNzYWdlcy5cclxuICovXHJcbmNvbnN0IHVuZXhwZWN0ZWRFcnJvciA9IFwidW5leHBlY3RlZF9lcnJvclwiO1xyXG5jb25zdCBwb3N0UmVxdWVzdEZhaWxlZCA9IFwicG9zdF9yZXF1ZXN0X2ZhaWxlZFwiO1xuXG5leHBvcnQgeyBwb3N0UmVxdWVzdEZhaWxlZCwgdW5leHBlY3RlZEVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoRXJyb3JDb2Rlcy5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSAnLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyB1bmV4cGVjdGVkRXJyb3IsIHBvc3RSZXF1ZXN0RmFpbGVkIH0gZnJvbSAnLi9BdXRoRXJyb3JDb2Rlcy5tanMnO1xuaW1wb3J0ICogYXMgQXV0aEVycm9yQ29kZXMgZnJvbSAnLi9BdXRoRXJyb3JDb2Rlcy5tanMnO1xuZXhwb3J0IHsgQXV0aEVycm9yQ29kZXMgfTtcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEF1dGhFcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgW3VuZXhwZWN0ZWRFcnJvcl06IFwiVW5leHBlY3RlZCBlcnJvciBpbiBhdXRoZW50aWNhdGlvbi5cIixcclxuICAgIFtwb3N0UmVxdWVzdEZhaWxlZF06IFwiUG9zdCByZXF1ZXN0IGZhaWxlZCBmcm9tIHRoZSBuZXR3b3JrLCBjb3VsZCBiZSBhIDR4eC81eHggb3IgYSBuZXR3b3JrIHVuYXZhaWxhYmlsaXR5LiBQbGVhc2UgY2hlY2sgdGhlIGV4YWN0IGVycm9yIGNvZGUgZm9yIGRldGFpbHMuXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBBdXRoRXJyb3JNZXNzYWdlIGNsYXNzIGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyB1c2VkIGJ5IGVycm9yIGNvZGVzIGFuZCBtZXNzYWdlcy5cclxuICogQGRlcHJlY2F0ZWQgVXNlIEF1dGhFcnJvckNvZGVzIGluc3RlYWRcclxuICovXHJcbmNvbnN0IEF1dGhFcnJvck1lc3NhZ2UgPSB7XHJcbiAgICB1bmV4cGVjdGVkRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiB1bmV4cGVjdGVkRXJyb3IsXHJcbiAgICAgICAgZGVzYzogQXV0aEVycm9yTWVzc2FnZXNbdW5leHBlY3RlZEVycm9yXSxcclxuICAgIH0sXHJcbiAgICBwb3N0UmVxdWVzdEZhaWxlZDoge1xyXG4gICAgICAgIGNvZGU6IHBvc3RSZXF1ZXN0RmFpbGVkLFxyXG4gICAgICAgIGRlc2M6IEF1dGhFcnJvck1lc3NhZ2VzW3Bvc3RSZXF1ZXN0RmFpbGVkXSxcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBHZW5lcmFsIGVycm9yIGNsYXNzIHRocm93biBieSB0aGUgTVNBTC5qcyBsaWJyYXJ5LlxyXG4gKi9cclxuY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIHN1YmVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JTdHJpbmcgPSBlcnJvck1lc3NhZ2VcclxuICAgICAgICAgICAgPyBgJHtlcnJvckNvZGV9OiAke2Vycm9yTWVzc2FnZX1gXHJcbiAgICAgICAgICAgIDogZXJyb3JDb2RlO1xyXG4gICAgICAgIHN1cGVyKGVycm9yU3RyaW5nKTtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQXV0aEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGUgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZSB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMuc3ViRXJyb3IgPSBzdWJlcnJvciB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiQXV0aEVycm9yXCI7XHJcbiAgICB9XHJcbiAgICBzZXRDb3JyZWxhdGlvbklkKGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWQgPSBjb3JyZWxhdGlvbklkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUF1dGhFcnJvcihjb2RlLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIG5ldyBBdXRoRXJyb3IoY29kZSwgYWRkaXRpb25hbE1lc3NhZ2VcclxuICAgICAgICA/IGAke0F1dGhFcnJvck1lc3NhZ2VzW2NvZGVdfSAke2FkZGl0aW9uYWxNZXNzYWdlfWBcclxuICAgICAgICA6IEF1dGhFcnJvck1lc3NhZ2VzW2NvZGVdKTtcclxufVxuXG5leHBvcnQgeyBBdXRoRXJyb3IsIEF1dGhFcnJvck1lc3NhZ2UsIEF1dGhFcnJvck1lc3NhZ2VzLCBjcmVhdGVBdXRoRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhFcnJvci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQ2FjaGVPdXRjb21lLCBDb25zdGFudHMsIFNFUlZFUl9URUxFTV9DT05TVEFOVFMsIFNlcGFyYXRvcnMgfSBmcm9tICcuLi8uLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9yL0F1dGhFcnJvci5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3Qgc2t1R3JvdXBTZXBhcmF0b3IgPSBcIixcIjtcclxuY29uc3Qgc2t1VmFsdWVTZXBhcmF0b3IgPSBcInxcIjtcclxuZnVuY3Rpb24gbWFrZUV4dHJhU2t1U3RyaW5nKHBhcmFtcykge1xyXG4gICAgY29uc3QgeyBza3VzLCBsaWJyYXJ5TmFtZSwgbGlicmFyeVZlcnNpb24sIGV4dGVuc2lvbk5hbWUsIGV4dGVuc2lvblZlcnNpb24sIH0gPSBwYXJhbXM7XHJcbiAgICBjb25zdCBza3VNYXAgPSBuZXcgTWFwKFtcclxuICAgICAgICBbMCwgW2xpYnJhcnlOYW1lLCBsaWJyYXJ5VmVyc2lvbl1dLFxyXG4gICAgICAgIFsyLCBbZXh0ZW5zaW9uTmFtZSwgZXh0ZW5zaW9uVmVyc2lvbl1dLFxyXG4gICAgXSk7XHJcbiAgICBsZXQgc2t1QXJyID0gW107XHJcbiAgICBpZiAoc2t1cz8ubGVuZ3RoKSB7XHJcbiAgICAgICAgc2t1QXJyID0gc2t1cy5zcGxpdChza3VHcm91cFNlcGFyYXRvcik7XHJcbiAgICAgICAgLy8gSWdub3JlIGludmFsaWQgaW5wdXQgc2t1IHBhcmFtXHJcbiAgICAgICAgaWYgKHNrdUFyci5sZW5ndGggPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBza3VzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNrdUFyciA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDQgfSwgKCkgPT4gc2t1VmFsdWVTZXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgc2t1TWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAyICYmIHZhbHVlWzBdPy5sZW5ndGggJiYgdmFsdWVbMV0/Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzZXRTa3Uoe1xyXG4gICAgICAgICAgICAgICAgc2t1QXJyLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGtleSxcclxuICAgICAgICAgICAgICAgIHNrdU5hbWU6IHZhbHVlWzBdLFxyXG4gICAgICAgICAgICAgICAgc2t1VmVyc2lvbjogdmFsdWVbMV0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNrdUFyci5qb2luKHNrdUdyb3VwU2VwYXJhdG9yKTtcclxufVxyXG5mdW5jdGlvbiBzZXRTa3UocGFyYW1zKSB7XHJcbiAgICBjb25zdCB7IHNrdUFyciwgaW5kZXgsIHNrdU5hbWUsIHNrdVZlcnNpb24gfSA9IHBhcmFtcztcclxuICAgIGlmIChpbmRleCA+PSBza3VBcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2t1QXJyW2luZGV4XSA9IFtza3VOYW1lLCBza3VWZXJzaW9uXS5qb2luKHNrdVZhbHVlU2VwYXJhdG9yKTtcclxufVxyXG4vKiogQGludGVybmFsICovXHJcbmNsYXNzIFNlcnZlclRlbGVtZXRyeU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IodGVsZW1ldHJ5UmVxdWVzdCwgY2FjaGVNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZU91dGNvbWUgPSBDYWNoZU91dGNvbWUuTk9UX0FQUExJQ0FCTEU7XHJcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIgPSBjYWNoZU1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5hcGlJZCA9IHRlbGVtZXRyeVJlcXVlc3QuYXBpSWQ7XHJcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gdGVsZW1ldHJ5UmVxdWVzdC5jb3JyZWxhdGlvbklkO1xyXG4gICAgICAgIHRoaXMud3JhcHBlclNLVSA9IHRlbGVtZXRyeVJlcXVlc3Qud3JhcHBlclNLVSB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMud3JhcHBlclZlciA9IHRlbGVtZXRyeVJlcXVlc3Qud3JhcHBlclZlciB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMudGVsZW1ldHJ5Q2FjaGVLZXkgPVxyXG4gICAgICAgICAgICBTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLkNBQ0hFX0tFWSArXHJcbiAgICAgICAgICAgICAgICBTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1IgK1xyXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5UmVxdWVzdC5jbGllbnRJZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQVBJIHRvIGFkZCBNU0VSIFRlbGVtZXRyeSB0byByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlQ3VycmVudFJlcXVlc3RIZWFkZXJWYWx1ZSgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gYCR7dGhpcy5hcGlJZH0ke1NFUlZFUl9URUxFTV9DT05TVEFOVFMuVkFMVUVfU0VQQVJBVE9SfSR7dGhpcy5jYWNoZU91dGNvbWV9YDtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUZpZWxkc0FyciA9IFt0aGlzLndyYXBwZXJTS1UsIHRoaXMud3JhcHBlclZlcl07XHJcbiAgICAgICAgY29uc3QgbmF0aXZlQnJva2VyRXJyb3JDb2RlID0gdGhpcy5nZXROYXRpdmVCcm9rZXJFcnJvckNvZGUoKTtcclxuICAgICAgICBpZiAobmF0aXZlQnJva2VyRXJyb3JDb2RlPy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcGxhdGZvcm1GaWVsZHNBcnIucHVzaChgYnJva2VyX2Vycm9yPSR7bmF0aXZlQnJva2VyRXJyb3JDb2RlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUZpZWxkcyA9IHBsYXRmb3JtRmllbGRzQXJyLmpvaW4oU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5WQUxVRV9TRVBBUkFUT1IpO1xyXG4gICAgICAgIGNvbnN0IHJlZ2lvbkRpc2NvdmVyeUZpZWxkcyA9IHRoaXMuZ2V0UmVnaW9uRGlzY292ZXJ5RmllbGRzKCk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWdpb25EaXNjb3ZlcnlGaWVsZHMgPSBbXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIHJlZ2lvbkRpc2NvdmVyeUZpZWxkcyxcclxuICAgICAgICBdLmpvaW4oU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5WQUxVRV9TRVBBUkFUT1IpO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFNFUlZFUl9URUxFTV9DT05TVEFOVFMuU0NIRU1BX1ZFUlNJT04sXHJcbiAgICAgICAgICAgIHJlcXVlc3RXaXRoUmVnaW9uRGlzY292ZXJ5RmllbGRzLFxyXG4gICAgICAgICAgICBwbGF0Zm9ybUZpZWxkcyxcclxuICAgICAgICBdLmpvaW4oU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5DQVRFR09SWV9TRVBBUkFUT1IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBUEkgdG8gYWRkIE1TRVIgVGVsZW1ldHJ5IGZvciB0aGUgbGFzdCBmYWlsZWQgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUxhc3RSZXF1ZXN0SGVhZGVyVmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdFJlcXVlc3RzID0gdGhpcy5nZXRMYXN0UmVxdWVzdHMoKTtcclxuICAgICAgICBjb25zdCBtYXhFcnJvcnMgPSBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLm1heEVycm9yc1RvU2VuZChsYXN0UmVxdWVzdHMpO1xyXG4gICAgICAgIGNvbnN0IGZhaWxlZFJlcXVlc3RzID0gbGFzdFJlcXVlc3RzLmZhaWxlZFJlcXVlc3RzXHJcbiAgICAgICAgICAgIC5zbGljZSgwLCAyICogbWF4RXJyb3JzKVxyXG4gICAgICAgICAgICAuam9pbihTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlZBTFVFX1NFUEFSQVRPUik7XHJcbiAgICAgICAgY29uc3QgZXJyb3JzID0gbGFzdFJlcXVlc3RzLmVycm9yc1xyXG4gICAgICAgICAgICAuc2xpY2UoMCwgbWF4RXJyb3JzKVxyXG4gICAgICAgICAgICAuam9pbihTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlZBTFVFX1NFUEFSQVRPUik7XHJcbiAgICAgICAgY29uc3QgZXJyb3JDb3VudCA9IGxhc3RSZXF1ZXN0cy5lcnJvcnMubGVuZ3RoO1xyXG4gICAgICAgIC8vIEluZGljYXRlIHdoZXRoZXIgdGhpcyBoZWFkZXIgY29udGFpbnMgYWxsIGRhdGEgb3IgcGFydGlhbCBkYXRhXHJcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBtYXhFcnJvcnMgPCBlcnJvckNvdW50XHJcbiAgICAgICAgICAgID8gU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5PVkVSRkxPV19UUlVFXHJcbiAgICAgICAgICAgIDogU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5PVkVSRkxPV19GQUxTRTtcclxuICAgICAgICBjb25zdCBwbGF0Zm9ybUZpZWxkcyA9IFtlcnJvckNvdW50LCBvdmVyZmxvd10uam9pbihTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLlZBTFVFX1NFUEFSQVRPUik7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5TQ0hFTUFfVkVSU0lPTixcclxuICAgICAgICAgICAgbGFzdFJlcXVlc3RzLmNhY2hlSGl0cyxcclxuICAgICAgICAgICAgZmFpbGVkUmVxdWVzdHMsXHJcbiAgICAgICAgICAgIGVycm9ycyxcclxuICAgICAgICAgICAgcGxhdGZvcm1GaWVsZHMsXHJcbiAgICAgICAgXS5qb2luKFNFUlZFUl9URUxFTV9DT05TVEFOVFMuQ0FURUdPUllfU0VQQVJBVE9SKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQVBJIHRvIGNhY2hlIHRva2VuIGZhaWx1cmVzIGZvciBNU0VSIGRhdGEgY2FwdHVyZVxyXG4gICAgICogQHBhcmFtIGVycm9yXHJcbiAgICAgKi9cclxuICAgIGNhY2hlRmFpbGVkUmVxdWVzdChlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0cyA9IHRoaXMuZ2V0TGFzdFJlcXVlc3RzKCk7XHJcbiAgICAgICAgaWYgKGxhc3RSZXF1ZXN0cy5lcnJvcnMubGVuZ3RoID49XHJcbiAgICAgICAgICAgIFNFUlZFUl9URUxFTV9DT05TVEFOVFMuTUFYX0NBQ0hFRF9FUlJPUlMpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGEgY2FjaGVkIGVycm9yIHRvIG1ha2Ugcm9vbSwgZmlyc3QgaW4gZmlyc3Qgb3V0XHJcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0cy5mYWlsZWRSZXF1ZXN0cy5zaGlmdCgpOyAvLyBhcGlJZFxyXG4gICAgICAgICAgICBsYXN0UmVxdWVzdHMuZmFpbGVkUmVxdWVzdHMuc2hpZnQoKTsgLy8gY29ycmVsYXRpb25JZFxyXG4gICAgICAgICAgICBsYXN0UmVxdWVzdHMuZXJyb3JzLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RSZXF1ZXN0cy5mYWlsZWRSZXF1ZXN0cy5wdXNoKHRoaXMuYXBpSWQsIHRoaXMuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgISFlcnJvciAmJiBlcnJvci50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN1YkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlcXVlc3RzLmVycm9ycy5wdXNoKGVycm9yLnN1YkVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLmVycm9yQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0cy5lcnJvcnMucHVzaChlcnJvci5lcnJvckNvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlcXVlc3RzLmVycm9ycy5wdXNoKGVycm9yLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJlcXVlc3RzLmVycm9ycy5wdXNoKGVycm9yLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsYXN0UmVxdWVzdHMuZXJyb3JzLnB1c2goU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5VTktOT1dOX0VSUk9SKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIuc2V0U2VydmVyVGVsZW1ldHJ5KHRoaXMudGVsZW1ldHJ5Q2FjaGVLZXksIGxhc3RSZXF1ZXN0cyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgc2VydmVyIHRlbGVtZXRyeSBjYWNoZSBlbnRyeSBieSBpbmNyZW1lbnRpbmcgY2FjaGUgaGl0IGNvdW50ZXJcclxuICAgICAqL1xyXG4gICAgaW5jcmVtZW50Q2FjaGVIaXRzKCkge1xyXG4gICAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0cyA9IHRoaXMuZ2V0TGFzdFJlcXVlc3RzKCk7XHJcbiAgICAgICAgbGFzdFJlcXVlc3RzLmNhY2hlSGl0cyArPSAxO1xyXG4gICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnNldFNlcnZlclRlbGVtZXRyeSh0aGlzLnRlbGVtZXRyeUNhY2hlS2V5LCBsYXN0UmVxdWVzdHMpO1xyXG4gICAgICAgIHJldHVybiBsYXN0UmVxdWVzdHMuY2FjaGVIaXRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNlcnZlciB0ZWxlbWV0cnkgZW50aXR5IGZyb20gY2FjaGUgb3IgaW5pdGlhbGl6ZSBhIG5ldyBvbmVcclxuICAgICAqL1xyXG4gICAgZ2V0TGFzdFJlcXVlc3RzKCkge1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IHtcclxuICAgICAgICAgICAgZmFpbGVkUmVxdWVzdHM6IFtdLFxyXG4gICAgICAgICAgICBlcnJvcnM6IFtdLFxyXG4gICAgICAgICAgICBjYWNoZUhpdHM6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBsYXN0UmVxdWVzdHMgPSB0aGlzLmNhY2hlTWFuYWdlci5nZXRTZXJ2ZXJUZWxlbWV0cnkodGhpcy50ZWxlbWV0cnlDYWNoZUtleSk7XHJcbiAgICAgICAgcmV0dXJuIGxhc3RSZXF1ZXN0cyB8fCBpbml0aWFsVmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBzZXJ2ZXIgdGVsZW1ldHJ5IGNhY2hlIGVudHJ5XHJcbiAgICAgKi9cclxuICAgIGNsZWFyVGVsZW1ldHJ5Q2FjaGUoKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdFJlcXVlc3RzID0gdGhpcy5nZXRMYXN0UmVxdWVzdHMoKTtcclxuICAgICAgICBjb25zdCBudW1FcnJvcnNGbHVzaGVkID0gU2VydmVyVGVsZW1ldHJ5TWFuYWdlci5tYXhFcnJvcnNUb1NlbmQobGFzdFJlcXVlc3RzKTtcclxuICAgICAgICBjb25zdCBlcnJvckNvdW50ID0gbGFzdFJlcXVlc3RzLmVycm9ycy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKG51bUVycm9yc0ZsdXNoZWQgPT09IGVycm9yQ291bnQpIHtcclxuICAgICAgICAgICAgLy8gQWxsIGVycm9ycyB3ZXJlIHNlbnQgb24gbGFzdCByZXF1ZXN0LCBjbGVhciBUZWxlbWV0cnkgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIucmVtb3ZlSXRlbSh0aGlzLnRlbGVtZXRyeUNhY2hlS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFBhcnRpYWwgZGF0YSB3YXMgZmx1c2hlZCB0byBzZXJ2ZXIsIGNvbnN0cnVjdCBhIG5ldyB0ZWxlbWV0cnkgY2FjaGUgaXRlbSB3aXRoIGVycm9ycyB0aGF0IHdlcmUgbm90IGZsdXNoZWRcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyVGVsZW1FbnRpdHkgPSB7XHJcbiAgICAgICAgICAgICAgICBmYWlsZWRSZXF1ZXN0czogbGFzdFJlcXVlc3RzLmZhaWxlZFJlcXVlc3RzLnNsaWNlKG51bUVycm9yc0ZsdXNoZWQgKiAyKSxcclxuICAgICAgICAgICAgICAgIGVycm9yczogbGFzdFJlcXVlc3RzLmVycm9ycy5zbGljZShudW1FcnJvcnNGbHVzaGVkKSxcclxuICAgICAgICAgICAgICAgIGNhY2hlSGl0czogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIuc2V0U2VydmVyVGVsZW1ldHJ5KHRoaXMudGVsZW1ldHJ5Q2FjaGVLZXksIHNlcnZlclRlbGVtRW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVycm9ycyB0aGF0IGNhbiBiZSBmbHVzaGVkIHRvIHRoZSBzZXJ2ZXIgaW4gdGhlIG5leHQgbmV0d29yayByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gc2VydmVyVGVsZW1ldHJ5RW50aXR5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtYXhFcnJvcnNUb1NlbmQoc2VydmVyVGVsZW1ldHJ5RW50aXR5KSB7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IG1heEVycm9ycyA9IDA7XHJcbiAgICAgICAgbGV0IGRhdGFTaXplID0gMDtcclxuICAgICAgICBjb25zdCBlcnJvckNvdW50ID0gc2VydmVyVGVsZW1ldHJ5RW50aXR5LmVycm9ycy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVycm9yQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBmYWlsZWRSZXF1ZXN0cyBwYXJhbWV0ZXIgY29udGFpbnMgcGFpcnMgb2YgYXBpSWQgYW5kIGNvcnJlbGF0aW9uSWQsIG11bHRpcGx5IGluZGV4IGJ5IDIgdG8gcHJlc2VydmUgcGFpcnNcclxuICAgICAgICAgICAgY29uc3QgYXBpSWQgPSBzZXJ2ZXJUZWxlbWV0cnlFbnRpdHkuZmFpbGVkUmVxdWVzdHNbMiAqIGldIHx8XHJcbiAgICAgICAgICAgICAgICBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgICAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gc2VydmVyVGVsZW1ldHJ5RW50aXR5LmZhaWxlZFJlcXVlc3RzWzIgKiBpICsgMV0gfHxcclxuICAgICAgICAgICAgICAgIENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHNlcnZlclRlbGVtZXRyeUVudGl0eS5lcnJvcnNbaV0gfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcclxuICAgICAgICAgICAgLy8gQ291bnQgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byBoZWFkZXIsIGVhY2ggY2hhcmFjdGVyIGlzIDEgYnl0ZS4gQWRkIDMgYXQgdGhlIGVuZCB0byBhY2NvdW50IGZvciBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgIGRhdGFTaXplICs9XHJcbiAgICAgICAgICAgICAgICBhcGlJZC50b1N0cmluZygpLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZC50b1N0cmluZygpLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgMztcclxuICAgICAgICAgICAgaWYgKGRhdGFTaXplIDwgU0VSVkVSX1RFTEVNX0NPTlNUQU5UUy5NQVhfTEFTVF9IRUFERVJfQllURVMpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZGluZyB0aGlzIGVudHJ5IHRvIHRoZSBoZWFkZXIgd291bGQgc3RpbGwga2VlcCBoZWFkZXIgc2l6ZSBiZWxvdyB0aGUgbGltaXRcclxuICAgICAgICAgICAgICAgIG1heEVycm9ycyArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heEVycm9ycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSByZWdpb24gZGlzY292ZXJ5IGZpZWxkc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBnZXRSZWdpb25EaXNjb3ZlcnlGaWVsZHMoKSB7XHJcbiAgICAgICAgY29uc3QgcmVnaW9uRGlzY292ZXJ5RmllbGRzID0gW107XHJcbiAgICAgICAgcmVnaW9uRGlzY292ZXJ5RmllbGRzLnB1c2godGhpcy5yZWdpb25Vc2VkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgIHJlZ2lvbkRpc2NvdmVyeUZpZWxkcy5wdXNoKHRoaXMucmVnaW9uU291cmNlIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgIHJlZ2lvbkRpc2NvdmVyeUZpZWxkcy5wdXNoKHRoaXMucmVnaW9uT3V0Y29tZSB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HKTtcclxuICAgICAgICByZXR1cm4gcmVnaW9uRGlzY292ZXJ5RmllbGRzLmpvaW4oXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHJlZ2lvbiBkaXNjb3ZlcnkgbWV0YWRhdGFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGlzY292ZXJ5TWV0YWRhdGFcclxuICAgICAqIEByZXR1cm5zIHZvaWRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlUmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEocmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLnJlZ2lvblVzZWQgPSByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fdXNlZDtcclxuICAgICAgICB0aGlzLnJlZ2lvblNvdXJjZSA9IHJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9zb3VyY2U7XHJcbiAgICAgICAgdGhpcy5yZWdpb25PdXRjb21lID0gcmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX291dGNvbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCBjYWNoZSBvdXRjb21lXHJcbiAgICAgKi9cclxuICAgIHNldENhY2hlT3V0Y29tZShjYWNoZU91dGNvbWUpIHtcclxuICAgICAgICB0aGlzLmNhY2hlT3V0Y29tZSA9IGNhY2hlT3V0Y29tZTtcclxuICAgIH1cclxuICAgIHNldE5hdGl2ZUJyb2tlckVycm9yQ29kZShlcnJvckNvZGUpIHtcclxuICAgICAgICBjb25zdCBsYXN0UmVxdWVzdHMgPSB0aGlzLmdldExhc3RSZXF1ZXN0cygpO1xyXG4gICAgICAgIGxhc3RSZXF1ZXN0cy5uYXRpdmVCcm9rZXJFcnJvckNvZGUgPSBlcnJvckNvZGU7XHJcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIuc2V0U2VydmVyVGVsZW1ldHJ5KHRoaXMudGVsZW1ldHJ5Q2FjaGVLZXksIGxhc3RSZXF1ZXN0cyk7XHJcbiAgICB9XHJcbiAgICBnZXROYXRpdmVCcm9rZXJFcnJvckNvZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdFJlcXVlc3RzKCkubmF0aXZlQnJva2VyRXJyb3JDb2RlO1xyXG4gICAgfVxyXG4gICAgY2xlYXJOYXRpdmVCcm9rZXJFcnJvckNvZGUoKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdFJlcXVlc3RzID0gdGhpcy5nZXRMYXN0UmVxdWVzdHMoKTtcclxuICAgICAgICBkZWxldGUgbGFzdFJlcXVlc3RzLm5hdGl2ZUJyb2tlckVycm9yQ29kZTtcclxuICAgICAgICB0aGlzLmNhY2hlTWFuYWdlci5zZXRTZXJ2ZXJUZWxlbWV0cnkodGhpcy50ZWxlbWV0cnlDYWNoZUtleSwgbGFzdFJlcXVlc3RzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYWtlRXh0cmFTa3VTdHJpbmcocGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1ha2VFeHRyYVNrdVN0cmluZyhwYXJhbXMpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFNlcnZlclRlbGVtZXRyeU1hbmFnZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcnZlclRlbGVtZXRyeU1hbmFnZXIubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBDTElFTlRfSUQgPSBcImNsaWVudF9pZFwiO1xyXG5jb25zdCBSRURJUkVDVF9VUkkgPSBcInJlZGlyZWN0X3VyaVwiO1xyXG5jb25zdCBSRVNQT05TRV9UWVBFID0gXCJyZXNwb25zZV90eXBlXCI7XHJcbmNvbnN0IFJFU1BPTlNFX01PREUgPSBcInJlc3BvbnNlX21vZGVcIjtcclxuY29uc3QgR1JBTlRfVFlQRSA9IFwiZ3JhbnRfdHlwZVwiO1xyXG5jb25zdCBDTEFJTVMgPSBcImNsYWltc1wiO1xyXG5jb25zdCBTQ09QRSA9IFwic2NvcGVcIjtcclxuY29uc3QgRVJST1IgPSBcImVycm9yXCI7XHJcbmNvbnN0IEVSUk9SX0RFU0NSSVBUSU9OID0gXCJlcnJvcl9kZXNjcmlwdGlvblwiO1xyXG5jb25zdCBBQ0NFU1NfVE9LRU4gPSBcImFjY2Vzc190b2tlblwiO1xyXG5jb25zdCBJRF9UT0tFTiA9IFwiaWRfdG9rZW5cIjtcclxuY29uc3QgUkVGUkVTSF9UT0tFTiA9IFwicmVmcmVzaF90b2tlblwiO1xyXG5jb25zdCBFWFBJUkVTX0lOID0gXCJleHBpcmVzX2luXCI7XHJcbmNvbnN0IFJFRlJFU0hfVE9LRU5fRVhQSVJFU19JTiA9IFwicmVmcmVzaF90b2tlbl9leHBpcmVzX2luXCI7XHJcbmNvbnN0IFNUQVRFID0gXCJzdGF0ZVwiO1xyXG5jb25zdCBOT05DRSA9IFwibm9uY2VcIjtcclxuY29uc3QgUFJPTVBUID0gXCJwcm9tcHRcIjtcclxuY29uc3QgU0VTU0lPTl9TVEFURSA9IFwic2Vzc2lvbl9zdGF0ZVwiO1xyXG5jb25zdCBDTElFTlRfSU5GTyA9IFwiY2xpZW50X2luZm9cIjtcclxuY29uc3QgQ09ERSA9IFwiY29kZVwiO1xyXG5jb25zdCBDT0RFX0NIQUxMRU5HRSA9IFwiY29kZV9jaGFsbGVuZ2VcIjtcclxuY29uc3QgQ09ERV9DSEFMTEVOR0VfTUVUSE9EID0gXCJjb2RlX2NoYWxsZW5nZV9tZXRob2RcIjtcclxuY29uc3QgQ09ERV9WRVJJRklFUiA9IFwiY29kZV92ZXJpZmllclwiO1xyXG5jb25zdCBDTElFTlRfUkVRVUVTVF9JRCA9IFwiY2xpZW50LXJlcXVlc3QtaWRcIjtcclxuY29uc3QgWF9DTElFTlRfU0tVID0gXCJ4LWNsaWVudC1TS1VcIjtcclxuY29uc3QgWF9DTElFTlRfVkVSID0gXCJ4LWNsaWVudC1WRVJcIjtcclxuY29uc3QgWF9DTElFTlRfT1MgPSBcIngtY2xpZW50LU9TXCI7XHJcbmNvbnN0IFhfQ0xJRU5UX0NQVSA9IFwieC1jbGllbnQtQ1BVXCI7XHJcbmNvbnN0IFhfQ0xJRU5UX0NVUlJfVEVMRU0gPSBcIngtY2xpZW50LWN1cnJlbnQtdGVsZW1ldHJ5XCI7XHJcbmNvbnN0IFhfQ0xJRU5UX0xBU1RfVEVMRU0gPSBcIngtY2xpZW50LWxhc3QtdGVsZW1ldHJ5XCI7XHJcbmNvbnN0IFhfTVNfTElCX0NBUEFCSUxJVFkgPSBcIngtbXMtbGliLWNhcGFiaWxpdHlcIjtcclxuY29uc3QgWF9BUFBfTkFNRSA9IFwieC1hcHAtbmFtZVwiO1xyXG5jb25zdCBYX0FQUF9WRVIgPSBcIngtYXBwLXZlclwiO1xyXG5jb25zdCBQT1NUX0xPR09VVF9VUkkgPSBcInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaVwiO1xyXG5jb25zdCBJRF9UT0tFTl9ISU5UID0gXCJpZF90b2tlbl9oaW50XCI7XHJcbmNvbnN0IERFVklDRV9DT0RFID0gXCJkZXZpY2VfY29kZVwiO1xyXG5jb25zdCBDTElFTlRfU0VDUkVUID0gXCJjbGllbnRfc2VjcmV0XCI7XHJcbmNvbnN0IENMSUVOVF9BU1NFUlRJT04gPSBcImNsaWVudF9hc3NlcnRpb25cIjtcclxuY29uc3QgQ0xJRU5UX0FTU0VSVElPTl9UWVBFID0gXCJjbGllbnRfYXNzZXJ0aW9uX3R5cGVcIjtcclxuY29uc3QgVE9LRU5fVFlQRSA9IFwidG9rZW5fdHlwZVwiO1xyXG5jb25zdCBSRVFfQ05GID0gXCJyZXFfY25mXCI7XHJcbmNvbnN0IE9CT19BU1NFUlRJT04gPSBcImFzc2VydGlvblwiO1xyXG5jb25zdCBSRVFVRVNURURfVE9LRU5fVVNFID0gXCJyZXF1ZXN0ZWRfdG9rZW5fdXNlXCI7XHJcbmNvbnN0IE9OX0JFSEFMRl9PRiA9IFwib25fYmVoYWxmX29mXCI7XHJcbmNvbnN0IEZPQ0kgPSBcImZvY2lcIjtcclxuY29uc3QgQ0NTX0hFQURFUiA9IFwiWC1BbmNob3JNYWlsYm94XCI7XHJcbmNvbnN0IFJFVFVSTl9TUEFfQ09ERSA9IFwicmV0dXJuX3NwYV9jb2RlXCI7XHJcbmNvbnN0IE5BVElWRV9CUk9LRVIgPSBcIm5hdGl2ZWJyb2tlclwiO1xyXG5jb25zdCBMT0dPVVRfSElOVCA9IFwibG9nb3V0X2hpbnRcIjtcclxuY29uc3QgU0lEID0gXCJzaWRcIjtcclxuY29uc3QgTE9HSU5fSElOVCA9IFwibG9naW5faGludFwiO1xyXG5jb25zdCBET01BSU5fSElOVCA9IFwiZG9tYWluX2hpbnRcIjtcclxuY29uc3QgWF9DTElFTlRfRVhUUkFfU0tVID0gXCJ4LWNsaWVudC14dHJhLXNrdVwiO1xyXG5jb25zdCBCUk9LRVJfQ0xJRU5UX0lEID0gXCJicmtfY2xpZW50X2lkXCI7XHJcbmNvbnN0IEJST0tFUl9SRURJUkVDVF9VUkkgPSBcImJya19yZWRpcmVjdF91cmlcIjtcclxuY29uc3QgSU5TVEFOQ0VfQVdBUkUgPSBcImluc3RhbmNlX2F3YXJlXCI7XHJcbmNvbnN0IEVBUl9KV0sgPSBcImVhcl9qd2tcIjtcclxuY29uc3QgRUFSX0pXRV9DUllQVE8gPSBcImVhcl9qd2VfY3J5cHRvXCI7XG5cbmV4cG9ydCB7IEFDQ0VTU19UT0tFTiwgQlJPS0VSX0NMSUVOVF9JRCwgQlJPS0VSX1JFRElSRUNUX1VSSSwgQ0NTX0hFQURFUiwgQ0xBSU1TLCBDTElFTlRfQVNTRVJUSU9OLCBDTElFTlRfQVNTRVJUSU9OX1RZUEUsIENMSUVOVF9JRCwgQ0xJRU5UX0lORk8sIENMSUVOVF9SRVFVRVNUX0lELCBDTElFTlRfU0VDUkVULCBDT0RFLCBDT0RFX0NIQUxMRU5HRSwgQ09ERV9DSEFMTEVOR0VfTUVUSE9ELCBDT0RFX1ZFUklGSUVSLCBERVZJQ0VfQ09ERSwgRE9NQUlOX0hJTlQsIEVBUl9KV0VfQ1JZUFRPLCBFQVJfSldLLCBFUlJPUiwgRVJST1JfREVTQ1JJUFRJT04sIEVYUElSRVNfSU4sIEZPQ0ksIEdSQU5UX1RZUEUsIElEX1RPS0VOLCBJRF9UT0tFTl9ISU5ULCBJTlNUQU5DRV9BV0FSRSwgTE9HSU5fSElOVCwgTE9HT1VUX0hJTlQsIE5BVElWRV9CUk9LRVIsIE5PTkNFLCBPQk9fQVNTRVJUSU9OLCBPTl9CRUhBTEZfT0YsIFBPU1RfTE9HT1VUX1VSSSwgUFJPTVBULCBSRURJUkVDVF9VUkksIFJFRlJFU0hfVE9LRU4sIFJFRlJFU0hfVE9LRU5fRVhQSVJFU19JTiwgUkVRVUVTVEVEX1RPS0VOX1VTRSwgUkVRX0NORiwgUkVTUE9OU0VfTU9ERSwgUkVTUE9OU0VfVFlQRSwgUkVUVVJOX1NQQV9DT0RFLCBTQ09QRSwgU0VTU0lPTl9TVEFURSwgU0lELCBTVEFURSwgVE9LRU5fVFlQRSwgWF9BUFBfTkFNRSwgWF9BUFBfVkVSLCBYX0NMSUVOVF9DUFUsIFhfQ0xJRU5UX0NVUlJfVEVMRU0sIFhfQ0xJRU5UX0VYVFJBX1NLVSwgWF9DTElFTlRfTEFTVF9URUxFTSwgWF9DTElFTlRfT1MsIFhfQ0xJRU5UX1NLVSwgWF9DTElFTlRfVkVSLCBYX01TX0xJQl9DQVBBQklMSVRZIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BQURTZXJ2ZXJQYXJhbUtleXMubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gJy4vQXV0aEVycm9yLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3Igd2l0aCB0aGUgc2VydmVyIGNvZGUsIGZvciBleGFtcGxlLCB1bmF2YWlsYWJpbGl0eS5cclxuICovXHJcbmNsYXNzIFNlcnZlckVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZSwgZXJyb3JNZXNzYWdlLCBzdWJFcnJvciwgZXJyb3JObywgc3RhdHVzKSB7XHJcbiAgICAgICAgc3VwZXIoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIHN1YkVycm9yKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNlcnZlckVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5lcnJvck5vID0gZXJyb3JObztcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgU2VydmVyRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBTZXJ2ZXJFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VydmVyRXJyb3IubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIExvZyBtZXNzYWdlIGxldmVsLlxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yXCJdID0gMF0gPSBcIkVycm9yXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5pbmdcIl0gPSAxXSA9IFwiV2FybmluZ1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJbmZvXCJdID0gMl0gPSBcIkluZm9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVmVyYm9zZVwiXSA9IDNdID0gXCJWZXJib3NlXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlRyYWNlXCJdID0gNF0gPSBcIlRyYWNlXCI7XHJcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDbGFzcyB3aGljaCBmYWNpbGl0YXRlcyBsb2dnaW5nIG9mIG1lc3NhZ2VzIHRvIGEgc3BlY2lmaWMgcGxhY2UuXHJcbiAqL1xyXG5jbGFzcyBMb2dnZXIge1xyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyT3B0aW9ucywgcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uKSB7XHJcbiAgICAgICAgLy8gQ3VycmVudCBsb2cgbGV2ZWwsIGRlZmF1bHRzIHRvIGluZm8uXHJcbiAgICAgICAgdGhpcy5sZXZlbCA9IExvZ0xldmVsLkluZm87XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdExvZ2dlckNhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzZXRMb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucyB8fCBMb2dnZXIuY3JlYXRlRGVmYXVsdExvZ2dlck9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLmxvY2FsQ2FsbGJhY2sgPVxyXG4gICAgICAgICAgICBzZXRMb2dnZXJPcHRpb25zLmxvZ2dlckNhbGxiYWNrIHx8IGRlZmF1bHRMb2dnZXJDYWxsYmFjaztcclxuICAgICAgICB0aGlzLnBpaUxvZ2dpbmdFbmFibGVkID0gc2V0TG9nZ2VyT3B0aW9ucy5waWlMb2dnaW5nRW5hYmxlZCB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLmxldmVsID1cclxuICAgICAgICAgICAgdHlwZW9mIHNldExvZ2dlck9wdGlvbnMubG9nTGV2ZWwgPT09IFwibnVtYmVyXCJcclxuICAgICAgICAgICAgICAgID8gc2V0TG9nZ2VyT3B0aW9ucy5sb2dMZXZlbFxyXG4gICAgICAgICAgICAgICAgOiBMb2dMZXZlbC5JbmZvO1xyXG4gICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9XHJcbiAgICAgICAgICAgIHNldExvZ2dlck9wdGlvbnMuY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMucGFja2FnZU5hbWUgPSBwYWNrYWdlTmFtZSB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMucGFja2FnZVZlcnNpb24gPSBwYWNrYWdlVmVyc2lvbiB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZURlZmF1bHRMb2dnZXJPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxvZ2dlckNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB1c2VycyB0byBub3Qgc2V0IGxvZ2dlckNhbGxiYWNrXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBpaUxvZ2dpbmdFbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm8sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIG5ldyBMb2dnZXIgd2l0aCBleGlzdGluZyBjb25maWd1cmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgY2xvbmUocGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uLCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIoe1xyXG4gICAgICAgICAgICBsb2dnZXJDYWxsYmFjazogdGhpcy5sb2NhbENhbGxiYWNrLFxyXG4gICAgICAgICAgICBwaWlMb2dnaW5nRW5hYmxlZDogdGhpcy5waWlMb2dnaW5nRW5hYmxlZCxcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IHRoaXMubGV2ZWwsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgdGhpcy5jb3JyZWxhdGlvbklkLFxyXG4gICAgICAgIH0sIHBhY2thZ2VOYW1lLCBwYWNrYWdlVmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZyBtZXNzYWdlIHdpdGggcmVxdWlyZWQgb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgbG9nTWVzc2FnZShsb2dNZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubG9nTGV2ZWwgPiB0aGlzLmxldmVsIHx8XHJcbiAgICAgICAgICAgICghdGhpcy5waWlMb2dnaW5nRW5hYmxlZCAmJiBvcHRpb25zLmNvbnRhaW5zUGlpKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKTtcclxuICAgICAgICAvLyBBZGQgY29ycmVsYXRpb25JZCB0byBsb2dzIGlmIHNldCwgY29ycmVsYXRpb25JZCBwcm92aWRlZCBvbiBsb2cgbWVzc2FnZXMgdGFrZSBwcmVjZWRlbmNlXHJcbiAgICAgICAgY29uc3QgbG9nSGVhZGVyID0gYFske3RpbWVzdGFtcH1dIDogWyR7b3B0aW9ucy5jb3JyZWxhdGlvbklkIHx8IHRoaXMuY29ycmVsYXRpb25JZCB8fCBcIlwifV1gO1xyXG4gICAgICAgIGNvbnN0IGxvZyA9IGAke2xvZ0hlYWRlcn0gOiAke3RoaXMucGFja2FnZU5hbWV9QCR7dGhpcy5wYWNrYWdlVmVyc2lvbn0gOiAke0xvZ0xldmVsW29wdGlvbnMubG9nTGV2ZWxdfSAtICR7bG9nTWVzc2FnZX1gO1xyXG4gICAgICAgIC8vIGRlYnVnKGBtc2FsOiR7TG9nTGV2ZWxbb3B0aW9ucy5sb2dMZXZlbF19JHtvcHRpb25zLmNvbnRhaW5zUGlpID8gXCItUGlpXCI6IENvbnN0YW50cy5FTVBUWV9TVFJJTkd9JHtvcHRpb25zLmNvbnRleHQgPyBgOiR7b3B0aW9ucy5jb250ZXh0fWAgOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HfWApKGxvZ01lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZUNhbGxiYWNrKG9wdGlvbnMubG9nTGV2ZWwsIGxvZywgb3B0aW9ucy5jb250YWluc1BpaSB8fCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGUgY2FsbGJhY2sgd2l0aCBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBleGVjdXRlQ2FsbGJhY2sobGV2ZWwsIG1lc3NhZ2UsIGNvbnRhaW5zUGlpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubG9jYWxDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsQ2FsbGJhY2sobGV2ZWwsIG1lc3NhZ2UsIGNvbnRhaW5zUGlpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIGVycm9yKG1lc3NhZ2UsIGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xyXG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuRXJyb3IsXHJcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiBmYWxzZSxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGVycm9yIG1lc3NhZ2VzIHdpdGggUElJLlxyXG4gICAgICovXHJcbiAgICBlcnJvclBpaShtZXNzYWdlLCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkVycm9yLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogdHJ1ZSxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHdhcm5pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIHdhcm5pbmcobWVzc2FnZSwgY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgIHRoaXMubG9nTWVzc2FnZShtZXNzYWdlLCB7XHJcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5XYXJuaW5nLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyB3YXJuaW5nIG1lc3NhZ2VzIHdpdGggUElJLlxyXG4gICAgICovXHJcbiAgICB3YXJuaW5nUGlpKG1lc3NhZ2UsIGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xyXG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuV2FybmluZyxcclxuICAgICAgICAgICAgY29udGFpbnNQaWk6IHRydWUsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBpbmZvIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBpbmZvKG1lc3NhZ2UsIGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICB0aGlzLmxvZ01lc3NhZ2UobWVzc2FnZSwge1xyXG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuSW5mbyxcclxuICAgICAgICAgICAgY29udGFpbnNQaWk6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgaW5mbyBtZXNzYWdlcyB3aXRoIFBJSS5cclxuICAgICAqL1xyXG4gICAgaW5mb1BpaShtZXNzYWdlLCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm8sXHJcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiB0cnVlLFxyXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgdmVyYm9zZSBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgdmVyYm9zZShtZXNzYWdlLCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLlZlcmJvc2UsXHJcbiAgICAgICAgICAgIGNvbnRhaW5zUGlpOiBmYWxzZSxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHZlcmJvc2UgbWVzc2FnZXMgd2l0aCBQSUkuXHJcbiAgICAgKi9cclxuICAgIHZlcmJvc2VQaWkobWVzc2FnZSwgY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgIHRoaXMubG9nTWVzc2FnZShtZXNzYWdlLCB7XHJcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5WZXJib3NlLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogdHJ1ZSxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHRyYWNlIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICB0cmFjZShtZXNzYWdlLCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dNZXNzYWdlKG1lc3NhZ2UsIHtcclxuICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ0xldmVsLlRyYWNlLFxyXG4gICAgICAgICAgICBjb250YWluc1BpaTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyB0cmFjZSBtZXNzYWdlcyB3aXRoIFBJSS5cclxuICAgICAqL1xyXG4gICAgdHJhY2VQaWkobWVzc2FnZSwgY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgIHRoaXMubG9nTWVzc2FnZShtZXNzYWdlLCB7XHJcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5UcmFjZSxcclxuICAgICAgICAgICAgY29udGFpbnNQaWk6IHRydWUsXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIFBJSSBMb2dnaW5nIGlzIGVuYWJsZWQgb3Igbm90LlxyXG4gICAgICovXHJcbiAgICBpc1BpaUxvZ2dpbmdFbmFibGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpaUxvZ2dpbmdFbmFibGVkIHx8IGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IExvZ0xldmVsLCBMb2dnZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ2dlci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBdXRob3JpdHkgdHlwZXMgc3VwcG9ydGVkIGJ5IE1TQUwuXHJcbiAqL1xyXG5jb25zdCBBdXRob3JpdHlUeXBlID0ge1xyXG4gICAgRGVmYXVsdDogMCxcclxuICAgIEFkZnM6IDEsXHJcbiAgICBEc3RzOiAyLFxyXG4gICAgQ2lhbTogMyxcclxufTtcblxuZXhwb3J0IHsgQXV0aG9yaXR5VHlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aG9yaXR5VHlwZS5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzT3BlbklkQ29uZmlnUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiAocmVzcG9uc2UuaGFzT3duUHJvcGVydHkoXCJhdXRob3JpemF0aW9uX2VuZHBvaW50XCIpICYmXHJcbiAgICAgICAgcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoXCJ0b2tlbl9lbmRwb2ludFwiKSAmJlxyXG4gICAgICAgIHJlc3BvbnNlLmhhc093blByb3BlcnR5KFwiaXNzdWVyXCIpICYmXHJcbiAgICAgICAgcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoXCJqd2tzX3VyaVwiKSk7XHJcbn1cblxuZXhwb3J0IHsgaXNPcGVuSWRDb25maWdSZXNwb25zZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3BlbklkQ29uZmlnUmVzcG9uc2UubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCByZWRpcmVjdFVyaUVtcHR5ID0gXCJyZWRpcmVjdF91cmlfZW1wdHlcIjtcclxuY29uc3QgY2xhaW1zUmVxdWVzdFBhcnNpbmdFcnJvciA9IFwiY2xhaW1zX3JlcXVlc3RfcGFyc2luZ19lcnJvclwiO1xyXG5jb25zdCBhdXRob3JpdHlVcmlJbnNlY3VyZSA9IFwiYXV0aG9yaXR5X3VyaV9pbnNlY3VyZVwiO1xyXG5jb25zdCB1cmxQYXJzZUVycm9yID0gXCJ1cmxfcGFyc2VfZXJyb3JcIjtcclxuY29uc3QgdXJsRW1wdHlFcnJvciA9IFwiZW1wdHlfdXJsX2Vycm9yXCI7XHJcbmNvbnN0IGVtcHR5SW5wdXRTY29wZXNFcnJvciA9IFwiZW1wdHlfaW5wdXRfc2NvcGVzX2Vycm9yXCI7XHJcbmNvbnN0IGludmFsaWRQcm9tcHRWYWx1ZSA9IFwiaW52YWxpZF9wcm9tcHRfdmFsdWVcIjtcclxuY29uc3QgaW52YWxpZENsYWltcyA9IFwiaW52YWxpZF9jbGFpbXNcIjtcclxuY29uc3QgdG9rZW5SZXF1ZXN0RW1wdHkgPSBcInRva2VuX3JlcXVlc3RfZW1wdHlcIjtcclxuY29uc3QgbG9nb3V0UmVxdWVzdEVtcHR5ID0gXCJsb2dvdXRfcmVxdWVzdF9lbXB0eVwiO1xyXG5jb25zdCBpbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZCA9IFwiaW52YWxpZF9jb2RlX2NoYWxsZW5nZV9tZXRob2RcIjtcclxuY29uc3QgcGtjZVBhcmFtc01pc3NpbmcgPSBcInBrY2VfcGFyYW1zX21pc3NpbmdcIjtcclxuY29uc3QgaW52YWxpZENsb3VkRGlzY292ZXJ5TWV0YWRhdGEgPSBcImludmFsaWRfY2xvdWRfZGlzY292ZXJ5X21ldGFkYXRhXCI7XHJcbmNvbnN0IGludmFsaWRBdXRob3JpdHlNZXRhZGF0YSA9IFwiaW52YWxpZF9hdXRob3JpdHlfbWV0YWRhdGFcIjtcclxuY29uc3QgdW50cnVzdGVkQXV0aG9yaXR5ID0gXCJ1bnRydXN0ZWRfYXV0aG9yaXR5XCI7XHJcbmNvbnN0IG1pc3NpbmdTc2hKd2sgPSBcIm1pc3Npbmdfc3NoX2p3a1wiO1xyXG5jb25zdCBtaXNzaW5nU3NoS2lkID0gXCJtaXNzaW5nX3NzaF9raWRcIjtcclxuY29uc3QgbWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXIgPSBcIm1pc3Npbmdfbm9uY2VfYXV0aGVudGljYXRpb25faGVhZGVyXCI7XHJcbmNvbnN0IGludmFsaWRBdXRoZW50aWNhdGlvbkhlYWRlciA9IFwiaW52YWxpZF9hdXRoZW50aWNhdGlvbl9oZWFkZXJcIjtcclxuY29uc3QgY2Fubm90U2V0T0lEQ09wdGlvbnMgPSBcImNhbm5vdF9zZXRfT0lEQ09wdGlvbnNcIjtcclxuY29uc3QgY2Fubm90QWxsb3dQbGF0Zm9ybUJyb2tlciA9IFwiY2Fubm90X2FsbG93X3BsYXRmb3JtX2Jyb2tlclwiO1xyXG5jb25zdCBhdXRob3JpdHlNaXNtYXRjaCA9IFwiYXV0aG9yaXR5X21pc21hdGNoXCI7XG5cbmV4cG9ydCB7IGF1dGhvcml0eU1pc21hdGNoLCBhdXRob3JpdHlVcmlJbnNlY3VyZSwgY2Fubm90QWxsb3dQbGF0Zm9ybUJyb2tlciwgY2Fubm90U2V0T0lEQ09wdGlvbnMsIGNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3IsIGVtcHR5SW5wdXRTY29wZXNFcnJvciwgaW52YWxpZEF1dGhlbnRpY2F0aW9uSGVhZGVyLCBpbnZhbGlkQXV0aG9yaXR5TWV0YWRhdGEsIGludmFsaWRDbGFpbXMsIGludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhLCBpbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZCwgaW52YWxpZFByb21wdFZhbHVlLCBsb2dvdXRSZXF1ZXN0RW1wdHksIG1pc3NpbmdOb25jZUF1dGhlbnRpY2F0aW9uSGVhZGVyLCBtaXNzaW5nU3NoSndrLCBtaXNzaW5nU3NoS2lkLCBwa2NlUGFyYW1zTWlzc2luZywgcmVkaXJlY3RVcmlFbXB0eSwgdG9rZW5SZXF1ZXN0RW1wdHksIHVudHJ1c3RlZEF1dGhvcml0eSwgdXJsRW1wdHlFcnJvciwgdXJsUGFyc2VFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gJy4vQXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyByZWRpcmVjdFVyaUVtcHR5LCBjbGFpbXNSZXF1ZXN0UGFyc2luZ0Vycm9yLCBhdXRob3JpdHlVcmlJbnNlY3VyZSwgdXJsUGFyc2VFcnJvciwgdXJsRW1wdHlFcnJvciwgZW1wdHlJbnB1dFNjb3Blc0Vycm9yLCBpbnZhbGlkUHJvbXB0VmFsdWUsIGludmFsaWRDbGFpbXMsIHRva2VuUmVxdWVzdEVtcHR5LCBsb2dvdXRSZXF1ZXN0RW1wdHksIGludmFsaWRDb2RlQ2hhbGxlbmdlTWV0aG9kLCBwa2NlUGFyYW1zTWlzc2luZywgaW52YWxpZENsb3VkRGlzY292ZXJ5TWV0YWRhdGEsIGludmFsaWRBdXRob3JpdHlNZXRhZGF0YSwgdW50cnVzdGVkQXV0aG9yaXR5LCBtaXNzaW5nU3NoSndrLCBtaXNzaW5nU3NoS2lkLCBtaXNzaW5nTm9uY2VBdXRoZW50aWNhdGlvbkhlYWRlciwgaW52YWxpZEF1dGhlbnRpY2F0aW9uSGVhZGVyLCBjYW5ub3RTZXRPSURDT3B0aW9ucywgY2Fubm90QWxsb3dQbGF0Zm9ybUJyb2tlciwgYXV0aG9yaXR5TWlzbWF0Y2ggfSBmcm9tICcuL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1qcyc7XG5pbXBvcnQgKiBhcyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2RlcyBmcm9tICcuL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1qcyc7XG5leHBvcnQgeyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2RlcyB9O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXMgPSB7XHJcbiAgICBbcmVkaXJlY3RVcmlFbXB0eV06IFwiQSByZWRpcmVjdCBVUkkgaXMgcmVxdWlyZWQgZm9yIGFsbCBjYWxscywgYW5kIG5vbmUgaGFzIGJlZW4gc2V0LlwiLFxyXG4gICAgW2NsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3JdOiBcIkNvdWxkIG5vdCBwYXJzZSB0aGUgZ2l2ZW4gY2xhaW1zIHJlcXVlc3Qgb2JqZWN0LlwiLFxyXG4gICAgW2F1dGhvcml0eVVyaUluc2VjdXJlXTogXCJBdXRob3JpdHkgVVJJcyBtdXN0IHVzZSBodHRwcy4gIFBsZWFzZSBzZWUgaGVyZSBmb3IgdmFsaWQgYXV0aG9yaXR5IGNvbmZpZ3VyYXRpb24gb3B0aW9uczogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvYWN0aXZlLWRpcmVjdG9yeS9kZXZlbG9wL21zYWwtanMtaW5pdGlhbGl6aW5nLWNsaWVudC1hcHBsaWNhdGlvbnMjY29uZmlndXJhdGlvbi1vcHRpb25zXCIsXHJcbiAgICBbdXJsUGFyc2VFcnJvcl06IFwiVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWQgaW50byBhcHByb3ByaWF0ZSBzZWdtZW50cy5cIixcclxuICAgIFt1cmxFbXB0eUVycm9yXTogXCJVUkwgd2FzIGVtcHR5IG9yIG51bGwuXCIsXHJcbiAgICBbZW1wdHlJbnB1dFNjb3Blc0Vycm9yXTogXCJTY29wZXMgY2Fubm90IGJlIHBhc3NlZCBhcyBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkgYXJyYXkgYmVjYXVzZSB0aGV5IGFyZSByZXF1aXJlZCB0byBvYnRhaW4gYW4gYWNjZXNzIHRva2VuLlwiLFxyXG4gICAgW2ludmFsaWRQcm9tcHRWYWx1ZV06IFwiUGxlYXNlIHNlZSBoZXJlIGZvciB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbnM6IGh0dHBzOi8vYXp1cmVhZC5naXRodWIuaW8vbWljcm9zb2Z0LWF1dGhlbnRpY2F0aW9uLWxpYnJhcnktZm9yLWpzL3JlZi9tb2R1bGVzL19henVyZV9tc2FsX2NvbW1vbi5odG1sI2NvbW1vbmF1dGhvcml6YXRpb251cmxyZXF1ZXN0XCIsXHJcbiAgICBbaW52YWxpZENsYWltc106IFwiR2l2ZW4gY2xhaW1zIHBhcmFtZXRlciBtdXN0IGJlIGEgc3RyaW5naWZpZWQgSlNPTiBvYmplY3QuXCIsXHJcbiAgICBbdG9rZW5SZXF1ZXN0RW1wdHldOiBcIlRva2VuIHJlcXVlc3Qgd2FzIGVtcHR5IGFuZCBub3QgZm91bmQgaW4gY2FjaGUuXCIsXHJcbiAgICBbbG9nb3V0UmVxdWVzdEVtcHR5XTogXCJUaGUgbG9nb3V0IHJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkLlwiLFxyXG4gICAgW2ludmFsaWRDb2RlQ2hhbGxlbmdlTWV0aG9kXTogJ2NvZGVfY2hhbGxlbmdlX21ldGhvZCBwYXNzZWQgaXMgaW52YWxpZC4gVmFsaWQgdmFsdWVzIGFyZSBcInBsYWluXCIgYW5kIFwiUzI1NlwiLicsXHJcbiAgICBbcGtjZVBhcmFtc01pc3NpbmddOiBcIkJvdGggcGFyYW1zOiBjb2RlX2NoYWxsZW5nZSBhbmQgY29kZV9jaGFsbGVuZ2VfbWV0aG9kIGFyZSB0byBiZSBwYXNzZWQgaWYgdG8gYmUgc2VudCBpbiB0aGUgcmVxdWVzdFwiLFxyXG4gICAgW2ludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhXTogXCJJbnZhbGlkIGNsb3VkRGlzY292ZXJ5TWV0YWRhdGEgcHJvdmlkZWQuIE11c3QgYmUgYSBzdHJpbmdpZmllZCBKU09OIG9iamVjdCBjb250YWluaW5nIHRlbmFudF9kaXNjb3ZlcnlfZW5kcG9pbnQgYW5kIG1ldGFkYXRhIGZpZWxkc1wiLFxyXG4gICAgW2ludmFsaWRBdXRob3JpdHlNZXRhZGF0YV06IFwiSW52YWxpZCBhdXRob3JpdHlNZXRhZGF0YSBwcm92aWRlZC4gTXVzdCBieSBhIHN0cmluZ2lmaWVkIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgYXV0aG9yaXphdGlvbl9lbmRwb2ludCwgdG9rZW5fZW5kcG9pbnQsIGlzc3VlciBmaWVsZHMuXCIsXHJcbiAgICBbdW50cnVzdGVkQXV0aG9yaXR5XTogXCJUaGUgcHJvdmlkZWQgYXV0aG9yaXR5IGlzIG5vdCBhIHRydXN0ZWQgYXV0aG9yaXR5LiBQbGVhc2UgaW5jbHVkZSB0aGlzIGF1dGhvcml0eSBpbiB0aGUga25vd25BdXRob3JpdGllcyBjb25maWcgcGFyYW1ldGVyLlwiLFxyXG4gICAgW21pc3NpbmdTc2hKd2tdOiBcIk1pc3Npbmcgc3NoSndrIGluIFNTSCBjZXJ0aWZpY2F0ZSByZXF1ZXN0LiBBIHN0cmluZ2lmaWVkIEpTT04gV2ViIEtleSBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIHRoZSBTU0ggYXV0aGVudGljYXRpb24gc2NoZW1lLlwiLFxyXG4gICAgW21pc3NpbmdTc2hLaWRdOiBcIk1pc3Npbmcgc3NoS2lkIGluIFNTSCBjZXJ0aWZpY2F0ZSByZXF1ZXN0LiBBIHN0cmluZyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIHB1YmxpYyBTU0gga2V5IGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgdGhlIFNTSCBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXCIsXHJcbiAgICBbbWlzc2luZ05vbmNlQXV0aGVudGljYXRpb25IZWFkZXJdOiBcIlVuYWJsZSB0byBmaW5kIGFuIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBjb250YWluaW5nIHNlcnZlciBub25jZS4gRWl0aGVyIHRoZSBBdXRoZW50aWNhdGlvbi1JbmZvIG9yIFdXVy1BdXRoZW50aWNhdGUgaGVhZGVycyBtdXN0IGJlIHByZXNlbnQgaW4gb3JkZXIgdG8gb2J0YWluIGEgc2VydmVyIG5vbmNlLlwiLFxyXG4gICAgW2ludmFsaWRBdXRoZW50aWNhdGlvbkhlYWRlcl06IFwiSW52YWxpZCBhdXRoZW50aWNhdGlvbiBoZWFkZXIgcHJvdmlkZWRcIixcclxuICAgIFtjYW5ub3RTZXRPSURDT3B0aW9uc106IFwiQ2Fubm90IHNldCBPSURDT3B0aW9ucyBwYXJhbWV0ZXIuIFBsZWFzZSBjaGFuZ2UgdGhlIHByb3RvY29sIG1vZGUgdG8gT0lEQyBvciB1c2UgYSBub24tTWljcm9zb2Z0IGF1dGhvcml0eS5cIixcclxuICAgIFtjYW5ub3RBbGxvd1BsYXRmb3JtQnJva2VyXTogXCJDYW5ub3Qgc2V0IGFsbG93UGxhdGZvcm1Ccm9rZXIgcGFyYW1ldGVyIHRvIHRydWUgd2hlbiBub3QgaW4gQUFEIHByb3RvY29sIG1vZGUuXCIsXHJcbiAgICBbYXV0aG9yaXR5TWlzbWF0Y2hdOiBcIkF1dGhvcml0eSBtaXNtYXRjaCBlcnJvci4gQXV0aG9yaXR5IHByb3ZpZGVkIGluIGxvZ2luIHJlcXVlc3Qgb3IgUHVibGljQ2xpZW50QXBwbGljYXRpb24gY29uZmlnIGRvZXMgbm90IG1hdGNoIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgcHJvdmlkZWQgYWNjb3VudC4gUGxlYXNlIHVzZSBhIG1hdGNoaW5nIGFjY291bnQgb3IgbWFrZSBhbiBpbnRlcmFjdGl2ZSByZXF1ZXN0IHRvIGxvZ2luIHRvIHRoaXMgYXV0aG9yaXR5LlwiLFxyXG59O1xyXG4vKipcclxuICogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZSBjbGFzcyBjb250YWluaW5nIHN0cmluZyBjb25zdGFudHMgdXNlZCBieSBlcnJvciBjb2RlcyBhbmQgbWVzc2FnZXMuXHJcbiAqIEBkZXByZWNhdGVkIFVzZSBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2RlcyBpbnN0ZWFkXHJcbiAqL1xyXG5jb25zdCBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlID0ge1xyXG4gICAgcmVkaXJlY3RVcmlOb3RTZXQ6IHtcclxuICAgICAgICBjb2RlOiByZWRpcmVjdFVyaUVtcHR5LFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW3JlZGlyZWN0VXJpRW1wdHldLFxyXG4gICAgfSxcclxuICAgIGNsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBjbGFpbXNSZXF1ZXN0UGFyc2luZ0Vycm9yLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2NsYWltc1JlcXVlc3RQYXJzaW5nRXJyb3JdLFxyXG4gICAgfSxcclxuICAgIGF1dGhvcml0eVVyaUluc2VjdXJlOiB7XHJcbiAgICAgICAgY29kZTogYXV0aG9yaXR5VXJpSW5zZWN1cmUsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbYXV0aG9yaXR5VXJpSW5zZWN1cmVdLFxyXG4gICAgfSxcclxuICAgIHVybFBhcnNlRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiB1cmxQYXJzZUVycm9yLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW3VybFBhcnNlRXJyb3JdLFxyXG4gICAgfSxcclxuICAgIHVybEVtcHR5RXJyb3I6IHtcclxuICAgICAgICBjb2RlOiB1cmxFbXB0eUVycm9yLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW3VybEVtcHR5RXJyb3JdLFxyXG4gICAgfSxcclxuICAgIGVtcHR5U2NvcGVzRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBlbXB0eUlucHV0U2NvcGVzRXJyb3IsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbZW1wdHlJbnB1dFNjb3Blc0Vycm9yXSxcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkUHJvbXB0OiB7XHJcbiAgICAgICAgY29kZTogaW52YWxpZFByb21wdFZhbHVlLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2ludmFsaWRQcm9tcHRWYWx1ZV0sXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZENsYWltc1JlcXVlc3Q6IHtcclxuICAgICAgICBjb2RlOiBpbnZhbGlkQ2xhaW1zLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2ludmFsaWRDbGFpbXNdLFxyXG4gICAgfSxcclxuICAgIHRva2VuUmVxdWVzdEVtcHR5RXJyb3I6IHtcclxuICAgICAgICBjb2RlOiB0b2tlblJlcXVlc3RFbXB0eSxcclxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1t0b2tlblJlcXVlc3RFbXB0eV0sXHJcbiAgICB9LFxyXG4gICAgbG9nb3V0UmVxdWVzdEVtcHR5RXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBsb2dvdXRSZXF1ZXN0RW1wdHksXHJcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbbG9nb3V0UmVxdWVzdEVtcHR5XSxcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZDoge1xyXG4gICAgICAgIGNvZGU6IGludmFsaWRDb2RlQ2hhbGxlbmdlTWV0aG9kLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2ludmFsaWRDb2RlQ2hhbGxlbmdlTWV0aG9kXSxcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkQ29kZUNoYWxsZW5nZVBhcmFtczoge1xyXG4gICAgICAgIGNvZGU6IHBrY2VQYXJhbXNNaXNzaW5nLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW3BrY2VQYXJhbXNNaXNzaW5nXSxcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YToge1xyXG4gICAgICAgIGNvZGU6IGludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2ludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhXSxcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkQXV0aG9yaXR5TWV0YWRhdGE6IHtcclxuICAgICAgICBjb2RlOiBpbnZhbGlkQXV0aG9yaXR5TWV0YWRhdGEsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbaW52YWxpZEF1dGhvcml0eU1ldGFkYXRhXSxcclxuICAgIH0sXHJcbiAgICB1bnRydXN0ZWRBdXRob3JpdHk6IHtcclxuICAgICAgICBjb2RlOiB1bnRydXN0ZWRBdXRob3JpdHksXHJcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbdW50cnVzdGVkQXV0aG9yaXR5XSxcclxuICAgIH0sXHJcbiAgICBtaXNzaW5nU3NoSndrOiB7XHJcbiAgICAgICAgY29kZTogbWlzc2luZ1NzaEp3ayxcclxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1ttaXNzaW5nU3NoSndrXSxcclxuICAgIH0sXHJcbiAgICBtaXNzaW5nU3NoS2lkOiB7XHJcbiAgICAgICAgY29kZTogbWlzc2luZ1NzaEtpZCxcclxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1ttaXNzaW5nU3NoS2lkXSxcclxuICAgIH0sXHJcbiAgICBtaXNzaW5nTm9uY2VBdXRoZW50aWNhdGlvbkhlYWRlcjoge1xyXG4gICAgICAgIGNvZGU6IG1pc3NpbmdOb25jZUF1dGhlbnRpY2F0aW9uSGVhZGVyLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW21pc3NpbmdOb25jZUF1dGhlbnRpY2F0aW9uSGVhZGVyXSxcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkQXV0aGVudGljYXRpb25IZWFkZXI6IHtcclxuICAgICAgICBjb2RlOiBpbnZhbGlkQXV0aGVudGljYXRpb25IZWFkZXIsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXNbaW52YWxpZEF1dGhlbnRpY2F0aW9uSGVhZGVyXSxcclxuICAgIH0sXHJcbiAgICBjYW5ub3RTZXRPSURDT3B0aW9uczoge1xyXG4gICAgICAgIGNvZGU6IGNhbm5vdFNldE9JRENPcHRpb25zLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2Nhbm5vdFNldE9JRENPcHRpb25zXSxcclxuICAgIH0sXHJcbiAgICBjYW5ub3RBbGxvd1BsYXRmb3JtQnJva2VyOiB7XHJcbiAgICAgICAgY29kZTogY2Fubm90QWxsb3dQbGF0Zm9ybUJyb2tlcixcclxuICAgICAgICBkZXNjOiBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tjYW5ub3RBbGxvd1BsYXRmb3JtQnJva2VyXSxcclxuICAgIH0sXHJcbiAgICBhdXRob3JpdHlNaXNtYXRjaDoge1xyXG4gICAgICAgIGNvZGU6IGF1dGhvcml0eU1pc21hdGNoLFxyXG4gICAgICAgIGRlc2M6IENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2VzW2F1dGhvcml0eU1pc21hdGNoXSxcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBpbiBjb25maWd1cmF0aW9uIG9mIHRoZSBNU0FMLmpzIGxpYnJhcnkuXHJcbiAqL1xyXG5jbGFzcyBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlKSB7XHJcbiAgICAgICAgc3VwZXIoZXJyb3JDb2RlLCBDbGllbnRDb25maWd1cmF0aW9uRXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIkNsaWVudENvbmZpZ3VyYXRpb25FcnJvclwiO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDbGllbnRDb25maWd1cmF0aW9uRXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoZXJyb3JDb2RlKSB7XHJcbiAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb25FcnJvcihlcnJvckNvZGUpO1xyXG59XG5cbmV4cG9ydCB7IENsaWVudENvbmZpZ3VyYXRpb25FcnJvciwgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZSwgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yTWVzc2FnZXMsIGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50Q29uZmlndXJhdGlvbkVycm9yLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmNsYXNzIFN0cmluZ1V0aWxzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgc3RyaW5naWZpZWQgb2JqZWN0IGlzIGVtcHR5XHJcbiAgICAgKiBAcGFyYW0gc3RyT2JqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0VtcHR5T2JqKHN0ck9iaikge1xyXG4gICAgICAgIGlmIChzdHJPYmopIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2Uoc3RyT2JqKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoKSA9PT0gMDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbmRzV2l0aChzdHIsIHNlYXJjaCkge1xyXG4gICAgICAgIHJldHVybiAoc3RyLmxlbmd0aCA+PSBzZWFyY2gubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHN0ci5sYXN0SW5kZXhPZihzZWFyY2gpID09PSBzdHIubGVuZ3RoIC0gc2VhcmNoLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBzdHJpbmcgaW50byBhbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBxdWVyeVN0cmluZ1RvT2JqZWN0KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gcXVlcnkuc3BsaXQoXCImXCIpO1xyXG4gICAgICAgIGNvbnN0IGRlY29kZSA9IChzKSA9PiBkZWNvZGVVUklDb21wb25lbnQocy5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcclxuICAgICAgICBwYXJhbXMuZm9yRWFjaCgocGFpcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGFpci50cmltKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXIuc3BsaXQoLz0oLispL2csIDIpOyAvLyBTcGxpdCBvbiB0aGUgZmlyc3Qgb2NjdXJlbmNlIG9mIHRoZSAnPScgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2RlY29kZShrZXkpXSA9IGRlY29kZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmltcyBlbnRyaWVzIGluIGFuIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhcnJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyaW1BcnJheUVudHJpZXMoYXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKGVudHJ5KSA9PiBlbnRyeS50cmltKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGVtcHR5IHN0cmluZ3MgZnJvbSBhcnJheVxyXG4gICAgICogQHBhcmFtIGFyclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVtb3ZlRW1wdHlTdHJpbmdzRnJvbUFycmF5KGFycikge1xyXG4gICAgICAgIHJldHVybiBhcnIuZmlsdGVyKChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gISFlbnRyeTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSBzdHJpbmcgaW50byBKU09OXHJcbiAgICAgKiBAcGFyYW0gc3RyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBqc29uUGFyc2VIZWxwZXIoc3RyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiBhIGdpdmVuIHN0cmluZyBtYXRjaGVzIGEgZ2l2ZW4gcGF0dGVybiwgd2l0aCBzdXBwb3J0IGZvciB3aWxkY2FyZHMgYW5kIHF1ZXJpZXMuXHJcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBXaWxkY2FyZCBwYXR0ZXJuIHRvIHN0cmluZyBtYXRjaC4gU3VwcG9ydHMgXCIqXCIgZm9yIHdpbGRjYXJkcyBhbmQgXCI/XCIgZm9yIHF1ZXJpZXNcclxuICAgICAqIEBwYXJhbSBpbnB1dCBTdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIGlucHV0KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2lsZGNhcmQgc3VwcG9ydDogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxMTcyNDgvNDg4ODU1OVxyXG4gICAgICAgICAqIFF1ZXJpZXM6IHJlcGxhY2VzIFwiP1wiIGluIHN0cmluZyB3aXRoIGVzY2FwZWQgXCJcXD9cIiBmb3IgcmVnZXggdGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtbm9uLWxpdGVyYWwtcmVnZXhwXHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm5cclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwqL2csIFwiW14gXSpcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcPy9nLCBcIlxcXFw/XCIpKTtcclxuICAgICAgICByZXR1cm4gcmVnZXgudGVzdChpbnB1dCk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgU3RyaW5nVXRpbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ1V0aWxzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgY2xpZW50SW5mb0RlY29kaW5nRXJyb3IgPSBcImNsaWVudF9pbmZvX2RlY29kaW5nX2Vycm9yXCI7XHJcbmNvbnN0IGNsaWVudEluZm9FbXB0eUVycm9yID0gXCJjbGllbnRfaW5mb19lbXB0eV9lcnJvclwiO1xyXG5jb25zdCB0b2tlblBhcnNpbmdFcnJvciA9IFwidG9rZW5fcGFyc2luZ19lcnJvclwiO1xyXG5jb25zdCBudWxsT3JFbXB0eVRva2VuID0gXCJudWxsX29yX2VtcHR5X3Rva2VuXCI7XHJcbmNvbnN0IGVuZHBvaW50UmVzb2x1dGlvbkVycm9yID0gXCJlbmRwb2ludHNfcmVzb2x1dGlvbl9lcnJvclwiO1xyXG5jb25zdCBuZXR3b3JrRXJyb3IgPSBcIm5ldHdvcmtfZXJyb3JcIjtcclxuY29uc3Qgb3BlbklkQ29uZmlnRXJyb3IgPSBcIm9wZW5pZF9jb25maWdfZXJyb3JcIjtcclxuY29uc3QgaGFzaE5vdERlc2VyaWFsaXplZCA9IFwiaGFzaF9ub3RfZGVzZXJpYWxpemVkXCI7XHJcbmNvbnN0IGludmFsaWRTdGF0ZSA9IFwiaW52YWxpZF9zdGF0ZVwiO1xyXG5jb25zdCBzdGF0ZU1pc21hdGNoID0gXCJzdGF0ZV9taXNtYXRjaFwiO1xyXG5jb25zdCBzdGF0ZU5vdEZvdW5kID0gXCJzdGF0ZV9ub3RfZm91bmRcIjtcclxuY29uc3Qgbm9uY2VNaXNtYXRjaCA9IFwibm9uY2VfbWlzbWF0Y2hcIjtcclxuY29uc3QgYXV0aFRpbWVOb3RGb3VuZCA9IFwiYXV0aF90aW1lX25vdF9mb3VuZFwiO1xyXG5jb25zdCBtYXhBZ2VUcmFuc3BpcmVkID0gXCJtYXhfYWdlX3RyYW5zcGlyZWRcIjtcclxuY29uc3QgbXVsdGlwbGVNYXRjaGluZ1Rva2VucyA9IFwibXVsdGlwbGVfbWF0Y2hpbmdfdG9rZW5zXCI7XHJcbmNvbnN0IG11bHRpcGxlTWF0Y2hpbmdBY2NvdW50cyA9IFwibXVsdGlwbGVfbWF0Y2hpbmdfYWNjb3VudHNcIjtcclxuY29uc3QgbXVsdGlwbGVNYXRjaGluZ0FwcE1ldGFkYXRhID0gXCJtdWx0aXBsZV9tYXRjaGluZ19hcHBNZXRhZGF0YVwiO1xyXG5jb25zdCByZXF1ZXN0Q2Fubm90QmVNYWRlID0gXCJyZXF1ZXN0X2Nhbm5vdF9iZV9tYWRlXCI7XHJcbmNvbnN0IGNhbm5vdFJlbW92ZUVtcHR5U2NvcGUgPSBcImNhbm5vdF9yZW1vdmVfZW1wdHlfc2NvcGVcIjtcclxuY29uc3QgY2Fubm90QXBwZW5kU2NvcGVTZXQgPSBcImNhbm5vdF9hcHBlbmRfc2NvcGVzZXRcIjtcclxuY29uc3QgZW1wdHlJbnB1dFNjb3BlU2V0ID0gXCJlbXB0eV9pbnB1dF9zY29wZXNldFwiO1xyXG5jb25zdCBkZXZpY2VDb2RlUG9sbGluZ0NhbmNlbGxlZCA9IFwiZGV2aWNlX2NvZGVfcG9sbGluZ19jYW5jZWxsZWRcIjtcclxuY29uc3QgZGV2aWNlQ29kZUV4cGlyZWQgPSBcImRldmljZV9jb2RlX2V4cGlyZWRcIjtcclxuY29uc3QgZGV2aWNlQ29kZVVua25vd25FcnJvciA9IFwiZGV2aWNlX2NvZGVfdW5rbm93bl9lcnJvclwiO1xyXG5jb25zdCBub0FjY291bnRJblNpbGVudFJlcXVlc3QgPSBcIm5vX2FjY291bnRfaW5fc2lsZW50X3JlcXVlc3RcIjtcclxuY29uc3QgaW52YWxpZENhY2hlUmVjb3JkID0gXCJpbnZhbGlkX2NhY2hlX3JlY29yZFwiO1xyXG5jb25zdCBpbnZhbGlkQ2FjaGVFbnZpcm9ubWVudCA9IFwiaW52YWxpZF9jYWNoZV9lbnZpcm9ubWVudFwiO1xyXG5jb25zdCBub0FjY291bnRGb3VuZCA9IFwibm9fYWNjb3VudF9mb3VuZFwiO1xyXG5jb25zdCBub0NyeXB0b09iamVjdCA9IFwibm9fY3J5cHRvX29iamVjdFwiO1xyXG5jb25zdCB1bmV4cGVjdGVkQ3JlZGVudGlhbFR5cGUgPSBcInVuZXhwZWN0ZWRfY3JlZGVudGlhbF90eXBlXCI7XHJcbmNvbnN0IGludmFsaWRBc3NlcnRpb24gPSBcImludmFsaWRfYXNzZXJ0aW9uXCI7XHJcbmNvbnN0IGludmFsaWRDbGllbnRDcmVkZW50aWFsID0gXCJpbnZhbGlkX2NsaWVudF9jcmVkZW50aWFsXCI7XHJcbmNvbnN0IHRva2VuUmVmcmVzaFJlcXVpcmVkID0gXCJ0b2tlbl9yZWZyZXNoX3JlcXVpcmVkXCI7XHJcbmNvbnN0IHVzZXJUaW1lb3V0UmVhY2hlZCA9IFwidXNlcl90aW1lb3V0X3JlYWNoZWRcIjtcclxuY29uc3QgdG9rZW5DbGFpbXNDbmZSZXF1aXJlZEZvclNpZ25lZEp3dCA9IFwidG9rZW5fY2xhaW1zX2NuZl9yZXF1aXJlZF9mb3Jfc2lnbmVkand0XCI7XHJcbmNvbnN0IGF1dGhvcml6YXRpb25Db2RlTWlzc2luZ0Zyb21TZXJ2ZXJSZXNwb25zZSA9IFwiYXV0aG9yaXphdGlvbl9jb2RlX21pc3NpbmdfZnJvbV9zZXJ2ZXJfcmVzcG9uc2VcIjtcclxuY29uc3QgYmluZGluZ0tleU5vdFJlbW92ZWQgPSBcImJpbmRpbmdfa2V5X25vdF9yZW1vdmVkXCI7XHJcbmNvbnN0IGVuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZCA9IFwiZW5kX3Nlc3Npb25fZW5kcG9pbnRfbm90X3N1cHBvcnRlZFwiO1xyXG5jb25zdCBrZXlJZE1pc3NpbmcgPSBcImtleV9pZF9taXNzaW5nXCI7XHJcbmNvbnN0IG5vTmV0d29ya0Nvbm5lY3Rpdml0eSA9IFwibm9fbmV0d29ya19jb25uZWN0aXZpdHlcIjtcclxuY29uc3QgdXNlckNhbmNlbGVkID0gXCJ1c2VyX2NhbmNlbGVkXCI7XHJcbmNvbnN0IG1pc3NpbmdUZW5hbnRJZEVycm9yID0gXCJtaXNzaW5nX3RlbmFudF9pZF9lcnJvclwiO1xyXG5jb25zdCBtZXRob2ROb3RJbXBsZW1lbnRlZCA9IFwibWV0aG9kX25vdF9pbXBsZW1lbnRlZFwiO1xyXG5jb25zdCBuZXN0ZWRBcHBBdXRoQnJpZGdlRGlzYWJsZWQgPSBcIm5lc3RlZF9hcHBfYXV0aF9icmlkZ2VfZGlzYWJsZWRcIjtcblxuZXhwb3J0IHsgYXV0aFRpbWVOb3RGb3VuZCwgYXV0aG9yaXphdGlvbkNvZGVNaXNzaW5nRnJvbVNlcnZlclJlc3BvbnNlLCBiaW5kaW5nS2V5Tm90UmVtb3ZlZCwgY2Fubm90QXBwZW5kU2NvcGVTZXQsIGNhbm5vdFJlbW92ZUVtcHR5U2NvcGUsIGNsaWVudEluZm9EZWNvZGluZ0Vycm9yLCBjbGllbnRJbmZvRW1wdHlFcnJvciwgZGV2aWNlQ29kZUV4cGlyZWQsIGRldmljZUNvZGVQb2xsaW5nQ2FuY2VsbGVkLCBkZXZpY2VDb2RlVW5rbm93bkVycm9yLCBlbXB0eUlucHV0U2NvcGVTZXQsIGVuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZCwgZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3IsIGhhc2hOb3REZXNlcmlhbGl6ZWQsIGludmFsaWRBc3NlcnRpb24sIGludmFsaWRDYWNoZUVudmlyb25tZW50LCBpbnZhbGlkQ2FjaGVSZWNvcmQsIGludmFsaWRDbGllbnRDcmVkZW50aWFsLCBpbnZhbGlkU3RhdGUsIGtleUlkTWlzc2luZywgbWF4QWdlVHJhbnNwaXJlZCwgbWV0aG9kTm90SW1wbGVtZW50ZWQsIG1pc3NpbmdUZW5hbnRJZEVycm9yLCBtdWx0aXBsZU1hdGNoaW5nQWNjb3VudHMsIG11bHRpcGxlTWF0Y2hpbmdBcHBNZXRhZGF0YSwgbXVsdGlwbGVNYXRjaGluZ1Rva2VucywgbmVzdGVkQXBwQXV0aEJyaWRnZURpc2FibGVkLCBuZXR3b3JrRXJyb3IsIG5vQWNjb3VudEZvdW5kLCBub0FjY291bnRJblNpbGVudFJlcXVlc3QsIG5vQ3J5cHRvT2JqZWN0LCBub05ldHdvcmtDb25uZWN0aXZpdHksIG5vbmNlTWlzbWF0Y2gsIG51bGxPckVtcHR5VG9rZW4sIG9wZW5JZENvbmZpZ0Vycm9yLCByZXF1ZXN0Q2Fubm90QmVNYWRlLCBzdGF0ZU1pc21hdGNoLCBzdGF0ZU5vdEZvdW5kLCB0b2tlbkNsYWltc0NuZlJlcXVpcmVkRm9yU2lnbmVkSnd0LCB0b2tlblBhcnNpbmdFcnJvciwgdG9rZW5SZWZyZXNoUmVxdWlyZWQsIHVuZXhwZWN0ZWRDcmVkZW50aWFsVHlwZSwgdXNlckNhbmNlbGVkLCB1c2VyVGltZW91dFJlYWNoZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsaWVudEF1dGhFcnJvckNvZGVzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tICcuL0F1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgY2xpZW50SW5mb0RlY29kaW5nRXJyb3IsIGNsaWVudEluZm9FbXB0eUVycm9yLCB0b2tlblBhcnNpbmdFcnJvciwgbnVsbE9yRW1wdHlUb2tlbiwgZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3IsIG5ldHdvcmtFcnJvciwgb3BlbklkQ29uZmlnRXJyb3IsIGhhc2hOb3REZXNlcmlhbGl6ZWQsIGludmFsaWRTdGF0ZSwgc3RhdGVNaXNtYXRjaCwgc3RhdGVOb3RGb3VuZCwgbm9uY2VNaXNtYXRjaCwgYXV0aFRpbWVOb3RGb3VuZCwgbWF4QWdlVHJhbnNwaXJlZCwgbXVsdGlwbGVNYXRjaGluZ1Rva2VucywgbXVsdGlwbGVNYXRjaGluZ0FjY291bnRzLCBtdWx0aXBsZU1hdGNoaW5nQXBwTWV0YWRhdGEsIHJlcXVlc3RDYW5ub3RCZU1hZGUsIGNhbm5vdFJlbW92ZUVtcHR5U2NvcGUsIGNhbm5vdEFwcGVuZFNjb3BlU2V0LCBlbXB0eUlucHV0U2NvcGVTZXQsIGRldmljZUNvZGVQb2xsaW5nQ2FuY2VsbGVkLCBkZXZpY2VDb2RlRXhwaXJlZCwgZGV2aWNlQ29kZVVua25vd25FcnJvciwgbm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0LCBpbnZhbGlkQ2FjaGVSZWNvcmQsIGludmFsaWRDYWNoZUVudmlyb25tZW50LCBub0FjY291bnRGb3VuZCwgbm9DcnlwdG9PYmplY3QsIHVuZXhwZWN0ZWRDcmVkZW50aWFsVHlwZSwgaW52YWxpZEFzc2VydGlvbiwgaW52YWxpZENsaWVudENyZWRlbnRpYWwsIHRva2VuUmVmcmVzaFJlcXVpcmVkLCB1c2VyVGltZW91dFJlYWNoZWQsIHRva2VuQ2xhaW1zQ25mUmVxdWlyZWRGb3JTaWduZWRKd3QsIGF1dGhvcml6YXRpb25Db2RlTWlzc2luZ0Zyb21TZXJ2ZXJSZXNwb25zZSwgYmluZGluZ0tleU5vdFJlbW92ZWQsIGVuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZCwga2V5SWRNaXNzaW5nLCBub05ldHdvcmtDb25uZWN0aXZpdHksIHVzZXJDYW5jZWxlZCwgbWlzc2luZ1RlbmFudElkRXJyb3IsIG5lc3RlZEFwcEF1dGhCcmlkZ2VEaXNhYmxlZCwgbWV0aG9kTm90SW1wbGVtZW50ZWQgfSBmcm9tICcuL0NsaWVudEF1dGhFcnJvckNvZGVzLm1qcyc7XG5pbXBvcnQgKiBhcyBDbGllbnRBdXRoRXJyb3JDb2RlcyBmcm9tICcuL0NsaWVudEF1dGhFcnJvckNvZGVzLm1qcyc7XG5leHBvcnQgeyBDbGllbnRBdXRoRXJyb3JDb2RlcyB9O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENsaWVudEF1dGhFcnJvck1lc3NhZ2UgY2xhc3MgY29udGFpbmluZyBzdHJpbmcgY29uc3RhbnRzIHVzZWQgYnkgZXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxyXG4gKi9cclxuY29uc3QgQ2xpZW50QXV0aEVycm9yTWVzc2FnZXMgPSB7XHJcbiAgICBbY2xpZW50SW5mb0RlY29kaW5nRXJyb3JdOiBcIlRoZSBjbGllbnQgaW5mbyBjb3VsZCBub3QgYmUgcGFyc2VkL2RlY29kZWQgY29ycmVjdGx5XCIsXHJcbiAgICBbY2xpZW50SW5mb0VtcHR5RXJyb3JdOiBcIlRoZSBjbGllbnQgaW5mbyB3YXMgZW1wdHlcIixcclxuICAgIFt0b2tlblBhcnNpbmdFcnJvcl06IFwiVG9rZW4gY2Fubm90IGJlIHBhcnNlZFwiLFxyXG4gICAgW251bGxPckVtcHR5VG9rZW5dOiBcIlRoZSB0b2tlbiBpcyBudWxsIG9yIGVtcHR5XCIsXHJcbiAgICBbZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3JdOiBcIkVuZHBvaW50cyBjYW5ub3QgYmUgcmVzb2x2ZWRcIixcclxuICAgIFtuZXR3b3JrRXJyb3JdOiBcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIixcclxuICAgIFtvcGVuSWRDb25maWdFcnJvcl06IFwiQ291bGQgbm90IHJldHJpZXZlIGVuZHBvaW50cy4gQ2hlY2sgeW91ciBhdXRob3JpdHkgYW5kIHZlcmlmeSB0aGUgLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24gZW5kcG9pbnQgcmV0dXJucyB0aGUgcmVxdWlyZWQgZW5kcG9pbnRzLlwiLFxyXG4gICAgW2hhc2hOb3REZXNlcmlhbGl6ZWRdOiBcIlRoZSBoYXNoIHBhcmFtZXRlcnMgY291bGQgbm90IGJlIGRlc2VyaWFsaXplZFwiLFxyXG4gICAgW2ludmFsaWRTdGF0ZV06IFwiU3RhdGUgd2FzIG5vdCB0aGUgZXhwZWN0ZWQgZm9ybWF0XCIsXHJcbiAgICBbc3RhdGVNaXNtYXRjaF06IFwiU3RhdGUgbWlzbWF0Y2ggZXJyb3JcIixcclxuICAgIFtzdGF0ZU5vdEZvdW5kXTogXCJTdGF0ZSBub3QgZm91bmRcIixcclxuICAgIFtub25jZU1pc21hdGNoXTogXCJOb25jZSBtaXNtYXRjaCBlcnJvclwiLFxyXG4gICAgW2F1dGhUaW1lTm90Rm91bmRdOiBcIk1heCBBZ2Ugd2FzIHJlcXVlc3RlZCBhbmQgdGhlIElEIHRva2VuIGlzIG1pc3NpbmcgdGhlIGF1dGhfdGltZSB2YXJpYWJsZS5cIiArXHJcbiAgICAgICAgXCIgYXV0aF90aW1lIGlzIGFuIG9wdGlvbmFsIGNsYWltIGFuZCBpcyBub3QgZW5hYmxlZCBieSBkZWZhdWx0IC0gaXQgbXVzdCBiZSBlbmFibGVkLlwiICtcclxuICAgICAgICBcIiBTZWUgaHR0cHM6Ly9ha2EubXMvbXNhbGpzL29wdGlvbmFsLWNsYWltcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIixcclxuICAgIFttYXhBZ2VUcmFuc3BpcmVkXTogXCJNYXggQWdlIGlzIHNldCB0byAwLCBvciB0b28gbXVjaCB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGVuZC11c2VyIGF1dGhlbnRpY2F0aW9uLlwiLFxyXG4gICAgW211bHRpcGxlTWF0Y2hpbmdUb2tlbnNdOiBcIlRoZSBjYWNoZSBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMgc2F0aXNmeWluZyB0aGUgcmVxdWlyZW1lbnRzLiBcIiArXHJcbiAgICAgICAgXCJDYWxsIEFjcXVpcmVUb2tlbiBhZ2FpbiBwcm92aWRpbmcgbW9yZSByZXF1aXJlbWVudHMgc3VjaCBhcyBhdXRob3JpdHkgb3IgYWNjb3VudC5cIixcclxuICAgIFttdWx0aXBsZU1hdGNoaW5nQWNjb3VudHNdOiBcIlRoZSBjYWNoZSBjb250YWlucyBtdWx0aXBsZSBhY2NvdW50cyBzYXRpc2Z5aW5nIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBQbGVhc2UgcGFzcyBtb3JlIGluZm8gdG8gb2J0YWluIHRoZSBjb3JyZWN0IGFjY291bnRcIixcclxuICAgIFttdWx0aXBsZU1hdGNoaW5nQXBwTWV0YWRhdGFdOiBcIlRoZSBjYWNoZSBjb250YWlucyBtdWx0aXBsZSBhcHBNZXRhZGF0YSBzYXRpc2Z5aW5nIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBQbGVhc2UgcGFzcyBtb3JlIGluZm8gdG8gb2J0YWluIHRoZSBjb3JyZWN0IGFwcE1ldGFkYXRhXCIsXHJcbiAgICBbcmVxdWVzdENhbm5vdEJlTWFkZV06IFwiVG9rZW4gcmVxdWVzdCBjYW5ub3QgYmUgbWFkZSB3aXRob3V0IGF1dGhvcml6YXRpb24gY29kZSBvciByZWZyZXNoIHRva2VuLlwiLFxyXG4gICAgW2Nhbm5vdFJlbW92ZUVtcHR5U2NvcGVdOiBcIkNhbm5vdCByZW1vdmUgbnVsbCBvciBlbXB0eSBzY29wZSBmcm9tIFNjb3BlU2V0XCIsXHJcbiAgICBbY2Fubm90QXBwZW5kU2NvcGVTZXRdOiBcIkNhbm5vdCBhcHBlbmQgU2NvcGVTZXRcIixcclxuICAgIFtlbXB0eUlucHV0U2NvcGVTZXRdOiBcIkVtcHR5IGlucHV0IFNjb3BlU2V0IGNhbm5vdCBiZSBwcm9jZXNzZWRcIixcclxuICAgIFtkZXZpY2VDb2RlUG9sbGluZ0NhbmNlbGxlZF06IFwiQ2FsbGVyIGhhcyBjYW5jZWxsZWQgdG9rZW4gZW5kcG9pbnQgcG9sbGluZyBkdXJpbmcgZGV2aWNlIGNvZGUgZmxvdyBieSBzZXR0aW5nIERldmljZUNvZGVSZXF1ZXN0LmNhbmNlbCA9IHRydWUuXCIsXHJcbiAgICBbZGV2aWNlQ29kZUV4cGlyZWRdOiBcIkRldmljZSBjb2RlIGlzIGV4cGlyZWQuXCIsXHJcbiAgICBbZGV2aWNlQ29kZVVua25vd25FcnJvcl06IFwiRGV2aWNlIGNvZGUgc3RvcHBlZCBwb2xsaW5nIGZvciB1bmtub3duIHJlYXNvbnMuXCIsXHJcbiAgICBbbm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0XTogXCJQbGVhc2UgcGFzcyBhbiBhY2NvdW50IG9iamVjdCwgc2lsZW50IGZsb3cgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IGFjY291bnQgaW5mb3JtYXRpb25cIixcclxuICAgIFtpbnZhbGlkQ2FjaGVSZWNvcmRdOiBcIkNhY2hlIHJlY29yZCBvYmplY3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkLlwiLFxyXG4gICAgW2ludmFsaWRDYWNoZUVudmlyb25tZW50XTogXCJJbnZhbGlkIGVudmlyb25tZW50IHdoZW4gYXR0ZW1wdGluZyB0byBjcmVhdGUgY2FjaGUgZW50cnlcIixcclxuICAgIFtub0FjY291bnRGb3VuZF06IFwiTm8gYWNjb3VudCBmb3VuZCBpbiBjYWNoZSBmb3IgZ2l2ZW4ga2V5LlwiLFxyXG4gICAgW25vQ3J5cHRvT2JqZWN0XTogXCJObyBjcnlwdG8gb2JqZWN0IGRldGVjdGVkLlwiLFxyXG4gICAgW3VuZXhwZWN0ZWRDcmVkZW50aWFsVHlwZV06IFwiVW5leHBlY3RlZCBjcmVkZW50aWFsIHR5cGUuXCIsXHJcbiAgICBbaW52YWxpZEFzc2VydGlvbl06IFwiQ2xpZW50IGFzc2VydGlvbiBtdXN0IG1lZXQgcmVxdWlyZW1lbnRzIGRlc2NyaWJlZCBpbiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNVwiLFxyXG4gICAgW2ludmFsaWRDbGllbnRDcmVkZW50aWFsXTogXCJDbGllbnQgY3JlZGVudGlhbCAoc2VjcmV0LCBjZXJ0aWZpY2F0ZSwgb3IgYXNzZXJ0aW9uKSBtdXN0IG5vdCBiZSBlbXB0eSB3aGVuIGNyZWF0aW5nIGEgY29uZmlkZW50aWFsIGNsaWVudC4gQW4gYXBwbGljYXRpb24gc2hvdWxkIGF0IG1vc3QgaGF2ZSBvbmUgY3JlZGVudGlhbFwiLFxyXG4gICAgW3Rva2VuUmVmcmVzaFJlcXVpcmVkXTogXCJDYW5ub3QgcmV0dXJuIHRva2VuIGZyb20gY2FjaGUgYmVjYXVzZSBpdCBtdXN0IGJlIHJlZnJlc2hlZC4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6IGZvcmNlUmVmcmVzaCBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWUsIGNsYWltcyBoYXZlIGJlZW4gcmVxdWVzdGVkLCB0aGVyZSBpcyBubyBjYWNoZWQgYWNjZXNzIHRva2VuIG9yIGl0IGlzIGV4cGlyZWQuXCIsXHJcbiAgICBbdXNlclRpbWVvdXRSZWFjaGVkXTogXCJVc2VyIGRlZmluZWQgdGltZW91dCBmb3IgZGV2aWNlIGNvZGUgcG9sbGluZyByZWFjaGVkXCIsXHJcbiAgICBbdG9rZW5DbGFpbXNDbmZSZXF1aXJlZEZvclNpZ25lZEp3dF06IFwiQ2Fubm90IGdlbmVyYXRlIGEgUE9QIGp3dCBpZiB0aGUgdG9rZW5fY2xhaW1zIGFyZSBub3QgcG9wdWxhdGVkXCIsXHJcbiAgICBbYXV0aG9yaXphdGlvbkNvZGVNaXNzaW5nRnJvbVNlcnZlclJlc3BvbnNlXTogXCJTZXJ2ZXIgcmVzcG9uc2UgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpemF0aW9uIGNvZGUgdG8gcHJvY2VlZFwiLFxyXG4gICAgW2JpbmRpbmdLZXlOb3RSZW1vdmVkXTogXCJDb3VsZCBub3QgcmVtb3ZlIHRoZSBjcmVkZW50aWFsJ3MgYmluZGluZyBrZXkgZnJvbSBzdG9yYWdlLlwiLFxyXG4gICAgW2VuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZF06IFwiVGhlIHByb3ZpZGVkIGF1dGhvcml0eSBkb2VzIG5vdCBzdXBwb3J0IGxvZ291dFwiLFxyXG4gICAgW2tleUlkTWlzc2luZ106IFwiQSBrZXlJZCB2YWx1ZSBpcyBtaXNzaW5nIGZyb20gdGhlIHJlcXVlc3RlZCBib3VuZCB0b2tlbidzIGNhY2hlIHJlY29yZCBhbmQgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggdGhlIHRva2VuIHRvIGl0J3Mgc3RvcmVkIGJpbmRpbmcga2V5LlwiLFxyXG4gICAgW25vTmV0d29ya0Nvbm5lY3Rpdml0eV06IFwiTm8gbmV0d29yayBjb25uZWN0aXZpdHkuIENoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbi5cIixcclxuICAgIFt1c2VyQ2FuY2VsZWRdOiBcIlVzZXIgY2FuY2VsbGVkIHRoZSBmbG93LlwiLFxyXG4gICAgW21pc3NpbmdUZW5hbnRJZEVycm9yXTogXCJBIHRlbmFudCBpZCAtIG5vdCBjb21tb24sIG9yZ2FuaXphdGlvbnMsIG9yIGNvbnN1bWVycyAtIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gdXNpbmcgdGhlIGNsaWVudF9jcmVkZW50aWFscyBmbG93LlwiLFxyXG4gICAgW21ldGhvZE5vdEltcGxlbWVudGVkXTogXCJUaGlzIG1ldGhvZCBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWRcIixcclxuICAgIFtuZXN0ZWRBcHBBdXRoQnJpZGdlRGlzYWJsZWRdOiBcIlRoZSBuZXN0ZWQgYXBwIGF1dGggYnJpZGdlIGlzIGRpc2FibGVkXCIsXHJcbn07XHJcbi8qKlxyXG4gKiBTdHJpbmcgY29uc3RhbnRzIHVzZWQgYnkgZXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgQ2xpZW50QXV0aEVycm9yQ29kZXMgaW5zdGVhZFxyXG4gKi9cclxuY29uc3QgQ2xpZW50QXV0aEVycm9yTWVzc2FnZSA9IHtcclxuICAgIGNsaWVudEluZm9EZWNvZGluZ0Vycm9yOiB7XHJcbiAgICAgICAgY29kZTogY2xpZW50SW5mb0RlY29kaW5nRXJyb3IsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbY2xpZW50SW5mb0RlY29kaW5nRXJyb3JdLFxyXG4gICAgfSxcclxuICAgIGNsaWVudEluZm9FbXB0eUVycm9yOiB7XHJcbiAgICAgICAgY29kZTogY2xpZW50SW5mb0VtcHR5RXJyb3IsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbY2xpZW50SW5mb0VtcHR5RXJyb3JdLFxyXG4gICAgfSxcclxuICAgIHRva2VuUGFyc2luZ0Vycm9yOiB7XHJcbiAgICAgICAgY29kZTogdG9rZW5QYXJzaW5nRXJyb3IsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbdG9rZW5QYXJzaW5nRXJyb3JdLFxyXG4gICAgfSxcclxuICAgIG51bGxPckVtcHR5VG9rZW46IHtcclxuICAgICAgICBjb2RlOiBudWxsT3JFbXB0eVRva2VuLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW251bGxPckVtcHR5VG9rZW5dLFxyXG4gICAgfSxcclxuICAgIGVuZHBvaW50UmVzb2x1dGlvbkVycm9yOiB7XHJcbiAgICAgICAgY29kZTogZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3IsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3JdLFxyXG4gICAgfSxcclxuICAgIG5ldHdvcmtFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IG5ldHdvcmtFcnJvcixcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tuZXR3b3JrRXJyb3JdLFxyXG4gICAgfSxcclxuICAgIHVuYWJsZVRvR2V0T3BlbmlkQ29uZmlnRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBvcGVuSWRDb25maWdFcnJvcixcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tvcGVuSWRDb25maWdFcnJvcl0sXHJcbiAgICB9LFxyXG4gICAgaGFzaE5vdERlc2VyaWFsaXplZDoge1xyXG4gICAgICAgIGNvZGU6IGhhc2hOb3REZXNlcmlhbGl6ZWQsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbaGFzaE5vdERlc2VyaWFsaXplZF0sXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZFN0YXRlRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBpbnZhbGlkU3RhdGUsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbaW52YWxpZFN0YXRlXSxcclxuICAgIH0sXHJcbiAgICBzdGF0ZU1pc21hdGNoRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBzdGF0ZU1pc21hdGNoLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW3N0YXRlTWlzbWF0Y2hdLFxyXG4gICAgfSxcclxuICAgIHN0YXRlTm90Rm91bmRFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IHN0YXRlTm90Rm91bmQsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbc3RhdGVOb3RGb3VuZF0sXHJcbiAgICB9LFxyXG4gICAgbm9uY2VNaXNtYXRjaEVycm9yOiB7XHJcbiAgICAgICAgY29kZTogbm9uY2VNaXNtYXRjaCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tub25jZU1pc21hdGNoXSxcclxuICAgIH0sXHJcbiAgICBhdXRoVGltZU5vdEZvdW5kRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBhdXRoVGltZU5vdEZvdW5kLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW2F1dGhUaW1lTm90Rm91bmRdLFxyXG4gICAgfSxcclxuICAgIG1heEFnZVRyYW5zcGlyZWQ6IHtcclxuICAgICAgICBjb2RlOiBtYXhBZ2VUcmFuc3BpcmVkLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW21heEFnZVRyYW5zcGlyZWRdLFxyXG4gICAgfSxcclxuICAgIG11bHRpcGxlTWF0Y2hpbmdUb2tlbnM6IHtcclxuICAgICAgICBjb2RlOiBtdWx0aXBsZU1hdGNoaW5nVG9rZW5zLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW211bHRpcGxlTWF0Y2hpbmdUb2tlbnNdLFxyXG4gICAgfSxcclxuICAgIG11bHRpcGxlTWF0Y2hpbmdBY2NvdW50czoge1xyXG4gICAgICAgIGNvZGU6IG11bHRpcGxlTWF0Y2hpbmdBY2NvdW50cyxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1ttdWx0aXBsZU1hdGNoaW5nQWNjb3VudHNdLFxyXG4gICAgfSxcclxuICAgIG11bHRpcGxlTWF0Y2hpbmdBcHBNZXRhZGF0YToge1xyXG4gICAgICAgIGNvZGU6IG11bHRpcGxlTWF0Y2hpbmdBcHBNZXRhZGF0YSxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1ttdWx0aXBsZU1hdGNoaW5nQXBwTWV0YWRhdGFdLFxyXG4gICAgfSxcclxuICAgIHRva2VuUmVxdWVzdENhbm5vdEJlTWFkZToge1xyXG4gICAgICAgIGNvZGU6IHJlcXVlc3RDYW5ub3RCZU1hZGUsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbcmVxdWVzdENhbm5vdEJlTWFkZV0sXHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRW1wdHlTY29wZUVycm9yOiB7XHJcbiAgICAgICAgY29kZTogY2Fubm90UmVtb3ZlRW1wdHlTY29wZSxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tjYW5ub3RSZW1vdmVFbXB0eVNjb3BlXSxcclxuICAgIH0sXHJcbiAgICBhcHBlbmRTY29wZVNldEVycm9yOiB7XHJcbiAgICAgICAgY29kZTogY2Fubm90QXBwZW5kU2NvcGVTZXQsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbY2Fubm90QXBwZW5kU2NvcGVTZXRdLFxyXG4gICAgfSxcclxuICAgIGVtcHR5SW5wdXRTY29wZVNldEVycm9yOiB7XHJcbiAgICAgICAgY29kZTogZW1wdHlJbnB1dFNjb3BlU2V0LFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW2VtcHR5SW5wdXRTY29wZVNldF0sXHJcbiAgICB9LFxyXG4gICAgRGV2aWNlQ29kZVBvbGxpbmdDYW5jZWxsZWQ6IHtcclxuICAgICAgICBjb2RlOiBkZXZpY2VDb2RlUG9sbGluZ0NhbmNlbGxlZCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tkZXZpY2VDb2RlUG9sbGluZ0NhbmNlbGxlZF0sXHJcbiAgICB9LFxyXG4gICAgRGV2aWNlQ29kZUV4cGlyZWQ6IHtcclxuICAgICAgICBjb2RlOiBkZXZpY2VDb2RlRXhwaXJlZCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tkZXZpY2VDb2RlRXhwaXJlZF0sXHJcbiAgICB9LFxyXG4gICAgRGV2aWNlQ29kZVVua25vd25FcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IGRldmljZUNvZGVVbmtub3duRXJyb3IsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbZGV2aWNlQ29kZVVua25vd25FcnJvcl0sXHJcbiAgICB9LFxyXG4gICAgTm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0OiB7XHJcbiAgICAgICAgY29kZTogbm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0LFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW25vQWNjb3VudEluU2lsZW50UmVxdWVzdF0sXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZENhY2hlUmVjb3JkOiB7XHJcbiAgICAgICAgY29kZTogaW52YWxpZENhY2hlUmVjb3JkLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW2ludmFsaWRDYWNoZVJlY29yZF0sXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZENhY2hlRW52aXJvbm1lbnQ6IHtcclxuICAgICAgICBjb2RlOiBpbnZhbGlkQ2FjaGVFbnZpcm9ubWVudCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tpbnZhbGlkQ2FjaGVFbnZpcm9ubWVudF0sXHJcbiAgICB9LFxyXG4gICAgbm9BY2NvdW50Rm91bmQ6IHtcclxuICAgICAgICBjb2RlOiBub0FjY291bnRGb3VuZCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tub0FjY291bnRGb3VuZF0sXHJcbiAgICB9LFxyXG4gICAgbm9DcnlwdG9PYmo6IHtcclxuICAgICAgICBjb2RlOiBub0NyeXB0b09iamVjdCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tub0NyeXB0b09iamVjdF0sXHJcbiAgICB9LFxyXG4gICAgdW5leHBlY3RlZENyZWRlbnRpYWxUeXBlOiB7XHJcbiAgICAgICAgY29kZTogdW5leHBlY3RlZENyZWRlbnRpYWxUeXBlLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW3VuZXhwZWN0ZWRDcmVkZW50aWFsVHlwZV0sXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZEFzc2VydGlvbjoge1xyXG4gICAgICAgIGNvZGU6IGludmFsaWRBc3NlcnRpb24sXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbaW52YWxpZEFzc2VydGlvbl0sXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZENsaWVudENyZWRlbnRpYWw6IHtcclxuICAgICAgICBjb2RlOiBpbnZhbGlkQ2xpZW50Q3JlZGVudGlhbCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tpbnZhbGlkQ2xpZW50Q3JlZGVudGlhbF0sXHJcbiAgICB9LFxyXG4gICAgdG9rZW5SZWZyZXNoUmVxdWlyZWQ6IHtcclxuICAgICAgICBjb2RlOiB0b2tlblJlZnJlc2hSZXF1aXJlZCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1t0b2tlblJlZnJlc2hSZXF1aXJlZF0sXHJcbiAgICB9LFxyXG4gICAgdXNlclRpbWVvdXRSZWFjaGVkOiB7XHJcbiAgICAgICAgY29kZTogdXNlclRpbWVvdXRSZWFjaGVkLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW3VzZXJUaW1lb3V0UmVhY2hlZF0sXHJcbiAgICB9LFxyXG4gICAgdG9rZW5DbGFpbXNSZXF1aXJlZDoge1xyXG4gICAgICAgIGNvZGU6IHRva2VuQ2xhaW1zQ25mUmVxdWlyZWRGb3JTaWduZWRKd3QsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbdG9rZW5DbGFpbXNDbmZSZXF1aXJlZEZvclNpZ25lZEp3dF0sXHJcbiAgICB9LFxyXG4gICAgbm9BdXRob3JpemF0aW9uQ29kZUZyb21TZXJ2ZXI6IHtcclxuICAgICAgICBjb2RlOiBhdXRob3JpemF0aW9uQ29kZU1pc3NpbmdGcm9tU2VydmVyUmVzcG9uc2UsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbYXV0aG9yaXphdGlvbkNvZGVNaXNzaW5nRnJvbVNlcnZlclJlc3BvbnNlXSxcclxuICAgIH0sXHJcbiAgICBiaW5kaW5nS2V5Tm90UmVtb3ZlZEVycm9yOiB7XHJcbiAgICAgICAgY29kZTogYmluZGluZ0tleU5vdFJlbW92ZWQsXHJcbiAgICAgICAgZGVzYzogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbYmluZGluZ0tleU5vdFJlbW92ZWRdLFxyXG4gICAgfSxcclxuICAgIGxvZ291dE5vdFN1cHBvcnRlZDoge1xyXG4gICAgICAgIGNvZGU6IGVuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZCxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tlbmRTZXNzaW9uRW5kcG9pbnROb3RTdXBwb3J0ZWRdLFxyXG4gICAgfSxcclxuICAgIGtleUlkTWlzc2luZzoge1xyXG4gICAgICAgIGNvZGU6IGtleUlkTWlzc2luZyxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1trZXlJZE1pc3NpbmddLFxyXG4gICAgfSxcclxuICAgIG5vTmV0d29ya0Nvbm5lY3Rpdml0eToge1xyXG4gICAgICAgIGNvZGU6IG5vTmV0d29ya0Nvbm5lY3Rpdml0eSxcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tub05ldHdvcmtDb25uZWN0aXZpdHldLFxyXG4gICAgfSxcclxuICAgIHVzZXJDYW5jZWxlZEVycm9yOiB7XHJcbiAgICAgICAgY29kZTogdXNlckNhbmNlbGVkLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW3VzZXJDYW5jZWxlZF0sXHJcbiAgICB9LFxyXG4gICAgbWlzc2luZ1RlbmFudElkRXJyb3I6IHtcclxuICAgICAgICBjb2RlOiBtaXNzaW5nVGVuYW50SWRFcnJvcixcclxuICAgICAgICBkZXNjOiBDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1ttaXNzaW5nVGVuYW50SWRFcnJvcl0sXHJcbiAgICB9LFxyXG4gICAgbmVzdGVkQXBwQXV0aEJyaWRnZURpc2FibGVkOiB7XHJcbiAgICAgICAgY29kZTogbmVzdGVkQXBwQXV0aEJyaWRnZURpc2FibGVkLFxyXG4gICAgICAgIGRlc2M6IENsaWVudEF1dGhFcnJvck1lc3NhZ2VzW25lc3RlZEFwcEF1dGhCcmlkZ2VEaXNhYmxlZF0sXHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIGNsaWVudCBjb2RlIHJ1bm5pbmcgb24gdGhlIGJyb3dzZXIuXHJcbiAqL1xyXG5jbGFzcyBDbGllbnRBdXRoRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xyXG4gICAgICAgIHN1cGVyKGVycm9yQ29kZSwgYWRkaXRpb25hbE1lc3NhZ2VcclxuICAgICAgICAgICAgPyBgJHtDbGllbnRBdXRoRXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdfTogJHthZGRpdGlvbmFsTWVzc2FnZX1gXHJcbiAgICAgICAgICAgIDogQ2xpZW50QXV0aEVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDbGllbnRBdXRoRXJyb3JcIjtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ2xpZW50QXV0aEVycm9yLnByb3RvdHlwZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50QXV0aEVycm9yKGVycm9yQ29kZSwgYWRkaXRpb25hbE1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBuZXcgQ2xpZW50QXV0aEVycm9yKGVycm9yQ29kZSwgYWRkaXRpb25hbE1lc3NhZ2UpO1xyXG59XG5cbmV4cG9ydCB7IENsaWVudEF1dGhFcnJvciwgQ2xpZW50QXV0aEVycm9yTWVzc2FnZSwgQ2xpZW50QXV0aEVycm9yTWVzc2FnZXMsIGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50QXV0aEVycm9yLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IGhhc2hOb3REZXNlcmlhbGl6ZWQgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBhcnNlcyBoYXNoIHN0cmluZyBmcm9tIGdpdmVuIHN0cmluZy4gUmV0dXJucyBlbXB0eSBzdHJpbmcgaWYgbm8gaGFzaCBzeW1ib2wgaXMgZm91bmQuXHJcbiAqIEBwYXJhbSBoYXNoU3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpcExlYWRpbmdIYXNoT3JRdWVyeShyZXNwb25zZVN0cmluZykge1xyXG4gICAgaWYgKHJlc3BvbnNlU3RyaW5nLnN0YXJ0c1dpdGgoXCIjL1wiKSkge1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZVN0cmluZy5zdWJzdHJpbmcoMik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZXNwb25zZVN0cmluZy5zdGFydHNXaXRoKFwiI1wiKSB8fFxyXG4gICAgICAgIHJlc3BvbnNlU3RyaW5nLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlU3RyaW5nLnN1YnN0cmluZygxKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXNwb25zZVN0cmluZztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBVUkwgaGFzaCBhcyBzZXJ2ZXIgYXV0aCBjb2RlIHJlc3BvbnNlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdldERlc2VyaWFsaXplZFJlc3BvbnNlKHJlc3BvbnNlU3RyaW5nKSB7XHJcbiAgICAvLyBDaGVjayBpZiBnaXZlbiBoYXNoIGlzIGVtcHR5XHJcbiAgICBpZiAoIXJlc3BvbnNlU3RyaW5nIHx8IHJlc3BvbnNlU3RyaW5nLmluZGV4T2YoXCI9XCIpIDwgMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBTdHJpcCB0aGUgIyBvciA/IHN5bWJvbCBpZiBwcmVzZW50XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlc3BvbnNlID0gc3RyaXBMZWFkaW5nSGFzaE9yUXVlcnkocmVzcG9uc2VTdHJpbmcpO1xyXG4gICAgICAgIC8vIElmICMgc3ltYm9sIHdhcyBub3QgcHJlc2VudCwgYWJvdmUgd2lsbCByZXR1cm4gZW1wdHkgc3RyaW5nLCBzbyBnaXZlIG9yaWdpbmFsIGhhc2ggdmFsdWVcclxuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRIYXNoID0gT2JqZWN0LmZyb21FbnRyaWVzKG5ldyBVUkxTZWFyY2hQYXJhbXMobm9ybWFsaXplZFJlc3BvbnNlKSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGtub3duIHJlc3BvbnNlIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAoZGVzZXJpYWxpemVkSGFzaC5jb2RlIHx8XHJcbiAgICAgICAgICAgIGRlc2VyaWFsaXplZEhhc2guZWFyX2p3ZSB8fFxyXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZWRIYXNoLmVycm9yIHx8XHJcbiAgICAgICAgICAgIGRlc2VyaWFsaXplZEhhc2guZXJyb3JfZGVzY3JpcHRpb24gfHxcclxuICAgICAgICAgICAgZGVzZXJpYWxpemVkSGFzaC5zdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVkSGFzaDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihoYXNoTm90RGVzZXJpYWxpemVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBVdGlsaXR5IHRvIGNyZWF0ZSBhIFVSTCBmcm9tIHRoZSBwYXJhbXMgbWFwXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMsIGVuY29kZUV4dHJhUGFyYW1zID0gdHJ1ZSwgZXh0cmFRdWVyeVBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVyQXJyYXkgPSBuZXcgQXJyYXkoKTtcclxuICAgIHBhcmFtZXRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGlmICghZW5jb2RlRXh0cmFQYXJhbXMgJiZcclxuICAgICAgICAgICAgZXh0cmFRdWVyeVBhcmFtZXRlcnMgJiZcclxuICAgICAgICAgICAga2V5IGluIGV4dHJhUXVlcnlQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyQXJyYXkucHVzaChgJHtrZXl9PSR7dmFsdWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeVBhcmFtZXRlckFycmF5LnB1c2goYCR7a2V5fT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcXVlcnlQYXJhbWV0ZXJBcnJheS5qb2luKFwiJlwiKTtcclxufVxuXG5leHBvcnQgeyBnZXREZXNlcmlhbGl6ZWRSZXNwb25zZSwgbWFwVG9RdWVyeVN0cmluZywgc3RyaXBMZWFkaW5nSGFzaE9yUXVlcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVybFV0aWxzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3IubWpzJztcbmltcG9ydCB7IFN0cmluZ1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMvU3RyaW5nVXRpbHMubWpzJztcbmltcG9ydCB7IEFBREF1dGhvcml0eUNvbnN0YW50cywgQ29uc3RhbnRzIH0gZnJvbSAnLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyBnZXREZXNlcmlhbGl6ZWRSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzL1VybFV0aWxzLm1qcyc7XG5pbXBvcnQgeyB1cmxFbXB0eUVycm9yLCB1cmxQYXJzZUVycm9yLCBhdXRob3JpdHlVcmlJbnNlY3VyZSB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVXJsIG9iamVjdCBjbGFzcyB3aGljaCBjYW4gcGVyZm9ybSB2YXJpb3VzIHRyYW5zZm9ybWF0aW9ucyBvbiB1cmwgc3RyaW5ncy5cclxuICovXHJcbmNsYXNzIFVybFN0cmluZyB7XHJcbiAgICBnZXQgdXJsU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cmxTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcclxuICAgICAgICB0aGlzLl91cmxTdHJpbmcgPSB1cmw7XHJcbiAgICAgICAgaWYgKCF0aGlzLl91cmxTdHJpbmcpIHtcclxuICAgICAgICAgICAgLy8gVGhyb3dzIGVycm9yIGlmIHVybCBpcyBlbXB0eVxyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IodXJsRW1wdHlFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXJsLmluY2x1ZGVzKFwiI1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cmxTdHJpbmcgPSBVcmxTdHJpbmcuY2Fub25pY2FsaXplVXJpKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmUgdXJscyBhcmUgbG93ZXIgY2FzZSBhbmQgZW5kIHdpdGggYSAvIGNoYXJhY3Rlci5cclxuICAgICAqIEBwYXJhbSB1cmxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNhbm9uaWNhbGl6ZVVyaSh1cmwpIHtcclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgIGxldCBsb3dlckNhc2VVcmwgPSB1cmwudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKFN0cmluZ1V0aWxzLmVuZHNXaXRoKGxvd2VyQ2FzZVVybCwgXCI/XCIpKSB7XHJcbiAgICAgICAgICAgICAgICBsb3dlckNhc2VVcmwgPSBsb3dlckNhc2VVcmwuc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFN0cmluZ1V0aWxzLmVuZHNXaXRoKGxvd2VyQ2FzZVVybCwgXCI/L1wiKSkge1xyXG4gICAgICAgICAgICAgICAgbG93ZXJDYXNlVXJsID0gbG93ZXJDYXNlVXJsLnNsaWNlKDAsIC0yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmVuZHNXaXRoKGxvd2VyQ2FzZVVybCwgXCIvXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBsb3dlckNhc2VVcmwgKz0gXCIvXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxvd2VyQ2FzZVVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhyb3dzIGlmIHVybFN0cmluZyBwYXNzZWQgaXMgbm90IGEgdmFsaWQgYXV0aG9yaXR5IFVSSSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlQXNVcmkoKSB7XHJcbiAgICAgICAgLy8gQXR0ZW1wdHMgdG8gcGFyc2UgdXJsIGZvciB1cmkgY29tcG9uZW50c1xyXG4gICAgICAgIGxldCBjb21wb25lbnRzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSB0aGlzLmdldFVybENvbXBvbmVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKHVybFBhcnNlRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaHJvdyBlcnJvciBpZiBVUkkgb3IgcGF0aCBzZWdtZW50cyBhcmUgbm90IHBhcnNlYWJsZS5cclxuICAgICAgICBpZiAoIWNvbXBvbmVudHMuSG9zdE5hbWVBbmRQb3J0IHx8ICFjb21wb25lbnRzLlBhdGhTZWdtZW50cykge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IodXJsUGFyc2VFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRocm93IGVycm9yIGlmIHVyaSBpcyBpbnNlY3VyZS5cclxuICAgICAgICBpZiAoIWNvbXBvbmVudHMuUHJvdG9jb2wgfHxcclxuICAgICAgICAgICAgY29tcG9uZW50cy5Qcm90b2NvbC50b0xvd2VyQ2FzZSgpICE9PSBcImh0dHBzOlwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihhdXRob3JpdHlVcmlJbnNlY3VyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHVybCBhbmQgYSBxdWVyeSBzdHJpbmcgcmV0dXJuIHRoZSB1cmwgd2l0aCBwcm92aWRlZCBxdWVyeSBzdHJpbmcgYXBwZW5kZWRcclxuICAgICAqIEBwYXJhbSB1cmxcclxuICAgICAqIEBwYXJhbSBxdWVyeVN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXBwZW5kUXVlcnlTdHJpbmcodXJsLCBxdWVyeVN0cmluZykge1xyXG4gICAgICAgIGlmICghcXVlcnlTdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybC5pbmRleE9mKFwiP1wiKSA8IDBcclxuICAgICAgICAgICAgPyBgJHt1cmx9PyR7cXVlcnlTdHJpbmd9YFxyXG4gICAgICAgICAgICA6IGAke3VybH0mJHtxdWVyeVN0cmluZ31gO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgdXJsIHdpdGggdGhlIGhhc2ggcmVtb3ZlZFxyXG4gICAgICogQHBhcmFtIHVybFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVtb3ZlSGFzaEZyb21VcmwodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIFVybFN0cmluZy5jYW5vbmljYWxpemVVcmkodXJsLnNwbGl0KFwiI1wiKVswXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgdXJsIGxpa2UgaHR0cHM6Ly9hOmIvY29tbW9uL2Q/ZT1mI2csIGFuZCBhIHRlbmFudElkLCByZXR1cm5zIGh0dHBzOi8vYTpiL3RlbmFudElkL2RcclxuICAgICAqIEBwYXJhbSBocmVmIFRoZSB1cmxcclxuICAgICAqIEBwYXJhbSB0ZW5hbnRJZCBUaGUgdGVuYW50IGlkIHRvIHJlcGxhY2VcclxuICAgICAqL1xyXG4gICAgcmVwbGFjZVRlbmFudFBhdGgodGVuYW50SWQpIHtcclxuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSB0aGlzLmdldFVybENvbXBvbmVudHMoKTtcclxuICAgICAgICBjb25zdCBwYXRoQXJyYXkgPSB1cmxPYmplY3QuUGF0aFNlZ21lbnRzO1xyXG4gICAgICAgIGlmICh0ZW5hbnRJZCAmJlxyXG4gICAgICAgICAgICBwYXRoQXJyYXkubGVuZ3RoICE9PSAwICYmXHJcbiAgICAgICAgICAgIChwYXRoQXJyYXlbMF0gPT09IEFBREF1dGhvcml0eUNvbnN0YW50cy5DT01NT04gfHxcclxuICAgICAgICAgICAgICAgIHBhdGhBcnJheVswXSA9PT0gQUFEQXV0aG9yaXR5Q29uc3RhbnRzLk9SR0FOSVpBVElPTlMpKSB7XHJcbiAgICAgICAgICAgIHBhdGhBcnJheVswXSA9IHRlbmFudElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVXJsU3RyaW5nLmNvbnN0cnVjdEF1dGhvcml0eVVyaUZyb21PYmplY3QodXJsT2JqZWN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIG91dCB0aGUgY29tcG9uZW50cyBmcm9tIGEgdXJsIHN0cmluZy5cclxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSB2YXJpb3VzIGNvbXBvbmVudHMuIFBsZWFzZSBjYWNoZSB0aGlzIHZhbHVlIGluc3RlZCBvZiBjYWxsaW5nIHRoaXMgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgdXJsLlxyXG4gICAgICovXHJcbiAgICBnZXRVcmxDb21wb25lbnRzKCkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2N1cnRpc3ovMTExMzliMmNmY2FlZjRhMjYxZTBcclxuICAgICAgICBjb25zdCByZWdFeCA9IFJlZ0V4cChcIl4oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFxcXD8oW14jXSopKT8oIyguKikpP1wiKTtcclxuICAgICAgICAvLyBJZiB1cmwgc3RyaW5nIGRvZXMgbm90IG1hdGNoIHJlZ0V4LCB3ZSB0aHJvdyBhbiBlcnJvclxyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy51cmxTdHJpbmcubWF0Y2gocmVnRXgpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKHVybFBhcnNlRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcmwgY29tcG9uZW50IG9iamVjdFxyXG4gICAgICAgIGNvbnN0IHVybENvbXBvbmVudHMgPSB7XHJcbiAgICAgICAgICAgIFByb3RvY29sOiBtYXRjaFsxXSxcclxuICAgICAgICAgICAgSG9zdE5hbWVBbmRQb3J0OiBtYXRjaFs0XSxcclxuICAgICAgICAgICAgQWJzb2x1dGVQYXRoOiBtYXRjaFs1XSxcclxuICAgICAgICAgICAgUXVlcnlTdHJpbmc6IG1hdGNoWzddLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHBhdGhTZWdtZW50cyA9IHVybENvbXBvbmVudHMuQWJzb2x1dGVQYXRoLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICBwYXRoU2VnbWVudHMgPSBwYXRoU2VnbWVudHMuZmlsdGVyKCh2YWwpID0+IHZhbCAmJiB2YWwubGVuZ3RoID4gMCk7IC8vIHJlbW92ZSBlbXB0eSBlbGVtZW50c1xyXG4gICAgICAgIHVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzID0gcGF0aFNlZ21lbnRzO1xyXG4gICAgICAgIGlmICh1cmxDb21wb25lbnRzLlF1ZXJ5U3RyaW5nICYmXHJcbiAgICAgICAgICAgIHVybENvbXBvbmVudHMuUXVlcnlTdHJpbmcuZW5kc1dpdGgoXCIvXCIpKSB7XHJcbiAgICAgICAgICAgIHVybENvbXBvbmVudHMuUXVlcnlTdHJpbmcgPSB1cmxDb21wb25lbnRzLlF1ZXJ5U3RyaW5nLnN1YnN0cmluZygwLCB1cmxDb21wb25lbnRzLlF1ZXJ5U3RyaW5nLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsQ29tcG9uZW50cztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXREb21haW5Gcm9tVXJsKHVybCkge1xyXG4gICAgICAgIGNvbnN0IHJlZ0V4ID0gUmVnRXhwKFwiXihbXjovPyNdKzovLyk/KFteLz8jXSopXCIpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlZ0V4KTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcih1cmxQYXJzZUVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoWzJdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEFic29sdXRlVXJsKHJlbGF0aXZlVXJsLCBiYXNlVXJsKSB7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlVXJsWzBdID09PSBDb25zdGFudHMuRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVXJsU3RyaW5nKGJhc2VVcmwpO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlQ29tcG9uZW50cyA9IHVybC5nZXRVcmxDb21wb25lbnRzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYmFzZUNvbXBvbmVudHMuUHJvdG9jb2wgK1xyXG4gICAgICAgICAgICAgICAgXCIvL1wiICtcclxuICAgICAgICAgICAgICAgIGJhc2VDb21wb25lbnRzLkhvc3ROYW1lQW5kUG9ydCArXHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWxhdGl2ZVVybDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb25zdHJ1Y3RBdXRob3JpdHlVcmlGcm9tT2JqZWN0KHVybE9iamVjdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVXJsU3RyaW5nKHVybE9iamVjdC5Qcm90b2NvbCArXHJcbiAgICAgICAgICAgIFwiLy9cIiArXHJcbiAgICAgICAgICAgIHVybE9iamVjdC5Ib3N0TmFtZUFuZFBvcnQgK1xyXG4gICAgICAgICAgICBcIi9cIiArXHJcbiAgICAgICAgICAgIHVybE9iamVjdC5QYXRoU2VnbWVudHMuam9pbihcIi9cIikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgaGFzaCBvZiB0aGUgVVJMIHN0cmluZyBjb250YWlucyBrbm93biBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzaENvbnRhaW5zS25vd25Qcm9wZXJ0aWVzKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuICEhZ2V0RGVzZXJpYWxpemVkUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFVybFN0cmluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXJsU3RyaW5nLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBVcmxTdHJpbmcgfSBmcm9tICcuLi91cmwvVXJsU3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgcmF3TWV0ZGF0YUpTT04gPSB7XHJcbiAgICBlbmRwb2ludE1ldGFkYXRhOiB7XHJcbiAgICAgICAgXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tXCI6IHtcclxuICAgICAgICAgICAgdG9rZW5fZW5kcG9pbnQ6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL3t0ZW5hbnRpZH0vb2F1dGgyL3YyLjAvdG9rZW5cIixcclxuICAgICAgICAgICAgandrc191cmk6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL3t0ZW5hbnRpZH0vZGlzY292ZXJ5L3YyLjAva2V5c1wiLFxyXG4gICAgICAgICAgICBpc3N1ZXI6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL3t0ZW5hbnRpZH0vdjIuMFwiLFxyXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uX2VuZHBvaW50OiBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS97dGVuYW50aWR9L29hdXRoMi92Mi4wL2F1dGhvcml6ZVwiLFxyXG4gICAgICAgICAgICBlbmRfc2Vzc2lvbl9lbmRwb2ludDogXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20ve3RlbmFudGlkfS9vYXV0aDIvdjIuMC9sb2dvdXRcIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibG9naW4uY2hpbmFjbG91ZGFwaS5jblwiOiB7XHJcbiAgICAgICAgICAgIHRva2VuX2VuZHBvaW50OiBcImh0dHBzOi8vbG9naW4uY2hpbmFjbG91ZGFwaS5jbi97dGVuYW50aWR9L29hdXRoMi92Mi4wL3Rva2VuXCIsXHJcbiAgICAgICAgICAgIGp3a3NfdXJpOiBcImh0dHBzOi8vbG9naW4uY2hpbmFjbG91ZGFwaS5jbi97dGVuYW50aWR9L2Rpc2NvdmVyeS92Mi4wL2tleXNcIixcclxuICAgICAgICAgICAgaXNzdWVyOiBcImh0dHBzOi8vbG9naW4ucGFydG5lci5taWNyb3NvZnRvbmxpbmUuY24ve3RlbmFudGlkfS92Mi4wXCIsXHJcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6IFwiaHR0cHM6Ly9sb2dpbi5jaGluYWNsb3VkYXBpLmNuL3t0ZW5hbnRpZH0vb2F1dGgyL3YyLjAvYXV0aG9yaXplXCIsXHJcbiAgICAgICAgICAgIGVuZF9zZXNzaW9uX2VuZHBvaW50OiBcImh0dHBzOi8vbG9naW4uY2hpbmFjbG91ZGFwaS5jbi97dGVuYW50aWR9L29hdXRoMi92Mi4wL2xvZ291dFwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUudXNcIjoge1xyXG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludDogXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS51cy97dGVuYW50aWR9L29hdXRoMi92Mi4wL3Rva2VuXCIsXHJcbiAgICAgICAgICAgIGp3a3NfdXJpOiBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLnVzL3t0ZW5hbnRpZH0vZGlzY292ZXJ5L3YyLjAva2V5c1wiLFxyXG4gICAgICAgICAgICBpc3N1ZXI6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUudXMve3RlbmFudGlkfS92Mi4wXCIsXHJcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUudXMve3RlbmFudGlkfS9vYXV0aDIvdjIuMC9hdXRob3JpemVcIixcclxuICAgICAgICAgICAgZW5kX3Nlc3Npb25fZW5kcG9pbnQ6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUudXMve3RlbmFudGlkfS9vYXV0aDIvdjIuMC9sb2dvdXRcIixcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIGluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGE6IHtcclxuICAgICAgICB0ZW5hbnRfZGlzY292ZXJ5X2VuZHBvaW50OiBcImh0dHBzOi8ve2Nhbm9uaWNhbEF1dGhvcml0eX0vdjIuMC8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvblwiLFxyXG4gICAgICAgIG1ldGFkYXRhOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9uZXR3b3JrOiBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb21cIixcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogXCJsb2dpbi53aW5kb3dzLm5ldFwiLFxyXG4gICAgICAgICAgICAgICAgYWxpYXNlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4ubWljcm9zb2Z0b25saW5lLmNvbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4ud2luZG93cy5uZXRcIixcclxuICAgICAgICAgICAgICAgICAgICBcImxvZ2luLm1pY3Jvc29mdC5jb21cIixcclxuICAgICAgICAgICAgICAgICAgICBcInN0cy53aW5kb3dzLm5ldFwiLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkX25ldHdvcms6IFwibG9naW4ucGFydG5lci5taWNyb3NvZnRvbmxpbmUuY25cIixcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogXCJsb2dpbi5wYXJ0bmVyLm1pY3Jvc29mdG9ubGluZS5jblwiLFxyXG4gICAgICAgICAgICAgICAgYWxpYXNlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4ucGFydG5lci5taWNyb3NvZnRvbmxpbmUuY25cIixcclxuICAgICAgICAgICAgICAgICAgICBcImxvZ2luLmNoaW5hY2xvdWRhcGkuY25cIixcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9uZXR3b3JrOiBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5kZVwiLFxyXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkX2NhY2hlOiBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS5kZVwiLFxyXG4gICAgICAgICAgICAgICAgYWxpYXNlczogW1wibG9naW4ubWljcm9zb2Z0b25saW5lLmRlXCJdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfbmV0d29yazogXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUudXNcIixcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogXCJsb2dpbi5taWNyb3NvZnRvbmxpbmUudXNcIixcclxuICAgICAgICAgICAgICAgIGFsaWFzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICBcImxvZ2luLm1pY3Jvc29mdG9ubGluZS51c1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibG9naW4udXNnb3ZjbG91ZGFwaS5uZXRcIixcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9uZXR3b3JrOiBcImxvZ2luLXVzLm1pY3Jvc29mdG9ubGluZS5jb21cIixcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogXCJsb2dpbi11cy5taWNyb3NvZnRvbmxpbmUuY29tXCIsXHJcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXCJsb2dpbi11cy5taWNyb3NvZnRvbmxpbmUuY29tXCJdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG59O1xyXG5jb25zdCBFbmRwb2ludE1ldGFkYXRhID0gcmF3TWV0ZGF0YUpTT04uZW5kcG9pbnRNZXRhZGF0YTtcclxuY29uc3QgSW5zdGFuY2VEaXNjb3ZlcnlNZXRhZGF0YSA9IHJhd01ldGRhdGFKU09OLmluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGE7XHJcbmNvbnN0IEluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGFBbGlhc2VzID0gbmV3IFNldCgpO1xyXG5JbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhLm1ldGFkYXRhLmZvckVhY2goKG1ldGFkYXRhRW50cnkpID0+IHtcclxuICAgIG1ldGFkYXRhRW50cnkuYWxpYXNlcy5mb3JFYWNoKChhbGlhcykgPT4ge1xyXG4gICAgICAgIEluc3RhbmNlRGlzY292ZXJ5TWV0YWRhdGFBbGlhc2VzLmFkZChhbGlhcyk7XHJcbiAgICB9KTtcclxufSk7XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBnZXQgYW4gYWxpYXNlcyBhcnJheSBmcm9tIHRoZSBzdGF0aWMgYXV0aG9yaXR5IG1ldGFkYXRhIHNvdXJjZXMgYmFzZWQgb24gdGhlIGNhbm9uaWNhbCBhdXRob3JpdHkgaG9zdFxyXG4gKiBAcGFyYW0gc3RhdGljQXV0aG9yaXR5T3B0aW9uc1xyXG4gKiBAcGFyYW0gbG9nZ2VyXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBbGlhc2VzRnJvbVN0YXRpY1NvdXJjZXMoc3RhdGljQXV0aG9yaXR5T3B0aW9ucywgbG9nZ2VyKSB7XHJcbiAgICBsZXQgc3RhdGljQWxpYXNlcztcclxuICAgIGNvbnN0IGNhbm9uaWNhbEF1dGhvcml0eSA9IHN0YXRpY0F1dGhvcml0eU9wdGlvbnMuY2Fub25pY2FsQXV0aG9yaXR5O1xyXG4gICAgaWYgKGNhbm9uaWNhbEF1dGhvcml0eSkge1xyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eUhvc3QgPSBuZXcgVXJsU3RyaW5nKGNhbm9uaWNhbEF1dGhvcml0eSkuZ2V0VXJsQ29tcG9uZW50cygpLkhvc3ROYW1lQW5kUG9ydDtcclxuICAgICAgICBzdGF0aWNBbGlhc2VzID1cclxuICAgICAgICAgICAgZ2V0QWxpYXNlc0Zyb21NZXRhZGF0YShhdXRob3JpdHlIb3N0LCBzdGF0aWNBdXRob3JpdHlPcHRpb25zLmNsb3VkRGlzY292ZXJ5TWV0YWRhdGE/Lm1ldGFkYXRhLCBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZS5DT05GSUcsIGxvZ2dlcikgfHxcclxuICAgICAgICAgICAgICAgIGdldEFsaWFzZXNGcm9tTWV0YWRhdGEoYXV0aG9yaXR5SG9zdCwgSW5zdGFuY2VEaXNjb3ZlcnlNZXRhZGF0YS5tZXRhZGF0YSwgQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuSEFSRENPREVEX1ZBTFVFUywgbG9nZ2VyKSB8fFxyXG4gICAgICAgICAgICAgICAgc3RhdGljQXV0aG9yaXR5T3B0aW9ucy5rbm93bkF1dGhvcml0aWVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXRpY0FsaWFzZXMgfHwgW107XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYWxpYXNlcyBmb3IgZnJvbSB0aGUgcmF3IGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBwYXNzZWQgaW5cclxuICogQHBhcmFtIGF1dGhvcml0eUhvc3RcclxuICogQHBhcmFtIHJhd0Nsb3VkRGlzY292ZXJ5TWV0YWRhdGFcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFsaWFzZXNGcm9tTWV0YWRhdGEoYXV0aG9yaXR5SG9zdCwgY2xvdWREaXNjb3ZlcnlNZXRhZGF0YSwgc291cmNlLCBsb2dnZXIpIHtcclxuICAgIGxvZ2dlcj8udHJhY2UoYGdldEFsaWFzZXNGcm9tTWV0YWRhdGEgY2FsbGVkIHdpdGggc291cmNlOiAke3NvdXJjZX1gKTtcclxuICAgIGlmIChhdXRob3JpdHlIb3N0ICYmIGNsb3VkRGlzY292ZXJ5TWV0YWRhdGEpIHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya1Jlc3BvbnNlKGNsb3VkRGlzY292ZXJ5TWV0YWRhdGEsIGF1dGhvcml0eUhvc3QpO1xyXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICBsb2dnZXI/LnRyYWNlKGBnZXRBbGlhc2VzRnJvbU1ldGFkYXRhOiBmb3VuZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgaW4gJHtzb3VyY2V9LCByZXR1cm5pbmcgYWxpYXNlc2ApO1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGEuYWxpYXNlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ2dlcj8udHJhY2UoYGdldEFsaWFzZXNGcm9tTWV0YWRhdGE6IGRpZCBub3QgZmluZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgaW4gJHtzb3VyY2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIEdldCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgZm9yIGNvbW1vbiBhdXRob3JpdGllc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXMoYXV0aG9yaXR5SG9zdCkge1xyXG4gICAgY29uc3QgbWV0YWRhdGEgPSBnZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcmtSZXNwb25zZShJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhLm1ldGFkYXRhLCBhdXRob3JpdHlIb3N0KTtcclxuICAgIHJldHVybiBtZXRhZGF0YTtcclxufVxyXG4vKipcclxuICogU2VhcmNoZXMgaW5zdGFuY2UgZGlzY292ZXJ5IG5ldHdvcmsgcmVzcG9uc2UgZm9yIHRoZSBlbnRyeSB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGluIHRoZSBhbGlhc2VzIGxpc3RcclxuICogQHBhcmFtIHJlc3BvbnNlXHJcbiAqIEBwYXJhbSBhdXRob3JpdHlcclxuICovXHJcbmZ1bmN0aW9uIGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya1Jlc3BvbnNlKHJlc3BvbnNlLCBhdXRob3JpdHlIb3N0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXNwb25zZVtpXTtcclxuICAgICAgICBpZiAobWV0YWRhdGEuYWxpYXNlcy5pbmNsdWRlcyhhdXRob3JpdHlIb3N0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cblxuZXhwb3J0IHsgRW5kcG9pbnRNZXRhZGF0YSwgSW5zdGFuY2VEaXNjb3ZlcnlNZXRhZGF0YSwgSW5zdGFuY2VEaXNjb3ZlcnlNZXRhZGF0YUFsaWFzZXMsIGdldEFsaWFzZXNGcm9tTWV0YWRhdGEsIGdldEFsaWFzZXNGcm9tU3RhdGljU291cmNlcywgZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXMsIGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya1Jlc3BvbnNlLCByYXdNZXRkYXRhSlNPTiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aG9yaXR5TWV0YWRhdGEubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdG9jb2wgbW9kZXMgc3VwcG9ydGVkIGJ5IE1TQUwuXHJcbiAqL1xyXG5jb25zdCBQcm90b2NvbE1vZGUgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEF1dGggQ29kZSArIFBLQ0Ugd2l0aCBFbnRyYSBJRCAoZm9ybWVybHkgQUFEKSBzcGVjaWZpYyBvcHRpbWl6YXRpb25zIGFuZCBmZWF0dXJlc1xyXG4gICAgICovXHJcbiAgICBBQUQ6IFwiQUFEXCIsXHJcbiAgICAvKipcclxuICAgICAqIEF1dGggQ29kZSArIFBLQ0Ugd2l0aG91dCBFbnRyYSBJRCBzcGVjaWZpYyBvcHRpbWl6YXRpb25zIGFuZCBmZWF0dXJlcy4gRm9yIHVzZSBvbmx5IHdpdGggbm9uLU1pY3Jvc29mdCBvd25lZCBhdXRob3JpdGllcy5cclxuICAgICAqIFN1cHBvcnQgaXMgbGltaXRlZCBmb3IgdGhpcyBtb2RlLlxyXG4gICAgICovXHJcbiAgICBPSURDOiBcIk9JRENcIixcclxuICAgIC8qKlxyXG4gICAgICogRW5jcnlwdGVkIEF1dGhvcml6ZSBSZXNwb25zZSAoRUFSKSB3aXRoIEVudHJhIElEIHNwZWNpZmljIG9wdGltaXphdGlvbnMgYW5kIGZlYXR1cmVzXHJcbiAgICAgKi9cclxuICAgIEVBUjogXCJFQVJcIixcclxufTtcblxuZXhwb3J0IHsgUHJvdG9jb2xNb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm90b2NvbE1vZGUubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBBenVyZUNsb3VkSW5zdGFuY2UgPSB7XHJcbiAgICAvLyBBenVyZUNsb3VkSW5zdGFuY2UgaXMgbm90IHNwZWNpZmllZC5cclxuICAgIE5vbmU6IFwibm9uZVwiLFxyXG4gICAgLy8gTWljcm9zb2Z0IEF6dXJlIHB1YmxpYyBjbG91ZFxyXG4gICAgQXp1cmVQdWJsaWM6IFwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tXCIsXHJcbiAgICAvLyBNaWNyb3NvZnQgUFBFXHJcbiAgICBBenVyZVBwZTogXCJodHRwczovL2xvZ2luLndpbmRvd3MtcHBlLm5ldFwiLFxyXG4gICAgLy8gTWljcm9zb2Z0IENoaW5lc2UgbmF0aW9uYWwvcmVnaW9uYWwgY2xvdWRcclxuICAgIEF6dXJlQ2hpbmE6IFwiaHR0cHM6Ly9sb2dpbi5jaGluYWNsb3VkYXBpLmNuXCIsXHJcbiAgICAvLyBNaWNyb3NvZnQgR2VybWFuIG5hdGlvbmFsL3JlZ2lvbmFsIGNsb3VkIChcIkJsYWNrIEZvcmVzdFwiKVxyXG4gICAgQXp1cmVHZXJtYW55OiBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmRlXCIsXHJcbiAgICAvLyBVUyBHb3Zlcm5tZW50IGNsb3VkXHJcbiAgICBBenVyZVVzR292ZXJubWVudDogXCJodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS51c1wiLFxyXG59O1xuXG5leHBvcnQgeyBBenVyZUNsb3VkSW5zdGFuY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml0eU9wdGlvbnMubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIChyZXNwb25zZS5oYXNPd25Qcm9wZXJ0eShcInRlbmFudF9kaXNjb3ZlcnlfZW5kcG9pbnRcIikgJiZcclxuICAgICAgICByZXNwb25zZS5oYXNPd25Qcm9wZXJ0eShcIm1ldGFkYXRhXCIpKTtcclxufVxuXG5leHBvcnQgeyBpc0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xvdWRJbnN0YW5jZURpc2NvdmVyeVJlc3BvbnNlLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIChyZXNwb25zZS5oYXNPd25Qcm9wZXJ0eShcImVycm9yXCIpICYmXHJcbiAgICAgICAgcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoXCJlcnJvcl9kZXNjcmlwdGlvblwiKSk7XHJcbn1cblxuZXhwb3J0IHsgaXNDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xvdWRJbnN0YW5jZURpc2NvdmVyeUVycm9yUmVzcG9uc2UubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRW51bWVyYXRpb24gb2Ygb3BlcmF0aW9ucyB0aGF0IGFyZSBpbnN0cnVtZW50ZWQgYnkgaGF2ZSB0aGVpciBwZXJmb3JtYW5jZSBtZWFzdXJlZCBieSB0aGUgUGVyZm9ybWFuY2VDbGllbnQuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbmNvbnN0IFBlcmZvcm1hbmNlRXZlbnRzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBhY3F1aXJlVG9rZW5CeUNvZGUgQVBJIChtc2FsLWJyb3dzZXIgYW5kIG1zYWwtbm9kZSkuXHJcbiAgICAgKiBVc2VkIHRvIGFjcXVpcmUgdG9rZW5zIGJ5IHRyYWRpbmcgYW4gYXV0aG9yaXphdGlvbiBjb2RlIGFnYWluc3QgdGhlIHRva2VuIGVuZHBvaW50LlxyXG4gICAgICovXHJcbiAgICBBY3F1aXJlVG9rZW5CeUNvZGU6IFwiYWNxdWlyZVRva2VuQnlDb2RlXCIsXHJcbiAgICAvKipcclxuICAgICAqIGFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuIEFQSSAobXNhbC1icm93c2VyIGFuZCBtc2FsLW5vZGUpLlxyXG4gICAgICogVXNlZCB0byByZW5ldyBhbiBhY2Nlc3MgdG9rZW4gdXNpbmcgYSByZWZyZXNoIHRva2VuIGFnYWluc3QgdGhlIHRva2VuIGVuZHBvaW50LlxyXG4gICAgICovXHJcbiAgICBBY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbjogXCJhY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlblwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBhY3F1aXJlVG9rZW5TaWxlbnQgQVBJIChtc2FsLWJyb3dzZXIgYW5kIG1zYWwtbm9kZSkuXHJcbiAgICAgKiBVc2VkIHRvIHNpbGVudGx5IGFjcXVpcmUgYSBuZXcgYWNjZXNzIHRva2VuIChmcm9tIHRoZSBjYWNoZSBvciB0aGUgbmV0d29yaykuXHJcbiAgICAgKi9cclxuICAgIEFjcXVpcmVUb2tlblNpbGVudDogXCJhY3F1aXJlVG9rZW5TaWxlbnRcIixcclxuICAgIC8qKlxyXG4gICAgICogYWNxdWlyZVRva2VuU2lsZW50QXN5bmMgKG1zYWwtYnJvd3NlcikuXHJcbiAgICAgKiBJbnRlcm5hbCBBUEkgZm9yIGFjcXVpcmVUb2tlblNpbGVudC5cclxuICAgICAqL1xyXG4gICAgQWNxdWlyZVRva2VuU2lsZW50QXN5bmM6IFwiYWNxdWlyZVRva2VuU2lsZW50QXN5bmNcIixcclxuICAgIC8qKlxyXG4gICAgICogYWNxdWlyZVRva2VuUG9wdXAgKG1zYWwtYnJvd3NlcikuXHJcbiAgICAgKiBVc2VkIHRvIGFjcXVpcmUgYSBuZXcgYWNjZXNzIHRva2VuIGludGVyYWN0aXZlbHkgdGhyb3VnaCBwb3AgdXBzXHJcbiAgICAgKi9cclxuICAgIEFjcXVpcmVUb2tlblBvcHVwOiBcImFjcXVpcmVUb2tlblBvcHVwXCIsXHJcbiAgICAvKipcclxuICAgICAqIGFjcXVpcmVUb2tlblByZVJlZGlyZWN0IChtc2FsLWJyb3dzZXIpLlxyXG4gICAgICogRmlyc3QgcGFydCBvZiB0aGUgcmVkaXJlY3QgZmxvdy5cclxuICAgICAqIFVzZWQgdG8gYWNxdWlyZSBhIG5ldyBhY2Nlc3MgdG9rZW4gaW50ZXJhY3RpdmVseSB0aHJvdWdoIHJlZGlyZWN0cy5cclxuICAgICAqL1xyXG4gICAgQWNxdWlyZVRva2VuUHJlUmVkaXJlY3Q6IFwiYWNxdWlyZVRva2VuUHJlUmVkaXJlY3RcIixcclxuICAgIC8qKlxyXG4gICAgICogYWNxdWlyZVRva2VuUmVkaXJlY3QgKG1zYWwtYnJvd3NlcikuXHJcbiAgICAgKiBTZWNvbmQgcGFydCBvZiB0aGUgcmVkaXJlY3QgZmxvdy5cclxuICAgICAqIFVzZWQgdG8gYWNxdWlyZSBhIG5ldyBhY2Nlc3MgdG9rZW4gaW50ZXJhY3RpdmVseSB0aHJvdWdoIHJlZGlyZWN0cy5cclxuICAgICAqL1xyXG4gICAgQWNxdWlyZVRva2VuUmVkaXJlY3Q6IFwiYWNxdWlyZVRva2VuUmVkaXJlY3RcIixcclxuICAgIC8qKlxyXG4gICAgICogZ2V0UHVibGljS2V5VGh1bWJwcmludCBBUEkgaW4gQ3J5cHRvT3B0cyBjbGFzcyAobXNhbC1icm93c2VyKS5cclxuICAgICAqIFVzZWQgdG8gZ2VuZXJhdGUgYSBwdWJsaWMvcHJpdmF0ZSBrZXlwYWlyIGFuZCBnZW5lcmF0ZSBhIHB1YmxpYyBrZXkgdGh1bWJwcmludCBmb3IgcG9wIHJlcXVlc3RzLlxyXG4gICAgICovXHJcbiAgICBDcnlwdG9PcHRzR2V0UHVibGljS2V5VGh1bWJwcmludDogXCJjcnlwdG9PcHRzR2V0UHVibGljS2V5VGh1bWJwcmludFwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBzaWduSnd0IEFQSSBpbiBDcnlwdG9PcHRzIGNsYXNzIChtc2FsLWJyb3dzZXIpLlxyXG4gICAgICogVXNlZCB0byBzaWduZWQgYSBwb3AgdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIENyeXB0b09wdHNTaWduSnd0OiBcImNyeXB0b09wdHNTaWduSnd0XCIsXHJcbiAgICAvKipcclxuICAgICAqIGFjcXVpcmVUb2tlbiBBUEkgaW4gdGhlIFNpbGVudENhY2hlQ2xpZW50IGNsYXNzIChtc2FsLWJyb3dzZXIpLlxyXG4gICAgICogVXNlZCB0byByZWFkIGFjY2VzcyB0b2tlbnMgZnJvbSB0aGUgY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIFNpbGVudENhY2hlQ2xpZW50QWNxdWlyZVRva2VuOiBcInNpbGVudENhY2hlQ2xpZW50QWNxdWlyZVRva2VuXCIsXHJcbiAgICAvKipcclxuICAgICAqIGFjcXVpcmVUb2tlbiBBUEkgaW4gdGhlIFNpbGVudElmcmFtZUNsaWVudCBjbGFzcyAobXNhbC1icm93c2VyKS5cclxuICAgICAqIFVzZWQgdG8gYWNxdWlyZSBhIG5ldyBzZXQgb2YgdG9rZW5zIGZyb20gdGhlIGF1dGhvcml6ZSBlbmRwb2ludCBpbiBhIGhpZGRlbiBpZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIFNpbGVudElmcmFtZUNsaWVudEFjcXVpcmVUb2tlbjogXCJzaWxlbnRJZnJhbWVDbGllbnRBY3F1aXJlVG9rZW5cIixcclxuICAgIEF3YWl0Q29uY3VycmVudElmcmFtZTogXCJhd2FpdENvbmN1cnJlbnRJZnJhbWVcIixcclxuICAgIC8qKlxyXG4gICAgICogYWNxdWlyZVRva2VuIEFQSSBpbiBTaWxlbnRSZXJlc2hDbGllbnQgKG1zYWwtYnJvd3NlcikuXHJcbiAgICAgKiBVc2VkIHRvIGFjcXVpcmUgYSBuZXcgc2V0IG9mIHRva2VucyBmcm9tIHRoZSB0b2tlbiBlbmRwb2ludCB1c2luZyBhIHJlZnJlc2ggdG9rZW4uXHJcbiAgICAgKi9cclxuICAgIFNpbGVudFJlZnJlc2hDbGllbnRBY3F1aXJlVG9rZW46IFwic2lsZW50UmVmcmVzaENsaWVudEFjcXVpcmVUb2tlblwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBzc29TaWxlbnQgQVBJIChtc2FsLWJyb3dzZXIpLlxyXG4gICAgICogVXNlZCB0byBzaWxlbnRseSBhY3F1aXJlIGFuIGF1dGhvcml6YXRpb24gY29kZSBhbmQgc2V0IG9mIHRva2VucyB1c2luZyBhIGhpZGRlbiBpZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIFNzb1NpbGVudDogXCJzc29TaWxlbnRcIixcclxuICAgIC8qKlxyXG4gICAgICogZ2V0RGlzY292ZXJlZEF1dGhvcml0eSBBUEkgaW4gU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudCBjbGFzcyAobXNhbC1icm93c2VyKS5cclxuICAgICAqIFVzZWQgdG8gbG9hZCBhdXRob3JpdHkgbWV0YWRhdGEgZm9yIGEgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudEdldERpc2NvdmVyZWRBdXRob3JpdHk6IFwic3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudEdldERpc2NvdmVyZWRBdXRob3JpdHlcIixcclxuICAgIC8qKlxyXG4gICAgICogYWNxdWlyZVRva2VuIEFQSXMgaW4gbXNhbC1icm93c2VyLlxyXG4gICAgICogVXNlZCB0byBtYWtlIGFuIC9hdXRob3JpemUgZW5kcG9pbnQgY2FsbCB3aXRoIG5hdGl2ZSBicm9rZXJpbmcgZW5hYmxlZC5cclxuICAgICAqL1xyXG4gICAgRmV0Y2hBY2NvdW50SWRXaXRoTmF0aXZlQnJva2VyOiBcImZldGNoQWNjb3VudElkV2l0aE5hdGl2ZUJyb2tlclwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBhY3F1aXJlVG9rZW4gQVBJIGluIE5hdGl2ZUludGVyYWN0aW9uQ2xpZW50IGNsYXNzIChtc2FsLWJyb3dzZXIpLlxyXG4gICAgICogVXNlZCB0byBhY3F1aXJlIGEgdG9rZW4gZnJvbSBOYXRpdmUgY29tcG9uZW50IHdoZW4gbmF0aXZlIGJyb2tlcmluZyBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBOYXRpdmVJbnRlcmFjdGlvbkNsaWVudEFjcXVpcmVUb2tlbjogXCJuYXRpdmVJbnRlcmFjdGlvbkNsaWVudEFjcXVpcmVUb2tlblwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lIHNwZW50IGNyZWF0aW5nIGRlZmF1bHQgaGVhZGVycyBmb3IgcmVxdWVzdHMgdG8gdG9rZW4gZW5kcG9pbnRcclxuICAgICAqL1xyXG4gICAgQmFzZUNsaWVudENyZWF0ZVRva2VuUmVxdWVzdEhlYWRlcnM6IFwiYmFzZUNsaWVudENyZWF0ZVRva2VuUmVxdWVzdEhlYWRlcnNcIixcclxuICAgIC8qKlxyXG4gICAgICogVGltZSBzcGVudCBzZW5kaW5nL3dhaXRpbmcgZm9yIHRoZSByZXNwb25zZSBvZiBhIHJlcXVlc3QgdG8gdGhlIHRva2VuIGVuZHBvaW50XHJcbiAgICAgKi9cclxuICAgIE5ldHdvcmtDbGllbnRTZW5kUG9zdFJlcXVlc3RBc3luYzogXCJuZXR3b3JrQ2xpZW50U2VuZFBvc3RSZXF1ZXN0QXN5bmNcIixcclxuICAgIFJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50OiBcInJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50XCIsXHJcbiAgICBBdXRob3JpemF0aW9uQ29kZUNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50OiBcImF1dGhvcml6YXRpb25Db2RlQ2xpZW50RXhlY3V0ZVBvc3RUb1Rva2VuRW5kcG9pbnRcIixcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBtZWFzdXJlIHRoZSB0aW1lIHRha2VuIGZvciBjb21wbGV0aW5nIGVtYmVkZGVkLWJyb2tlciBoYW5kc2hha2UgKFBXLUJyb2tlcikuXHJcbiAgICAgKi9cclxuICAgIEJyb2tlckhhbmRoc2hha2U6IFwiYnJva2VySGFuZHNoYWtlXCIsXHJcbiAgICAvKipcclxuICAgICAqIGFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuIEFQSSBpbiBCcm9rZXJDbGllbnRBcHBsaWNhdGlvbiAoUFctQnJva2VyKSAuXHJcbiAgICAgKi9cclxuICAgIEFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuSW5Ccm9rZXI6IFwiYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW5JbkJyb2tlclwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lIHRha2VuIGZvciB0b2tlbiBhY3F1aXNpdGlvbiBieSBicm9rZXJcclxuICAgICAqL1xyXG4gICAgQWNxdWlyZVRva2VuQnlCcm9rZXI6IFwiYWNxdWlyZVRva2VuQnlCcm9rZXJcIixcclxuICAgIC8qKlxyXG4gICAgICogVGltZSBzcGVudCBvbiB0aGUgbmV0d29yayBmb3IgcmVmcmVzaCB0b2tlbiBhY3F1aXNpdGlvblxyXG4gICAgICovXHJcbiAgICBSZWZyZXNoVG9rZW5DbGllbnRFeGVjdXRlVG9rZW5SZXF1ZXN0OiBcInJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVUb2tlblJlcXVlc3RcIixcclxuICAgIC8qKlxyXG4gICAgICogVGltZSB0YWtlbiBmb3IgYWNxdWlyaW5nIHJlZnJlc2ggdG9rZW4gLCByZWNvcmRzIFJUIHNpemVcclxuICAgICAqL1xyXG4gICAgUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuOiBcInJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlblwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lIHRha2VuIGZvciBhY3F1aXJpbmcgY2FjaGVkIHJlZnJlc2ggdG9rZW5cclxuICAgICAqL1xyXG4gICAgUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbjogXCJyZWZyZXNoVG9rZW5DbGllbnRBY3F1aXJlVG9rZW5XaXRoQ2FjaGVkUmVmcmVzaFRva2VuXCIsXHJcbiAgICAvKipcclxuICAgICAqIGFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuIEFQSSBpbiBSZWZyZXNoVG9rZW5DbGllbnQgKG1zYWwtY29tbW9uKS5cclxuICAgICAqL1xyXG4gICAgUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW46IFwicmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW5cIixcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0b2tlbiByZXF1ZXN0IGJvZHkgaW4gUmVmcmVzaFRva2VuQ2xpZW50IChtc2FsLWNvbW1vbikuXHJcbiAgICAgKi9cclxuICAgIFJlZnJlc2hUb2tlbkNsaWVudENyZWF0ZVRva2VuUmVxdWVzdEJvZHk6IFwicmVmcmVzaFRva2VuQ2xpZW50Q3JlYXRlVG9rZW5SZXF1ZXN0Qm9keVwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBhY3F1aXJlVG9rZW5Gcm9tQ2FjaGUgKG1zYWwtYnJvd3NlcikuXHJcbiAgICAgKiBJbnRlcm5hbCBBUEkgZm9yIGFjcXVpcmluZyB0b2tlbiBmcm9tIGNhY2hlXHJcbiAgICAgKi9cclxuICAgIEFjcXVpcmVUb2tlbkZyb21DYWNoZTogXCJhY3F1aXJlVG9rZW5Gcm9tQ2FjaGVcIixcclxuICAgIFNpbGVudEZsb3dDbGllbnRBY3F1aXJlQ2FjaGVkVG9rZW46IFwic2lsZW50Rmxvd0NsaWVudEFjcXVpcmVDYWNoZWRUb2tlblwiLFxyXG4gICAgU2lsZW50Rmxvd0NsaWVudEdlbmVyYXRlUmVzdWx0RnJvbUNhY2hlUmVjb3JkOiBcInNpbGVudEZsb3dDbGllbnRHZW5lcmF0ZVJlc3VsdEZyb21DYWNoZVJlY29yZFwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBhY3F1aXJlVG9rZW5CeVNpbGVudElmcmFtZSAobXNhbC1icm93c2VyKS5cclxuICAgICAqIEludGVybmFsIEFQSSBmb3IgYWNxdWlyaW5nIHRva2VuIGJ5IHNpbGVudCBJZnJhbWVcclxuICAgICAqL1xyXG4gICAgQWNxdWlyZVRva2VuQnlTaWxlbnRJZnJhbWU6IFwiYWNxdWlyZVRva2VuQnlTaWxlbnRJZnJhbWVcIixcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgQVBJIGZvciBpbml0aWFsaXppbmcgYmFzZSByZXF1ZXN0IGluIEJhc2VJbnRlcmFjdGlvbkNsaWVudCAobXNhbC1icm93c2VyKVxyXG4gICAgICovXHJcbiAgICBJbml0aWFsaXplQmFzZVJlcXVlc3Q6IFwiaW5pdGlhbGl6ZUJhc2VSZXF1ZXN0XCIsXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIEFQSSBmb3IgaW5pdGlhbGl6aW5nIHNpbGVudCByZXF1ZXN0IGluIFNpbGVudENhY2hlQ2xpZW50IChtc2FsLWJyb3dzZXIpXHJcbiAgICAgKi9cclxuICAgIEluaXRpYWxpemVTaWxlbnRSZXF1ZXN0OiBcImluaXRpYWxpemVTaWxlbnRSZXF1ZXN0XCIsXHJcbiAgICBJbml0aWFsaXplQ2xpZW50QXBwbGljYXRpb246IFwiaW5pdGlhbGl6ZUNsaWVudEFwcGxpY2F0aW9uXCIsXHJcbiAgICBJbml0aWFsaXplQ2FjaGU6IFwiaW5pdGlhbGl6ZUNhY2hlXCIsXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBpbiBTaWxlbnRJZnJhbWVDbGllbnQgY2xhc3MgKG1zYWwtYnJvd3NlcikuXHJcbiAgICAgKi9cclxuICAgIFNpbGVudElmcmFtZUNsaWVudFRva2VuSGVscGVyOiBcInNpbGVudElmcmFtZUNsaWVudFRva2VuSGVscGVyXCIsXHJcbiAgICAvKipcclxuICAgICAqIFNpbGVudEhhbmRsZXJcclxuICAgICAqL1xyXG4gICAgU2lsZW50SGFuZGxlckluaXRpYXRlQXV0aFJlcXVlc3Q6IFwic2lsZW50SGFuZGxlckluaXRpYXRlQXV0aFJlcXVlc3RcIixcclxuICAgIFNpbGVudEhhbmRsZXJNb25pdG9ySWZyYW1lRm9ySGFzaDogXCJzaWxlbnRIYW5kbGVyTW9uaXRvcklmcmFtZUZvckhhc2hcIixcclxuICAgIFNpbGVudEhhbmRsZXJMb2FkRnJhbWU6IFwic2lsZW50SGFuZGxlckxvYWRGcmFtZVwiLFxyXG4gICAgU2lsZW50SGFuZGxlckxvYWRGcmFtZVN5bmM6IFwic2lsZW50SGFuZGxlckxvYWRGcmFtZVN5bmNcIixcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9ucyBpbiBTdGFuZGFyZEludGVyYWN0aW9uQ2xpZW50IGNsYXNzIChtc2FsLWJyb3dzZXIpXHJcbiAgICAgKi9cclxuICAgIFN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRDcmVhdGVBdXRoQ29kZUNsaWVudDogXCJzdGFuZGFyZEludGVyYWN0aW9uQ2xpZW50Q3JlYXRlQXV0aENvZGVDbGllbnRcIixcclxuICAgIFN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRHZXRDbGllbnRDb25maWd1cmF0aW9uOiBcInN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRHZXRDbGllbnRDb25maWd1cmF0aW9uXCIsXHJcbiAgICBTdGFuZGFyZEludGVyYWN0aW9uQ2xpZW50SW5pdGlhbGl6ZUF1dGhvcml6YXRpb25SZXF1ZXN0OiBcInN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRJbml0aWFsaXplQXV0aG9yaXphdGlvblJlcXVlc3RcIixcclxuICAgIC8qKlxyXG4gICAgICogZ2V0QXV0aENvZGVVcmwgQVBJIChtc2FsLWJyb3dzZXIgYW5kIG1zYWwtbm9kZSkuXHJcbiAgICAgKi9cclxuICAgIEdldEF1dGhDb2RlVXJsOiBcImdldEF1dGhDb2RlVXJsXCIsXHJcbiAgICBHZXRTdGFuZGFyZFBhcmFtczogXCJnZXRTdGFuZGFyZFBhcmFtc1wiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbnMgZnJvbSBJbnRlcmFjdGlvbkhhbmRsZXIgKG1zYWwtYnJvd3NlcilcclxuICAgICAqL1xyXG4gICAgSGFuZGxlQ29kZVJlc3BvbnNlRnJvbVNlcnZlcjogXCJoYW5kbGVDb2RlUmVzcG9uc2VGcm9tU2VydmVyXCIsXHJcbiAgICBIYW5kbGVDb2RlUmVzcG9uc2U6IFwiaGFuZGxlQ29kZVJlc3BvbnNlXCIsXHJcbiAgICBIYW5kbGVSZXNwb25zZUVhcjogXCJoYW5kbGVSZXNwb25zZUVhclwiLFxyXG4gICAgSGFuZGxlUmVzcG9uc2VQbGF0Zm9ybUJyb2tlcjogXCJoYW5kbGVSZXNwb25zZVBsYXRmb3JtQnJva2VyXCIsXHJcbiAgICBIYW5kbGVSZXNwb25zZUNvZGU6IFwiaGFuZGxlUmVzcG9uc2VDb2RlXCIsXHJcbiAgICBVcGRhdGVUb2tlbkVuZHBvaW50QXV0aG9yaXR5OiBcInVwZGF0ZVRva2VuRW5kcG9pbnRBdXRob3JpdHlcIixcclxuICAgIC8qKlxyXG4gICAgICogQVBJcyBpbiBBdXRob3JpemF0aW9uIENvZGUgQ2xpZW50IChtc2FsLWNvbW1vbilcclxuICAgICAqL1xyXG4gICAgQXV0aENsaWVudEFjcXVpcmVUb2tlbjogXCJhdXRoQ2xpZW50QWNxdWlyZVRva2VuXCIsXHJcbiAgICBBdXRoQ2xpZW50RXhlY3V0ZVRva2VuUmVxdWVzdDogXCJhdXRoQ2xpZW50RXhlY3V0ZVRva2VuUmVxdWVzdFwiLFxyXG4gICAgQXV0aENsaWVudENyZWF0ZVRva2VuUmVxdWVzdEJvZHk6IFwiYXV0aENsaWVudENyZWF0ZVRva2VuUmVxdWVzdEJvZHlcIixcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgZnVuY3Rpb25zIGluIFBvcFRva2VuR2VuZXJhdG9yIChtc2FsLWNvbW1vbilcclxuICAgICAqL1xyXG4gICAgUG9wVG9rZW5HZW5lcmF0ZUNuZjogXCJwb3BUb2tlbkdlbmVyYXRlQ25mXCIsXHJcbiAgICBQb3BUb2tlbkdlbmVyYXRlS2lkOiBcInBvcFRva2VuR2VuZXJhdGVLaWRcIixcclxuICAgIC8qKlxyXG4gICAgICogaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZSBBUEkgaW4gUmVzcG9uc2VIYW5kbGVyIChtc2FsLWNvbW1vbilcclxuICAgICAqL1xyXG4gICAgSGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZTogXCJoYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlXCIsXHJcbiAgICBEZXNlcmlhbGl6ZVJlc3BvbnNlOiBcImRlc2VyaWFsaXplUmVzcG9uc2VcIixcclxuICAgIC8qKlxyXG4gICAgICogQXV0aG9yaXR5IGZ1bmN0aW9uc1xyXG4gICAgICovXHJcbiAgICBBdXRob3JpdHlGYWN0b3J5Q3JlYXRlRGlzY292ZXJlZEluc3RhbmNlOiBcImF1dGhvcml0eUZhY3RvcnlDcmVhdGVEaXNjb3ZlcmVkSW5zdGFuY2VcIixcclxuICAgIEF1dGhvcml0eVJlc29sdmVFbmRwb2ludHNBc3luYzogXCJhdXRob3JpdHlSZXNvbHZlRW5kcG9pbnRzQXN5bmNcIixcclxuICAgIEF1dGhvcml0eVJlc29sdmVFbmRwb2ludHNGcm9tTG9jYWxTb3VyY2VzOiBcImF1dGhvcml0eVJlc29sdmVFbmRwb2ludHNGcm9tTG9jYWxTb3VyY2VzXCIsXHJcbiAgICBBdXRob3JpdHlHZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbU5ldHdvcms6IFwiYXV0aG9yaXR5R2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrXCIsXHJcbiAgICBBdXRob3JpdHlVcGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhOiBcImF1dGhvcml0eVVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFcIixcclxuICAgIEF1dGhvcml0eUdldEVuZHBvaW50TWV0YWRhdGFGcm9tTmV0d29yazogXCJhdXRob3JpdHlHZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcmtcIixcclxuICAgIEF1dGhvcml0eVVwZGF0ZUVuZHBvaW50TWV0YWRhdGE6IFwiYXV0aG9yaXR5VXBkYXRlRW5kcG9pbnRNZXRhZGF0YVwiLFxyXG4gICAgQXV0aG9yaXR5VXBkYXRlTWV0YWRhdGFXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbjogXCJhdXRob3JpdHlVcGRhdGVNZXRhZGF0YVdpdGhSZWdpb25hbEluZm9ybWF0aW9uXCIsXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lvbiBEaXNjb3ZlcnkgZnVuY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIFJlZ2lvbkRpc2NvdmVyeURldGVjdFJlZ2lvbjogXCJyZWdpb25EaXNjb3ZlcnlEZXRlY3RSZWdpb25cIixcclxuICAgIFJlZ2lvbkRpc2NvdmVyeUdldFJlZ2lvbkZyb21JTURTOiBcInJlZ2lvbkRpc2NvdmVyeUdldFJlZ2lvbkZyb21JTURTXCIsXHJcbiAgICBSZWdpb25EaXNjb3ZlcnlHZXRDdXJyZW50VmVyc2lvbjogXCJyZWdpb25EaXNjb3ZlcnlHZXRDdXJyZW50VmVyc2lvblwiLFxyXG4gICAgQWNxdWlyZVRva2VuQnlDb2RlQXN5bmM6IFwiYWNxdWlyZVRva2VuQnlDb2RlQXN5bmNcIixcclxuICAgIEdldEVuZHBvaW50TWV0YWRhdGFGcm9tTmV0d29yazogXCJnZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcmtcIixcclxuICAgIEdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya01lYXN1cmVtZW50OiBcImdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya01lYXN1cmVtZW50XCIsXHJcbiAgICBIYW5kbGVSZWRpcmVjdFByb21pc2VNZWFzdXJlbWVudDogXCJoYW5kbGVSZWRpcmVjdFByb21pc2VcIixcclxuICAgIEhhbmRsZU5hdGl2ZVJlZGlyZWN0UHJvbWlzZU1lYXN1cmVtZW50OiBcImhhbmRsZU5hdGl2ZVJlZGlyZWN0UHJvbWlzZVwiLFxyXG4gICAgVXBkYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YU1lYXN1cmVtZW50OiBcInVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFNZWFzdXJlbWVudFwiLFxyXG4gICAgVXNlcm5hbWVQYXNzd29yZENsaWVudEFjcXVpcmVUb2tlbjogXCJ1c2VybmFtZVBhc3N3b3JkQ2xpZW50QWNxdWlyZVRva2VuXCIsXHJcbiAgICBOYXRpdmVNZXNzYWdlSGFuZGxlckhhbmRzaGFrZTogXCJuYXRpdmVNZXNzYWdlSGFuZGxlckhhbmRzaGFrZVwiLFxyXG4gICAgTmF0aXZlR2VuZXJhdGVBdXRoUmVzdWx0OiBcIm5hdGl2ZUdlbmVyYXRlQXV0aFJlc3VsdFwiLFxyXG4gICAgUmVtb3ZlSGlkZGVuSWZyYW1lOiBcInJlbW92ZUhpZGRlbklmcmFtZVwiLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZSBvcGVyYXRpb25zXHJcbiAgICAgKi9cclxuICAgIENsZWFyVG9rZW5zQW5kS2V5c1dpdGhDbGFpbXM6IFwiY2xlYXJUb2tlbnNBbmRLZXlzV2l0aENsYWltc1wiLFxyXG4gICAgQ2FjaGVNYW5hZ2VyR2V0UmVmcmVzaFRva2VuOiBcImNhY2hlTWFuYWdlckdldFJlZnJlc2hUb2tlblwiLFxyXG4gICAgSW1wb3J0RXhpc3RpbmdDYWNoZTogXCJpbXBvcnRFeGlzdGluZ0NhY2hlXCIsXHJcbiAgICBTZXRVc2VyRGF0YTogXCJzZXRVc2VyRGF0YVwiLFxyXG4gICAgTG9jYWxTdG9yYWdlVXBkYXRlZDogXCJsb2NhbFN0b3JhZ2VVcGRhdGVkXCIsXHJcbiAgICAvKipcclxuICAgICAqIENyeXB0byBPcGVyYXRpb25zXHJcbiAgICAgKi9cclxuICAgIEdlbmVyYXRlUGtjZUNvZGVzOiBcImdlbmVyYXRlUGtjZUNvZGVzXCIsXHJcbiAgICBHZW5lcmF0ZUNvZGVWZXJpZmllcjogXCJnZW5lcmF0ZUNvZGVWZXJpZmllclwiLFxyXG4gICAgR2VuZXJhdGVDb2RlQ2hhbGxlbmdlRnJvbVZlcmlmaWVyOiBcImdlbmVyYXRlQ29kZUNoYWxsZW5nZUZyb21WZXJpZmllclwiLFxyXG4gICAgU2hhMjU2RGlnZXN0OiBcInNoYTI1NkRpZ2VzdFwiLFxyXG4gICAgR2V0UmFuZG9tVmFsdWVzOiBcImdldFJhbmRvbVZhbHVlc1wiLFxyXG4gICAgR2VuZXJhdGVIS0RGOiBcImdlbmVyYXRlSEtERlwiLFxyXG4gICAgR2VuZXJhdGVCYXNlS2V5OiBcImdlbmVyYXRlQmFzZUtleVwiLFxyXG4gICAgQmFzZTY0RGVjb2RlOiBcImJhc2U2NERlY29kZVwiLFxyXG4gICAgVXJsRW5jb2RlQXJyOiBcInVybEVuY29kZUFyclwiLFxyXG4gICAgRW5jcnlwdDogXCJlbmNyeXB0XCIsXHJcbiAgICBEZWNyeXB0OiBcImRlY3J5cHRcIixcclxuICAgIEdlbmVyYXRlRWFyS2V5OiBcImdlbmVyYXRlRWFyS2V5XCIsXHJcbiAgICBEZWNyeXB0RWFyUmVzcG9uc2U6IFwiZGVjcnlwdEVhclJlc3BvbnNlXCIsXHJcbn07XHJcbmNvbnN0IFBlcmZvcm1hbmNlRXZlbnRBYmJyZXZpYXRpb25zID0gbmV3IE1hcChbXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuQnlDb2RlLCBcIkFUQnlDb2RlXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuLCBcIkFUQnlSVFwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5BY3F1aXJlVG9rZW5TaWxlbnQsIFwiQVRTXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlblNpbGVudEFzeW5jLCBcIkFUU0FzeW5jXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlblBvcHVwLCBcIkFUUG9wdXBcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuUmVkaXJlY3QsIFwiQVRSZWRpcmVjdFwiXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5DcnlwdG9PcHRzR2V0UHVibGljS2V5VGh1bWJwcmludCxcclxuICAgICAgICBcIkNyeXB0b0dldFBLVGh1bWJcIixcclxuICAgIF0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuQ3J5cHRvT3B0c1NpZ25Kd3QsIFwiQ3J5cHRvU2lnbkp3dFwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5TaWxlbnRDYWNoZUNsaWVudEFjcXVpcmVUb2tlbiwgXCJTbHRDYWNoZUNsaWVudEFUXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLlNpbGVudElmcmFtZUNsaWVudEFjcXVpcmVUb2tlbiwgXCJTbHRJZnJhbWVDbGllbnRBVFwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5TaWxlbnRSZWZyZXNoQ2xpZW50QWNxdWlyZVRva2VuLCBcIlNsdFJDbGllbnRBVFwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5Tc29TaWxlbnQsIFwiU3NvU2x0XCJdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRHZXREaXNjb3ZlcmVkQXV0aG9yaXR5LFxyXG4gICAgICAgIFwiU3RkSW50Q2xpZW50R2V0RGlzY0F1dGhcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuRmV0Y2hBY2NvdW50SWRXaXRoTmF0aXZlQnJva2VyLFxyXG4gICAgICAgIFwiRmV0Y2hBY2NJZFdpdGhOdHZCcm9rZXJcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuTmF0aXZlSW50ZXJhY3Rpb25DbGllbnRBY3F1aXJlVG9rZW4sXHJcbiAgICAgICAgXCJOdHZJbnRDbGllbnRBVFwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5CYXNlQ2xpZW50Q3JlYXRlVG9rZW5SZXF1ZXN0SGVhZGVycyxcclxuICAgICAgICBcIkJhc2VDbGllbnRDcmVhdGVUUmVxSGVhZFwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5OZXR3b3JrQ2xpZW50U2VuZFBvc3RSZXF1ZXN0QXN5bmMsXHJcbiAgICAgICAgXCJOZXRDbGllbnRTZW5kUG9zdFwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRFeGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludCxcclxuICAgICAgICBcIlJUQ2xpZW50RXhlY1Bvc3RcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXphdGlvbkNvZGVDbGllbnRFeGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludCxcclxuICAgICAgICBcIkF1dGhDb2RlQ2xpZW50RXhlY1Bvc3RcIixcclxuICAgIF0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuQnJva2VySGFuZGhzaGFrZSwgXCJCcm9rZXJIYW5kc2hha2VcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW5JbkJyb2tlcixcclxuICAgICAgICBcIkFUQnlSVEluQnJva2VyXCIsXHJcbiAgICBdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlbkJ5QnJva2VyLCBcIkFUQnlCcm9rZXJcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50RXhlY3V0ZVRva2VuUmVxdWVzdCxcclxuICAgICAgICBcIlJUQ2xpZW50RXhlY1RSZXFcIixcclxuICAgIF0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuLCBcIlJUQ2xpZW50QVRcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbixcclxuICAgICAgICBcIlJUQ2xpZW50QVRXaXRoQ2FjaGVkUlRcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW4sXHJcbiAgICAgICAgXCJSVENsaWVudEFUQnlSVFwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRDcmVhdGVUb2tlblJlcXVlc3RCb2R5LFxyXG4gICAgICAgIFwiUlRDbGllbnRDcmVhdGVUUmVxQm9keVwiLFxyXG4gICAgXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5BY3F1aXJlVG9rZW5Gcm9tQ2FjaGUsIFwiQVRGcm9tQ2FjaGVcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50Rmxvd0NsaWVudEFjcXVpcmVDYWNoZWRUb2tlbixcclxuICAgICAgICBcIlNsdEZsb3dDbGllbnRBVENhY2hlZFwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5TaWxlbnRGbG93Q2xpZW50R2VuZXJhdGVSZXN1bHRGcm9tQ2FjaGVSZWNvcmQsXHJcbiAgICAgICAgXCJTbHRGbG93Q2xpZW50R2VuUmVzRnJvbUNhY2hlXCIsXHJcbiAgICBdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkFjcXVpcmVUb2tlbkJ5U2lsZW50SWZyYW1lLCBcIkFUQnlTbHRJZnJhbWVcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuSW5pdGlhbGl6ZUJhc2VSZXF1ZXN0LCBcIkluaXRCYXNlUmVxXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkluaXRpYWxpemVTaWxlbnRSZXF1ZXN0LCBcIkluaXRTbHRSZXFcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuSW5pdGlhbGl6ZUNsaWVudEFwcGxpY2F0aW9uLFxyXG4gICAgICAgIFwiSW5pdENsaWVudEFwcGxpY2F0aW9uXCIsXHJcbiAgICBdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkluaXRpYWxpemVDYWNoZSwgXCJJbml0Q2FjaGVcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuSW1wb3J0RXhpc3RpbmdDYWNoZSwgXCJpbXBvcnRDYWNoZVwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5TZXRVc2VyRGF0YSwgXCJzZXRVc2VyRGF0YVwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5Mb2NhbFN0b3JhZ2VVcGRhdGVkLCBcImxvY2FsU3RvcmFnZVVwZGF0ZWRcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50SWZyYW1lQ2xpZW50VG9rZW5IZWxwZXIsIFwiU0lDbGllbnRUSGVscGVyXCJdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlNpbGVudEhhbmRsZXJJbml0aWF0ZUF1dGhSZXF1ZXN0LFxyXG4gICAgICAgIFwiU0hhbmRsZXJJbml0QXV0aFJlcVwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5TaWxlbnRIYW5kbGVyTW9uaXRvcklmcmFtZUZvckhhc2gsXHJcbiAgICAgICAgXCJTbHRIYW5kbGVyTW9uaXRvcklmcmFtZUZvckhhc2hcIixcclxuICAgIF0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuU2lsZW50SGFuZGxlckxvYWRGcmFtZSwgXCJTSGFuZGxlckxvYWRGcmFtZVwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5TaWxlbnRIYW5kbGVyTG9hZEZyYW1lU3luYywgXCJTSGFuZGxlckxvYWRGcmFtZVN5bmNcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudENyZWF0ZUF1dGhDb2RlQ2xpZW50LFxyXG4gICAgICAgIFwiU3RkSW50Q2xpZW50Q3JlYXRlQXV0aENvZGVDbGllbnRcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuU3RhbmRhcmRJbnRlcmFjdGlvbkNsaWVudEdldENsaWVudENvbmZpZ3VyYXRpb24sXHJcbiAgICAgICAgXCJTdGRJbnRDbGllbnRHZXRDbGllbnRDb25mXCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlN0YW5kYXJkSW50ZXJhY3Rpb25DbGllbnRJbml0aWFsaXplQXV0aG9yaXphdGlvblJlcXVlc3QsXHJcbiAgICAgICAgXCJTdGRJbnRDbGllbnRJbml0QXV0aFJlcVwiLFxyXG4gICAgXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZXRBdXRoQ29kZVVybCwgXCJHZXRBdXRoQ29kZVVybFwiXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5IYW5kbGVDb2RlUmVzcG9uc2VGcm9tU2VydmVyLFxyXG4gICAgICAgIFwiSGFuZGxlQ29kZVJlc0Zyb21TZXJ2ZXJcIixcclxuICAgIF0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlQ29kZVJlc3BvbnNlLCBcIkhhbmRsZUNvZGVSZXNwXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkhhbmRsZVJlc3BvbnNlRWFyLCBcIkhhbmRsZVJlc3BFYXJcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlUmVzcG9uc2VDb2RlLCBcIkhhbmRsZVJlc3BDb2RlXCJdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkhhbmRsZVJlc3BvbnNlUGxhdGZvcm1Ccm9rZXIsXHJcbiAgICAgICAgXCJIYW5kbGVSZXNwUGxhdEJyb2tlclwiLFxyXG4gICAgXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5VcGRhdGVUb2tlbkVuZHBvaW50QXV0aG9yaXR5LCBcIlVwZFRFbmRwb2ludEF1dGhcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuQXV0aENsaWVudEFjcXVpcmVUb2tlbiwgXCJBdXRoQ2xpZW50QVRcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuQXV0aENsaWVudEV4ZWN1dGVUb2tlblJlcXVlc3QsIFwiQXV0aENsaWVudEV4ZWNUUmVxXCJdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhDbGllbnRDcmVhdGVUb2tlblJlcXVlc3RCb2R5LFxyXG4gICAgICAgIFwiQXV0aENsaWVudENyZWF0ZVRSZXFCb2R5XCIsXHJcbiAgICBdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLlBvcFRva2VuR2VuZXJhdGVDbmYsIFwiUG9wVEdlbkNuZlwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5Qb3BUb2tlbkdlbmVyYXRlS2lkLCBcIlBvcFRHZW5LaWRcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuSGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZSwgXCJIYW5kbGVTZXJ2ZXJUUmVzXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkRlc2VyaWFsaXplUmVzcG9uc2UsIFwiRGVzZXJpYWxpemVSZXNcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5RmFjdG9yeUNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZSxcclxuICAgICAgICBcIkF1dGhGYWN0Q3JlYXRlRGlzY0luc3RcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5UmVzb2x2ZUVuZHBvaW50c0FzeW5jLFxyXG4gICAgICAgIFwiQXV0aFJlc29sdmVFbmRwb2ludHNBc3luY1wiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlSZXNvbHZlRW5kcG9pbnRzRnJvbUxvY2FsU291cmNlcyxcclxuICAgICAgICBcIkF1dGhSZXNvbHZlRW5kcG9pbnRzRnJvbUxvY2FsXCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eUdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29yayxcclxuICAgICAgICBcIkF1dGhHZXRDRE1ldGFGcm9tTmV0XCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEsXHJcbiAgICAgICAgXCJBdXRoVXBkQ0RNZXRhXCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eUdldEVuZHBvaW50TWV0YWRhdGFGcm9tTmV0d29yayxcclxuICAgICAgICBcIkF1dGhVcGRDRE1ldGFGcm9tTmV0XCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZUVuZHBvaW50TWV0YWRhdGEsXHJcbiAgICAgICAgXCJBdXRoVXBkRW5kcG9pbnRNZXRhXCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZU1ldGFkYXRhV2l0aFJlZ2lvbmFsSW5mb3JtYXRpb24sXHJcbiAgICAgICAgXCJBdXRoVXBkTWV0YVdpdGhSZWdJbmZvXCIsXHJcbiAgICBdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeURldGVjdFJlZ2lvbiwgXCJSZWdEaXNjRGV0ZWN0UmVnXCJdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeUdldFJlZ2lvbkZyb21JTURTLFxyXG4gICAgICAgIFwiUmVnRGlzY0dldFJlZ0Zyb21JTURTXCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeUdldEN1cnJlbnRWZXJzaW9uLFxyXG4gICAgICAgIFwiUmVnRGlzY0dldEN1cnJlbnRWZXJcIixcclxuICAgIF0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuQWNxdWlyZVRva2VuQnlDb2RlQXN5bmMsIFwiQVRCeUNvZGVBc3luY1wiXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5HZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcmssXHJcbiAgICAgICAgXCJHZXRFbmRwb2ludE1ldGFGcm9tTmV0XCIsXHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya01lYXN1cmVtZW50LFxyXG4gICAgICAgIFwiR2V0Q0RNZXRhRnJvbU5ldFwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5IYW5kbGVSZWRpcmVjdFByb21pc2VNZWFzdXJlbWVudCxcclxuICAgICAgICBcIkhhbmRsZVJlZGlyZWN0UHJvbWlzZVwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5IYW5kbGVOYXRpdmVSZWRpcmVjdFByb21pc2VNZWFzdXJlbWVudCxcclxuICAgICAgICBcIkhhbmRsZU50dlJlZGlyZWN0UHJvbWlzZVwiLFxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICBQZXJmb3JtYW5jZUV2ZW50cy5VcGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhTWVhc3VyZW1lbnQsXHJcbiAgICAgICAgXCJVcGRhdGVDRE1ldGFcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuVXNlcm5hbWVQYXNzd29yZENsaWVudEFjcXVpcmVUb2tlbixcclxuICAgICAgICBcIlVzZXJQYXNzQ2xpZW50QVRcIixcclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuTmF0aXZlTWVzc2FnZUhhbmRsZXJIYW5kc2hha2UsXHJcbiAgICAgICAgXCJOdHZNc2dIYW5kbGVySGFuZHNoYWtlXCIsXHJcbiAgICBdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLk5hdGl2ZUdlbmVyYXRlQXV0aFJlc3VsdCwgXCJOdHZHZW5BdXRoUmVzXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLlJlbW92ZUhpZGRlbklmcmFtZSwgXCJSZW1vdmVIaWRkZW5JZnJhbWVcIl0sXHJcbiAgICBbXHJcbiAgICAgICAgUGVyZm9ybWFuY2VFdmVudHMuQ2xlYXJUb2tlbnNBbmRLZXlzV2l0aENsYWltcyxcclxuICAgICAgICBcIkNsZWFyVEFuZEtleXNXaXRoQ2xhaW1zXCIsXHJcbiAgICBdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkNhY2hlTWFuYWdlckdldFJlZnJlc2hUb2tlbiwgXCJDYWNoZU1hbmFnZXJHZXRSVFwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZW5lcmF0ZVBrY2VDb2RlcywgXCJHZW5Qa2NlQ29kZXNcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuR2VuZXJhdGVDb2RlVmVyaWZpZXIsIFwiR2VuQ29kZVZlcmlmaWVyXCJdLFxyXG4gICAgW1xyXG4gICAgICAgIFBlcmZvcm1hbmNlRXZlbnRzLkdlbmVyYXRlQ29kZUNoYWxsZW5nZUZyb21WZXJpZmllcixcclxuICAgICAgICBcIkdlbkNvZGVDaGFsbGVuZ2VGcm9tVmVyaWZpZXJcIixcclxuICAgIF0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuU2hhMjU2RGlnZXN0LCBcIlNoYTI1NkRpZ2VzdFwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5HZXRSYW5kb21WYWx1ZXMsIFwiR2V0UmFuZG9tVmFsdWVzXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkdlbmVyYXRlSEtERiwgXCJnZW5IS0RGXCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkdlbmVyYXRlQmFzZUtleSwgXCJnZW5CYXNlS2V5XCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkJhc2U2NERlY29kZSwgXCJiNjREZWNvZGVcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuVXJsRW5jb2RlQXJyLCBcInVybEVuY0FyclwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5FbmNyeXB0LCBcImVuY3J5cHRcIl0sXHJcbiAgICBbUGVyZm9ybWFuY2VFdmVudHMuRGVjcnlwdCwgXCJkZWNyeXB0XCJdLFxyXG4gICAgW1BlcmZvcm1hbmNlRXZlbnRzLkdlbmVyYXRlRWFyS2V5LCBcImdlbkVhcktleVwiXSxcclxuICAgIFtQZXJmb3JtYW5jZUV2ZW50cy5EZWNyeXB0RWFyUmVzcG9uc2UsIFwiZGVjcnlwdEVhclJlc3BcIl0sXHJcbl0pO1xyXG4vKipcclxuICogU3RhdGUgb2YgdGhlIHBlcmZvcm1hbmNlIGV2ZW50LlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBQZXJmb3JtYW5jZUV2ZW50U3RhdHVzID0ge1xyXG4gICAgTm90U3RhcnRlZDogMCxcclxuICAgIEluUHJvZ3Jlc3M6IDEsXHJcbiAgICBDb21wbGV0ZWQ6IDIsXHJcbn07XHJcbmNvbnN0IEludEZpZWxkcyA9IG5ldyBTZXQoW1xyXG4gICAgXCJhY2Nlc3NUb2tlblNpemVcIixcclxuICAgIFwiZHVyYXRpb25Nc1wiLFxyXG4gICAgXCJpZFRva2VuU2l6ZVwiLFxyXG4gICAgXCJtYXRzU2lsZW50U3RhdHVzXCIsXHJcbiAgICBcIm1hdHNIdHRwU3RhdHVzXCIsXHJcbiAgICBcInJlZnJlc2hUb2tlblNpemVcIixcclxuICAgIFwicXVldWVkVGltZU1zXCIsXHJcbiAgICBcInN0YXJ0VGltZU1zXCIsXHJcbiAgICBcInN0YXR1c1wiLFxyXG4gICAgXCJtdWx0aU1hdGNoZWRBVFwiLFxyXG4gICAgXCJtdWx0aU1hdGNoZWRJRFwiLFxyXG4gICAgXCJtdWx0aU1hdGNoZWRSVFwiLFxyXG4gICAgXCJ1bmVuY3J5cHRlZENhY2hlQ291bnRcIixcclxuICAgIFwiZW5jcnlwdGVkQ2FjaGVFeHBpcmVkQ291bnRcIixcclxuXSk7XG5cbmV4cG9ydCB7IEludEZpZWxkcywgUGVyZm9ybWFuY2VFdmVudEFiYnJldmlhdGlvbnMsIFBlcmZvcm1hbmNlRXZlbnRTdGF0dXMsIFBlcmZvcm1hbmNlRXZlbnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJmb3JtYW5jZUV2ZW50Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50LlxyXG4gKiBVc2FnZTogaW52b2tlKGZ1bmN0aW9uVG9DYWxsLCBwZXJmb3JtYW5jZUNsaWVudCwgXCJFdmVudE5hbWVcIiwgXCJjb3JyZWxhdGlvbklkXCIpKC4uLmFyZ3NUb1Bhc3NUb0Z1bmN0aW9uKVxyXG4gKiBAcGFyYW0gY2FsbGJhY2tcclxuICogQHBhcmFtIGV2ZW50TmFtZVxyXG4gKiBAcGFyYW0gbG9nZ2VyXHJcbiAqIEBwYXJhbSB0ZWxlbWV0cnlDbGllbnRcclxuICogQHBhcmFtIGNvcnJlbGF0aW9uSWRcclxuICogQHJldHVybnNcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdCBpbnZva2UgPSAoY2FsbGJhY2ssIGV2ZW50TmFtZSwgbG9nZ2VyLCB0ZWxlbWV0cnlDbGllbnQsIGNvcnJlbGF0aW9uSWQpID0+IHtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGxvZ2dlci50cmFjZShgRXhlY3V0aW5nIGZ1bmN0aW9uICR7ZXZlbnROYW1lfWApO1xyXG4gICAgICAgIGNvbnN0IGluUHJvZ3Jlc3NFdmVudCA9IHRlbGVtZXRyeUNsaWVudD8uc3RhcnRNZWFzdXJlbWVudChldmVudE5hbWUsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGlmIChjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyYWNrIG51bWJlciBvZiB0aW1lcyB0aGlzIEFQSSBpcyBjYWxsZWQgaW4gYSBzaW5nbGUgcmVxdWVzdFxyXG4gICAgICAgICAgICBjb25zdCBldmVudENvdW50ID0gZXZlbnROYW1lICsgXCJDYWxsQ291bnRcIjtcclxuICAgICAgICAgICAgdGVsZW1ldHJ5Q2xpZW50Py5pbmNyZW1lbnRGaWVsZHMoeyBbZXZlbnRDb3VudF06IDEgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICBpblByb2dyZXNzRXZlbnQ/LmVuZCh7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBSZXR1cm5pbmcgcmVzdWx0IGZyb20gJHtldmVudE5hbWV9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci50cmFjZShgRXJyb3Igb2NjdXJyZWQgaW4gJHtldmVudE5hbWV9YCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoSlNPTi5zdHJpbmdpZnkoZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJVbmFibGUgdG8gcHJpbnQgZXJyb3IgbWVzc2FnZS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5Qcm9ncmVzc0V2ZW50Py5lbmQoe1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sIGUpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbi8qKlxyXG4gKiBXcmFwcyBhbiBhc3luYyBmdW5jdGlvbiB3aXRoIGEgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQuXHJcbiAqIFVzYWdlOiBpbnZva2VBc3luYyhmdW5jdGlvblRvQ2FsbCwgcGVyZm9ybWFuY2VDbGllbnQsIFwiRXZlbnROYW1lXCIsIFwiY29ycmVsYXRpb25JZFwiKSguLi5hcmdzVG9QYXNzVG9GdW5jdGlvbilcclxuICogQHBhcmFtIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSBldmVudE5hbWVcclxuICogQHBhcmFtIGxvZ2dlclxyXG4gKiBAcGFyYW0gdGVsZW1ldHJ5Q2xpZW50XHJcbiAqIEBwYXJhbSBjb3JyZWxhdGlvbklkXHJcbiAqIEByZXR1cm5zXHJcbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3QgaW52b2tlQXN5bmMgPSAoY2FsbGJhY2ssIGV2ZW50TmFtZSwgbG9nZ2VyLCB0ZWxlbWV0cnlDbGllbnQsIGNvcnJlbGF0aW9uSWQpID0+IHtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGxvZ2dlci50cmFjZShgRXhlY3V0aW5nIGZ1bmN0aW9uICR7ZXZlbnROYW1lfWApO1xyXG4gICAgICAgIGNvbnN0IGluUHJvZ3Jlc3NFdmVudCA9IHRlbGVtZXRyeUNsaWVudD8uc3RhcnRNZWFzdXJlbWVudChldmVudE5hbWUsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGlmIChjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyYWNrIG51bWJlciBvZiB0aW1lcyB0aGlzIEFQSSBpcyBjYWxsZWQgaW4gYSBzaW5nbGUgcmVxdWVzdFxyXG4gICAgICAgICAgICBjb25zdCBldmVudENvdW50ID0gZXZlbnROYW1lICsgXCJDYWxsQ291bnRcIjtcclxuICAgICAgICAgICAgdGVsZW1ldHJ5Q2xpZW50Py5pbmNyZW1lbnRGaWVsZHMoeyBbZXZlbnRDb3VudF06IDEgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbGVtZXRyeUNsaWVudD8uc2V0UHJlUXVldWVUaW1lKGV2ZW50TmFtZSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpXHJcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBsb2dnZXIudHJhY2UoYFJldHVybmluZyByZXN1bHQgZnJvbSAke2V2ZW50TmFtZX1gKTtcclxuICAgICAgICAgICAgaW5Qcm9ncmVzc0V2ZW50Py5lbmQoe1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBFcnJvciBvY2N1cnJlZCBpbiAke2V2ZW50TmFtZX1gKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShKU09OLnN0cmluZ2lmeShlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlVuYWJsZSB0byBwcmludCBlcnJvciBtZXNzYWdlLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpblByb2dyZXNzRXZlbnQ/LmVuZCh7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgfSwgZSk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xuXG5leHBvcnQgeyBpbnZva2UsIGludm9rZUFzeW5jIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5jdGlvbldyYXBwZXJzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBDb25zdGFudHMsIEh0dHBTdGF0dXMsIFJlZ2lvbkRpc2NvdmVyeVNvdXJjZXMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IFBlcmZvcm1hbmNlRXZlbnRzIH0gZnJvbSAnLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL1BlcmZvcm1hbmNlRXZlbnQubWpzJztcbmltcG9ydCB7IGludm9rZUFzeW5jIH0gZnJvbSAnLi4vdXRpbHMvRnVuY3Rpb25XcmFwcGVycy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgUmVnaW9uRGlzY292ZXJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmtJbnRlcmZhY2UsIGxvZ2dlciwgcGVyZm9ybWFuY2VDbGllbnQsIGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICB0aGlzLm5ldHdvcmtJbnRlcmZhY2UgPSBuZXR3b3JrSW50ZXJmYWNlO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQgPSBwZXJmb3JtYW5jZUNsaWVudDtcclxuICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWQgPSBjb3JyZWxhdGlvbklkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlY3QgdGhlIHJlZ2lvbiBmcm9tIHRoZSBhcHBsaWNhdGlvbidzIGVudmlyb25tZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2U8c3RyaW5nIHwgbnVsbD5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZGV0ZWN0UmVnaW9uKGVudmlyb25tZW50UmVnaW9uLCByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5RGV0ZWN0UmVnaW9uLCB0aGlzLmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYXV0byBkZXRlY3RlZCByZWdpb24gd2l0aCB0aGUgcmVnaW9uIGZyb20gdGhlIGVudnJpb25tZW50XHJcbiAgICAgICAgbGV0IGF1dG9kZXRlY3RlZFJlZ2lvbk5hbWUgPSBlbnZpcm9ubWVudFJlZ2lvbjtcclxuICAgICAgICAvLyBDaGVjayBpZiBhIHJlZ2lvbiB3YXMgZGV0ZWN0ZWQgZnJvbSB0aGUgZW52aXJvbm1lbnQsIGlmIG5vdCwgYXR0ZW1wdCB0byBnZXQgdGhlIHJlZ2lvbiBmcm9tIElNRFNcclxuICAgICAgICBpZiAoIWF1dG9kZXRlY3RlZFJlZ2lvbk5hbWUpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFJlZ2lvbkRpc2NvdmVyeS5JTURTX09QVElPTlM7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbElNRFNWZXJzaW9uUmVzcG9uc2UgPSBhd2FpdCBpbnZva2VBc3luYyh0aGlzLmdldFJlZ2lvbkZyb21JTURTLmJpbmQodGhpcyksIFBlcmZvcm1hbmNlRXZlbnRzLlJlZ2lvbkRpc2NvdmVyeUdldFJlZ2lvbkZyb21JTURTLCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgdGhpcy5jb3JyZWxhdGlvbklkKShDb25zdGFudHMuSU1EU19WRVJTSU9OLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmIChsb2NhbElNRFNWZXJzaW9uUmVzcG9uc2Uuc3RhdHVzID09PSBIdHRwU3RhdHVzLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lID0gbG9jYWxJTURTVmVyc2lvblJlc3BvbnNlLmJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX3NvdXJjZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZ2lvbkRpc2NvdmVyeVNvdXJjZXMuSU1EUztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXNwb25zZSB1c2luZyB0aGUgbG9jYWwgSU1EUyB2ZXJzaW9uIGZhaWxlZCwgdHJ5IHRvIGZldGNoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgSU1EUyBhbmQgcmV0cnkuXHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJTURTVmVyc2lvblJlc3BvbnNlLnN0YXR1cyA9PT0gSHR0cFN0YXR1cy5CQURfUkVRVUVTVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJTURTVmVyc2lvbiA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMuZ2V0Q3VycmVudFZlcnNpb24uYmluZCh0aGlzKSwgUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5R2V0Q3VycmVudFZlcnNpb24sIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCB0aGlzLmNvcnJlbGF0aW9uSWQpKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudElNRFNWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9zb3VyY2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVnaW9uRGlzY292ZXJ5U291cmNlcy5GQUlMRURfQVVUT19ERVRFQ1RJT047XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SU1EU1ZlcnNpb25SZXNwb25zZSA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMuZ2V0UmVnaW9uRnJvbUlNRFMuYmluZCh0aGlzKSwgUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5R2V0UmVnaW9uRnJvbUlNRFMsIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCB0aGlzLmNvcnJlbGF0aW9uSWQpKGN1cnJlbnRJTURTVmVyc2lvbiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJTURTVmVyc2lvblJlc3BvbnNlLnN0YXR1cyA9PT0gSHR0cFN0YXR1cy5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9kZXRlY3RlZFJlZ2lvbk5hbWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudElNRFNWZXJzaW9uUmVzcG9uc2UuYm9keTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX3NvdXJjZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWdpb25EaXNjb3ZlcnlTb3VyY2VzLklNRFM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fc291cmNlID1cclxuICAgICAgICAgICAgICAgICAgICBSZWdpb25EaXNjb3ZlcnlTb3VyY2VzLkZBSUxFRF9BVVRPX0RFVEVDVElPTjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fc291cmNlID1cclxuICAgICAgICAgICAgICAgIFJlZ2lvbkRpc2NvdmVyeVNvdXJjZXMuRU5WSVJPTk1FTlRfVkFSSUFCTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIG5vIHJlZ2lvbiB3YXMgYXV0byBkZXRlY3RlZCBmcm9tIHRoZSBlbnZpcm9ubWVudCBvciBmcm9tIHRoZSBJTURTIGVuZHBvaW50LCBtYXJrIHRoZSBhdHRlbXB0IGFzIGEgRkFJTEVEX0FVVE9fREVURUNUSU9OXHJcbiAgICAgICAgaWYgKCFhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9zb3VyY2UgPVxyXG4gICAgICAgICAgICAgICAgUmVnaW9uRGlzY292ZXJ5U291cmNlcy5GQUlMRURfQVVUT19ERVRFQ1RJT047XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgdGhlIGNhbGwgdG8gdGhlIElNRFMgZW5kcG9pbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW1kc0VuZHBvaW50VXJsXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlPE5ldHdvcmtSZXNwb25zZTxzdHJpbmc+PlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRSZWdpb25Gcm9tSU1EUyh2ZXJzaW9uLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChQZXJmb3JtYW5jZUV2ZW50cy5SZWdpb25EaXNjb3ZlcnlHZXRSZWdpb25Gcm9tSU1EUywgdGhpcy5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrSW50ZXJmYWNlLnNlbmRHZXRSZXF1ZXN0QXN5bmMoYCR7Q29uc3RhbnRzLklNRFNfRU5EUE9JTlR9P2FwaS12ZXJzaW9uPSR7dmVyc2lvbn0mZm9ybWF0PXRleHRgLCBvcHRpb25zLCBDb25zdGFudHMuSU1EU19USU1FT1VUKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIG9mIHRoZSBJTURTIGVuZHBvaW50IGF2YWlsYWJsZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2U8c3RyaW5nIHwgbnVsbD5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0Q3VycmVudFZlcnNpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5R2V0Q3VycmVudFZlcnNpb24sIHRoaXMuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm5ldHdvcmtJbnRlcmZhY2Uuc2VuZEdldFJlcXVlc3RBc3luYyhgJHtDb25zdGFudHMuSU1EU19FTkRQT0lOVH0/Zm9ybWF0PWpzb25gLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gV2hlbiBJTURTIGVuZHBvaW50IGlzIGNhbGxlZCB3aXRob3V0IHRoZSBhcGkgdmVyc2lvbiBxdWVyeSBwYXJhbSwgYmFkIHJlcXVlc3QgcmVzcG9uc2UgY29tZXMgYmFjayB3aXRoIGxhdGVzdCB2ZXJzaW9uLlxyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBIdHRwU3RhdHVzLkJBRF9SRVFVRVNUICYmXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ICYmXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5W1wibmV3ZXN0LXZlcnNpb25zXCJdICYmXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5W1wibmV3ZXN0LXZlcnNpb25zXCJdLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ib2R5W1wibmV3ZXN0LXZlcnNpb25zXCJdWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gT3B0aW9ucyBmb3IgdGhlIElNRFMgZW5kcG9pbnQgcmVxdWVzdFxyXG5SZWdpb25EaXNjb3ZlcnkuSU1EU19PUFRJT05TID0ge1xyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAgIE1ldGFkYXRhOiBcInRydWVcIixcclxuICAgIH0sXHJcbn07XG5cbmV4cG9ydCB7IFJlZ2lvbkRpc2NvdmVyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVnaW9uRGlzY292ZXJ5Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IHRva2VuUGFyc2luZ0Vycm9yLCBudWxsT3JFbXB0eVRva2VuLCBtYXhBZ2VUcmFuc3BpcmVkIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yQ29kZXMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFeHRyYWN0IHRva2VuIGJ5IGRlY29kaW5nIHRoZSByYXdUb2tlblxyXG4gKlxyXG4gKiBAcGFyYW0gZW5jb2RlZFRva2VuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0VG9rZW5DbGFpbXMoZW5jb2RlZFRva2VuLCBiYXNlNjREZWNvZGUpIHtcclxuICAgIGNvbnN0IGpzd1BheWxvYWQgPSBnZXRKV1NQYXlsb2FkKGVuY29kZWRUb2tlbik7XHJcbiAgICAvLyB0b2tlbiB3aWxsIGJlIGRlY29kZWQgdG8gZ2V0IHRoZSB1c2VybmFtZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBiYXNlNjREZWNvZGUoKSBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYW4gaXNzdWVcclxuICAgICAgICBjb25zdCBiYXNlNjREZWNvZGVkID0gYmFzZTY0RGVjb2RlKGpzd1BheWxvYWQpO1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJhc2U2NERlY29kZWQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcih0b2tlblBhcnNpbmdFcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRlY29kZSBhIEpXVFxyXG4gKlxyXG4gKiBAcGFyYW0gYXV0aFRva2VuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRKV1NQYXlsb2FkKGF1dGhUb2tlbikge1xyXG4gICAgaWYgKCFhdXRoVG9rZW4pIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobnVsbE9yRW1wdHlUb2tlbik7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0b2tlblBhcnRzUmVnZXggPSAvXihbXlxcLlxcc10qKVxcLihbXlxcLlxcc10rKVxcLihbXlxcLlxcc10qKSQvO1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IHRva2VuUGFydHNSZWdleC5leGVjKGF1dGhUb2tlbik7XHJcbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCA0KSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKHRva2VuUGFyc2luZ0Vycm9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogY29uc3QgY3JhY2tlZFRva2VuID0ge1xyXG4gICAgICogIGhlYWRlcjogbWF0Y2hlc1sxXSxcclxuICAgICAqICBKV1NQYXlsb2FkOiBtYXRjaGVzWzJdLFxyXG4gICAgICogIEpXU1NpZzogbWF0Y2hlc1szXSxcclxuICAgICAqIH07XHJcbiAgICAgKi9cclxuICAgIHJldHVybiBtYXRjaGVzWzJdO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHRva2VuJ3MgbWF4X2FnZSBoYXMgdHJhbnNwaXJlZFxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tNYXhBZ2UoYXV0aFRpbWUsIG1heEFnZSkge1xyXG4gICAgLypcclxuICAgICAqIHBlciBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNBdXRoUmVxdWVzdFxyXG4gICAgICogVG8gZm9yY2UgYW4gaW1tZWRpYXRlIHJlLWF1dGhlbnRpY2F0aW9uOiBJZiBhbiBhcHAgcmVxdWlyZXMgdGhhdCBhIHVzZXIgcmUtYXV0aGVudGljYXRlIHByaW9yIHRvIGFjY2VzcyxcclxuICAgICAqIHByb3ZpZGUgYSB2YWx1ZSBvZiAwIGZvciB0aGUgbWF4X2FnZSBwYXJhbWV0ZXIgYW5kIHRoZSBBUyB3aWxsIGZvcmNlIGEgZnJlc2ggbG9naW4uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGZpdmVNaW51dGVTa2V3ID0gMzAwMDAwOyAvLyBmaXZlIG1pbnV0ZXMgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICBpZiAobWF4QWdlID09PSAwIHx8IERhdGUubm93KCkgLSBmaXZlTWludXRlU2tldyA+IGF1dGhUaW1lICsgbWF4QWdlKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1heEFnZVRyYW5zcGlyZWQpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IGNoZWNrTWF4QWdlLCBleHRyYWN0VG9rZW5DbGFpbXMsIGdldEpXU1BheWxvYWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhUb2tlbi5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZGF0ZSBhbmQgdGltZSBvcGVyYXRpb25zLlxyXG4gKi9cclxuLyoqXHJcbiAqIHJldHVybiB0aGUgY3VycmVudCB0aW1lIGluIFVuaXggdGltZSAoc2Vjb25kcykuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3dTZWNvbmRzKCkge1xyXG4gICAgLy8gRGF0ZS5nZXRUaW1lKCkgcmV0dXJucyBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDAuMCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIEpTIERhdGUgb2JqZWN0IHRvIHNlY29uZHNcclxuICogQHBhcmFtIGRhdGUgRGF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdG9TZWNvbmRzRnJvbURhdGUoZGF0ZSkge1xyXG4gICAgLy8gQ29udmVydCBkYXRlIHRvIHNlY29uZHNcclxuICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQgc2Vjb25kcyB0byBKUyBEYXRlIG9iamVjdC4gU2Vjb25kcyBjYW4gYmUgaW4gYSBudW1iZXIgb3Igc3RyaW5nIGZvcm1hdCBvciB1bmRlZmluZWQgKHdpbGwgc3RpbGwgcmV0dXJuIGEgZGF0ZSkuXHJcbiAqIEBwYXJhbSBzZWNvbmRzXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RhdGVGcm9tU2Vjb25kcyhzZWNvbmRzKSB7XHJcbiAgICBpZiAoc2Vjb25kcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIoc2Vjb25kcykgKiAxMDAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRGF0ZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBjaGVjayBpZiBhIHRva2VuIGlzIGV4cGlyZWQgYmFzZWQgb24gZ2l2ZW4gVVRDIHRpbWUgaW4gc2Vjb25kcy5cclxuICogQHBhcmFtIGV4cGlyZXNPblxyXG4gKi9cclxuZnVuY3Rpb24gaXNUb2tlbkV4cGlyZWQoZXhwaXJlc09uLCBvZmZzZXQpIHtcclxuICAgIC8vIGNoZWNrIGZvciBhY2Nlc3MgdG9rZW4gZXhwaXJ5XHJcbiAgICBjb25zdCBleHBpcmF0aW9uU2VjID0gTnVtYmVyKGV4cGlyZXNPbikgfHwgMDtcclxuICAgIGNvbnN0IG9mZnNldEN1cnJlbnRUaW1lU2VjID0gbm93U2Vjb25kcygpICsgb2Zmc2V0O1xyXG4gICAgLy8gSWYgY3VycmVudCB0aW1lICsgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0b2tlbiBleHBpcmF0aW9uIHRpbWUsIHRoZW4gdG9rZW4gaXMgZXhwaXJlZC5cclxuICAgIHJldHVybiBvZmZzZXRDdXJyZW50VGltZVNlYyA+IGV4cGlyYXRpb25TZWM7XHJcbn1cclxuLyoqXHJcbiAqIElmIHRoZSBjdXJyZW50IHRpbWUgaXMgZWFybGllciB0aGFuIHRoZSB0aW1lIHRoYXQgYSB0b2tlbiB3YXMgY2FjaGVkIGF0LCB3ZSBtdXN0IGRpc2NhcmQgdGhlIHRva2VuXHJcbiAqIGkuZS4gVGhlIHN5c3RlbSBjbG9jayB3YXMgdHVybmVkIGJhY2sgYWZ0ZXIgYWNxdWlyaW5nIHRoZSBjYWNoZWQgdG9rZW5cclxuICogQHBhcmFtIGNhY2hlZEF0XHJcbiAqIEBwYXJhbSBvZmZzZXRcclxuICovXHJcbmZ1bmN0aW9uIHdhc0Nsb2NrVHVybmVkQmFjayhjYWNoZWRBdCkge1xyXG4gICAgY29uc3QgY2FjaGVkQXRTZWMgPSBOdW1iZXIoY2FjaGVkQXQpO1xyXG4gICAgcmV0dXJuIGNhY2hlZEF0U2VjID4gbm93U2Vjb25kcygpO1xyXG59XHJcbi8qKlxyXG4gKiBXYWl0cyBmb3IgdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXHJcbiAqIEBwYXJhbSB0IG51bWJlclxyXG4gKiBAcGFyYW0gdmFsdWUgVFxyXG4gKi9cclxuZnVuY3Rpb24gZGVsYXkodCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHZhbHVlKSwgdCkpO1xyXG59XG5cbmV4cG9ydCB7IGRlbGF5LCBpc1Rva2VuRXhwaXJlZCwgbm93U2Vjb25kcywgdG9EYXRlRnJvbVNlY29uZHMsIHRvU2Vjb25kc0Zyb21EYXRlLCB3YXNDbG9ja1R1cm5lZEJhY2sgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVVdGlscy5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgZXh0cmFjdFRva2VuQ2xhaW1zIH0gZnJvbSAnLi4vLi4vYWNjb3VudC9BdXRoVG9rZW4ubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgU2VwYXJhdG9ycywgQ3JlZGVudGlhbFR5cGUsIEF1dGhlbnRpY2F0aW9uU2NoZW1lLCBTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLCBUaHJvdHRsaW5nQ29uc3RhbnRzLCBBUFBfTUVUQURBVEEsIEFVVEhPUklUWV9NRVRBREFUQV9DT05TVEFOVFMgfSBmcm9tICcuLi8uLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IG5vd1NlY29uZHMgfSBmcm9tICcuLi8uLi91dGlscy9UaW1lVXRpbHMubWpzJztcbmltcG9ydCB7IHRva2VuQ2xhaW1zQ25mUmVxdWlyZWRGb3JTaWduZWRKd3QgfSBmcm9tICcuLi8uLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENhY2hlIEtleTogPGhvbWVfYWNjb3VudF9pZD4tPGVudmlyb25tZW50Pi08Y3JlZGVudGlhbF90eXBlPi08Y2xpZW50X2lkIG9yIGZhbWlseUlkPi08cmVhbG0+LTxzY29wZXM+LTxjbGFpbXMgaGFzaD4tPHNjaGVtZT5cclxuICogSWRUb2tlbiBFeGFtcGxlOiB1aWQudXRpZC1sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tLWlkdG9rZW4tYXBwX2NsaWVudF9pZC1jb250b3NvLmNvbVxyXG4gKiBBY2Nlc3NUb2tlbiBFeGFtcGxlOiB1aWQudXRpZC1sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tLWFjY2Vzc3Rva2VuLWFwcF9jbGllbnRfaWQtY29udG9zby5jb20tc2NvcGUxIHNjb3BlMi0tcG9wXHJcbiAqIFJlZnJlc2hUb2tlbiBFeGFtcGxlOiB1aWQudXRpZC1sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tLXJlZnJlc2h0b2tlbi0xLWNvbnRvc28uY29tXHJcbiAqIEBwYXJhbSBjcmVkZW50aWFsRW50aXR5XHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNyZWRlbnRpYWxLZXkoY3JlZGVudGlhbEVudGl0eSkge1xyXG4gICAgY29uc3QgY3JlZGVudGlhbEtleSA9IFtcclxuICAgICAgICBnZW5lcmF0ZUFjY291bnRJZChjcmVkZW50aWFsRW50aXR5KSxcclxuICAgICAgICBnZW5lcmF0ZUNyZWRlbnRpYWxJZChjcmVkZW50aWFsRW50aXR5KSxcclxuICAgICAgICBnZW5lcmF0ZVRhcmdldChjcmVkZW50aWFsRW50aXR5KSxcclxuICAgICAgICBnZW5lcmF0ZUNsYWltc0hhc2goY3JlZGVudGlhbEVudGl0eSksXHJcbiAgICAgICAgZ2VuZXJhdGVTY2hlbWUoY3JlZGVudGlhbEVudGl0eSksXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGNyZWRlbnRpYWxLZXkuam9pbihTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1IpLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBJZFRva2VuRW50aXR5XHJcbiAqIEBwYXJhbSBob21lQWNjb3VudElkXHJcbiAqIEBwYXJhbSBhdXRoZW50aWNhdGlvblJlc3VsdFxyXG4gKiBAcGFyYW0gY2xpZW50SWRcclxuICogQHBhcmFtIGF1dGhvcml0eVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlSWRUb2tlbkVudGl0eShob21lQWNjb3VudElkLCBlbnZpcm9ubWVudCwgaWRUb2tlbiwgY2xpZW50SWQsIHRlbmFudElkKSB7XHJcbiAgICBjb25zdCBpZFRva2VuRW50aXR5ID0ge1xyXG4gICAgICAgIGNyZWRlbnRpYWxUeXBlOiBDcmVkZW50aWFsVHlwZS5JRF9UT0tFTixcclxuICAgICAgICBob21lQWNjb3VudElkOiBob21lQWNjb3VudElkLFxyXG4gICAgICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcclxuICAgICAgICBjbGllbnRJZDogY2xpZW50SWQsXHJcbiAgICAgICAgc2VjcmV0OiBpZFRva2VuLFxyXG4gICAgICAgIHJlYWxtOiB0ZW5hbnRJZCxcclxuICAgIH07XHJcbiAgICByZXR1cm4gaWRUb2tlbkVudGl0eTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIEFjY2Vzc1Rva2VuRW50aXR5XHJcbiAqIEBwYXJhbSBob21lQWNjb3VudElkXHJcbiAqIEBwYXJhbSBlbnZpcm9ubWVudFxyXG4gKiBAcGFyYW0gYWNjZXNzVG9rZW5cclxuICogQHBhcmFtIGNsaWVudElkXHJcbiAqIEBwYXJhbSB0ZW5hbnRJZFxyXG4gKiBAcGFyYW0gc2NvcGVzXHJcbiAqIEBwYXJhbSBleHBpcmVzT25cclxuICogQHBhcmFtIGV4dEV4cGlyZXNPblxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQWNjZXNzVG9rZW5FbnRpdHkoaG9tZUFjY291bnRJZCwgZW52aXJvbm1lbnQsIGFjY2Vzc1Rva2VuLCBjbGllbnRJZCwgdGVuYW50SWQsIHNjb3BlcywgZXhwaXJlc09uLCBleHRFeHBpcmVzT24sIGJhc2U2NERlY29kZSwgcmVmcmVzaE9uLCB0b2tlblR5cGUsIHVzZXJBc3NlcnRpb25IYXNoLCBrZXlJZCwgcmVxdWVzdGVkQ2xhaW1zLCByZXF1ZXN0ZWRDbGFpbXNIYXNoKSB7XHJcbiAgICBjb25zdCBhdEVudGl0eSA9IHtcclxuICAgICAgICBob21lQWNjb3VudElkOiBob21lQWNjb3VudElkLFxyXG4gICAgICAgIGNyZWRlbnRpYWxUeXBlOiBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU4sXHJcbiAgICAgICAgc2VjcmV0OiBhY2Nlc3NUb2tlbixcclxuICAgICAgICBjYWNoZWRBdDogbm93U2Vjb25kcygpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgZXhwaXJlc09uOiBleHBpcmVzT24udG9TdHJpbmcoKSxcclxuICAgICAgICBleHRlbmRlZEV4cGlyZXNPbjogZXh0RXhwaXJlc09uLnRvU3RyaW5nKCksXHJcbiAgICAgICAgZW52aXJvbm1lbnQ6IGVudmlyb25tZW50LFxyXG4gICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcclxuICAgICAgICByZWFsbTogdGVuYW50SWQsXHJcbiAgICAgICAgdGFyZ2V0OiBzY29wZXMsXHJcbiAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGUgfHwgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSLFxyXG4gICAgfTtcclxuICAgIGlmICh1c2VyQXNzZXJ0aW9uSGFzaCkge1xyXG4gICAgICAgIGF0RW50aXR5LnVzZXJBc3NlcnRpb25IYXNoID0gdXNlckFzc2VydGlvbkhhc2g7XHJcbiAgICB9XHJcbiAgICBpZiAocmVmcmVzaE9uKSB7XHJcbiAgICAgICAgYXRFbnRpdHkucmVmcmVzaE9uID0gcmVmcmVzaE9uLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdGVkQ2xhaW1zKSB7XHJcbiAgICAgICAgYXRFbnRpdHkucmVxdWVzdGVkQ2xhaW1zID0gcmVxdWVzdGVkQ2xhaW1zO1xyXG4gICAgICAgIGF0RW50aXR5LnJlcXVlc3RlZENsYWltc0hhc2ggPSByZXF1ZXN0ZWRDbGFpbXNIYXNoO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAqIENyZWF0ZSBBY2Nlc3MgVG9rZW4gV2l0aCBBdXRoIFNjaGVtZSBpbnN0ZWFkIG9mIHJlZ3VsYXIgYWNjZXNzIHRva2VuXHJcbiAgICAgKiBDYXN0IHRvIGxvd2VyIHRvIGhhbmRsZSBcImJlYXJlclwiIGZyb20gQURGU1xyXG4gICAgICovXHJcbiAgICBpZiAoYXRFbnRpdHkudG9rZW5UeXBlPy50b0xvd2VyQ2FzZSgpICE9PVxyXG4gICAgICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUi50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgYXRFbnRpdHkuY3JlZGVudGlhbFR5cGUgPSBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRTtcclxuICAgICAgICBzd2l0Y2ggKGF0RW50aXR5LnRva2VuVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEF1dGhlbnRpY2F0aW9uU2NoZW1lLlBPUDpcclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBrZXlJZCBpcyBwcmVzZW50IGFuZCBhZGQgaXQgdG8gY3JlZGVudGlhbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5DbGFpbXMgPSBleHRyYWN0VG9rZW5DbGFpbXMoYWNjZXNzVG9rZW4sIGJhc2U2NERlY29kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuQ2xhaW1zPy5jbmY/LmtpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcih0b2tlbkNsYWltc0NuZlJlcXVpcmVkRm9yU2lnbmVkSnd0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGF0RW50aXR5LmtleUlkID0gdG9rZW5DbGFpbXMuY25mLmtpZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEF1dGhlbnRpY2F0aW9uU2NoZW1lLlNTSDpcclxuICAgICAgICAgICAgICAgIGF0RW50aXR5LmtleUlkID0ga2V5SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF0RW50aXR5O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgUmVmcmVzaFRva2VuRW50aXR5XHJcbiAqIEBwYXJhbSBob21lQWNjb3VudElkXHJcbiAqIEBwYXJhbSBhdXRoZW50aWNhdGlvblJlc3VsdFxyXG4gKiBAcGFyYW0gY2xpZW50SWRcclxuICogQHBhcmFtIGF1dGhvcml0eVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVmcmVzaFRva2VuRW50aXR5KGhvbWVBY2NvdW50SWQsIGVudmlyb25tZW50LCByZWZyZXNoVG9rZW4sIGNsaWVudElkLCBmYW1pbHlJZCwgdXNlckFzc2VydGlvbkhhc2gsIGV4cGlyZXNPbikge1xyXG4gICAgY29uc3QgcnRFbnRpdHkgPSB7XHJcbiAgICAgICAgY3JlZGVudGlhbFR5cGU6IENyZWRlbnRpYWxUeXBlLlJFRlJFU0hfVE9LRU4sXHJcbiAgICAgICAgaG9tZUFjY291bnRJZDogaG9tZUFjY291bnRJZCxcclxuICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXHJcbiAgICAgICAgY2xpZW50SWQ6IGNsaWVudElkLFxyXG4gICAgICAgIHNlY3JldDogcmVmcmVzaFRva2VuLFxyXG4gICAgfTtcclxuICAgIGlmICh1c2VyQXNzZXJ0aW9uSGFzaCkge1xyXG4gICAgICAgIHJ0RW50aXR5LnVzZXJBc3NlcnRpb25IYXNoID0gdXNlckFzc2VydGlvbkhhc2g7XHJcbiAgICB9XHJcbiAgICBpZiAoZmFtaWx5SWQpIHtcclxuICAgICAgICBydEVudGl0eS5mYW1pbHlJZCA9IGZhbWlseUlkO1xyXG4gICAgfVxyXG4gICAgaWYgKGV4cGlyZXNPbikge1xyXG4gICAgICAgIHJ0RW50aXR5LmV4cGlyZXNPbiA9IGV4cGlyZXNPbi50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJ0RW50aXR5O1xyXG59XHJcbmZ1bmN0aW9uIGlzQ3JlZGVudGlhbEVudGl0eShlbnRpdHkpIHtcclxuICAgIHJldHVybiAoZW50aXR5Lmhhc093blByb3BlcnR5KFwiaG9tZUFjY291bnRJZFwiKSAmJlxyXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImVudmlyb25tZW50XCIpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiY3JlZGVudGlhbFR5cGVcIikgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJjbGllbnRJZFwiKSAmJlxyXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInNlY3JldFwiKSk7XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhbiBlbnRpdHk6IGNoZWNrcyBmb3IgYWxsIGV4cGVjdGVkIHBhcmFtc1xyXG4gKiBAcGFyYW0gZW50aXR5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FjY2Vzc1Rva2VuRW50aXR5KGVudGl0eSkge1xyXG4gICAgaWYgKCFlbnRpdHkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGlzQ3JlZGVudGlhbEVudGl0eShlbnRpdHkpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwicmVhbG1cIikgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJ0YXJnZXRcIikgJiZcclxuICAgICAgICAoZW50aXR5W1wiY3JlZGVudGlhbFR5cGVcIl0gPT09IENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTiB8fFxyXG4gICAgICAgICAgICBlbnRpdHlbXCJjcmVkZW50aWFsVHlwZVwiXSA9PT1cclxuICAgICAgICAgICAgICAgIENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTl9XSVRIX0FVVEhfU0NIRU1FKSk7XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhbiBlbnRpdHk6IGNoZWNrcyBmb3IgYWxsIGV4cGVjdGVkIHBhcmFtc1xyXG4gKiBAcGFyYW0gZW50aXR5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0lkVG9rZW5FbnRpdHkoZW50aXR5KSB7XHJcbiAgICBpZiAoIWVudGl0eSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoaXNDcmVkZW50aWFsRW50aXR5KGVudGl0eSkgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJyZWFsbVwiKSAmJlxyXG4gICAgICAgIGVudGl0eVtcImNyZWRlbnRpYWxUeXBlXCJdID09PSBDcmVkZW50aWFsVHlwZS5JRF9UT0tFTik7XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhbiBlbnRpdHk6IGNoZWNrcyBmb3IgYWxsIGV4cGVjdGVkIHBhcmFtc1xyXG4gKiBAcGFyYW0gZW50aXR5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlZnJlc2hUb2tlbkVudGl0eShlbnRpdHkpIHtcclxuICAgIGlmICghZW50aXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChpc0NyZWRlbnRpYWxFbnRpdHkoZW50aXR5KSAmJlxyXG4gICAgICAgIGVudGl0eVtcImNyZWRlbnRpYWxUeXBlXCJdID09PSBDcmVkZW50aWFsVHlwZS5SRUZSRVNIX1RPS0VOKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgQWNjb3VudCBJZCBrZXkgY29tcG9uZW50IGFzIHBlciB0aGUgc2NoZW1hOiA8aG9tZV9hY2NvdW50X2lkPi08ZW52aXJvbm1lbnQ+XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUFjY291bnRJZChjcmVkZW50aWFsRW50aXR5KSB7XHJcbiAgICBjb25zdCBhY2NvdW50SWQgPSBbXHJcbiAgICAgICAgY3JlZGVudGlhbEVudGl0eS5ob21lQWNjb3VudElkLFxyXG4gICAgICAgIGNyZWRlbnRpYWxFbnRpdHkuZW52aXJvbm1lbnQsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGFjY291bnRJZC5qb2luKFNlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUikudG9Mb3dlckNhc2UoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgQ3JlZGVudGlhbCBJZCBrZXkgY29tcG9uZW50IGFzIHBlciB0aGUgc2NoZW1hOiA8Y3JlZGVudGlhbF90eXBlPi08Y2xpZW50X2lkPi08cmVhbG0+XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNyZWRlbnRpYWxJZChjcmVkZW50aWFsRW50aXR5KSB7XHJcbiAgICBjb25zdCBjbGllbnRPckZhbWlseUlkID0gY3JlZGVudGlhbEVudGl0eS5jcmVkZW50aWFsVHlwZSA9PT0gQ3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTlxyXG4gICAgICAgID8gY3JlZGVudGlhbEVudGl0eS5mYW1pbHlJZCB8fCBjcmVkZW50aWFsRW50aXR5LmNsaWVudElkXHJcbiAgICAgICAgOiBjcmVkZW50aWFsRW50aXR5LmNsaWVudElkO1xyXG4gICAgY29uc3QgY3JlZGVudGlhbElkID0gW1xyXG4gICAgICAgIGNyZWRlbnRpYWxFbnRpdHkuY3JlZGVudGlhbFR5cGUsXHJcbiAgICAgICAgY2xpZW50T3JGYW1pbHlJZCxcclxuICAgICAgICBjcmVkZW50aWFsRW50aXR5LnJlYWxtIHx8IFwiXCIsXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGNyZWRlbnRpYWxJZC5qb2luKFNlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUikudG9Mb3dlckNhc2UoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgdGFyZ2V0IGtleSBjb21wb25lbnQgYXMgcGVyIHNjaGVtYTogPHRhcmdldD5cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlVGFyZ2V0KGNyZWRlbnRpYWxFbnRpdHkpIHtcclxuICAgIHJldHVybiAoY3JlZGVudGlhbEVudGl0eS50YXJnZXQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgcmVxdWVzdGVkIGNsYWltcyBrZXkgY29tcG9uZW50IGFzIHBlciBzY2hlbWE6IDxyZXF1ZXN0ZWRDbGFpbXM+XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNsYWltc0hhc2goY3JlZGVudGlhbEVudGl0eSkge1xyXG4gICAgcmV0dXJuIChjcmVkZW50aWFsRW50aXR5LnJlcXVlc3RlZENsYWltc0hhc2ggfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgc2NoZW1lIGtleSBjb21wb25lbmV0IGFzIHBlciBzY2hlbWE6IDxzY2hlbWU+XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVNjaGVtZShjcmVkZW50aWFsRW50aXR5KSB7XHJcbiAgICAvKlxyXG4gICAgICogUG9QIFRva2VucyBhbmQgU1NIIGNlcnRzIGluY2x1ZGUgc2NoZW1lIGluIGNhY2hlIGtleVxyXG4gICAgICogQ2FzdCB0byBsb3dlcmNhc2UgdG8gaGFuZGxlIFwiYmVhcmVyXCIgZnJvbSBBREZTXHJcbiAgICAgKi9cclxuICAgIHJldHVybiBjcmVkZW50aWFsRW50aXR5LnRva2VuVHlwZSAmJlxyXG4gICAgICAgIGNyZWRlbnRpYWxFbnRpdHkudG9rZW5UeXBlLnRvTG93ZXJDYXNlKCkgIT09XHJcbiAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUi50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgPyBjcmVkZW50aWFsRW50aXR5LnRva2VuVHlwZS50b0xvd2VyQ2FzZSgpXHJcbiAgICAgICAgOiBcIlwiO1xyXG59XHJcbi8qKlxyXG4gKiB2YWxpZGF0ZXMgaWYgYSBnaXZlbiBjYWNoZSBlbnRyeSBpcyBcIlRlbGVtZXRyeVwiLCBwYXJzZXMgPGtleSx2YWx1ZT5cclxuICogQHBhcmFtIGtleVxyXG4gKiBAcGFyYW0gZW50aXR5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1NlcnZlclRlbGVtZXRyeUVudGl0eShrZXksIGVudGl0eSkge1xyXG4gICAgY29uc3QgdmFsaWRhdGVLZXkgPSBrZXkuaW5kZXhPZihTRVJWRVJfVEVMRU1fQ09OU1RBTlRTLkNBQ0hFX0tFWSkgPT09IDA7XHJcbiAgICBsZXQgdmFsaWRhdGVFbnRpdHkgPSB0cnVlO1xyXG4gICAgaWYgKGVudGl0eSkge1xyXG4gICAgICAgIHZhbGlkYXRlRW50aXR5ID1cclxuICAgICAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiZmFpbGVkUmVxdWVzdHNcIikgJiZcclxuICAgICAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImVycm9yc1wiKSAmJlxyXG4gICAgICAgICAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiY2FjaGVIaXRzXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkYXRlS2V5ICYmIHZhbGlkYXRlRW50aXR5O1xyXG59XHJcbi8qKlxyXG4gKiB2YWxpZGF0ZXMgaWYgYSBnaXZlbiBjYWNoZSBlbnRyeSBpcyBcIlRocm90dGxpbmdcIiwgcGFyc2VzIDxrZXksdmFsdWU+XHJcbiAqIEBwYXJhbSBrZXlcclxuICogQHBhcmFtIGVudGl0eVxyXG4gKi9cclxuZnVuY3Rpb24gaXNUaHJvdHRsaW5nRW50aXR5KGtleSwgZW50aXR5KSB7XHJcbiAgICBsZXQgdmFsaWRhdGVLZXkgPSBmYWxzZTtcclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgICB2YWxpZGF0ZUtleSA9IGtleS5pbmRleE9mKFRocm90dGxpbmdDb25zdGFudHMuVEhST1RUTElOR19QUkVGSVgpID09PSAwO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbGlkYXRlRW50aXR5ID0gdHJ1ZTtcclxuICAgIGlmIChlbnRpdHkpIHtcclxuICAgICAgICB2YWxpZGF0ZUVudGl0eSA9IGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInRocm90dGxlVGltZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWxpZGF0ZUtleSAmJiB2YWxpZGF0ZUVudGl0eTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgQXBwTWV0YWRhdGEgQ2FjaGUgS2V5IGFzIHBlciB0aGUgc2NoZW1hOiBhcHBtZXRhZGF0YS08ZW52aXJvbm1lbnQ+LTxjbGllbnRfaWQ+XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUFwcE1ldGFkYXRhS2V5KHsgZW52aXJvbm1lbnQsIGNsaWVudElkLCB9KSB7XHJcbiAgICBjb25zdCBhcHBNZXRhRGF0YUtleUFycmF5ID0gW1xyXG4gICAgICAgIEFQUF9NRVRBREFUQSxcclxuICAgICAgICBlbnZpcm9ubWVudCxcclxuICAgICAgICBjbGllbnRJZCxcclxuICAgIF07XHJcbiAgICByZXR1cm4gYXBwTWV0YURhdGFLZXlBcnJheVxyXG4gICAgICAgIC5qb2luKFNlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUilcclxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcclxufVxyXG4vKlxyXG4gKiBWYWxpZGF0ZXMgYW4gZW50aXR5OiBjaGVja3MgZm9yIGFsbCBleHBlY3RlZCBwYXJhbXNcclxuICogQHBhcmFtIGVudGl0eVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcHBNZXRhZGF0YUVudGl0eShrZXksIGVudGl0eSkge1xyXG4gICAgaWYgKCFlbnRpdHkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGtleS5pbmRleE9mKEFQUF9NRVRBREFUQSkgPT09IDAgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJjbGllbnRJZFwiKSAmJlxyXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImVudmlyb25tZW50XCIpKTtcclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIGFuIGVudGl0eTogY2hlY2tzIGZvciBhbGwgZXhwZWN0ZWQgcGFyYW1zXHJcbiAqIEBwYXJhbSBlbnRpdHlcclxuICovXHJcbmZ1bmN0aW9uIGlzQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkoa2V5LCBlbnRpdHkpIHtcclxuICAgIGlmICghZW50aXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChrZXkuaW5kZXhPZihBVVRIT1JJVFlfTUVUQURBVEFfQ09OU1RBTlRTLkNBQ0hFX0tFWSkgPT09IDAgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJhbGlhc2VzXCIpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwicHJlZmVycmVkX2NhY2hlXCIpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwicHJlZmVycmVkX25ldHdvcmtcIikgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJjYW5vbmljYWxfYXV0aG9yaXR5XCIpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiYXV0aG9yaXphdGlvbl9lbmRwb2ludFwiKSAmJlxyXG4gICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInRva2VuX2VuZHBvaW50XCIpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiaXNzdWVyXCIpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiYWxpYXNlc0Zyb21OZXR3b3JrXCIpICYmXHJcbiAgICAgICAgZW50aXR5Lmhhc093blByb3BlcnR5KFwiZW5kcG9pbnRzRnJvbU5ldHdvcmtcIikgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJleHBpcmVzQXRcIikgJiZcclxuICAgICAgICBlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJqd2tzX3VyaVwiKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlc2V0IHRoZSBleGlyZXNBdCB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVBdXRob3JpdHlNZXRhZGF0YUV4cGlyZXNBdCgpIHtcclxuICAgIHJldHVybiAobm93U2Vjb25kcygpICtcclxuICAgICAgICBBVVRIT1JJVFlfTUVUQURBVEFfQ09OU1RBTlRTLlJFRlJFU0hfVElNRV9TRUNPTkRTKTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVBdXRob3JpdHlFbmRwb2ludE1ldGFkYXRhKGF1dGhvcml0eU1ldGFkYXRhLCB1cGRhdGVkVmFsdWVzLCBmcm9tTmV0d29yaykge1xyXG4gICAgYXV0aG9yaXR5TWV0YWRhdGEuYXV0aG9yaXphdGlvbl9lbmRwb2ludCA9XHJcbiAgICAgICAgdXBkYXRlZFZhbHVlcy5hdXRob3JpemF0aW9uX2VuZHBvaW50O1xyXG4gICAgYXV0aG9yaXR5TWV0YWRhdGEudG9rZW5fZW5kcG9pbnQgPSB1cGRhdGVkVmFsdWVzLnRva2VuX2VuZHBvaW50O1xyXG4gICAgYXV0aG9yaXR5TWV0YWRhdGEuZW5kX3Nlc3Npb25fZW5kcG9pbnQgPSB1cGRhdGVkVmFsdWVzLmVuZF9zZXNzaW9uX2VuZHBvaW50O1xyXG4gICAgYXV0aG9yaXR5TWV0YWRhdGEuaXNzdWVyID0gdXBkYXRlZFZhbHVlcy5pc3N1ZXI7XHJcbiAgICBhdXRob3JpdHlNZXRhZGF0YS5lbmRwb2ludHNGcm9tTmV0d29yayA9IGZyb21OZXR3b3JrO1xyXG4gICAgYXV0aG9yaXR5TWV0YWRhdGEuandrc191cmkgPSB1cGRhdGVkVmFsdWVzLmp3a3NfdXJpO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEoYXV0aG9yaXR5TWV0YWRhdGEsIHVwZGF0ZWRWYWx1ZXMsIGZyb21OZXR3b3JrKSB7XHJcbiAgICBhdXRob3JpdHlNZXRhZGF0YS5hbGlhc2VzID0gdXBkYXRlZFZhbHVlcy5hbGlhc2VzO1xyXG4gICAgYXV0aG9yaXR5TWV0YWRhdGEucHJlZmVycmVkX2NhY2hlID0gdXBkYXRlZFZhbHVlcy5wcmVmZXJyZWRfY2FjaGU7XHJcbiAgICBhdXRob3JpdHlNZXRhZGF0YS5wcmVmZXJyZWRfbmV0d29yayA9IHVwZGF0ZWRWYWx1ZXMucHJlZmVycmVkX25ldHdvcms7XHJcbiAgICBhdXRob3JpdHlNZXRhZGF0YS5hbGlhc2VzRnJvbU5ldHdvcmsgPSBmcm9tTmV0d29yaztcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZGF0YSBuZWVkcyB0byBiZSByZWZyZXNoZWRcclxuICovXHJcbmZ1bmN0aW9uIGlzQXV0aG9yaXR5TWV0YWRhdGFFeHBpcmVkKG1ldGFkYXRhKSB7XHJcbiAgICByZXR1cm4gbWV0YWRhdGEuZXhwaXJlc0F0IDw9IG5vd1NlY29uZHMoKTtcclxufVxuXG5leHBvcnQgeyBjcmVhdGVBY2Nlc3NUb2tlbkVudGl0eSwgY3JlYXRlSWRUb2tlbkVudGl0eSwgY3JlYXRlUmVmcmVzaFRva2VuRW50aXR5LCBnZW5lcmF0ZUFwcE1ldGFkYXRhS2V5LCBnZW5lcmF0ZUF1dGhvcml0eU1ldGFkYXRhRXhwaXJlc0F0LCBnZW5lcmF0ZUNyZWRlbnRpYWxLZXksIGlzQWNjZXNzVG9rZW5FbnRpdHksIGlzQXBwTWV0YWRhdGFFbnRpdHksIGlzQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHksIGlzQXV0aG9yaXR5TWV0YWRhdGFFeHBpcmVkLCBpc0NyZWRlbnRpYWxFbnRpdHksIGlzSWRUb2tlbkVudGl0eSwgaXNSZWZyZXNoVG9rZW5FbnRpdHksIGlzU2VydmVyVGVsZW1ldHJ5RW50aXR5LCBpc1Rocm90dGxpbmdFbnRpdHksIHVwZGF0ZUF1dGhvcml0eUVuZHBvaW50TWV0YWRhdGEsIHVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlSGVscGVycy5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQXV0aG9yaXR5VHlwZSB9IGZyb20gJy4vQXV0aG9yaXR5VHlwZS5tanMnO1xuaW1wb3J0IHsgaXNPcGVuSWRDb25maWdSZXNwb25zZSB9IGZyb20gJy4vT3BlbklkQ29uZmlnUmVzcG9uc2UubWpzJztcbmltcG9ydCB7IFVybFN0cmluZyB9IGZyb20gJy4uL3VybC9VcmxTdHJpbmcubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZSwgUmVnaW9uRGlzY292ZXJ5T3V0Y29tZXMsIEFBREF1dGhvcml0eUNvbnN0YW50cyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgRW5kcG9pbnRNZXRhZGF0YSwgZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXMsIGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29ya1Jlc3BvbnNlLCBJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhQWxpYXNlcyB9IGZyb20gJy4vQXV0aG9yaXR5TWV0YWRhdGEubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvci5tanMnO1xuaW1wb3J0IHsgUHJvdG9jb2xNb2RlIH0gZnJvbSAnLi9Qcm90b2NvbE1vZGUubWpzJztcbmltcG9ydCB7IEF6dXJlQ2xvdWRJbnN0YW5jZSB9IGZyb20gJy4vQXV0aG9yaXR5T3B0aW9ucy5tanMnO1xuaW1wb3J0IHsgaXNDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2UgfSBmcm9tICcuL0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlSZXNwb25zZS5tanMnO1xuaW1wb3J0IHsgaXNDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZSB9IGZyb20gJy4vQ2xvdWRJbnN0YW5jZURpc2NvdmVyeUVycm9yUmVzcG9uc2UubWpzJztcbmltcG9ydCB7IFJlZ2lvbkRpc2NvdmVyeSB9IGZyb20gJy4vUmVnaW9uRGlzY292ZXJ5Lm1qcyc7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9BdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IFBlcmZvcm1hbmNlRXZlbnRzIH0gZnJvbSAnLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL1BlcmZvcm1hbmNlRXZlbnQubWpzJztcbmltcG9ydCB7IGludm9rZUFzeW5jIH0gZnJvbSAnLi4vdXRpbHMvRnVuY3Rpb25XcmFwcGVycy5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVBdXRob3JpdHlNZXRhZGF0YUV4cGlyZXNBdCwgdXBkYXRlQXV0aG9yaXR5RW5kcG9pbnRNZXRhZGF0YSwgaXNBdXRob3JpdHlNZXRhZGF0YUV4cGlyZWQsIHVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEgfSBmcm9tICcuLi9jYWNoZS91dGlscy9DYWNoZUhlbHBlcnMubWpzJztcbmltcG9ydCB7IGVuZHBvaW50UmVzb2x1dGlvbkVycm9yLCBlbmRTZXNzaW9uRW5kcG9pbnROb3RTdXBwb3J0ZWQsIG9wZW5JZENvbmZpZ0Vycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yQ29kZXMubWpzJztcbmltcG9ydCB7IGludmFsaWRBdXRob3JpdHlNZXRhZGF0YSwgdW50cnVzdGVkQXV0aG9yaXR5LCBpbnZhbGlkQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGF1dGhvcml0eSBjbGFzcyB2YWxpZGF0ZXMgdGhlIGF1dGhvcml0eSBVUklzIHVzZWQgYnkgdGhlIHVzZXIsIGFuZCByZXRyaWV2ZXMgdGhlIE9wZW5JRCBDb25maWd1cmF0aW9uIERhdGEgZnJvbSB0aGVcclxuICogZW5kcG9pbnQuIEl0IHdpbGwgc3RvcmUgdGhlIHBlcnRpbmVudCBjb25maWcgZGF0YSBpbiB0aGlzIG9iamVjdCBmb3IgdXNlIGR1cmluZyB0b2tlbiBjYWxscy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBBdXRob3JpdHkge1xyXG4gICAgY29uc3RydWN0b3IoYXV0aG9yaXR5LCBuZXR3b3JrSW50ZXJmYWNlLCBjYWNoZU1hbmFnZXIsIGF1dGhvcml0eU9wdGlvbnMsIGxvZ2dlciwgY29ycmVsYXRpb25JZCwgcGVyZm9ybWFuY2VDbGllbnQsIG1hbmFnZWRJZGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5ID0gYXV0aG9yaXR5O1xyXG4gICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eS52YWxpZGF0ZUFzVXJpKCk7XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrSW50ZXJmYWNlID0gbmV0d29ya0ludGVyZmFjZTtcclxuICAgICAgICB0aGlzLmNhY2hlTWFuYWdlciA9IGNhY2hlTWFuYWdlcjtcclxuICAgICAgICB0aGlzLmF1dGhvcml0eU9wdGlvbnMgPSBhdXRob3JpdHlPcHRpb25zO1xyXG4gICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEgPSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbl91c2VkOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHJlZ2lvbl9zb3VyY2U6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcmVnaW9uX291dGNvbWU6IHVuZGVmaW5lZCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQgPSBwZXJmb3JtYW5jZUNsaWVudDtcclxuICAgICAgICB0aGlzLmNvcnJlbGF0aW9uSWQgPSBjb3JyZWxhdGlvbklkO1xyXG4gICAgICAgIHRoaXMubWFuYWdlZElkZW50aXR5ID0gbWFuYWdlZElkZW50aXR5IHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5ID0gbmV3IFJlZ2lvbkRpc2NvdmVyeShuZXR3b3JrSW50ZXJmYWNlLCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgdGhpcy5jb3JyZWxhdGlvbklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHtAbGluayBBdXRob3JpdHlUeXBlfVxyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVVyaSB7QGxpbmsgSVVyaX1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEF1dGhvcml0eVR5cGUoYXV0aG9yaXR5VXJpKSB7XHJcbiAgICAgICAgLy8gQ0lBTSBhdXRoIHVybCBwYXR0ZXJuIGlzIGJlaW5nIHN0YW5kYXJkaXplZCBhczogPHRlbmFudD4uY2lhbWxvZ2luLmNvbVxyXG4gICAgICAgIGlmIChhdXRob3JpdHlVcmkuSG9zdE5hbWVBbmRQb3J0LmVuZHNXaXRoKENvbnN0YW50cy5DSUFNX0FVVEhfVVJMKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5VHlwZS5DaWFtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXRoU2VnbWVudHMgPSBhdXRob3JpdHlVcmkuUGF0aFNlZ21lbnRzO1xyXG4gICAgICAgIGlmIChwYXRoU2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocGF0aFNlZ21lbnRzWzBdLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLkFERlM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eVR5cGUuQWRmcztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLkRTVFM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eVR5cGUuRHN0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQXV0aG9yaXR5VHlwZS5EZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgLy8gU2VlIGFib3ZlIGZvciBBdXRob3JpdHlUeXBlXHJcbiAgICBnZXQgYXV0aG9yaXR5VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdXRob3JpdHlUeXBlKHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb3RvY29sTW9kZSBlbnVtIHJlcHJlc2VudGluZyB0aGUgd2F5IGVuZHBvaW50cyBhcmUgY29uc3RydWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcm90b2NvbE1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5wcm90b2NvbE1vZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYXV0aG9yaXR5T3B0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCB0byByZWluc3RhbnRpYXRlIGEgbmV3IGF1dGhvcml0eSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpdHlPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIFVSTCB0aGF0IGlzIHRoZSBhdXRob3JpdHkgc2V0IGJ5IHRoZSBkZXZlbG9wZXJcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbm9uaWNhbEF1dGhvcml0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2Fub25pY2FsQXV0aG9yaXR5LnVybFN0cmluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBjYW5vbmljYWwgYXV0aG9yaXR5LlxyXG4gICAgICovXHJcbiAgICBzZXQgY2Fub25pY2FsQXV0aG9yaXR5KHVybCkge1xyXG4gICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eSA9IG5ldyBVcmxTdHJpbmcodXJsKTtcclxuICAgICAgICB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHkudmFsaWRhdGVBc1VyaSgpO1xyXG4gICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYXV0aG9yaXR5IGNvbXBvbmVudHMuXHJcbiAgICAgKi9cclxuICAgIGdldCBjYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzID1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2Nhbm9uaWNhbEF1dGhvcml0eS5nZXRVcmxDb21wb25lbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5vbmljYWxBdXRob3JpdHlVcmxDb21wb25lbnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgaG9zdG5hbWUgYW5kIHBvcnQgaS5lLiBsb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tXHJcbiAgICAgKi9cclxuICAgIGdldCBob3N0bmFtZUFuZFBvcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cy5Ib3N0TmFtZUFuZFBvcnQudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRlbmFudCBmb3IgYXV0aG9yaXR5LlxyXG4gICAgICovXHJcbiAgICBnZXQgdGVuYW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzWzBdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPQXV0aCAvYXV0aG9yaXplIGVuZHBvaW50IGZvciByZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBnZXQgYXV0aG9yaXphdGlvbkVuZHBvaW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVBhdGgodGhpcy5tZXRhZGF0YS5hdXRob3JpemF0aW9uX2VuZHBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihlbmRwb2ludFJlc29sdXRpb25FcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPQXV0aCAvdG9rZW4gZW5kcG9pbnQgZm9yIHJlcXVlc3RzXHJcbiAgICAgKi9cclxuICAgIGdldCB0b2tlbkVuZHBvaW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVBhdGgodGhpcy5tZXRhZGF0YS50b2tlbl9lbmRwb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBkZXZpY2VDb2RlRW5kcG9pbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlUGF0aCh0aGlzLm1ldGFkYXRhLnRva2VuX2VuZHBvaW50LnJlcGxhY2UoXCIvdG9rZW5cIiwgXCIvZGV2aWNlY29kZVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT0F1dGggbG9nb3V0IGVuZHBvaW50IGZvciByZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBnZXQgZW5kU2Vzc2lvbkVuZHBvaW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgLy8gUk9QQyBwb2xpY2llcyBtYXkgbm90IGhhdmUgZW5kX3Nlc3Npb25fZW5kcG9pbnQgc2V0XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5tZXRhZGF0YS5lbmRfc2Vzc2lvbl9lbmRwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGVuZFNlc3Npb25FbmRwb2ludE5vdFN1cHBvcnRlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVBhdGgodGhpcy5tZXRhZGF0YS5lbmRfc2Vzc2lvbl9lbmRwb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoZW5kcG9pbnRSZXNvbHV0aW9uRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT0F1dGggaXNzdWVyIGZvciByZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBnZXQgc2VsZlNpZ25lZEp3dEF1ZGllbmNlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2NvdmVyeUNvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVBhdGgodGhpcy5tZXRhZGF0YS5pc3N1ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGVuZHBvaW50UmVzb2x1dGlvbkVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEp3a3NfdXJpIGZvciB0b2tlbiBzaWduaW5nIGtleXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGp3a3NVcmkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzY292ZXJ5Q29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlUGF0aCh0aGlzLm1ldGFkYXRhLmp3a3NfdXJpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihlbmRwb2ludFJlc29sdXRpb25FcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGVuYW50IG5hbWUgY2FuIGJlIHJlcGxhY2VkIGluIGF1dGhvcml0eSB7QGxpbmsgSVVyaX1cclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHlVcmkge0BsaW5rIElVcml9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjYW5SZXBsYWNlVGVuYW50KGF1dGhvcml0eVVyaSkge1xyXG4gICAgICAgIHJldHVybiAoYXV0aG9yaXR5VXJpLlBhdGhTZWdtZW50cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgIUF1dGhvcml0eS5yZXNlcnZlZFRlbmFudERvbWFpbnMuaGFzKGF1dGhvcml0eVVyaS5QYXRoU2VnbWVudHNbMF0pICYmXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QXV0aG9yaXR5VHlwZShhdXRob3JpdHlVcmkpID09PSBBdXRob3JpdHlUeXBlLkRlZmF1bHQgJiZcclxuICAgICAgICAgICAgdGhpcy5wcm90b2NvbE1vZGUgIT09IFByb3RvY29sTW9kZS5PSURDKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgdGVuYW50IGluIHVybCBwYXRoIHdpdGggY3VycmVudCB0ZW5hbnQuIERlZmF1bHRzIHRvIGNvbW1vbi5cclxuICAgICAqIEBwYXJhbSB1cmxTdHJpbmdcclxuICAgICAqL1xyXG4gICAgcmVwbGFjZVRlbmFudCh1cmxTdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gdXJsU3RyaW5nLnJlcGxhY2UoL3t0ZW5hbnR9fHt0ZW5hbnRpZH0vZywgdGhpcy50ZW5hbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyBwYXRoIHN1Y2ggYXMgdGVuYW50IG9yIHBvbGljeSB3aXRoIHRoZSBjdXJyZW50IHRlbmFudCBvciBwb2xpY3kuXHJcbiAgICAgKiBAcGFyYW0gdXJsU3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHJlcGxhY2VQYXRoKHVybFN0cmluZykge1xyXG4gICAgICAgIGxldCBlbmRwb2ludCA9IHVybFN0cmluZztcclxuICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpdHlVcmwgPSBuZXcgVXJsU3RyaW5nKHRoaXMubWV0YWRhdGEuY2Fub25pY2FsX2F1dGhvcml0eSk7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXR5VXJsQ29tcG9uZW50cyA9IGNhY2hlZEF1dGhvcml0eVVybC5nZXRVcmxDb21wb25lbnRzKCk7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXR5UGFydHMgPSBjYWNoZWRBdXRob3JpdHlVcmxDb21wb25lbnRzLlBhdGhTZWdtZW50cztcclxuICAgICAgICBjb25zdCBjdXJyZW50QXV0aG9yaXR5UGFydHMgPSB0aGlzLmNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzO1xyXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlQYXJ0cy5mb3JFYWNoKChjdXJyZW50UGFydCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNhY2hlZFBhcnQgPSBjYWNoZWRBdXRob3JpdHlQYXJ0c1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5SZXBsYWNlVGVuYW50KGNhY2hlZEF1dGhvcml0eVVybENvbXBvbmVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IG5ldyBVcmxTdHJpbmcodGhpcy5tZXRhZGF0YS5hdXRob3JpemF0aW9uX2VuZHBvaW50KS5nZXRVcmxDb21wb25lbnRzKCkuUGF0aFNlZ21lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVjayBpZiBBQUQgY2Fub25pY2FsIGF1dGhvcml0eSBjb250YWlucyB0ZW5hbnQgZG9tYWluIG5hbWUsIGZvciBleGFtcGxlIFwidGVzdGRvbWFpbi5vbm1pY3Jvc29mdC5jb21cIixcclxuICAgICAgICAgICAgICAgICAqIGJ5IGNvbXBhcmluZyBpdHMgZmlyc3QgcGF0aCBzZWdtZW50IHRvIHRoZSBjb3JyZXNwb25kaW5nIGF1dGhvcml6YXRpb24gZW5kcG9pbnQgcGF0aCBzZWdtZW50LCB3aGljaCBpc1xyXG4gICAgICAgICAgICAgICAgICogYWx3YXlzIHJlc29sdmVkIHdpdGggdGVuYW50IGlkIGJ5IE9JREMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRQYXJ0ICE9PSB0ZW5hbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoYFJlcGxhY2luZyB0ZW5hbnQgZG9tYWluIG5hbWUgJHtjYWNoZWRQYXJ0fSB3aXRoIGlkICR7dGVuYW50SWR9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkUGFydCA9IHRlbmFudElkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCAhPT0gY2FjaGVkUGFydCkge1xyXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBlbmRwb2ludC5yZXBsYWNlKGAvJHtjYWNoZWRQYXJ0fS9gLCBgLyR7Y3VycmVudFBhcnR9L2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVRlbmFudChlbmRwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IG9wZW4gaWQgY29uZmlndXJhdGlvbiBlbmRwb2ludCBmb3IgYW55IGNhbm9uaWNhbCBhdXRob3JpdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBkZWZhdWx0T3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50KCkge1xyXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbEF1dGhvcml0eUhvc3QgPSB0aGlzLmhvc3RuYW1lQW5kUG9ydDtcclxuICAgICAgICBpZiAodGhpcy5jYW5vbmljYWxBdXRob3JpdHkuZW5kc1dpdGgoXCJ2Mi4wL1wiKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eVR5cGUgPT09IEF1dGhvcml0eVR5cGUuQWRmcyB8fFxyXG4gICAgICAgICAgICAodGhpcy5wcm90b2NvbE1vZGUgPT09IFByb3RvY29sTW9kZS5PSURDICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0FsaWFzT2ZLbm93bk1pY3Jvc29mdEF1dGhvcml0eShjYW5vbmljYWxBdXRob3JpdHlIb3N0KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuY2Fub25pY2FsQXV0aG9yaXR5fS53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY2Fub25pY2FsQXV0aG9yaXR5fXYyLjAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCb29sZWFuIHRoYXQgcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0ZW5hbnQgZGlzY292ZXJ5IGhhcyBiZWVuIGNvbXBsZXRlZC5cclxuICAgICAqL1xyXG4gICAgZGlzY292ZXJ5Q29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5tZXRhZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybSBlbmRwb2ludCBkaXNjb3ZlcnkgdG8gZGlzY292ZXIgYWxpYXNlcywgcHJlZmVycmVkX2NhY2hlLCBwcmVmZXJyZWRfbmV0d29ya1xyXG4gICAgICogYW5kIHRoZSAvYXV0aG9yaXplLCAvdG9rZW4gYW5kIGxvZ291dCBlbmRwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlc29sdmVFbmRwb2ludHNBc3luYygpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVJlc29sdmVFbmRwb2ludHNBc3luYywgdGhpcy5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YUVudGl0eSA9IHRoaXMuZ2V0Q3VycmVudE1ldGFkYXRhRW50aXR5KCk7XHJcbiAgICAgICAgY29uc3QgY2xvdWREaXNjb3ZlcnlTb3VyY2UgPSBhd2FpdCBpbnZva2VBc3luYyh0aGlzLnVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEuYmluZCh0aGlzKSwgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5VXBkYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YSwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHRoaXMuY29ycmVsYXRpb25JZCkobWV0YWRhdGFFbnRpdHkpO1xyXG4gICAgICAgIHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5ID0gdGhpcy5jYW5vbmljYWxBdXRob3JpdHkucmVwbGFjZSh0aGlzLmhvc3RuYW1lQW5kUG9ydCwgbWV0YWRhdGFFbnRpdHkucHJlZmVycmVkX25ldHdvcmspO1xyXG4gICAgICAgIGNvbnN0IGVuZHBvaW50U291cmNlID0gYXdhaXQgaW52b2tlQXN5bmModGhpcy51cGRhdGVFbmRwb2ludE1ldGFkYXRhLmJpbmQodGhpcyksIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZUVuZHBvaW50TWV0YWRhdGEsIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCB0aGlzLmNvcnJlbGF0aW9uSWQpKG1ldGFkYXRhRW50aXR5KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZE1ldGFkYXRhKG1ldGFkYXRhRW50aXR5LCBjbG91ZERpc2NvdmVyeVNvdXJjZSwge1xyXG4gICAgICAgICAgICBzb3VyY2U6IGVuZHBvaW50U291cmNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyh7XHJcbiAgICAgICAgICAgIGNsb3VkRGlzY292ZXJ5U291cmNlOiBjbG91ZERpc2NvdmVyeVNvdXJjZSxcclxuICAgICAgICAgICAgYXV0aG9yaXR5RW5kcG9pbnRTb3VyY2U6IGVuZHBvaW50U291cmNlLFxyXG4gICAgICAgIH0sIHRoaXMuY29ycmVsYXRpb25JZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbWV0YWRhdGEgZW50aXR5IGZyb20gY2FjaGUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2VyIHJldHVybnMgYSBuZXcgbWV0YWRhdGEgZW50aXR5IGJ1aWx0XHJcbiAgICAgKiBmcm9tIHRoZSBjb25maWd1cmVkIGNhbm9uaWNhbCBhdXRob3JpdHlcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGdldEN1cnJlbnRNZXRhZGF0YUVudGl0eSgpIHtcclxuICAgICAgICBsZXQgbWV0YWRhdGFFbnRpdHkgPSB0aGlzLmNhY2hlTWFuYWdlci5nZXRBdXRob3JpdHlNZXRhZGF0YUJ5QWxpYXModGhpcy5ob3N0bmFtZUFuZFBvcnQpO1xyXG4gICAgICAgIGlmICghbWV0YWRhdGFFbnRpdHkpIHtcclxuICAgICAgICAgICAgbWV0YWRhdGFFbnRpdHkgPSB7XHJcbiAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXSxcclxuICAgICAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogdGhpcy5ob3N0bmFtZUFuZFBvcnQsXHJcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfbmV0d29yazogdGhpcy5ob3N0bmFtZUFuZFBvcnQsXHJcbiAgICAgICAgICAgICAgICBjYW5vbmljYWxfYXV0aG9yaXR5OiB0aGlzLmNhbm9uaWNhbEF1dGhvcml0eSxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICB0b2tlbl9lbmRwb2ludDogXCJcIixcclxuICAgICAgICAgICAgICAgIGVuZF9zZXNzaW9uX2VuZHBvaW50OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgaXNzdWVyOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgYWxpYXNlc0Zyb21OZXR3b3JrOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50c0Zyb21OZXR3b3JrOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGV4cGlyZXNBdDogZ2VuZXJhdGVBdXRob3JpdHlNZXRhZGF0YUV4cGlyZXNBdCgpLFxyXG4gICAgICAgICAgICAgICAgandrc191cmk6IFwiXCIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YUVudGl0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjYWNoZWQgbWV0YWRhdGEgYmFzZWQgb24gbWV0YWRhdGEgc291cmNlIGFuZCBzZXRzIHRoZSBpbnN0YW5jZSdzIG1ldGFkYXRhXHJcbiAgICAgKiBwcm9wZXJ0eSB0byB0aGUgc2FtZSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIG1ldGFkYXRhRW50aXR5XHJcbiAgICAgKiBAcGFyYW0gY2xvdWREaXNjb3ZlcnlTb3VyY2VcclxuICAgICAqIEBwYXJhbSBlbmRwb2ludE1ldGFkYXRhUmVzdWx0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUNhY2hlZE1ldGFkYXRhKG1ldGFkYXRhRW50aXR5LCBjbG91ZERpc2NvdmVyeVNvdXJjZSwgZW5kcG9pbnRNZXRhZGF0YVJlc3VsdCkge1xyXG4gICAgICAgIGlmIChjbG91ZERpc2NvdmVyeVNvdXJjZSAhPT0gQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuQ0FDSEUgJiZcclxuICAgICAgICAgICAgZW5kcG9pbnRNZXRhZGF0YVJlc3VsdD8uc291cmNlICE9PSBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZS5DQUNIRSkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZXhwaXJhdGlvbiB0aW1lIHVubGVzcyBib3RoIHZhbHVlcyBjYW1lIGZyb20gYSBzdWNjZXNzZnVsIGNhY2hlIGxvb2t1cFxyXG4gICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5leHBpcmVzQXQgPVxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBdXRob3JpdHlNZXRhZGF0YUV4cGlyZXNBdCgpO1xyXG4gICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5jYW5vbmljYWxfYXV0aG9yaXR5ID0gdGhpcy5jYW5vbmljYWxBdXRob3JpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5jYWNoZU1hbmFnZXIuZ2VuZXJhdGVBdXRob3JpdHlNZXRhZGF0YUNhY2hlS2V5KG1ldGFkYXRhRW50aXR5LnByZWZlcnJlZF9jYWNoZSk7XHJcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIuc2V0QXV0aG9yaXR5TWV0YWRhdGEoY2FjaGVLZXksIG1ldGFkYXRhRW50aXR5KTtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGFFbnRpdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBBdXRob3JpdHlNZXRhZGF0YUVudGl0eSB3aXRoIG5ldyBlbmRwb2ludHMgYW5kIHJldHVybiB3aGVyZSB0aGUgaW5mb3JtYXRpb24gY2FtZSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFFbnRpdHlcclxuICAgICAqL1xyXG4gICAgYXN5bmMgdXBkYXRlRW5kcG9pbnRNZXRhZGF0YShtZXRhZGF0YUVudGl0eSkge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5VXBkYXRlRW5kcG9pbnRNZXRhZGF0YSwgdGhpcy5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBjb25zdCBsb2NhbE1ldGFkYXRhID0gdGhpcy51cGRhdGVFbmRwb2ludE1ldGFkYXRhRnJvbUxvY2FsU291cmNlcyhtZXRhZGF0YUVudGl0eSk7XHJcbiAgICAgICAgLy8gRnVydGhlciB1cGRhdGUgbWF5IGJlIHJlcXVpcmVkIGZvciBoYXJkY29kZWQgbWV0YWRhdGEgaWYgcmVnaW9uYWwgbWV0YWRhdGEgaXMgcHJlZmVycmVkXHJcbiAgICAgICAgaWYgKGxvY2FsTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsTWV0YWRhdGEuc291cmNlID09PVxyXG4gICAgICAgICAgICAgICAgQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuSEFSRENPREVEX1ZBTFVFUykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgcHJlZmVycyB0byB1c2UgYW4gYXp1cmUgcmVnaW9uIHJlcGxhY2UgdGhlIGdsb2JhbCBlbmRwb2ludHMgd2l0aCByZWdpb25hbCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dGhvcml0eU9wdGlvbnMuYXp1cmVSZWdpb25Db25maWd1cmF0aW9uPy5henVyZVJlZ2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbE1ldGFkYXRhLm1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhcmRjb2RlZE1ldGFkYXRhID0gYXdhaXQgaW52b2tlQXN5bmModGhpcy51cGRhdGVNZXRhZGF0YVdpdGhSZWdpb25hbEluZm9ybWF0aW9uLmJpbmQodGhpcyksIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZU1ldGFkYXRhV2l0aFJlZ2lvbmFsSW5mb3JtYXRpb24sIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCB0aGlzLmNvcnJlbGF0aW9uSWQpKGxvY2FsTWV0YWRhdGEubWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBdXRob3JpdHlFbmRwb2ludE1ldGFkYXRhKG1ldGFkYXRhRW50aXR5LCBoYXJkY29kZWRNZXRhZGF0YSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVudGl0eS5jYW5vbmljYWxfYXV0aG9yaXR5ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fub25pY2FsQXV0aG9yaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxNZXRhZGF0YS5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCBtZXRhZGF0YSBmcm9tIG5ldHdvcmsgaWYgbG9jYWwgc291cmNlcyBhcmVuJ3QgYXZhaWxhYmxlXHJcbiAgICAgICAgbGV0IG1ldGFkYXRhID0gYXdhaXQgaW52b2tlQXN5bmModGhpcy5nZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcmsuYmluZCh0aGlzKSwgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5R2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrLCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgdGhpcy5jb3JyZWxhdGlvbklkKSgpO1xyXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBwcmVmZXJzIHRvIHVzZSBhbiBhenVyZSByZWdpb24gcmVwbGFjZSB0aGUgZ2xvYmFsIGVuZHBvaW50cyB3aXRoIHJlZ2lvbmFsIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRob3JpdHlPcHRpb25zLmF6dXJlUmVnaW9uQ29uZmlndXJhdGlvbj8uYXp1cmVSZWdpb24pIHtcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gYXdhaXQgaW52b2tlQXN5bmModGhpcy51cGRhdGVNZXRhZGF0YVdpdGhSZWdpb25hbEluZm9ybWF0aW9uLmJpbmQodGhpcyksIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eVVwZGF0ZU1ldGFkYXRhV2l0aFJlZ2lvbmFsSW5mb3JtYXRpb24sIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCB0aGlzLmNvcnJlbGF0aW9uSWQpKG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1cGRhdGVBdXRob3JpdHlFbmRwb2ludE1ldGFkYXRhKG1ldGFkYXRhRW50aXR5LCBtZXRhZGF0YSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZS5ORVRXT1JLO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWV0YWRhdGEgY291bGQgbm90IGJlIG9idGFpbmVkIGZyb20gdGhlIGNvbmZpZywgY2FjaGUsIG5ldHdvcmsgb3IgaGFyZGNvZGVkIHZhbHVlc1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3Iob3BlbklkQ29uZmlnRXJyb3IsIHRoaXMuZGVmYXVsdE9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGVuZHBvaW50IG1ldGFkYXRhIGZyb20gbG9jYWwgc291cmNlcyBhbmQgcmV0dXJucyB3aGVyZSB0aGUgaW5mb3JtYXRpb24gd2FzIHJldHJpZXZlZCBmcm9tIGFuZCB0aGUgbWV0YWRhdGEgY29uZmlnXHJcbiAgICAgKiByZXNwb25zZSBpZiB0aGUgc291cmNlIGlzIGhhcmRjb2RlZCBtZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIG1ldGFkYXRhRW50aXR5XHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGVFbmRwb2ludE1ldGFkYXRhRnJvbUxvY2FsU291cmNlcyhtZXRhZGF0YUVudGl0eSkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJBdHRlbXB0aW5nIHRvIGdldCBlbmRwb2ludCBtZXRhZGF0YSBmcm9tIGF1dGhvcml0eSBjb25maWd1cmF0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZ01ldGFkYXRhID0gdGhpcy5nZXRFbmRwb2ludE1ldGFkYXRhRnJvbUNvbmZpZygpO1xyXG4gICAgICAgIGlmIChjb25maWdNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiRm91bmQgZW5kcG9pbnQgbWV0YWRhdGEgaW4gYXV0aG9yaXR5IGNvbmZpZ3VyYXRpb25cIik7XHJcbiAgICAgICAgICAgIHVwZGF0ZUF1dGhvcml0eUVuZHBvaW50TWV0YWRhdGEobWV0YWRhdGFFbnRpdHksIGNvbmZpZ01ldGFkYXRhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkNPTkZJRyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIkRpZCBub3QgZmluZCBlbmRwb2ludCBtZXRhZGF0YSBpbiB0aGUgY29uZmlnLi4uIEF0dGVtcHRpbmcgdG8gZ2V0IGVuZHBvaW50IG1ldGFkYXRhIGZyb20gdGhlIGhhcmRjb2RlZCB2YWx1ZXMuXCIpO1xyXG4gICAgICAgIC8vIHNraXBBdXRob3JpdHlNZXRhZGF0YUNhY2hlIGlzIHVzZWQgdG8gYnlwYXNzIGhhcmRjb2RlZCBhdXRob3JpdHkgbWV0YWRhdGEgYW5kIGZvcmNlIGEgbmV0d29yayBtZXRhZGF0YSBjYWNoZSBsb29rdXAgYW5kIG5ldHdvcmsgbWV0YWRhdGEgcmVxdWVzdCBpZiBubyBjYWNoZWQgcmVzcG9uc2UgaXMgYXZhaWxhYmxlLlxyXG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eU9wdGlvbnMuc2tpcEF1dGhvcml0eU1ldGFkYXRhQ2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlNraXBwaW5nIGhhcmRjb2RlZCBtZXRhZGF0YSBjYWNoZSBzaW5jZSBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZSBpcyBzZXQgdG8gdHJ1ZS4gQXR0ZW1wdGluZyB0byBnZXQgZW5kcG9pbnQgbWV0YWRhdGEgZnJvbSB0aGUgbmV0d29yayBtZXRhZGF0YSBjYWNoZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBoYXJkY29kZWRNZXRhZGF0YSA9IHRoaXMuZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXMoKTtcclxuICAgICAgICAgICAgaWYgKGhhcmRjb2RlZE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVBdXRob3JpdHlFbmRwb2ludE1ldGFkYXRhKG1ldGFkYXRhRW50aXR5LCBoYXJkY29kZWRNZXRhZGF0YSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkhBUkRDT0RFRF9WQUxVRVMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IGhhcmRjb2RlZE1ldGFkYXRhLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJEaWQgbm90IGZpbmQgZW5kcG9pbnQgbWV0YWRhdGEgaW4gaGFyZGNvZGVkIHZhbHVlcy4uLiBBdHRlbXB0aW5nIHRvIGdldCBlbmRwb2ludCBtZXRhZGF0YSBmcm9tIHRoZSBuZXR3b3JrIG1ldGFkYXRhIGNhY2hlLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBjYWNoZWQgbWV0YWRhdGEgZW50aXR5IGV4cGlyYXRpb24gc3RhdHVzXHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFFbnRpdHlFeHBpcmVkID0gaXNBdXRob3JpdHlNZXRhZGF0YUV4cGlyZWQobWV0YWRhdGFFbnRpdHkpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0aG9yaXR5U2FtZVR5cGUobWV0YWRhdGFFbnRpdHkpICYmXHJcbiAgICAgICAgICAgIG1ldGFkYXRhRW50aXR5LmVuZHBvaW50c0Zyb21OZXR3b3JrICYmXHJcbiAgICAgICAgICAgICFtZXRhZGF0YUVudGl0eUV4cGlyZWQpIHtcclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1cGRhdGVcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIkZvdW5kIGVuZHBvaW50IG1ldGFkYXRhIGluIHRoZSBjYWNoZS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNvdXJjZTogQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuQ0FDSEUgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWV0YWRhdGFFbnRpdHlFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJUaGUgbWV0YWRhdGEgZW50aXR5IGlzIGV4cGlyZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhlIG51bWJlciBvZiB1cmwgY29tcG9uZW50cyBhZnRlciB0aGUgZG9tYWluIHRvIGRldGVybWluZSBpZiB0aGUgY2FjaGVkXHJcbiAgICAgKiBhdXRob3JpdHkgbWV0YWRhdGEgY2FuIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0ZWQgYXV0aG9yaXR5LiBQcm90ZWN0cyBhZ2FpbnN0IHNhbWUgZG9tYWluIGRpZmZlcmVudFxyXG4gICAgICogYXV0aG9yaXR5IHN1Y2ggYXMgbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS90ZW5hbnQgYW5kIGxvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vdGZwL3RlbmFudC9wb2xpY3lcclxuICAgICAqIEBwYXJhbSBtZXRhZGF0YUVudGl0eVxyXG4gICAgICovXHJcbiAgICBpc0F1dGhvcml0eVNhbWVUeXBlKG1ldGFkYXRhRW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXR5VXJsID0gbmV3IFVybFN0cmluZyhtZXRhZGF0YUVudGl0eS5jYW5vbmljYWxfYXV0aG9yaXR5KTtcclxuICAgICAgICBjb25zdCBjYWNoZWRQYXJ0cyA9IGNhY2hlZEF1dGhvcml0eVVybC5nZXRVcmxDb21wb25lbnRzKCkuUGF0aFNlZ21lbnRzO1xyXG4gICAgICAgIHJldHVybiAoY2FjaGVkUGFydHMubGVuZ3RoID09PVxyXG4gICAgICAgICAgICB0aGlzLmNhbm9uaWNhbEF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGF1dGhvcml0eU1ldGFkYXRhIGNvbmZpZyBvcHRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21Db25maWcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5hdXRob3JpdHlNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5hdXRob3JpdHlPcHRpb25zLmF1dGhvcml0eU1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKGludmFsaWRBdXRob3JpdHlNZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgT0F1dGggZW5kcG9pbnRzIGZyb20gdGhlIGdpdmVuIE9wZW5JRCBjb25maWd1cmF0aW9uIGVuZHBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBoYXNIYXJkY29kZWRNZXRhZGF0YSBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEVuZHBvaW50TWV0YWRhdGFGcm9tTmV0d29yaygpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eUdldEVuZHBvaW50TWV0YWRhdGFGcm9tTmV0d29yaywgdGhpcy5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUT0RPOiBBZGQgYSB0aW1lb3V0IGlmIHRoZSBhdXRob3JpdHkgZXhpc3RzIGluIG91ciBsaWJyYXJ5J3NcclxuICAgICAgICAgKiBoYXJkY29kZWQgbGlzdCBvZiBtZXRhZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IG9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludCA9IHRoaXMuZGVmYXVsdE9wZW5JZENvbmZpZ3VyYXRpb25FbmRwb2ludDtcclxuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKGBBdXRob3JpdHkuZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrOiBhdHRlbXB0aW5nIHRvIHJldHJpZXZlIE9BdXRoIGVuZHBvaW50cyBmcm9tICR7b3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50fWApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5uZXR3b3JrSW50ZXJmYWNlLnNlbmRHZXRSZXF1ZXN0QXN5bmMob3BlbklkQ29uZmlndXJhdGlvbkVuZHBvaW50LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFJlc3BvbnNlID0gaXNPcGVuSWRDb25maWdSZXNwb25zZShyZXNwb25zZS5ib2R5KTtcclxuICAgICAgICAgICAgaWYgKGlzVmFsaWRSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKGBBdXRob3JpdHkuZ2V0RW5kcG9pbnRNZXRhZGF0YUZyb21OZXR3b3JrOiBjb3VsZCBub3QgcGFyc2UgcmVzcG9uc2UgYXMgT3BlbklEIGNvbmZpZ3VyYXRpb25gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoYEF1dGhvcml0eS5nZXRFbmRwb2ludE1ldGFkYXRhRnJvbU5ldHdvcms6ICR7ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgT0F1dGggZW5kcG9pbnRzIGZvciBjb21tb24gYXV0aG9yaXRpZXMuXHJcbiAgICAgKi9cclxuICAgIGdldEVuZHBvaW50TWV0YWRhdGFGcm9tSGFyZGNvZGVkVmFsdWVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhvc3RuYW1lQW5kUG9ydCBpbiBFbmRwb2ludE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbmRwb2ludE1ldGFkYXRhW3RoaXMuaG9zdG5hbWVBbmRQb3J0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgcmV0cmlldmVkIG1ldGFkYXRhIHdpdGggcmVnaW9uYWwgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBVc2VyIHNlbGVjdGVkIEF6dXJlIHJlZ2lvbiB3aWxsIGJlIHVzZWQgaWYgY29uZmlndXJlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdXBkYXRlTWV0YWRhdGFXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbihtZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5VXBkYXRlTWV0YWRhdGFXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbiwgdGhpcy5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBjb25zdCB1c2VyQ29uZmlndXJlZEF6dXJlUmVnaW9uID0gdGhpcy5hdXRob3JpdHlPcHRpb25zLmF6dXJlUmVnaW9uQ29uZmlndXJhdGlvbj8uYXp1cmVSZWdpb247XHJcbiAgICAgICAgaWYgKHVzZXJDb25maWd1cmVkQXp1cmVSZWdpb24pIHtcclxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWd1cmVkQXp1cmVSZWdpb24gIT09XHJcbiAgICAgICAgICAgICAgICBDb25zdGFudHMuQVpVUkVfUkVHSU9OX0FVVE9fRElTQ09WRVJfRkxBRykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fb3V0Y29tZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgUmVnaW9uRGlzY292ZXJ5T3V0Y29tZXMuQ09ORklHVVJFRF9OT19BVVRPX0RFVEVDVElPTjtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX3VzZWQgPVxyXG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWd1cmVkQXp1cmVSZWdpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5LnJlcGxhY2VXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbihtZXRhZGF0YSwgdXNlckNvbmZpZ3VyZWRBenVyZVJlZ2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYXV0b2RldGVjdGVkUmVnaW9uTmFtZSA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMucmVnaW9uRGlzY292ZXJ5LmRldGVjdFJlZ2lvbi5iaW5kKHRoaXMucmVnaW9uRGlzY292ZXJ5KSwgUGVyZm9ybWFuY2VFdmVudHMuUmVnaW9uRGlzY292ZXJ5RGV0ZWN0UmVnaW9uLCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgdGhpcy5jb3JyZWxhdGlvbklkKSh0aGlzLmF1dGhvcml0eU9wdGlvbnMuYXp1cmVSZWdpb25Db25maWd1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICA/LmVudmlyb25tZW50UmVnaW9uLCB0aGlzLnJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhKTtcclxuICAgICAgICAgICAgaWYgKGF1dG9kZXRlY3RlZFJlZ2lvbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEucmVnaW9uX291dGNvbWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIFJlZ2lvbkRpc2NvdmVyeU91dGNvbWVzLkFVVE9fREVURUNUSU9OX1JFUVVFU1RFRF9TVUNDRVNTRlVMO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpb25EaXNjb3ZlcnlNZXRhZGF0YS5yZWdpb25fdXNlZCA9XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b2RldGVjdGVkUmVnaW9uTmFtZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHkucmVwbGFjZVdpdGhSZWdpb25hbEluZm9ybWF0aW9uKG1ldGFkYXRhLCBhdXRvZGV0ZWN0ZWRSZWdpb25OYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlZ2lvbkRpc2NvdmVyeU1ldGFkYXRhLnJlZ2lvbl9vdXRjb21lID1cclxuICAgICAgICAgICAgICAgIFJlZ2lvbkRpc2NvdmVyeU91dGNvbWVzLkFVVE9fREVURUNUSU9OX1JFUVVFU1RFRF9GQUlMRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkgd2l0aCBuZXcgYWxpYXNlcywgcHJlZmVycmVkX25ldHdvcmsgYW5kIHByZWZlcnJlZF9jYWNoZVxyXG4gICAgICogYW5kIHJldHVybnMgd2hlcmUgdGhlIGluZm9ybWF0aW9uIHdhcyByZXRyaWV2ZWQgZnJvbVxyXG4gICAgICogQHBhcmFtIG1ldGFkYXRhRW50aXR5XHJcbiAgICAgKiBAcmV0dXJucyBBdXRob3JpdHlNZXRhZGF0YVNvdXJjZVxyXG4gICAgICovXHJcbiAgICBhc3luYyB1cGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhKG1ldGFkYXRhRW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlVcGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhLCB0aGlzLmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsTWV0YWRhdGFTb3VyY2UgPSB0aGlzLnVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTG9jYWxTb3VyY2VzKG1ldGFkYXRhRW50aXR5KTtcclxuICAgICAgICBpZiAobG9jYWxNZXRhZGF0YVNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxNZXRhZGF0YVNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gbmV0d29yayBhcyBtZXRhZGF0YSBzb3VyY2VcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMuZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrLmJpbmQodGhpcyksIFBlcmZvcm1hbmNlRXZlbnRzLkF1dGhvcml0eUdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tTmV0d29yaywgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHRoaXMuY29ycmVsYXRpb25JZCkoKTtcclxuICAgICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdXBkYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YShtZXRhZGF0YUVudGl0eSwgbWV0YWRhdGEsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuTkVUV09SSztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWV0YWRhdGEgY291bGQgbm90IGJlIG9idGFpbmVkIGZyb20gdGhlIGNvbmZpZywgY2FjaGUsIG5ldHdvcmsgb3IgaGFyZGNvZGVkIHZhbHVlc1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcih1bnRydXN0ZWRBdXRob3JpdHkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21Mb2NhbFNvdXJjZXMobWV0YWRhdGFFbnRpdHkpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiQXR0ZW1wdGluZyB0byBnZXQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhICBmcm9tIGF1dGhvcml0eSBjb25maWd1cmF0aW9uXCIpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2VQaWkoYEtub3duIEF1dGhvcml0aWVzOiAke3RoaXMuYXV0aG9yaXR5T3B0aW9ucy5rbm93bkF1dGhvcml0aWVzIHx8XHJcbiAgICAgICAgICAgIENvbnN0YW50cy5OT1RfQVBQTElDQUJMRX1gKTtcclxuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlUGlpKGBBdXRob3JpdHkgTWV0YWRhdGE6ICR7dGhpcy5hdXRob3JpdHlPcHRpb25zLmF1dGhvcml0eU1ldGFkYXRhIHx8XHJcbiAgICAgICAgICAgIENvbnN0YW50cy5OT1RfQVBQTElDQUJMRX1gKTtcclxuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlUGlpKGBDYW5vbmljYWwgQXV0aG9yaXR5OiAke21ldGFkYXRhRW50aXR5LmNhbm9uaWNhbF9hdXRob3JpdHkgfHwgQ29uc3RhbnRzLk5PVF9BUFBMSUNBQkxFfWApO1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5nZXRDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbUNvbmZpZygpO1xyXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiRm91bmQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGluIGF1dGhvcml0eSBjb25maWd1cmF0aW9uXCIpO1xyXG4gICAgICAgICAgICB1cGRhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhKG1ldGFkYXRhRW50aXR5LCBtZXRhZGF0YSwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuQ09ORklHO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgY2FjaGVkIG1ldGFkYXRhIGNhbWUgZnJvbSBjb25maWcgYnV0IHRoYXQgY29uZmlnIHdhcyBub3QgcGFzc2VkIHRvIHRoaXMgaW5zdGFuY2UsIHdlIG11c3QgZ28gdG8gaGFyZGNvZGVkIHZhbHVlc1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJEaWQgbm90IGZpbmQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGluIHRoZSBjb25maWcuLi4gQXR0ZW1wdGluZyB0byBnZXQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIGZyb20gdGhlIGhhcmRjb2RlZCB2YWx1ZXMuXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcEF1dGhvcml0eU1ldGFkYXRhQ2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlNraXBwaW5nIGhhcmRjb2RlZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgY2FjaGUgc2luY2Ugc2tpcEF1dGhvcml0eU1ldGFkYXRhQ2FjaGUgaXMgc2V0IHRvIHRydWUuIEF0dGVtcHRpbmcgdG8gZ2V0IGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBmcm9tIHRoZSBuZXR3b3JrIG1ldGFkYXRhIGNhY2hlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhcmRjb2RlZE1ldGFkYXRhID0gZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21IYXJkY29kZWRWYWx1ZXModGhpcy5ob3N0bmFtZUFuZFBvcnQpO1xyXG4gICAgICAgICAgICBpZiAoaGFyZGNvZGVkTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJGb3VuZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgZnJvbSBoYXJkY29kZWQgdmFsdWVzLlwiKTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGEobWV0YWRhdGFFbnRpdHksIGhhcmRjb2RlZE1ldGFkYXRhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQXV0aG9yaXR5TWV0YWRhdGFTb3VyY2UuSEFSRENPREVEX1ZBTFVFUztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiRGlkIG5vdCBmaW5kIGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBpbiBoYXJkY29kZWQgdmFsdWVzLi4uIEF0dGVtcHRpbmcgdG8gZ2V0IGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YSBmcm9tIHRoZSBuZXR3b3JrIG1ldGFkYXRhIGNhY2hlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFFbnRpdHlFeHBpcmVkID0gaXNBdXRob3JpdHlNZXRhZGF0YUV4cGlyZWQobWV0YWRhdGFFbnRpdHkpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0aG9yaXR5U2FtZVR5cGUobWV0YWRhdGFFbnRpdHkpICYmXHJcbiAgICAgICAgICAgIG1ldGFkYXRhRW50aXR5LmFsaWFzZXNGcm9tTmV0d29yayAmJlxyXG4gICAgICAgICAgICAhbWV0YWRhdGFFbnRpdHlFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJGb3VuZCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgaW4gdGhlIGNhY2hlLlwiKTtcclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1cGRhdGVcclxuICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eU1ldGFkYXRhU291cmNlLkNBQ0hFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtZXRhZGF0YUVudGl0eUV4cGlyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlRoZSBtZXRhZGF0YSBlbnRpdHkgaXMgZXhwaXJlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBjbG91ZERpc2NvdmVyeU1ldGFkYXRhIGNvbmZpZyBvciBjaGVjayBrbm93bkF1dGhvcml0aWVzXHJcbiAgICAgKi9cclxuICAgIGdldENsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tQ29uZmlnKCkge1xyXG4gICAgICAgIC8vIENJQU0gZG9lcyBub3Qgc3VwcG9ydCBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGFcclxuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHlUeXBlID09PSBBdXRob3JpdHlUeXBlLkNpYW0pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIkNJQU0gYXV0aG9yaXRpZXMgZG8gbm90IHN1cHBvcnQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhLCBnZW5lcmF0ZSB0aGUgYWxpYXNlcyBmcm9tIGF1dGhvcml0eSBob3N0LlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml0eS5jcmVhdGVDbG91ZERpc2NvdmVyeU1ldGFkYXRhRnJvbUhvc3QodGhpcy5ob3N0bmFtZUFuZFBvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBpZiBuZXR3b3JrIHJlc3BvbnNlIHdhcyBwcm92aWRlZCBpbiBjb25maWdcclxuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHlPcHRpb25zLmNsb3VkRGlzY292ZXJ5TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlRoZSBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgaGFzIGJlZW4gcHJvdmlkZWQgYXMgYSBuZXR3b3JrIHJlc3BvbnNlLCBpbiB0aGUgY29uZmlnLlwiKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJBdHRlbXB0aW5nIHRvIHBhcnNlIHRoZSBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEuXCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBKU09OLnBhcnNlKHRoaXMuYXV0aG9yaXR5T3B0aW9ucy5jbG91ZERpc2NvdmVyeU1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrUmVzcG9uc2UocGFyc2VkUmVzcG9uc2UubWV0YWRhdGEsIHRoaXMuaG9zdG5hbWVBbmRQb3J0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJQYXJzZWQgdGhlIGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YS5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiVGhlcmUgaXMgcmV0dXJuYWJsZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgcGFyc2VkIGNsb3VkIGRpc2NvdmVyeSBtZXRhZGF0YS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlRoZXJlIGlzIG5vIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBwYXJzZWQgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlVuYWJsZSB0byBwYXJzZSB0aGUgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhLiBUaHJvd2luZyBJbnZhbGlkIENsb3VkIERpc2NvdmVyeSBNZXRhZGF0YSBFcnJvci5cIik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IoaW52YWxpZENsb3VkRGlzY292ZXJ5TWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGNsb3VkRGlzY292ZXJ5TWV0YWRhdGEgaXMgZW1wdHkgb3IgZG9lcyBub3QgY29udGFpbiB0aGUgaG9zdCwgY2hlY2sga25vd25BdXRob3JpdGllc1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5Lbm93bkF1dGhvcml0aWVzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlRoZSBob3N0IGlzIGluY2x1ZGVkIGluIGtub3duQXV0aG9yaXRpZXMuIENyZWF0aW5nIG5ldyBjbG91ZCBkaXNjb3ZlcnkgbWV0YWRhdGEgZnJvbSB0aGUgaG9zdC5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBBdXRob3JpdHkuY3JlYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21Ib3N0KHRoaXMuaG9zdG5hbWVBbmRQb3J0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB0byBnZXQgbWV0YWRhdGEgZnJvbSBuZXR3b3JrIGlmIENsb3VkRGlzY292ZXJ5TWV0YWRhdGEgd2FzIG5vdCBwb3B1bGF0ZWQgYnkgY29uZmlnXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhhc0hhcmRjb2RlZE1ldGFkYXRhIGJvb2xlYW5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrKCkge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5R2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrLCB0aGlzLmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlRGlzY292ZXJ5RW5kcG9pbnQgPSBgJHtDb25zdGFudHMuQUFEX0lOU1RBTkNFX0RJU0NPVkVSWV9FTkRQVH0ke3RoaXMuY2Fub25pY2FsQXV0aG9yaXR5fW9hdXRoMi92Mi4wL2F1dGhvcml6ZWA7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVE9ETzogQWRkIGEgdGltZW91dCBpZiB0aGUgYXV0aG9yaXR5IGV4aXN0cyBpbiBvdXIgbGlicmFyeSdzXHJcbiAgICAgICAgICogaGFyZGNvZGVkIGxpc3Qgb2YgbWV0YWRhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5uZXR3b3JrSW50ZXJmYWNlLnNlbmRHZXRSZXF1ZXN0QXN5bmMoaW5zdGFuY2VEaXNjb3ZlcnlFbmRwb2ludCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCB0eXBlZFJlc3BvbnNlQm9keTtcclxuICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xyXG4gICAgICAgICAgICBpZiAoaXNDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2UocmVzcG9uc2UuYm9keSkpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVkUmVzcG9uc2VCb2R5ID1cclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5O1xyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSB0eXBlZFJlc3BvbnNlQm9keS5tZXRhZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2VQaWkoYHRlbmFudF9kaXNjb3ZlcnlfZW5kcG9pbnQgaXM6ICR7dHlwZWRSZXNwb25zZUJvZHkudGVuYW50X2Rpc2NvdmVyeV9lbmRwb2ludH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Nsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlKHJlc3BvbnNlLmJvZHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuaW5nKGBBIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlIHdhcyByZXR1cm5lZC4gVGhlIGNsb3VkIGluc3RhbmNlIGRpc2NvdmVyeSBuZXR3b3JrIHJlcXVlc3QncyBzdGF0dXMgY29kZSBpczogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgICAgICAgICAgICB0eXBlZFJlc3BvbnNlQm9keSA9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlZFJlc3BvbnNlQm9keS5lcnJvciA9PT0gQ29uc3RhbnRzLklOVkFMSURfSU5TVEFOQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlRoZSBDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZSBlcnJvciBpcyBpbnZhbGlkX2luc3RhbmNlLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm5pbmcoYFRoZSBDbG91ZEluc3RhbmNlRGlzY292ZXJ5RXJyb3JSZXNwb25zZSBlcnJvciBpcyAke3R5cGVkUmVzcG9uc2VCb2R5LmVycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhgVGhlIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlFcnJvclJlc3BvbnNlIGVycm9yIGRlc2NyaXB0aW9uIGlzICR7dHlwZWRSZXNwb25zZUJvZHkuZXJyb3JfZGVzY3JpcHRpb259YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuaW5nKFwiU2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIENsb3VkSW5zdGFuY2VEaXNjb3ZlcnlNZXRhZGF0YSAocmV0dXJuZWQgZnJvbSB0aGUgbmV0d29yaykgdG8gW11cIik7XHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJBQUQgZGlkIG5vdCByZXR1cm4gYSBDbG91ZEluc3RhbmNlRGlzY292ZXJ5UmVzcG9uc2Ugb3IgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeUVycm9yUmVzcG9uc2VcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiQXR0ZW1wdGluZyB0byBmaW5kIGEgbWF0Y2ggYmV0d2VlbiB0aGUgZGV2ZWxvcGVyJ3MgYXV0aG9yaXR5IGFuZCB0aGUgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhIHJldHVybmVkIGZyb20gdGhlIG5ldHdvcmsgcmVxdWVzdC5cIik7XHJcbiAgICAgICAgICAgIG1hdGNoID0gZ2V0Q2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21OZXR3b3JrUmVzcG9uc2UobWV0YWRhdGEsIHRoaXMuaG9zdG5hbWVBbmRQb3J0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFRoZXJlIHdhcyBhIG5ldHdvcmsgZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGNsb3VkIGRpc2NvdmVyeSBpbnN0YW5jZSBtZXRhZGF0YS5cXG5FcnJvcjogJHtlcnJvci5lcnJvckNvZGV9XFxuRXJyb3IgRGVzY3JpcHRpb246ICR7ZXJyb3IuZXJyb3JNZXNzYWdlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRFcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEEgbm9uLU1TQUxKUyBlcnJvciB3YXMgdGhyb3duIHdoaWxlIGF0dGVtcHRpbmcgdG8gZ2V0IHRoZSBjbG91ZCBpbnN0YW5jZSBkaXNjb3ZlcnkgbWV0YWRhdGEuXFxuRXJyb3I6ICR7dHlwZWRFcnJvci5uYW1lfVxcbkVycm9yIERlc2NyaXB0aW9uOiAke3R5cGVkRXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3VzdG9tIERvbWFpbiBzY2VuYXJpbywgaG9zdCBpcyB0cnVzdGVkIGJlY2F1c2UgSW5zdGFuY2UgRGlzY292ZXJ5IGNhbGwgc3VjY2VlZGVkXHJcbiAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuaW5nKFwiVGhlIGRldmVsb3BlcidzIGF1dGhvcml0eSB3YXMgbm90IGZvdW5kIHdpdGhpbiB0aGUgQ2xvdWRJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhIHJldHVybmVkIGZyb20gdGhlIG5ldHdvcmsgcmVxdWVzdC5cIik7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJDcmVhdGluZyBjdXN0b20gQXV0aG9yaXR5IGZvciBjdXN0b20gZG9tYWluIHNjZW5hcmlvLlwiKTtcclxuICAgICAgICAgICAgbWF0Y2ggPSBBdXRob3JpdHkuY3JlYXRlQ2xvdWREaXNjb3ZlcnlNZXRhZGF0YUZyb21Ib3N0KHRoaXMuaG9zdG5hbWVBbmRQb3J0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaG9zdCBpcyBpbmNsdWRlZCBpbiB0aGUga25vd25BdXRob3JpdGllcyBjb25maWcgb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIGlzSW5Lbm93bkF1dGhvcml0aWVzKCkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmF1dGhvcml0eU9wdGlvbnMua25vd25BdXRob3JpdGllcy5maWx0ZXIoKGF1dGhvcml0eSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKGF1dGhvcml0eSAmJlxyXG4gICAgICAgICAgICAgICAgVXJsU3RyaW5nLmdldERvbWFpbkZyb21VcmwoYXV0aG9yaXR5KS50b0xvd2VyQ2FzZSgpID09PVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWVBbmRQb3J0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlcy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gcG9wdWxhdGUgdGhlIGF1dGhvcml0eSBiYXNlZCBvbiBhenVyZUNsb3VkT3B0aW9uc1xyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVN0cmluZ1xyXG4gICAgICogQHBhcmFtIGF6dXJlQ2xvdWRPcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUF1dGhvcml0eShhdXRob3JpdHlTdHJpbmcsIGF6dXJlQ2xvdWRPcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGF1dGhvcml0eUF6dXJlQ2xvdWRJbnN0YW5jZTtcclxuICAgICAgICBpZiAoYXp1cmVDbG91ZE9wdGlvbnMgJiZcclxuICAgICAgICAgICAgYXp1cmVDbG91ZE9wdGlvbnMuYXp1cmVDbG91ZEluc3RhbmNlICE9PSBBenVyZUNsb3VkSW5zdGFuY2UuTm9uZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW5hbnQgPSBhenVyZUNsb3VkT3B0aW9ucy50ZW5hbnRcclxuICAgICAgICAgICAgICAgID8gYXp1cmVDbG91ZE9wdGlvbnMudGVuYW50XHJcbiAgICAgICAgICAgICAgICA6IENvbnN0YW50cy5ERUZBVUxUX0NPTU1PTl9URU5BTlQ7XHJcbiAgICAgICAgICAgIGF1dGhvcml0eUF6dXJlQ2xvdWRJbnN0YW5jZSA9IGAke2F6dXJlQ2xvdWRPcHRpb25zLmF6dXJlQ2xvdWRJbnN0YW5jZX0vJHt0ZW5hbnR9L2A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhdXRob3JpdHlBenVyZUNsb3VkSW5zdGFuY2VcclxuICAgICAgICAgICAgPyBhdXRob3JpdHlBenVyZUNsb3VkSW5zdGFuY2VcclxuICAgICAgICAgICAgOiBhdXRob3JpdHlTdHJpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgY2xvdWQgZGlzY292ZXJ5IG1ldGFkYXRhIG9iamVjdCBmcm9tIGEgZ2l2ZW4gaG9zdFxyXG4gICAgICogQHBhcmFtIGhvc3RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUNsb3VkRGlzY292ZXJ5TWV0YWRhdGFGcm9tSG9zdChob3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJlZmVycmVkX25ldHdvcms6IGhvc3QsXHJcbiAgICAgICAgICAgIHByZWZlcnJlZF9jYWNoZTogaG9zdCxcclxuICAgICAgICAgICAgYWxpYXNlczogW2hvc3RdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBlbnZpcm9ubWVudCBmcm9tIGF1dGhvcml0eSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZmVycmVkQ2FjaGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlZElkZW50aXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb25zdGFudHMuREVGQVVMVF9BVVRIT1JJVFlfSE9TVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNjb3ZlcnlDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhLnByZWZlcnJlZF9jYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihlbmRwb2ludFJlc29sdXRpb25FcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCBob3N0IGlzIGFuIGFsaWFzIG9mIHRoaXMgYXV0aG9yaXR5IGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gaG9zdFxyXG4gICAgICovXHJcbiAgICBpc0FsaWFzKGhvc3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5hbGlhc2VzLmluZGV4T2YoaG9zdCkgPiAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaG9zdCBpcyBhbiBhbGlhcyBvZiBhIGtub3duIE1pY3Jvc29mdCBhdXRob3JpdHkgZm9yIHB1cnBvc2VzIG9mIGVuZHBvaW50IGRpc2NvdmVyeVxyXG4gICAgICogQHBhcmFtIGhvc3RcclxuICAgICAqL1xyXG4gICAgaXNBbGlhc09mS25vd25NaWNyb3NvZnRBdXRob3JpdHkoaG9zdCkge1xyXG4gICAgICAgIHJldHVybiBJbnN0YW5jZURpc2NvdmVyeU1ldGFkYXRhQWxpYXNlcy5oYXMoaG9zdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBob3N0IGlzIHRoYXQgb2YgYSBwdWJsaWMgY2xvdWQgYXV0aG9yaXR5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eSBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIGJvb2xcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzUHVibGljQ2xvdWRBdXRob3JpdHkoaG9zdCkge1xyXG4gICAgICAgIHJldHVybiBDb25zdGFudHMuS05PV05fUFVCTElDX0NMT1VEUy5pbmRleE9mKGhvc3QpID49IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYnVpbGQgdGhlIGF1dGhvcml0eSBzdHJpbmcgd2l0aCB0aGUgcmVnaW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhvc3Qgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnVpbGRSZWdpb25hbEF1dGhvcml0eVN0cmluZyhob3N0LCByZWdpb24sIHF1ZXJ5U3RyaW5nKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCB2YWxpZGF0ZSBhIFVybCBzdHJpbmcgb2JqZWN0IHdpdGggdGhlIGluaXRpYWwgYXV0aG9yaXR5IHN0cmluZ1xyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eVVybEluc3RhbmNlID0gbmV3IFVybFN0cmluZyhob3N0KTtcclxuICAgICAgICBhdXRob3JpdHlVcmxJbnN0YW5jZS52YWxpZGF0ZUFzVXJpKCk7XHJcbiAgICAgICAgY29uc3QgYXV0aG9yaXR5VXJsUGFydHMgPSBhdXRob3JpdHlVcmxJbnN0YW5jZS5nZXRVcmxDb21wb25lbnRzKCk7XHJcbiAgICAgICAgbGV0IGhvc3ROYW1lQW5kUG9ydCA9IGAke3JlZ2lvbn0uJHthdXRob3JpdHlVcmxQYXJ0cy5Ib3N0TmFtZUFuZFBvcnR9YDtcclxuICAgICAgICBpZiAodGhpcy5pc1B1YmxpY0Nsb3VkQXV0aG9yaXR5KGF1dGhvcml0eVVybFBhcnRzLkhvc3ROYW1lQW5kUG9ydCkpIHtcclxuICAgICAgICAgICAgaG9zdE5hbWVBbmRQb3J0ID0gYCR7cmVnaW9ufS4ke0NvbnN0YW50cy5SRUdJT05BTF9BVVRIX1BVQkxJQ19DTE9VRF9TVUZGSVh9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW5jbHVkZSB0aGUgcXVlcnkgc3RyaW5nIHBvcnRpb24gb2YgdGhlIHVybFxyXG4gICAgICAgIGNvbnN0IHVybCA9IFVybFN0cmluZy5jb25zdHJ1Y3RBdXRob3JpdHlVcmlGcm9tT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4uYXV0aG9yaXR5VXJsSW5zdGFuY2UuZ2V0VXJsQ29tcG9uZW50cygpLFxyXG4gICAgICAgICAgICBIb3N0TmFtZUFuZFBvcnQ6IGhvc3ROYW1lQW5kUG9ydCxcclxuICAgICAgICB9KS51cmxTdHJpbmc7XHJcbiAgICAgICAgLy8gQWRkIHRoZSBxdWVyeSBzdHJpbmcgaWYgYSBxdWVyeSBzdHJpbmcgd2FzIHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKHF1ZXJ5U3RyaW5nKVxyXG4gICAgICAgICAgICByZXR1cm4gYCR7dXJsfT8ke3F1ZXJ5U3RyaW5nfWA7XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZSB0aGUgZW5kcG9pbnRzIGluIHRoZSBtZXRhZGF0YSBvYmplY3Qgd2l0aCB0aGVpciByZWdpb25hbCBlcXVpdmFsZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGEgT3BlbklkQ29uZmlnUmVzcG9uc2VcclxuICAgICAqIEBwYXJhbSBhenVyZVJlZ2lvbiBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlcGxhY2VXaXRoUmVnaW9uYWxJbmZvcm1hdGlvbihtZXRhZGF0YSwgYXp1cmVSZWdpb24pIHtcclxuICAgICAgICBjb25zdCByZWdpb25hbE1ldGFkYXRhID0geyAuLi5tZXRhZGF0YSB9O1xyXG4gICAgICAgIHJlZ2lvbmFsTWV0YWRhdGEuYXV0aG9yaXphdGlvbl9lbmRwb2ludCA9XHJcbiAgICAgICAgICAgIEF1dGhvcml0eS5idWlsZFJlZ2lvbmFsQXV0aG9yaXR5U3RyaW5nKHJlZ2lvbmFsTWV0YWRhdGEuYXV0aG9yaXphdGlvbl9lbmRwb2ludCwgYXp1cmVSZWdpb24pO1xyXG4gICAgICAgIHJlZ2lvbmFsTWV0YWRhdGEudG9rZW5fZW5kcG9pbnQgPVxyXG4gICAgICAgICAgICBBdXRob3JpdHkuYnVpbGRSZWdpb25hbEF1dGhvcml0eVN0cmluZyhyZWdpb25hbE1ldGFkYXRhLnRva2VuX2VuZHBvaW50LCBhenVyZVJlZ2lvbik7XHJcbiAgICAgICAgaWYgKHJlZ2lvbmFsTWV0YWRhdGEuZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcclxuICAgICAgICAgICAgcmVnaW9uYWxNZXRhZGF0YS5lbmRfc2Vzc2lvbl9lbmRwb2ludCA9XHJcbiAgICAgICAgICAgICAgICBBdXRob3JpdHkuYnVpbGRSZWdpb25hbEF1dGhvcml0eVN0cmluZyhyZWdpb25hbE1ldGFkYXRhLmVuZF9zZXNzaW9uX2VuZHBvaW50LCBhenVyZVJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWdpb25hbE1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gQ0lBTV9BVVRIT1JJWSBhcyBwZXIgdGhlIGJlbG93IHJ1bGVzOlxyXG4gICAgICogSWYgbm8gcGF0aCBzZWdtZW50cyBmb3VuZCBhbmQgaXQgaXMgYSBDSUFNIGF1dGhvcml0eSAoaG9zdG5hbWUgZW5kcyB3aXRoIC5jaWFtbG9naW4uY29tKSwgdGhlbiB0cmFuc2Zvcm0gaXRcclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGUgdHJhbnNmb3JtYXRpb24gcGF0aCBzaG91bGQgZ28gYXdheSBvbmNlIFNUUyBzdXBwb3J0cyBDSUFNIHdpdGggdGhlIGZvcm1hdDogYHRlbmFudElkb3JEb21haW4uY2lhbWxvZ2luLmNvbWBcclxuICAgICAqIGBjaWFtbG9naW4uY29tYCBjYW4gYWxzbyBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSBhbmQgd2Ugc2hvdWxkIGFjY29tbW9kYXRlIHRoZSBzYW1lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNmb3JtQ0lBTUF1dGhvcml0eShhdXRob3JpdHkpIHtcclxuICAgICAgICBsZXQgY2lhbUF1dGhvcml0eSA9IGF1dGhvcml0eTtcclxuICAgICAgICBjb25zdCBhdXRob3JpdHlVcmwgPSBuZXcgVXJsU3RyaW5nKGF1dGhvcml0eSk7XHJcbiAgICAgICAgY29uc3QgYXV0aG9yaXR5VXJsQ29tcG9uZW50cyA9IGF1dGhvcml0eVVybC5nZXRVcmxDb21wb25lbnRzKCk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdHJhbnNmb3JtYXRpb24gaXMgbmVlZGVkXHJcbiAgICAgICAgaWYgKGF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgICAgICBhdXRob3JpdHlVcmxDb21wb25lbnRzLkhvc3ROYW1lQW5kUG9ydC5lbmRzV2l0aChDb25zdGFudHMuQ0lBTV9BVVRIX1VSTCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGVuYW50SWRPckRvbWFpbiA9IGF1dGhvcml0eVVybENvbXBvbmVudHMuSG9zdE5hbWVBbmRQb3J0LnNwbGl0KFwiLlwiKVswXTtcclxuICAgICAgICAgICAgY2lhbUF1dGhvcml0eSA9IGAke2NpYW1BdXRob3JpdHl9JHt0ZW5hbnRJZE9yRG9tYWlufSR7Q29uc3RhbnRzLkFBRF9URU5BTlRfRE9NQUlOX1NVRkZJWH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2lhbUF1dGhvcml0eTtcclxuICAgIH1cclxufVxyXG4vLyBSZXNlcnZlZCB0ZW5hbnQgZG9tYWluIG5hbWVzIHRoYXQgd2lsbCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0ZW5hbnQgaWRcclxuQXV0aG9yaXR5LnJlc2VydmVkVGVuYW50RG9tYWlucyA9IG5ldyBTZXQoW1xyXG4gICAgXCJ7dGVuYW50fVwiLFxyXG4gICAgXCJ7dGVuYW50aWR9XCIsXHJcbiAgICBBQURBdXRob3JpdHlDb25zdGFudHMuQ09NTU9OLFxyXG4gICAgQUFEQXV0aG9yaXR5Q29uc3RhbnRzLkNPTlNVTUVSUyxcclxuICAgIEFBREF1dGhvcml0eUNvbnN0YW50cy5PUkdBTklaQVRJT05TLFxyXG5dKTtcclxuLyoqXHJcbiAqIEV4dHJhY3QgdGVuYW50SWQgZnJvbSBhdXRob3JpdHlcclxuICovXHJcbmZ1bmN0aW9uIGdldFRlbmFudEZyb21BdXRob3JpdHlTdHJpbmcoYXV0aG9yaXR5KSB7XHJcbiAgICBjb25zdCBhdXRob3JpdHlVcmwgPSBuZXcgVXJsU3RyaW5nKGF1dGhvcml0eSk7XHJcbiAgICBjb25zdCBhdXRob3JpdHlVcmxDb21wb25lbnRzID0gYXV0aG9yaXR5VXJsLmdldFVybENvbXBvbmVudHMoKTtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGNyZWRlbnRpYWwgbWF0Y2hpbmcgcHVycG9zZXMsIHRlbmFudElkIGlzIHRoZSBsYXN0IHBhdGggc2VnbWVudCBvZiB0aGUgYXV0aG9yaXR5IFVSTDpcclxuICAgICAqICBBQUQgQXV0aG9yaXR5IC0gZG9tYWluL3RlbmFudElkIC0+IENyZWRlbnRpYWxzIGFyZSBjYWNoZWQgd2l0aCByZWFsbSA9IHRlbmFudElkXHJcbiAgICAgKiAgQjJDIEF1dGhvcml0eSAtIGRvbWFpbi97dGVuYW50SWR9Py8uLi4vcG9saWN5IC0+IENyZWRlbnRpYWxzIGFyZSBjYWNoZWQgd2l0aCByZWFsbSA9IHBvbGljeVxyXG4gICAgICogIHRlbmFudElkIGlzIGRvd25jYXNlZCBiZWNhdXNlIEIyQyBwb2xpY2llcyBjYW4gaGF2ZSBtaXhlZCBjYXNlIGJ1dCB0ZnAgY2xhaW0gaXMgZG93bmNhc2VkXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG1heSBub3QgaGF2ZSBhbnkgcGF0aCBzZWdtZW50cyBpbiBjZXJ0YWluIE9JREMgc2NlbmFyaW9zLlxyXG4gICAgICovXHJcbiAgICBjb25zdCB0ZW5hbnRJZCA9IGF1dGhvcml0eVVybENvbXBvbmVudHMuUGF0aFNlZ21lbnRzLnNsaWNlKC0xKVswXT8udG9Mb3dlckNhc2UoKTtcclxuICAgIHN3aXRjaCAodGVuYW50SWQpIHtcclxuICAgICAgICBjYXNlIEFBREF1dGhvcml0eUNvbnN0YW50cy5DT01NT046XHJcbiAgICAgICAgY2FzZSBBQURBdXRob3JpdHlDb25zdGFudHMuT1JHQU5JWkFUSU9OUzpcclxuICAgICAgICBjYXNlIEFBREF1dGhvcml0eUNvbnN0YW50cy5DT05TVU1FUlM6XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHRlbmFudElkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdEF1dGhvcml0eVVyaShhdXRob3JpdHlVcmkpIHtcclxuICAgIHJldHVybiBhdXRob3JpdHlVcmkuZW5kc1dpdGgoQ29uc3RhbnRzLkZPUldBUkRfU0xBU0gpXHJcbiAgICAgICAgPyBhdXRob3JpdHlVcmlcclxuICAgICAgICA6IGAke2F1dGhvcml0eVVyaX0ke0NvbnN0YW50cy5GT1JXQVJEX1NMQVNIfWA7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRTdGF0aWNBdXRob3JpdHlPcHRpb25zKGF1dGhPcHRpb25zKSB7XHJcbiAgICBjb25zdCByYXdDbG91ZERpc2NvdmVyeU1ldGFkYXRhID0gYXV0aE9wdGlvbnMuY2xvdWREaXNjb3ZlcnlNZXRhZGF0YTtcclxuICAgIGxldCBjbG91ZERpc2NvdmVyeU1ldGFkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKHJhd0Nsb3VkRGlzY292ZXJ5TWV0YWRhdGEpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhID0gSlNPTi5wYXJzZShyYXdDbG91ZERpc2NvdmVyeU1ldGFkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKGludmFsaWRDbG91ZERpc2NvdmVyeU1ldGFkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNhbm9uaWNhbEF1dGhvcml0eTogYXV0aE9wdGlvbnMuYXV0aG9yaXR5XHJcbiAgICAgICAgICAgID8gZm9ybWF0QXV0aG9yaXR5VXJpKGF1dGhPcHRpb25zLmF1dGhvcml0eSlcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbiAgICAgICAga25vd25BdXRob3JpdGllczogYXV0aE9wdGlvbnMua25vd25BdXRob3JpdGllcyxcclxuICAgICAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhOiBjbG91ZERpc2NvdmVyeU1ldGFkYXRhLFxyXG4gICAgfTtcclxufVxuXG5leHBvcnQgeyBBdXRob3JpdHksIGJ1aWxkU3RhdGljQXV0aG9yaXR5T3B0aW9ucywgZm9ybWF0QXV0aG9yaXR5VXJpLCBnZXRUZW5hbnRGcm9tQXV0aG9yaXR5U3RyaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRob3JpdHkubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgbWV0aG9kTm90SW1wbGVtZW50ZWQgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9DUllQVE9fSU1QTEVNRU5UQVRJT04gPSB7XHJcbiAgICBjcmVhdGVOZXdHdWlkOiAoKSA9PiB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH0sXHJcbiAgICBiYXNlNjREZWNvZGU6ICgpID0+IHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfSxcclxuICAgIGJhc2U2NEVuY29kZTogKCkgPT4ge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9LFxyXG4gICAgYmFzZTY0VXJsRW5jb2RlOiAoKSA9PiB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH0sXHJcbiAgICBlbmNvZGVLaWQ6ICgpID0+IHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGdldFB1YmxpY0tleVRodW1icHJpbnQoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH0sXHJcbiAgICBhc3luYyByZW1vdmVUb2tlbkJpbmRpbmdLZXkoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH0sXHJcbiAgICBhc3luYyBjbGVhcktleXN0b3JlKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9LFxyXG4gICAgYXN5bmMgc2lnbkp3dCgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGhhc2hTdHJpbmcoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH0sXHJcbn07XG5cbmV4cG9ydCB7IERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JQ3J5cHRvLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBoZWFkZXIvaGVhZGVyICovXHJcbmNvbnN0IG5hbWUgPSBcIkBhenVyZS9tc2FsLWNvbW1vblwiO1xyXG5jb25zdCB2ZXJzaW9uID0gXCIxNS43LjBcIjtcblxuZXhwb3J0IHsgbmFtZSwgdmVyc2lvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFja2FnZU1ldGFkYXRhLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3IubWpzJztcbmltcG9ydCB7IFN0cmluZ1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMvU3RyaW5nVXRpbHMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBPSURDX1NDT1BFUyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgZW1wdHlJbnB1dFNjb3Blc0Vycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMubWpzJztcbmltcG9ydCB7IGNhbm5vdEFwcGVuZFNjb3BlU2V0LCBjYW5ub3RSZW1vdmVFbXB0eVNjb3BlLCBlbXB0eUlucHV0U2NvcGVTZXQgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBTY29wZVNldCBjbGFzcyBjcmVhdGVzIGEgc2V0IG9mIHNjb3Blcy4gU2NvcGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLCB1bmlxdWUgdmFsdWVzLCBzbyB0aGUgU2V0IG9iamVjdCBpbiBKUyBtYWtlc1xyXG4gKiB0aGUgbW9zdCBzZW5zZSB0byBpbXBsZW1lbnQgZm9yIHRoaXMgY2xhc3MuIEFsbCBzY29wZXMgYXJlIHRyaW1tZWQgYW5kIGNvbnZlcnRlZCB0byBsb3dlciBjYXNlIHN0cmluZ3MgaW4gaW50ZXJzZWN0aW9uIGFuZCB1bmlvbiBmdW5jdGlvbnNcclxuICogdG8gZW5zdXJlIHVuaXF1ZW5lc3Mgb2Ygc3RyaW5ncy5cclxuICovXHJcbmNsYXNzIFNjb3BlU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGlucHV0U2NvcGVzKSB7XHJcbiAgICAgICAgLy8gRmlsdGVyIGVtcHR5IHN0cmluZyBhbmQgbnVsbC91bmRlZmluZWQgYXJyYXkgaXRlbXNcclxuICAgICAgICBjb25zdCBzY29wZUFyciA9IGlucHV0U2NvcGVzXHJcbiAgICAgICAgICAgID8gU3RyaW5nVXRpbHMudHJpbUFycmF5RW50cmllcyhbLi4uaW5wdXRTY29wZXNdKVxyXG4gICAgICAgICAgICA6IFtdO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkSW5wdXQgPSBzY29wZUFyclxyXG4gICAgICAgICAgICA/IFN0cmluZ1V0aWxzLnJlbW92ZUVtcHR5U3RyaW5nc0Zyb21BcnJheShzY29wZUFycilcclxuICAgICAgICAgICAgOiBbXTtcclxuICAgICAgICAvLyBDaGVjayBpZiBzY29wZXMgYXJyYXkgaGFzIGF0IGxlYXN0IG9uZSBtZW1iZXJcclxuICAgICAgICBpZiAoIWZpbHRlcmVkSW5wdXQgfHwgIWZpbHRlcmVkSW5wdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihlbXB0eUlucHV0U2NvcGVzRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjb3BlcyA9IG5ldyBTZXQoKTsgLy8gSXRlcmF0b3IgaW4gY29uc3RydWN0b3Igbm90IHN1cHBvcnRlZCBieSBJRTExXHJcbiAgICAgICAgZmlsdGVyZWRJbnB1dC5mb3JFYWNoKChzY29wZSkgPT4gdGhpcy5zY29wZXMuYWRkKHNjb3BlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBTY29wZVNldCBmcm9tIHNwYWNlLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBpbnB1dFNjb3BlU3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gYXBwQ2xpZW50SWRcclxuICAgICAqIEBwYXJhbSBzY29wZXNSZXF1aXJlZFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVN0cmluZyhpbnB1dFNjb3BlU3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc2NvcGVTdHJpbmcgPSBpbnB1dFNjb3BlU3RyaW5nIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XHJcbiAgICAgICAgY29uc3QgaW5wdXRTY29wZXMgPSBzY29wZVN0cmluZy5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTY29wZVNldChpbnB1dFNjb3Blcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHNldCBvZiBzY29wZXMgdG8gc2VhcmNoIGZvciBpbiBjYWNoZSBsb29rdXBzXHJcbiAgICAgKiBAcGFyYW0gaW5wdXRTY29wZVN0cmluZ1xyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVNlYXJjaFNjb3BlcyhpbnB1dFNjb3BlU3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc2NvcGVTZXQgPSBuZXcgU2NvcGVTZXQoaW5wdXRTY29wZVN0cmluZyk7XHJcbiAgICAgICAgaWYgKCFzY29wZVNldC5jb250YWluc09ubHlPSURDU2NvcGVzKCkpIHtcclxuICAgICAgICAgICAgc2NvcGVTZXQucmVtb3ZlT0lEQ1Njb3BlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2NvcGVTZXQucmVtb3ZlU2NvcGUoQ29uc3RhbnRzLk9GRkxJTkVfQUNDRVNTX1NDT1BFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjb3BlU2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIGdpdmVuIHNjb3BlIGlzIHByZXNlbnQgaW4gdGhpcyBzZXQgb2Ygc2NvcGVzLlxyXG4gICAgICogQHBhcmFtIHNjb3BlXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zU2NvcGUoc2NvcGUpIHtcclxuICAgICAgICBjb25zdCBsb3dlckNhc2VTY29wZXMgPSB0aGlzLnByaW50U2NvcGVzTG93ZXJDYXNlKCkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZVNjb3Blc1NldCA9IG5ldyBTY29wZVNldChsb3dlckNhc2VTY29wZXMpO1xyXG4gICAgICAgIC8vIGNvbXBhcmUgbG93ZXJjYXNlIHNjb3Blc1xyXG4gICAgICAgIHJldHVybiBzY29wZVxyXG4gICAgICAgICAgICA/IGxvd2VyQ2FzZVNjb3Blc1NldC5zY29wZXMuaGFzKHNjb3BlLnRvTG93ZXJDYXNlKCkpXHJcbiAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgc2V0IG9mIHNjb3BlcyBpcyBwcmVzZW50IGluIHRoaXMgc2V0IG9mIHNjb3Blcy5cclxuICAgICAqIEBwYXJhbSBzY29wZVNldFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1Njb3BlU2V0KHNjb3BlU2V0KSB7XHJcbiAgICAgICAgaWYgKCFzY29wZVNldCB8fCBzY29wZVNldC5zY29wZXMuc2l6ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNjb3Blcy5zaXplID49IHNjb3BlU2V0LnNjb3Blcy5zaXplICYmXHJcbiAgICAgICAgICAgIHNjb3BlU2V0LmFzQXJyYXkoKS5ldmVyeSgoc2NvcGUpID0+IHRoaXMuY29udGFpbnNTY29wZShzY29wZSkpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgc2V0IG9mIHNjb3BlcyBjb250YWlucyBvbmx5IHRoZSBkZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBjb250YWluc09ubHlPSURDU2NvcGVzKCkge1xyXG4gICAgICAgIGxldCBkZWZhdWx0U2NvcGVDb3VudCA9IDA7XHJcbiAgICAgICAgT0lEQ19TQ09QRVMuZm9yRWFjaCgoZGVmYXVsdFNjb3BlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zU2NvcGUoZGVmYXVsdFNjb3BlKSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFNjb3BlQ291bnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5zaXplID09PSBkZWZhdWx0U2NvcGVDb3VudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBzaW5nbGUgc2NvcGUgaWYgcGFzc2VkXHJcbiAgICAgKiBAcGFyYW0gbmV3U2NvcGVcclxuICAgICAqL1xyXG4gICAgYXBwZW5kU2NvcGUobmV3U2NvcGUpIHtcclxuICAgICAgICBpZiAobmV3U2NvcGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zY29wZXMuYWRkKG5ld1Njb3BlLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIG11bHRpcGxlIHNjb3BlcyBpZiBwYXNzZWRcclxuICAgICAqIEBwYXJhbSBuZXdTY29wZXNcclxuICAgICAqL1xyXG4gICAgYXBwZW5kU2NvcGVzKG5ld1Njb3Blcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG5ld1Njb3Blcy5mb3JFYWNoKChuZXdTY29wZSkgPT4gdGhpcy5hcHBlbmRTY29wZShuZXdTY29wZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoY2Fubm90QXBwZW5kU2NvcGVTZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBlbGVtZW50IGZyb20gc2V0IG9mIHNjb3Blcy5cclxuICAgICAqIEBwYXJhbSBzY29wZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVTY29wZShzY29wZSkge1xyXG4gICAgICAgIGlmICghc2NvcGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGNhbm5vdFJlbW92ZUVtcHR5U2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjb3Blcy5kZWxldGUoc2NvcGUudHJpbSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBkZWZhdWx0IHNjb3BlcyBmcm9tIHNldCBvZiBzY29wZXNcclxuICAgICAqIFByaW1hcmlseSB1c2VkIHRvIHByZXZlbnQgY2FjaGUgbWlzc2VzIGlmIHRoZSBkZWZhdWx0IHNjb3BlcyBhcmUgbm90IHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICByZW1vdmVPSURDU2NvcGVzKCkge1xyXG4gICAgICAgIE9JRENfU0NPUEVTLmZvckVhY2goKGRlZmF1bHRTY29wZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNjb3Blcy5kZWxldGUoZGVmYXVsdFNjb3BlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZXMgYW4gYXJyYXkgb2Ygc2NvcGVzIHdpdGggdGhlIGN1cnJlbnQgc2V0IG9mIHNjb3Blcy5cclxuICAgICAqIEBwYXJhbSBvdGhlclNjb3Blc1xyXG4gICAgICovXHJcbiAgICB1bmlvblNjb3BlU2V0cyhvdGhlclNjb3Blcykge1xyXG4gICAgICAgIGlmICghb3RoZXJTY29wZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGVtcHR5SW5wdXRTY29wZVNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuaW9uU2NvcGVzID0gbmV3IFNldCgpOyAvLyBJdGVyYXRvciBpbiBjb25zdHJ1Y3RvciBub3Qgc3VwcG9ydGVkIGluIElFMTFcclxuICAgICAgICBvdGhlclNjb3Blcy5zY29wZXMuZm9yRWFjaCgoc2NvcGUpID0+IHVuaW9uU2NvcGVzLmFkZChzY29wZS50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgICAgICAgdGhpcy5zY29wZXMuZm9yRWFjaCgoc2NvcGUpID0+IHVuaW9uU2NvcGVzLmFkZChzY29wZS50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgICAgICAgcmV0dXJuIHVuaW9uU2NvcGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBzY29wZXMgaW50ZXJzZWN0IGJldHdlZW4gdGhpcyBzZXQgYW5kIGFub3RoZXIuXHJcbiAgICAgKiBAcGFyYW0gb3RoZXJTY29wZXNcclxuICAgICAqL1xyXG4gICAgaW50ZXJzZWN0aW5nU2NvcGVTZXRzKG90aGVyU2NvcGVzKSB7XHJcbiAgICAgICAgaWYgKCFvdGhlclNjb3Blcykge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoZW1wdHlJbnB1dFNjb3BlU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IE9JREMgc2NvcGVzIHRvIGJlIHRoZSBvbmx5IGludGVyc2VjdGluZyBzY29wZXNcclxuICAgICAgICBpZiAoIW90aGVyU2NvcGVzLmNvbnRhaW5zT25seU9JRENTY29wZXMoKSkge1xyXG4gICAgICAgICAgICBvdGhlclNjb3Blcy5yZW1vdmVPSURDU2NvcGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVuaW9uU2NvcGVzID0gdGhpcy51bmlvblNjb3BlU2V0cyhvdGhlclNjb3Blcyk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZU90aGVyU2NvcGVzID0gb3RoZXJTY29wZXMuZ2V0U2NvcGVDb3VudCgpO1xyXG4gICAgICAgIGNvbnN0IHNpemVUaGlzU2NvcGVzID0gdGhpcy5nZXRTY29wZUNvdW50KCk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZVVuaW9uU2NvcGVzID0gdW5pb25TY29wZXMuc2l6ZTtcclxuICAgICAgICByZXR1cm4gc2l6ZVVuaW9uU2NvcGVzIDwgc2l6ZVRoaXNTY29wZXMgKyBzaXplT3RoZXJTY29wZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgc2l6ZSBvZiBzZXQgb2Ygc2NvcGVzLlxyXG4gICAgICovXHJcbiAgICBnZXRTY29wZUNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzY29wZXMgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nIHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBhc0FycmF5KCkge1xyXG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICAgICAgdGhpcy5zY29wZXMuZm9yRWFjaCgodmFsKSA9PiBhcnJheS5wdXNoKHZhbCkpO1xyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJpbnRzIHNjb3BlcyBpbnRvIGEgc3BhY2UtZGVsaW1pdGVkIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBwcmludFNjb3BlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NvcGVBcnIgPSB0aGlzLmFzQXJyYXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlQXJyLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ29uc3RhbnRzLkVNUFRZX1NUUklORztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJpbnRzIHNjb3BlcyBpbnRvIGEgc3BhY2UtZGVsaW1pdGVkIGxvd2VyLWNhc2Ugc3RyaW5nICh1c2VkIGZvciBjYWNoaW5nKVxyXG4gICAgICovXHJcbiAgICBwcmludFNjb3Blc0xvd2VyQ2FzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmludFNjb3BlcygpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgU2NvcGVTZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjb3BlU2V0Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IFNlcGFyYXRvcnMsIENvbnN0YW50cyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgY2xpZW50SW5mb0VtcHR5RXJyb3IsIGNsaWVudEluZm9EZWNvZGluZ0Vycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yQ29kZXMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0byBidWlsZCBhIGNsaWVudCBpbmZvIG9iamVjdCBmcm9tIHNlcnZlciBjbGllbnRJbmZvIHN0cmluZ1xyXG4gKiBAcGFyYW0gcmF3Q2xpZW50SW5mb1xyXG4gKiBAcGFyYW0gY3J5cHRvXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZENsaWVudEluZm8ocmF3Q2xpZW50SW5mbywgYmFzZTY0RGVjb2RlKSB7XHJcbiAgICBpZiAoIXJhd0NsaWVudEluZm8pIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoY2xpZW50SW5mb0VtcHR5RXJyb3IpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkZWNvZGVkQ2xpZW50SW5mbyA9IGJhc2U2NERlY29kZShyYXdDbGllbnRJbmZvKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkQ2xpZW50SW5mbyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihjbGllbnRJbmZvRGVjb2RpbmdFcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIHRvIGJ1aWxkIGEgY2xpZW50IGluZm8gb2JqZWN0IGZyb20gY2FjaGVkIGhvbWVBY2NvdW50SWQgc3RyaW5nXHJcbiAqIEBwYXJhbSBob21lQWNjb3VudElkXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZChob21lQWNjb3VudElkKSB7XHJcbiAgICBpZiAoIWhvbWVBY2NvdW50SWQpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoY2xpZW50SW5mb0RlY29kaW5nRXJyb3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2xpZW50SW5mb1BhcnRzID0gaG9tZUFjY291bnRJZC5zcGxpdChTZXBhcmF0b3JzLkNMSUVOVF9JTkZPX1NFUEFSQVRPUiwgMik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVpZDogY2xpZW50SW5mb1BhcnRzWzBdLFxyXG4gICAgICAgIHV0aWQ6IGNsaWVudEluZm9QYXJ0cy5sZW5ndGggPCAyXHJcbiAgICAgICAgICAgID8gQ29uc3RhbnRzLkVNUFRZX1NUUklOR1xyXG4gICAgICAgICAgICA6IGNsaWVudEluZm9QYXJ0c1sxXSxcclxuICAgIH07XHJcbn1cblxuZXhwb3J0IHsgYnVpbGRDbGllbnRJbmZvLCBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xpZW50SW5mby5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGVuYW50SWQgbWF0Y2hlcyB0aGUgdXRpZCBwb3J0aW9uIG9mIGhvbWVBY2NvdW50SWRcclxuICogQHBhcmFtIHRlbmFudElkXHJcbiAqIEBwYXJhbSBob21lQWNjb3VudElkXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiB0ZW5hbnRJZE1hdGNoZXNIb21lVGVuYW50KHRlbmFudElkLCBob21lQWNjb3VudElkKSB7XHJcbiAgICByZXR1cm4gKCEhdGVuYW50SWQgJiZcclxuICAgICAgICAhIWhvbWVBY2NvdW50SWQgJiZcclxuICAgICAgICB0ZW5hbnRJZCA9PT0gaG9tZUFjY291bnRJZC5zcGxpdChcIi5cIilbMV0pO1xyXG59XHJcbi8qKlxyXG4gKiBCdWlsZCB0ZW5hbnQgcHJvZmlsZVxyXG4gKiBAcGFyYW0gaG9tZUFjY291bnRJZCAtIEhvbWUgYWNjb3VudCBpZGVudGlmaWVyIGZvciB0aGlzIGFjY291bnQgb2JqZWN0XHJcbiAqIEBwYXJhbSBsb2NhbEFjY291bnRJZCAtIExvY2FsIGFjY291bnQgaWRlbnRpZmVyIGZvciB0aGlzIGFjY291bnQgb2JqZWN0XHJcbiAqIEBwYXJhbSB0ZW5hbnRJZCAtIEZ1bGwgdGVuYW50IG9yIG9yZ2FuaXphdGlvbmFsIGlkIHRoYXQgdGhpcyBhY2NvdW50IGJlbG9uZ3MgdG9cclxuICogQHBhcmFtIGlkVG9rZW5DbGFpbXMgLSBDbGFpbXMgZnJvbSB0aGUgSUQgdG9rZW5cclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkVGVuYW50UHJvZmlsZShob21lQWNjb3VudElkLCBsb2NhbEFjY291bnRJZCwgdGVuYW50SWQsIGlkVG9rZW5DbGFpbXMpIHtcclxuICAgIGlmIChpZFRva2VuQ2xhaW1zKSB7XHJcbiAgICAgICAgY29uc3QgeyBvaWQsIHN1YiwgdGlkLCBuYW1lLCB0ZnAsIGFjciB9ID0gaWRUb2tlbkNsYWltcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhdXRob3JpdHkgaXMgQUFEIG9yIEIyQywgd2UgZXhoYXVzdCBhbGwgdGhlIHBvc3NpYmxlIGNsYWltcyB0aGF0IGNhbiBzZXJ2ZSBhcyB0ZW5hbnQgSUQgd2l0aCB0aGUgZm9sbG93aW5nIHByZWNlZGVuY2U6XHJcbiAgICAgICAgICogdGlkIC0gVGVuYW50SUQgY2xhaW0gdGhhdCBpZGVudGlmaWVzIHRoZSB0ZW5hbnQgdGhhdCBpc3N1ZWQgdGhlIHRva2VuIGluIEFBRC4gRXhwZWN0ZWQgaW4gYWxsIEFBRCBJRCB0b2tlbnMsIG5vdCBwcmVzZW50IGluIEIyQyBJRCBUb2tlbnMuXHJcbiAgICAgICAgICogdGZwIC0gVHJ1c3QgRnJhbWV3b3JrIFBvbGljeSBjbGFpbSB0aGF0IGlkZW50aWZpZXMgdGhlIHBvbGljeSB0aGF0IHdhcyB1c2VkIHRvIGF1dGhlbnRpY2F0ZSB0aGUgdXNlci4gRnVuY3Rpb25zIGFzIHRlbmFudCBmb3IgQjJDIHNjZW5hcmlvcy5cclxuICAgICAgICAgKiBhY3IgLSBBdXRoZW50aWNhdGlvbiBDb250ZXh0IENsYXNzIFJlZmVyZW5jZSBjbGFpbSB1c2VkIG9ubHkgd2l0aCBvbGRlciBCMkMgcG9saWNpZXMuIEZhbGxiYWNrIGluIGNhc2UgdGZwIGlzIG5vdCBwcmVzZW50LCBidXQgbGlrZWx5IHdvbid0IGJlIHByZXNlbnQgYW55d2F5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gdGlkIHx8IHRmcCB8fCBhY3IgfHwgXCJcIjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZW5hbnRJZDogdGVuYW50SWQsXHJcbiAgICAgICAgICAgIGxvY2FsQWNjb3VudElkOiBvaWQgfHwgc3ViIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIGlzSG9tZVRlbmFudDogdGVuYW50SWRNYXRjaGVzSG9tZVRlbmFudCh0ZW5hbnRJZCwgaG9tZUFjY291bnRJZCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRlbmFudElkLFxyXG4gICAgICAgICAgICBsb2NhbEFjY291bnRJZCxcclxuICAgICAgICAgICAgaXNIb21lVGVuYW50OiB0ZW5hbnRJZE1hdGNoZXNIb21lVGVuYW50KHRlbmFudElkLCBob21lQWNjb3VudElkKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBhY2NvdW50IGluZm8gdGhhdCB2YXJpZXMgYnkgdGVuYW50IHByb2ZpbGUgc291cmNlZCBmcm9tIHRoZSBJRCB0b2tlbiBjbGFpbXMgcGFzc2VkIGluIHdpdGggdGhlIHRlbmFudC1zcGVjaWZpYyBhY2NvdW50IGluZm9cclxuICogQHBhcmFtIGJhc2VBY2NvdW50SW5mb1xyXG4gKiBAcGFyYW0gaWRUb2tlbkNsYWltc1xyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlQWNjb3VudFRlbmFudFByb2ZpbGVEYXRhKGJhc2VBY2NvdW50SW5mbywgdGVuYW50UHJvZmlsZSwgaWRUb2tlbkNsYWltcywgaWRUb2tlblNlY3JldCkge1xyXG4gICAgbGV0IHVwZGF0ZWRBY2NvdW50SW5mbyA9IGJhc2VBY2NvdW50SW5mbztcclxuICAgIC8vIFRlbmFudCBQcm9maWxlIG92ZXJyaWRlcyBwYXNzZWQgaW4gYWNjb3VudCBpbmZvXHJcbiAgICBpZiAodGVuYW50UHJvZmlsZSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgICAgICBjb25zdCB7IGlzSG9tZVRlbmFudCwgLi4udGVuYW50UHJvZmlsZU92ZXJyaWRlIH0gPSB0ZW5hbnRQcm9maWxlO1xyXG4gICAgICAgIHVwZGF0ZWRBY2NvdW50SW5mbyA9IHsgLi4uYmFzZUFjY291bnRJbmZvLCAuLi50ZW5hbnRQcm9maWxlT3ZlcnJpZGUgfTtcclxuICAgIH1cclxuICAgIC8vIElEIHRva2VuIGNsYWltcyBvdmVycmlkZSBwYXNzZWQgaW4gYWNjb3VudCBpbmZvIGFuZCB0ZW5hbnQgcHJvZmlsZVxyXG4gICAgaWYgKGlkVG9rZW5DbGFpbXMpIHtcclxuICAgICAgICAvLyBJZ25vcmUgaXNIb21lVGVuYW50LCBsb2dpbkhpbnQsIGFuZCBzaWQgd2hpY2ggYXJlIHBhcnQgb2YgdGVuYW50IHByb2ZpbGUgYnV0IG5vdCBiYXNlIGFjY291bnQgaW5mb1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgICAgICBjb25zdCB7IGlzSG9tZVRlbmFudCwgLi4uY2xhaW1zU291cmNlZFRlbmFudFByb2ZpbGUgfSA9IGJ1aWxkVGVuYW50UHJvZmlsZShiYXNlQWNjb3VudEluZm8uaG9tZUFjY291bnRJZCwgYmFzZUFjY291bnRJbmZvLmxvY2FsQWNjb3VudElkLCBiYXNlQWNjb3VudEluZm8udGVuYW50SWQsIGlkVG9rZW5DbGFpbXMpO1xyXG4gICAgICAgIHVwZGF0ZWRBY2NvdW50SW5mbyA9IHtcclxuICAgICAgICAgICAgLi4udXBkYXRlZEFjY291bnRJbmZvLFxyXG4gICAgICAgICAgICAuLi5jbGFpbXNTb3VyY2VkVGVuYW50UHJvZmlsZSxcclxuICAgICAgICAgICAgaWRUb2tlbkNsYWltczogaWRUb2tlbkNsYWltcyxcclxuICAgICAgICAgICAgaWRUb2tlbjogaWRUb2tlblNlY3JldCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVkQWNjb3VudEluZm87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXBkYXRlZEFjY291bnRJbmZvO1xyXG59XG5cbmV4cG9ydCB7IGJ1aWxkVGVuYW50UHJvZmlsZSwgdGVuYW50SWRNYXRjaGVzSG9tZVRlbmFudCwgdXBkYXRlQWNjb3VudFRlbmFudFByb2ZpbGVEYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2NvdW50SW5mby5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBHZXRzIHRlbmFudElkIGZyb20gYXZhaWxhYmxlIElEIHRva2VuIGNsYWltcyB0byBzZXQgYXMgY3JlZGVudGlhbCByZWFsbSB3aXRoIHRoZSBmb2xsb3dpbmcgcHJlY2VkZW5jZTpcclxuICogMS4gdGlkIC0gaWYgdGhlIHRva2VuIGlzIGFjcXVpcmVkIGZyb20gYW4gQXp1cmUgQUQgdGVuYW50IHRpZCB3aWxsIGJlIHByZXNlbnRcclxuICogMi4gdGZwIC0gaWYgdGhlIHRva2VuIGlzIGFjcXVpcmVkIGZyb20gYSBtb2Rlcm4gQjJDIHRlbmFudCB0ZnAgc2hvdWxkIGJlIHByZXNlbnRcclxuICogMy4gYWNyIC0gaWYgdGhlIHRva2VuIGlzIGFjcXVpcmVkIGZyb20gYSBsZWdhY3kgQjJDIHRlbmFudCBhY3Igc2hvdWxkIGJlIHByZXNlbnRcclxuICogRG93bmNhc2VkIHRvIG1hdGNoIHRoZSByZWFsbSBjYXNlLWluc2Vuc2l0aXZlIGNvbXBhcmlzb24gcmVxdWlyZW1lbnRzXHJcbiAqIEBwYXJhbSBpZFRva2VuQ2xhaW1zXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUZW5hbnRJZEZyb21JZFRva2VuQ2xhaW1zKGlkVG9rZW5DbGFpbXMpIHtcclxuICAgIGlmIChpZFRva2VuQ2xhaW1zKSB7XHJcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBpZFRva2VuQ2xhaW1zLnRpZCB8fCBpZFRva2VuQ2xhaW1zLnRmcCB8fCBpZFRva2VuQ2xhaW1zLmFjcjtcclxuICAgICAgICByZXR1cm4gdGVuYW50SWQgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XG5cbmV4cG9ydCB7IGdldFRlbmFudElkRnJvbUlkVG9rZW5DbGFpbXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2VuQ2xhaW1zLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBTZXBhcmF0b3JzLCBDYWNoZUFjY291bnRUeXBlIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyBidWlsZENsaWVudEluZm8gfSBmcm9tICcuLi8uLi9hY2NvdW50L0NsaWVudEluZm8ubWpzJztcbmltcG9ydCB7IGJ1aWxkVGVuYW50UHJvZmlsZSB9IGZyb20gJy4uLy4uL2FjY291bnQvQWNjb3VudEluZm8ubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgQXV0aG9yaXR5VHlwZSB9IGZyb20gJy4uLy4uL2F1dGhvcml0eS9BdXRob3JpdHlUeXBlLm1qcyc7XG5pbXBvcnQgeyBnZXRUZW5hbnRJZEZyb21JZFRva2VuQ2xhaW1zIH0gZnJvbSAnLi4vLi4vYWNjb3VudC9Ub2tlbkNsYWltcy5tanMnO1xuaW1wb3J0IHsgUHJvdG9jb2xNb2RlIH0gZnJvbSAnLi4vLi4vYXV0aG9yaXR5L1Byb3RvY29sTW9kZS5tanMnO1xuaW1wb3J0IHsgaW52YWxpZENhY2hlRW52aXJvbm1lbnQgfSBmcm9tICcuLi8uLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFR5cGUgdGhhdCBkZWZpbmVzIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBhbiBBY2NvdW50IGZpZWxkIChiYXNlZCBvbiB1bml2ZXJzYWwgY2FjaGUgc2NoZW1hIGltcGxlbWVudGVkIGJ5IGFsbCBNU0FMcykuXHJcbiAqXHJcbiAqIEtleSA6IFZhbHVlIFNjaGVtYVxyXG4gKlxyXG4gKiBLZXk6IDxob21lX2FjY291bnRfaWQ+LTxlbnZpcm9ubWVudD4tPHJlYWxtKj5cclxuICpcclxuICogVmFsdWUgU2NoZW1hOlxyXG4gKiB7XHJcbiAqICAgICAgaG9tZUFjY291bnRJZDogaG9tZSBhY2NvdW50IGlkZW50aWZpZXIgZm9yIHRoZSBhdXRoIHNjaGVtZSxcclxuICogICAgICBlbnZpcm9ubWVudDogZW50aXR5IHRoYXQgaXNzdWVkIHRoZSB0b2tlbiwgcmVwcmVzZW50ZWQgYXMgYSBmdWxsIGhvc3RcclxuICogICAgICByZWFsbTogRnVsbCB0ZW5hbnQgb3Igb3JnYW5pemF0aW9uYWwgaWRlbnRpZmllciB0aGF0IHRoZSBhY2NvdW50IGJlbG9uZ3MgdG9cclxuICogICAgICBsb2NhbEFjY291bnRJZDogT3JpZ2luYWwgdGVuYW50LXNwZWNpZmljIGFjY291bnRJRCwgdXN1YWxseSB1c2VkIGZvciBsZWdhY3kgY2FzZXNcclxuICogICAgICB1c2VybmFtZTogcHJpbWFyeSB1c2VybmFtZSB0aGF0IHJlcHJlc2VudHMgdGhlIHVzZXIsIHVzdWFsbHkgY29ycmVzcG9uZHMgdG8gcHJlZmVycmVkX3VzZXJuYW1lIGluIHRoZSB2MiBlbmRwdFxyXG4gKiAgICAgIGF1dGhvcml0eVR5cGU6IEFjY291bnRzIGF1dGhvcml0eSB0eXBlIGFzIGEgc3RyaW5nXHJcbiAqICAgICAgbmFtZTogRnVsbCBuYW1lIGZvciB0aGUgYWNjb3VudCwgaW5jbHVkaW5nIGdpdmVuIG5hbWUgYW5kIGZhbWlseSBuYW1lLFxyXG4gKiAgICAgIGxhc3RNb2RpZmljYXRpb25UaW1lOiBsYXN0IHRpbWUgdGhpcyBlbnRpdHkgd2FzIG1vZGlmaWVkIGluIHRoZSBjYWNoZVxyXG4gKiAgICAgIGxhc3RNb2RpZmljYXRpb25BcHA6XHJcbiAqICAgICAgbmF0aXZlQWNjb3VudElkOiBBY2NvdW50IGlkZW50aWZpZXIgb24gdGhlIG5hdGl2ZSBkZXZpY2VcclxuICogICAgICB0ZW5hbnRQcm9maWxlczogQXJyYXkgb2YgdGVuYW50IHByb2ZpbGUgb2JqZWN0cyBmb3IgZWFjaCB0ZW5hbnQgdGhhdCB0aGUgYWNjb3VudCBoYXMgYXV0aGVudGljYXRlZCB3aXRoIGluIHRoZSBicm93c2VyXHJcbiAqIH1cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBBY2NvdW50RW50aXR5IHtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgQWNjb3VudCBJZCBrZXkgY29tcG9uZW50IGFzIHBlciB0aGUgc2NoZW1hOiA8aG9tZV9hY2NvdW50X2lkPi08ZW52aXJvbm1lbnQ+XHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlQWNjb3VudElkKCkge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IFt0aGlzLmhvbWVBY2NvdW50SWQsIHRoaXMuZW52aXJvbm1lbnRdO1xyXG4gICAgICAgIHJldHVybiBhY2NvdW50SWQuam9pbihTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1IpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIEFjY291bnQgQ2FjaGUgS2V5IGFzIHBlciB0aGUgc2NoZW1hOiA8aG9tZV9hY2NvdW50X2lkPi08ZW52aXJvbm1lbnQ+LTxyZWFsbSo+XHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlQWNjb3VudEtleSgpIHtcclxuICAgICAgICByZXR1cm4gQWNjb3VudEVudGl0eS5nZW5lcmF0ZUFjY291bnRDYWNoZUtleSh7XHJcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHRoaXMuaG9tZUFjY291bnRJZCxcclxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICAgIHRlbmFudElkOiB0aGlzLnJlYWxtLFxyXG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcclxuICAgICAgICAgICAgbG9jYWxBY2NvdW50SWQ6IHRoaXMubG9jYWxBY2NvdW50SWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIEFjY291bnRJbmZvIGludGVyZmFjZSBmb3IgdGhpcyBhY2NvdW50LlxyXG4gICAgICovXHJcbiAgICBnZXRBY2NvdW50SW5mbygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBob21lQWNjb3VudElkOiB0aGlzLmhvbWVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgIGVudmlyb25tZW50OiB0aGlzLmVudmlyb25tZW50LFxyXG4gICAgICAgICAgICB0ZW5hbnRJZDogdGhpcy5yZWFsbSxcclxuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXHJcbiAgICAgICAgICAgIGxvY2FsQWNjb3VudElkOiB0aGlzLmxvY2FsQWNjb3VudElkLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG5hdGl2ZUFjY291bnRJZDogdGhpcy5uYXRpdmVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgIGF1dGhvcml0eVR5cGU6IHRoaXMuYXV0aG9yaXR5VHlwZSxcclxuICAgICAgICAgICAgLy8gRGVzZXJpYWxpemUgdGVuYW50IHByb2ZpbGVzIGFycmF5IGludG8gYSBNYXBcclxuICAgICAgICAgICAgdGVuYW50UHJvZmlsZXM6IG5ldyBNYXAoKHRoaXMudGVuYW50UHJvZmlsZXMgfHwgW10pLm1hcCgodGVuYW50UHJvZmlsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0ZW5hbnRQcm9maWxlLnRlbmFudElkLCB0ZW5hbnRQcm9maWxlXTtcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWNjb3VudCBlbnRpdHkgaXMgaW4gc2luZ2xlIHRlbmFudCBmb3JtYXQgKG91dGRhdGVkKSwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGlzU2luZ2xlVGVuYW50KCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy50ZW5hbnRQcm9maWxlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGFjY291bnQga2V5IGZyb20gaW50ZXJmYWNlXHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudEludGVyZmFjZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVBY2NvdW50Q2FjaGVLZXkoYWNjb3VudEludGVyZmFjZSkge1xyXG4gICAgICAgIGNvbnN0IGhvbWVUZW5hbnRJZCA9IGFjY291bnRJbnRlcmZhY2UuaG9tZUFjY291bnRJZC5zcGxpdChcIi5cIilbMV07XHJcbiAgICAgICAgY29uc3QgYWNjb3VudEtleSA9IFtcclxuICAgICAgICAgICAgYWNjb3VudEludGVyZmFjZS5ob21lQWNjb3VudElkLFxyXG4gICAgICAgICAgICBhY2NvdW50SW50ZXJmYWNlLmVudmlyb25tZW50IHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGhvbWVUZW5hbnRJZCB8fCBhY2NvdW50SW50ZXJmYWNlLnRlbmFudElkIHx8IFwiXCIsXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gYWNjb3VudEtleS5qb2luKFNlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUikudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgQWNjb3VudCBjYWNoZSBmcm9tIElkVG9rZW4sIGNsaWVudEluZm8gYW5kIGF1dGhvcml0eS9wb2xpY3kuIEFzc29jaWF0ZWQgd2l0aCBBQUQuXHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudERldGFpbHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUFjY291bnQoYWNjb3VudERldGFpbHMsIGF1dGhvcml0eSwgYmFzZTY0RGVjb2RlKSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50RW50aXR5KCk7XHJcbiAgICAgICAgaWYgKGF1dGhvcml0eS5hdXRob3JpdHlUeXBlID09PSBBdXRob3JpdHlUeXBlLkFkZnMpIHtcclxuICAgICAgICAgICAgYWNjb3VudC5hdXRob3JpdHlUeXBlID0gQ2FjaGVBY2NvdW50VHlwZS5BREZTX0FDQ09VTlRfVFlQRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXV0aG9yaXR5LnByb3RvY29sTW9kZSA9PT0gUHJvdG9jb2xNb2RlLk9JREMpIHtcclxuICAgICAgICAgICAgYWNjb3VudC5hdXRob3JpdHlUeXBlID0gQ2FjaGVBY2NvdW50VHlwZS5HRU5FUklDX0FDQ09VTlRfVFlQRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFjY291bnQuYXV0aG9yaXR5VHlwZSA9IENhY2hlQWNjb3VudFR5cGUuTVNTVFNfQUNDT1VOVF9UWVBFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY2xpZW50SW5mbztcclxuICAgICAgICBpZiAoYWNjb3VudERldGFpbHMuY2xpZW50SW5mbyAmJiBiYXNlNjREZWNvZGUpIHtcclxuICAgICAgICAgICAgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mbyhhY2NvdW50RGV0YWlscy5jbGllbnRJbmZvLCBiYXNlNjREZWNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY2NvdW50LmNsaWVudEluZm8gPSBhY2NvdW50RGV0YWlscy5jbGllbnRJbmZvO1xyXG4gICAgICAgIGFjY291bnQuaG9tZUFjY291bnRJZCA9IGFjY291bnREZXRhaWxzLmhvbWVBY2NvdW50SWQ7XHJcbiAgICAgICAgYWNjb3VudC5uYXRpdmVBY2NvdW50SWQgPSBhY2NvdW50RGV0YWlscy5uYXRpdmVBY2NvdW50SWQ7XHJcbiAgICAgICAgY29uc3QgZW52ID0gYWNjb3VudERldGFpbHMuZW52aXJvbm1lbnQgfHxcclxuICAgICAgICAgICAgKGF1dGhvcml0eSAmJiBhdXRob3JpdHkuZ2V0UHJlZmVycmVkQ2FjaGUoKSk7XHJcbiAgICAgICAgaWYgKCFlbnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGludmFsaWRDYWNoZUVudmlyb25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWNjb3VudC5lbnZpcm9ubWVudCA9IGVudjtcclxuICAgICAgICAvLyBub24gQUFEIHNjZW5hcmlvcyBjYW4gaGF2ZSBlbXB0eSByZWFsbVxyXG4gICAgICAgIGFjY291bnQucmVhbG0gPVxyXG4gICAgICAgICAgICBjbGllbnRJbmZvPy51dGlkIHx8XHJcbiAgICAgICAgICAgICAgICBnZXRUZW5hbnRJZEZyb21JZFRva2VuQ2xhaW1zKGFjY291bnREZXRhaWxzLmlkVG9rZW5DbGFpbXMpIHx8XHJcbiAgICAgICAgICAgICAgICBcIlwiO1xyXG4gICAgICAgIC8vIEhvdyBkbyB5b3UgYWNjb3VudCBmb3IgTVNBIENJRCBoZXJlP1xyXG4gICAgICAgIGFjY291bnQubG9jYWxBY2NvdW50SWQgPVxyXG4gICAgICAgICAgICBjbGllbnRJbmZvPy51aWQgfHxcclxuICAgICAgICAgICAgICAgIGFjY291bnREZXRhaWxzLmlkVG9rZW5DbGFpbXM/Lm9pZCB8fFxyXG4gICAgICAgICAgICAgICAgYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltcz8uc3ViIHx8XHJcbiAgICAgICAgICAgICAgICBcIlwiO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogSW4gQjJDIHNjZW5hcmlvcyB0aGUgZW1haWxzIGNsYWltIGlzIHVzZWQgaW5zdGVhZCBvZiBwcmVmZXJyZWRfdXNlcm5hbWUgYW5kIGl0IGlzIGFuIGFycmF5LlxyXG4gICAgICAgICAqIEluIG1vc3QgY2FzZXMgaXQgd2lsbCBjb250YWluIGEgc2luZ2xlIGVtYWlsLiBUaGlzIGZpZWxkIHNob3VsZCBub3QgYmUgcmVsaWVkIHVwb24gaWYgYSBjdXN0b21cclxuICAgICAgICAgKiBwb2xpY3kgaXMgY29uZmlndXJlZCB0byByZXR1cm4gbW9yZSB0aGFuIDEgZW1haWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgcHJlZmVycmVkVXNlcm5hbWUgPSBhY2NvdW50RGV0YWlscy5pZFRva2VuQ2xhaW1zPy5wcmVmZXJyZWRfdXNlcm5hbWUgfHxcclxuICAgICAgICAgICAgYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltcz8udXBuO1xyXG4gICAgICAgIGNvbnN0IGVtYWlsID0gYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltcz8uZW1haWxzXHJcbiAgICAgICAgICAgID8gYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltcy5lbWFpbHNbMF1cclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGFjY291bnQudXNlcm5hbWUgPSBwcmVmZXJyZWRVc2VybmFtZSB8fCBlbWFpbCB8fCBcIlwiO1xyXG4gICAgICAgIGFjY291bnQubmFtZSA9IGFjY291bnREZXRhaWxzLmlkVG9rZW5DbGFpbXM/Lm5hbWUgfHwgXCJcIjtcclxuICAgICAgICBhY2NvdW50LmNsb3VkR3JhcGhIb3N0TmFtZSA9IGFjY291bnREZXRhaWxzLmNsb3VkR3JhcGhIb3N0TmFtZTtcclxuICAgICAgICBhY2NvdW50Lm1zR3JhcGhIb3N0ID0gYWNjb3VudERldGFpbHMubXNHcmFwaEhvc3Q7XHJcbiAgICAgICAgaWYgKGFjY291bnREZXRhaWxzLnRlbmFudFByb2ZpbGVzKSB7XHJcbiAgICAgICAgICAgIGFjY291bnQudGVuYW50UHJvZmlsZXMgPSBhY2NvdW50RGV0YWlscy50ZW5hbnRQcm9maWxlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudFByb2ZpbGUgPSBidWlsZFRlbmFudFByb2ZpbGUoYWNjb3VudERldGFpbHMuaG9tZUFjY291bnRJZCwgYWNjb3VudC5sb2NhbEFjY291bnRJZCwgYWNjb3VudC5yZWFsbSwgYWNjb3VudERldGFpbHMuaWRUb2tlbkNsYWltcyk7XHJcbiAgICAgICAgICAgIGFjY291bnQudGVuYW50UHJvZmlsZXMgPSBbdGVuYW50UHJvZmlsZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2NvdW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIEFjY291bnRFbnRpdHkgb2JqZWN0IGZyb20gQWNjb3VudEluZm9cclxuICAgICAqIEBwYXJhbSBhY2NvdW50SW5mb1xyXG4gICAgICogQHBhcmFtIGNsb3VkR3JhcGhIb3N0TmFtZVxyXG4gICAgICogQHBhcmFtIG1zR3JhcGhIb3N0XHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUFjY291bnRJbmZvKGFjY291bnRJbmZvLCBjbG91ZEdyYXBoSG9zdE5hbWUsIG1zR3JhcGhIb3N0KSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IG5ldyBBY2NvdW50RW50aXR5KCk7XHJcbiAgICAgICAgYWNjb3VudC5hdXRob3JpdHlUeXBlID1cclxuICAgICAgICAgICAgYWNjb3VudEluZm8uYXV0aG9yaXR5VHlwZSB8fCBDYWNoZUFjY291bnRUeXBlLkdFTkVSSUNfQUNDT1VOVF9UWVBFO1xyXG4gICAgICAgIGFjY291bnQuaG9tZUFjY291bnRJZCA9IGFjY291bnRJbmZvLmhvbWVBY2NvdW50SWQ7XHJcbiAgICAgICAgYWNjb3VudC5sb2NhbEFjY291bnRJZCA9IGFjY291bnRJbmZvLmxvY2FsQWNjb3VudElkO1xyXG4gICAgICAgIGFjY291bnQubmF0aXZlQWNjb3VudElkID0gYWNjb3VudEluZm8ubmF0aXZlQWNjb3VudElkO1xyXG4gICAgICAgIGFjY291bnQucmVhbG0gPSBhY2NvdW50SW5mby50ZW5hbnRJZDtcclxuICAgICAgICBhY2NvdW50LmVudmlyb25tZW50ID0gYWNjb3VudEluZm8uZW52aXJvbm1lbnQ7XHJcbiAgICAgICAgYWNjb3VudC51c2VybmFtZSA9IGFjY291bnRJbmZvLnVzZXJuYW1lO1xyXG4gICAgICAgIGFjY291bnQubmFtZSA9IGFjY291bnRJbmZvLm5hbWU7XHJcbiAgICAgICAgYWNjb3VudC5jbG91ZEdyYXBoSG9zdE5hbWUgPSBjbG91ZEdyYXBoSG9zdE5hbWU7XHJcbiAgICAgICAgYWNjb3VudC5tc0dyYXBoSG9zdCA9IG1zR3JhcGhIb3N0O1xyXG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0ZW5hbnQgcHJvZmlsZXMgbWFwIGludG8gYW4gYXJyYXlcclxuICAgICAgICBhY2NvdW50LnRlbmFudFByb2ZpbGVzID0gQXJyYXkuZnJvbShhY2NvdW50SW5mby50ZW5hbnRQcm9maWxlcz8udmFsdWVzKCkgfHwgW10pO1xyXG4gICAgICAgIHJldHVybiBhY2NvdW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBIb21lQWNjb3VudElkIGZyb20gc2VydmVyIHJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gc2VydmVyQ2xpZW50SW5mb1xyXG4gICAgICogQHBhcmFtIGF1dGhUeXBlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUhvbWVBY2NvdW50SWQoc2VydmVyQ2xpZW50SW5mbywgYXV0aFR5cGUsIGxvZ2dlciwgY3J5cHRvT2JqLCBpZFRva2VuQ2xhaW1zKSB7XHJcbiAgICAgICAgLy8gc2luY2UgQURGUy9EU1RTIGRvIG5vdCBoYXZlIHRpZCBhbmQgZG9lcyBub3Qgc2V0IGNsaWVudF9pbmZvXHJcbiAgICAgICAgaWYgKCEoYXV0aFR5cGUgPT09IEF1dGhvcml0eVR5cGUuQWRmcyB8fFxyXG4gICAgICAgICAgICBhdXRoVHlwZSA9PT0gQXV0aG9yaXR5VHlwZS5Ec3RzKSkge1xyXG4gICAgICAgICAgICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgaXMgY2xpZW50SW5mb1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyQ2xpZW50SW5mbykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvKHNlcnZlckNsaWVudEluZm8sIGNyeXB0b09iai5iYXNlNjREZWNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnRJbmZvLnVpZCAmJiBjbGllbnRJbmZvLnV0aWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2NsaWVudEluZm8udWlkfS4ke2NsaWVudEluZm8udXRpZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2dnZXIud2FybmluZyhcIk5vIGNsaWVudCBpbmZvIGluIHJlc3BvbnNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWZhdWx0IHRvIFwic3ViXCIgY2xhaW1cclxuICAgICAgICByZXR1cm4gaWRUb2tlbkNsYWltcz8uc3ViIHx8IFwiXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyBhbiBlbnRpdHk6IGNoZWNrcyBmb3IgYWxsIGV4cGVjdGVkIHBhcmFtc1xyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNBY2NvdW50RW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIGlmICghZW50aXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChlbnRpdHkuaGFzT3duUHJvcGVydHkoXCJob21lQWNjb3VudElkXCIpICYmXHJcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImVudmlyb25tZW50XCIpICYmXHJcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInJlYWxtXCIpICYmXHJcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImxvY2FsQWNjb3VudElkXCIpICYmXHJcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcInVzZXJuYW1lXCIpICYmXHJcbiAgICAgICAgICAgIGVudGl0eS5oYXNPd25Qcm9wZXJ0eShcImF1dGhvcml0eVR5cGVcIikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgMiBhY2NvdW50SW5mbyBvYmplY3RzIHJlcHJlc2VudCB0aGUgc2FtZSBhY2NvdW50XHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudEFcclxuICAgICAqIEBwYXJhbSBhY2NvdW50QlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmVDbGFpbXMgLSBJZiBzZXQgdG8gdHJ1ZSBpZFRva2VuQ2xhaW1zIHdpbGwgYWxzbyBiZSBjb21wYXJlZCB0byBkZXRlcm1pbmUgYWNjb3VudCBlcXVhbGl0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYWNjb3VudEluZm9Jc0VxdWFsKGFjY291bnRBLCBhY2NvdW50QiwgY29tcGFyZUNsYWltcykge1xyXG4gICAgICAgIGlmICghYWNjb3VudEEgfHwgIWFjY291bnRCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNsYWltc01hdGNoID0gdHJ1ZTsgLy8gZGVmYXVsdCB0byB0cnVlIHNvIGFzIHRvIG5vdCBmYWlsIGNvbXBhcmlzb24gYmVsb3cgaWYgY29tcGFyZUNsYWltczogZmFsc2VcclxuICAgICAgICBpZiAoY29tcGFyZUNsYWltcykge1xyXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50QUNsYWltcyA9IChhY2NvdW50QS5pZFRva2VuQ2xhaW1zIHx8XHJcbiAgICAgICAgICAgICAgICB7fSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRCQ2xhaW1zID0gKGFjY291bnRCLmlkVG9rZW5DbGFpbXMgfHxcclxuICAgICAgICAgICAgICAgIHt9KTtcclxuICAgICAgICAgICAgLy8gaXNzdWVkIGF0IHRpbWVzdGFtcCBhbmQgbm9uY2UgYXJlIGV4cGVjdGVkIHRvIGNoYW5nZSBlYWNoIHRpbWUgYSBuZXcgaWQgdG9rZW4gaXMgYWNxdWlyZWRcclxuICAgICAgICAgICAgY2xhaW1zTWF0Y2ggPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudEFDbGFpbXMuaWF0ID09PSBhY2NvdW50QkNsYWltcy5pYXQgJiZcclxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50QUNsYWltcy5ub25jZSA9PT0gYWNjb3VudEJDbGFpbXMubm9uY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoYWNjb3VudEEuaG9tZUFjY291bnRJZCA9PT0gYWNjb3VudEIuaG9tZUFjY291bnRJZCAmJlxyXG4gICAgICAgICAgICBhY2NvdW50QS5sb2NhbEFjY291bnRJZCA9PT0gYWNjb3VudEIubG9jYWxBY2NvdW50SWQgJiZcclxuICAgICAgICAgICAgYWNjb3VudEEudXNlcm5hbWUgPT09IGFjY291bnRCLnVzZXJuYW1lICYmXHJcbiAgICAgICAgICAgIGFjY291bnRBLnRlbmFudElkID09PSBhY2NvdW50Qi50ZW5hbnRJZCAmJlxyXG4gICAgICAgICAgICBhY2NvdW50QS5lbnZpcm9ubWVudCA9PT0gYWNjb3VudEIuZW52aXJvbm1lbnQgJiZcclxuICAgICAgICAgICAgYWNjb3VudEEubmF0aXZlQWNjb3VudElkID09PSBhY2NvdW50Qi5uYXRpdmVBY2NvdW50SWQgJiZcclxuICAgICAgICAgICAgY2xhaW1zTWF0Y2gpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IEFjY291bnRFbnRpdHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY291bnRFbnRpdHkubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBjYWNoZVF1b3RhRXhjZWVkZWRFcnJvckNvZGUgPSBcImNhY2hlX3F1b3RhX2V4Y2VlZGVkXCI7XHJcbmNvbnN0IGNhY2hlVW5rbm93bkVycm9yQ29kZSA9IFwiY2FjaGVfZXJyb3JfdW5rbm93blwiO1xuXG5leHBvcnQgeyBjYWNoZVF1b3RhRXhjZWVkZWRFcnJvckNvZGUsIGNhY2hlVW5rbm93bkVycm9yQ29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVFcnJvckNvZGVzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjYWNoZVVua25vd25FcnJvckNvZGUsIGNhY2hlUXVvdGFFeGNlZWRlZEVycm9yQ29kZSB9IGZyb20gJy4vQ2FjaGVFcnJvckNvZGVzLm1qcyc7XG5pbXBvcnQgKiBhcyBDYWNoZUVycm9yQ29kZXMgZnJvbSAnLi9DYWNoZUVycm9yQ29kZXMubWpzJztcbmV4cG9ydCB7IENhY2hlRXJyb3JDb2RlcyB9O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgQ2FjaGVFcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgW2NhY2hlUXVvdGFFeGNlZWRlZEVycm9yQ29kZV06IFwiRXhjZWVkZWQgY2FjaGUgc3RvcmFnZSBjYXBhY2l0eS5cIixcclxuICAgIFtjYWNoZVVua25vd25FcnJvckNvZGVdOiBcIlVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hlbiB1c2luZyBjYWNoZSBzdG9yYWdlLlwiLFxyXG59O1xyXG4vKipcclxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3Igd2l0aCB0aGUgY2FjaGVcclxuICovXHJcbmNsYXNzIENhY2hlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlcnJvckNvZGUsIGVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvck1lc3NhZ2UgfHxcclxuICAgICAgICAgICAgKENhY2hlRXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdXHJcbiAgICAgICAgICAgICAgICA/IENhY2hlRXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdXHJcbiAgICAgICAgICAgICAgICA6IENhY2hlRXJyb3JNZXNzYWdlc1tjYWNoZVVua25vd25FcnJvckNvZGVdKTtcclxuICAgICAgICBzdXBlcihgJHtlcnJvckNvZGV9OiAke21lc3NhZ2V9YCk7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENhY2hlRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIkNhY2hlRXJyb3JcIjtcclxuICAgICAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQ2FjaGVFcnJvciwgQ2FjaGVFcnJvck1lc3NhZ2VzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZUVycm9yLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBTZXBhcmF0b3JzLCBDcmVkZW50aWFsVHlwZSwgQXV0aGVudGljYXRpb25TY2hlbWUsIFRIRV9GQU1JTFlfSUQsIEFQUF9NRVRBREFUQSwgQVVUSE9SSVRZX01FVEFEQVRBX0NPTlNUQU5UUyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVDcmVkZW50aWFsS2V5IH0gZnJvbSAnLi91dGlscy9DYWNoZUhlbHBlcnMubWpzJztcbmltcG9ydCB7IFNjb3BlU2V0IH0gZnJvbSAnLi4vcmVxdWVzdC9TY29wZVNldC5tanMnO1xuaW1wb3J0IHsgQWNjb3VudEVudGl0eSB9IGZyb20gJy4vZW50aXRpZXMvQWNjb3VudEVudGl0eS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50QXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVBY2NvdW50VGVuYW50UHJvZmlsZURhdGEgfSBmcm9tICcuLi9hY2NvdW50L0FjY291bnRJbmZvLm1qcyc7XG5pbXBvcnQgeyBleHRyYWN0VG9rZW5DbGFpbXMgfSBmcm9tICcuLi9hY2NvdW50L0F1dGhUb2tlbi5tanMnO1xuaW1wb3J0IHsgbmFtZSwgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2VNZXRhZGF0YS5tanMnO1xuaW1wb3J0IHsgZ2V0QWxpYXNlc0Zyb21TdGF0aWNTb3VyY2VzIH0gZnJvbSAnLi4vYXV0aG9yaXR5L0F1dGhvcml0eU1ldGFkYXRhLm1qcyc7XG5pbXBvcnQgeyBDYWNoZUVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2FjaGVFcnJvci5tanMnO1xuaW1wb3J0IHsgaW52YWxpZENhY2hlUmVjb3JkLCBiaW5kaW5nS2V5Tm90UmVtb3ZlZCwgbXVsdGlwbGVNYXRjaGluZ0FwcE1ldGFkYXRhLCBtZXRob2ROb3RJbXBsZW1lbnRlZCB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvckNvZGVzLm1qcyc7XG5pbXBvcnQgeyBjYWNoZVF1b3RhRXhjZWVkZWRFcnJvckNvZGUsIGNhY2hlVW5rbm93bkVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9yL0NhY2hlRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEludGVyZmFjZSBjbGFzcyB3aGljaCBpbXBsZW1lbnQgY2FjaGUgc3RvcmFnZSBmdW5jdGlvbnMgdXNlZCBieSBNU0FMIHRvIHBlcmZvcm0gdmFsaWRpdHkgY2hlY2tzLCBhbmQgc3RvcmUgdG9rZW5zLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIENhY2hlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgY3J5cHRvSW1wbCwgbG9nZ2VyLCBzdGF0aWNBdXRob3JpdHlPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG4gICAgICAgIHRoaXMuY3J5cHRvSW1wbCA9IGNyeXB0b0ltcGw7XHJcbiAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIgPSBsb2dnZXIuY2xvbmUobmFtZSwgdmVyc2lvbik7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNBdXRob3JpdHlPcHRpb25zID0gc3RhdGljQXV0aG9yaXR5T3B0aW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGFjY291bnRzIGluIHRoZSBjYWNoZSB0aGF0IG1hdGNoIHRoZSBvcHRpb25hbCBmaWx0ZXIuIElmIG5vIGZpbHRlciBpcyBwcm92aWRlZCwgYWxsIGFjY291bnRzIGFyZSByZXR1cm5lZC5cclxuICAgICAqIEBwYXJhbSBhY2NvdW50RmlsdGVyIC0gKE9wdGlvbmFsKSBmaWx0ZXIgdG8gbmFycm93IGRvd24gdGhlIGFjY291bnRzIHJldHVybmVkXHJcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBBY2NvdW50SW5mbyBvYmplY3RzIGluIGNhY2hlXHJcbiAgICAgKi9cclxuICAgIGdldEFsbEFjY291bnRzKGFjY291bnRGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFRlbmFudFByb2ZpbGVzKHRoaXMuZ2V0QWNjb3VudHNGaWx0ZXJlZEJ5KGFjY291bnRGaWx0ZXIgfHwge30pLCBhY2NvdW50RmlsdGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBmaXJzdCB0ZW5hbnRlZCBBY2NvdW50SW5mbyBvYmplY3QgZm91bmQgYmFzZWQgb24gcHJvdmlkZWQgZmlsdGVyc1xyXG4gICAgICovXHJcbiAgICBnZXRBY2NvdW50SW5mb0ZpbHRlcmVkQnkoYWNjb3VudEZpbHRlcikge1xyXG4gICAgICAgIGNvbnN0IGFsbEFjY291bnRzID0gdGhpcy5nZXRBbGxBY2NvdW50cyhhY2NvdW50RmlsdGVyKTtcclxuICAgICAgICBpZiAoYWxsQWNjb3VudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAvLyBJZiBvbmUgb3IgbW9yZSBhY2NvdW50cyBhcmUgZm91bmQsIHByaW9yaXRpemUgYWNjb3VudHMgdGhhdCBoYXZlIGFuIElEIHRva2VuXHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZEFjY291bnRzID0gYWxsQWNjb3VudHMuc29ydCgoYWNjb3VudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnQuaWRUb2tlbkNsYWltcyA/IC0xIDogMTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBY2NvdW50c1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWxsQWNjb3VudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIGFjY291bnQgaXMgZm91bmQsIHJldHVybiBpdCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgYSBtYXRjaGluZyBJRCB0b2tlbiB3YXMgZm91bmRcclxuICAgICAgICAgICAgcmV0dXJuIGFsbEFjY291bnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc2luZ2xlIG1hdGNoaW5nXHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudEZpbHRlclxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZ2V0QmFzZUFjY291bnRJbmZvKGFjY291bnRGaWx0ZXIpIHtcclxuICAgICAgICBjb25zdCBhY2NvdW50RW50aXRpZXMgPSB0aGlzLmdldEFjY291bnRzRmlsdGVyZWRCeShhY2NvdW50RmlsdGVyKTtcclxuICAgICAgICBpZiAoYWNjb3VudEVudGl0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRFbnRpdGllc1swXS5nZXRBY2NvdW50SW5mbygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIGZpbHRlcmVkIGFjY291bnQgZW50aXRpZXMgd2l0aCBjYWNoZWQgSUQgdG9rZW5zIHRoYXQgbWF0Y2ggdGhlIHRlbmFudCBwcm9maWxlLXNwZWNpZmljIGFjY291bnQgZmlsdGVyc1xyXG4gICAgICogYW5kIGJ1aWxkcyB0aGUgYWNjb3VudCBpbmZvIG9iamVjdHMgZnJvbSB0aGUgbWF0Y2hpbmcgSUQgdG9rZW4ncyBjbGFpbXNcclxuICAgICAqIEBwYXJhbSBjYWNoZWRBY2NvdW50c1xyXG4gICAgICogQHBhcmFtIGFjY291bnRGaWx0ZXJcclxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIEFjY291bnRJbmZvIG9iamVjdHMgdGhhdCBtYXRjaCBhY2NvdW50IGFuZCB0ZW5hbnQgcHJvZmlsZSBmaWx0ZXJzXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkVGVuYW50UHJvZmlsZXMoY2FjaGVkQWNjb3VudHMsIGFjY291bnRGaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkQWNjb3VudHMuZmxhdE1hcCgoYWNjb3VudEVudGl0eSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUZW5hbnRQcm9maWxlc0Zyb21BY2NvdW50RW50aXR5KGFjY291bnRFbnRpdHksIGFjY291bnRGaWx0ZXI/LnRlbmFudElkLCBhY2NvdW50RmlsdGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFRlbmFudGVkQWNjb3VudEluZm9CeUZpbHRlcihhY2NvdW50SW5mbywgdG9rZW5LZXlzLCB0ZW5hbnRQcm9maWxlLCB0ZW5hbnRQcm9maWxlRmlsdGVyKSB7XHJcbiAgICAgICAgbGV0IHRlbmFudGVkQWNjb3VudEluZm8gPSBudWxsO1xyXG4gICAgICAgIGxldCBpZFRva2VuQ2xhaW1zO1xyXG4gICAgICAgIGlmICh0ZW5hbnRQcm9maWxlRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy50ZW5hbnRQcm9maWxlTWF0Y2hlc0ZpbHRlcih0ZW5hbnRQcm9maWxlLCB0ZW5hbnRQcm9maWxlRmlsdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaWRUb2tlbiA9IHRoaXMuZ2V0SWRUb2tlbihhY2NvdW50SW5mbywgdG9rZW5LZXlzLCB0ZW5hbnRQcm9maWxlLnRlbmFudElkKTtcclxuICAgICAgICBpZiAoaWRUb2tlbikge1xyXG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zID0gZXh0cmFjdFRva2VuQ2xhaW1zKGlkVG9rZW4uc2VjcmV0LCB0aGlzLmNyeXB0b0ltcGwuYmFzZTY0RGVjb2RlKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlkVG9rZW5DbGFpbXNNYXRjaFRlbmFudFByb2ZpbGVGaWx0ZXIoaWRUb2tlbkNsYWltcywgdGVuYW50UHJvZmlsZUZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIElEIHRva2VuIHNvdXJjZWQgY2xhaW1zIGRvbid0IG1hdGNoIHNvIHRoaXMgdGVuYW50IHByb2ZpbGUgaXMgbm90IGEgbWF0Y2hcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV4cGFuZCB0ZW5hbnQgcHJvZmlsZSBpbnRvIGFjY291bnQgaW5mbyBiYXNlZCBvbiBtYXRjaGluZyB0ZW5hbnQgcHJvZmlsZSBhbmQgaWYgYXZhaWxhYmxlIG1hdGNoaW5nIElEIHRva2VuIGNsYWltc1xyXG4gICAgICAgIHRlbmFudGVkQWNjb3VudEluZm8gPSB1cGRhdGVBY2NvdW50VGVuYW50UHJvZmlsZURhdGEoYWNjb3VudEluZm8sIHRlbmFudFByb2ZpbGUsIGlkVG9rZW5DbGFpbXMsIGlkVG9rZW4/LnNlY3JldCk7XHJcbiAgICAgICAgcmV0dXJuIHRlbmFudGVkQWNjb3VudEluZm87XHJcbiAgICB9XHJcbiAgICBnZXRUZW5hbnRQcm9maWxlc0Zyb21BY2NvdW50RW50aXR5KGFjY291bnRFbnRpdHksIHRhcmdldFRlbmFudElkLCB0ZW5hbnRQcm9maWxlRmlsdGVyKSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhY2NvdW50RW50aXR5LmdldEFjY291bnRJbmZvKCk7XHJcbiAgICAgICAgbGV0IHNlYXJjaFRlbmFudFByb2ZpbGVzID0gYWNjb3VudEluZm8udGVuYW50UHJvZmlsZXMgfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuS2V5cyA9IHRoaXMuZ2V0VG9rZW5LZXlzKCk7XHJcbiAgICAgICAgLy8gSWYgYSB0ZW5hbnQgSUQgd2FzIHByb3ZpZGVkLCBvbmx5IHJldHVybiB0aGUgdGVuYW50IHByb2ZpbGUgZm9yIHRoYXQgdGVuYW50IElEIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgIGlmICh0YXJnZXRUZW5hbnRJZCkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRQcm9maWxlID0gc2VhcmNoVGVuYW50UHJvZmlsZXMuZ2V0KHRhcmdldFRlbmFudElkKTtcclxuICAgICAgICAgICAgaWYgKHRlbmFudFByb2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlZHVjZSBzZWFyY2ggZmllbGQgdG8ganVzdCB0aGlzIHRlbmFudCBwcm9maWxlXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hUZW5hbnRQcm9maWxlcyA9IG5ldyBNYXAoW1xyXG4gICAgICAgICAgICAgICAgICAgIFt0YXJnZXRUZW5hbnRJZCwgdGVuYW50UHJvZmlsZV0sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHRlbmFudCBwcm9maWxlIGZvciBzZWFyY2ggdGVuYW50IElELCByZXR1cm4gZW1wdHkgYXJyYXlcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtYXRjaGluZ1RlbmFudFByb2ZpbGVzID0gW107XHJcbiAgICAgICAgc2VhcmNoVGVuYW50UHJvZmlsZXMuZm9yRWFjaCgodGVuYW50UHJvZmlsZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRlZEFjY291bnRJbmZvID0gdGhpcy5nZXRUZW5hbnRlZEFjY291bnRJbmZvQnlGaWx0ZXIoYWNjb3VudEluZm8sIHRva2VuS2V5cywgdGVuYW50UHJvZmlsZSwgdGVuYW50UHJvZmlsZUZpbHRlcik7XHJcbiAgICAgICAgICAgIGlmICh0ZW5hbnRlZEFjY291bnRJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1RlbmFudFByb2ZpbGVzLnB1c2godGVuYW50ZWRBY2NvdW50SW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdUZW5hbnRQcm9maWxlcztcclxuICAgIH1cclxuICAgIHRlbmFudFByb2ZpbGVNYXRjaGVzRmlsdGVyKHRlbmFudFByb2ZpbGUsIHRlbmFudFByb2ZpbGVGaWx0ZXIpIHtcclxuICAgICAgICBpZiAoISF0ZW5hbnRQcm9maWxlRmlsdGVyLmxvY2FsQWNjb3VudElkICYmXHJcbiAgICAgICAgICAgICF0aGlzLm1hdGNoTG9jYWxBY2NvdW50SWRGcm9tVGVuYW50UHJvZmlsZSh0ZW5hbnRQcm9maWxlLCB0ZW5hbnRQcm9maWxlRmlsdGVyLmxvY2FsQWNjb3VudElkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIXRlbmFudFByb2ZpbGVGaWx0ZXIubmFtZSAmJlxyXG4gICAgICAgICAgICAhKHRlbmFudFByb2ZpbGUubmFtZSA9PT0gdGVuYW50UHJvZmlsZUZpbHRlci5uYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZW5hbnRQcm9maWxlRmlsdGVyLmlzSG9tZVRlbmFudCAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICEodGVuYW50UHJvZmlsZS5pc0hvbWVUZW5hbnQgPT09IHRlbmFudFByb2ZpbGVGaWx0ZXIuaXNIb21lVGVuYW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWRUb2tlbkNsYWltc01hdGNoVGVuYW50UHJvZmlsZUZpbHRlcihpZFRva2VuQ2xhaW1zLCB0ZW5hbnRQcm9maWxlRmlsdGVyKSB7XHJcbiAgICAgICAgLy8gVGVuYW50IFByb2ZpbGUgZmlsdGVyaW5nXHJcbiAgICAgICAgaWYgKHRlbmFudFByb2ZpbGVGaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEhdGVuYW50UHJvZmlsZUZpbHRlci5sb2NhbEFjY291bnRJZCAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hMb2NhbEFjY291bnRJZEZyb21Ub2tlbkNsYWltcyhpZFRva2VuQ2xhaW1zLCB0ZW5hbnRQcm9maWxlRmlsdGVyLmxvY2FsQWNjb3VudElkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghIXRlbmFudFByb2ZpbGVGaWx0ZXIubG9naW5IaW50ICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaExvZ2luSGludEZyb21Ub2tlbkNsYWltcyhpZFRva2VuQ2xhaW1zLCB0ZW5hbnRQcm9maWxlRmlsdGVyLmxvZ2luSGludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISF0ZW5hbnRQcm9maWxlRmlsdGVyLnVzZXJuYW1lICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaFVzZXJuYW1lKGlkVG9rZW5DbGFpbXMucHJlZmVycmVkX3VzZXJuYW1lLCB0ZW5hbnRQcm9maWxlRmlsdGVyLnVzZXJuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghIXRlbmFudFByb2ZpbGVGaWx0ZXIubmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hOYW1lKGlkVG9rZW5DbGFpbXMsIHRlbmFudFByb2ZpbGVGaWx0ZXIubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISF0ZW5hbnRQcm9maWxlRmlsdGVyLnNpZCAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hTaWQoaWRUb2tlbkNsYWltcywgdGVuYW50UHJvZmlsZUZpbHRlci5zaWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHNhdmVzIGEgY2FjaGUgcmVjb3JkXHJcbiAgICAgKiBAcGFyYW0gY2FjaGVSZWNvcmQge0NhY2hlUmVjb3JkfVxyXG4gICAgICogQHBhcmFtIHN0b3JlSW5DYWNoZSB7P1N0b3JlSW5DYWNoZX1cclxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkIHs/c3RyaW5nfSBjb3JyZWxhdGlvbiBpZFxyXG4gICAgICovXHJcbiAgICBhc3luYyBzYXZlQ2FjaGVSZWNvcmQoY2FjaGVSZWNvcmQsIGNvcnJlbGF0aW9uSWQsIHN0b3JlSW5DYWNoZSkge1xyXG4gICAgICAgIGlmICghY2FjaGVSZWNvcmQpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGludmFsaWRDYWNoZVJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICghIWNhY2hlUmVjb3JkLmFjY291bnQpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0QWNjb3VudChjYWNoZVJlY29yZC5hY2NvdW50LCBjb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISFjYWNoZVJlY29yZC5pZFRva2VuICYmIHN0b3JlSW5DYWNoZT8uaWRUb2tlbiAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0SWRUb2tlbkNyZWRlbnRpYWwoY2FjaGVSZWNvcmQuaWRUb2tlbiwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhY2FjaGVSZWNvcmQuYWNjZXNzVG9rZW4gJiZcclxuICAgICAgICAgICAgICAgIHN0b3JlSW5DYWNoZT8uYWNjZXNzVG9rZW4gIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVBY2Nlc3NUb2tlbihjYWNoZVJlY29yZC5hY2Nlc3NUb2tlbiwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhY2FjaGVSZWNvcmQucmVmcmVzaFRva2VuICYmXHJcbiAgICAgICAgICAgICAgICBzdG9yZUluQ2FjaGU/LnJlZnJlc2hUb2tlbiAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbChjYWNoZVJlY29yZC5yZWZyZXNoVG9rZW4sIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghIWNhY2hlUmVjb3JkLmFwcE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFwcE1ldGFkYXRhKGNhY2hlUmVjb3JkLmFwcE1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlcj8uZXJyb3IoYENhY2hlTWFuYWdlci5zYXZlQ2FjaGVSZWNvcmQ6IGZhaWxlZGApO1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlcj8uZXJyb3JQaWkoYENhY2hlTWFuYWdlci5zYXZlQ2FjaGVSZWNvcmQ6ICR7ZS5tZXNzYWdlfWAsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gXCJOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRFwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlLmluY2x1ZGVzKFwiZXhjZWVkZWQgdGhlIHF1b3RhXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb25Mb2dnZXI/LmVycm9yKGBDYWNoZU1hbmFnZXIuc2F2ZUNhY2hlUmVjb3JkOiBleGNlZWRlZCBzdG9yYWdlIHF1b3RhYCwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENhY2hlRXJyb3IoY2FjaGVRdW90YUV4Y2VlZGVkRXJyb3JDb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDYWNoZUVycm9yKGUubmFtZSwgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyPy5lcnJvclBpaShgQ2FjaGVNYW5hZ2VyLnNhdmVDYWNoZVJlY29yZDogJHtlfWAsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENhY2hlRXJyb3IoY2FjaGVVbmtub3duRXJyb3JDb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2F2ZXMgYWNjZXNzIHRva2VuIGNyZWRlbnRpYWxcclxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFsXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHNhdmVBY2Nlc3NUb2tlbihjcmVkZW50aWFsLCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5GaWx0ZXIgPSB7XHJcbiAgICAgICAgICAgIGNsaWVudElkOiBjcmVkZW50aWFsLmNsaWVudElkLFxyXG4gICAgICAgICAgICBjcmVkZW50aWFsVHlwZTogY3JlZGVudGlhbC5jcmVkZW50aWFsVHlwZSxcclxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGNyZWRlbnRpYWwuZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IGNyZWRlbnRpYWwuaG9tZUFjY291bnRJZCxcclxuICAgICAgICAgICAgcmVhbG06IGNyZWRlbnRpYWwucmVhbG0sXHJcbiAgICAgICAgICAgIHRva2VuVHlwZTogY3JlZGVudGlhbC50b2tlblR5cGUsXHJcbiAgICAgICAgICAgIHJlcXVlc3RlZENsYWltc0hhc2g6IGNyZWRlbnRpYWwucmVxdWVzdGVkQ2xhaW1zSGFzaCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRva2VuS2V5cyA9IHRoaXMuZ2V0VG9rZW5LZXlzKCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFNjb3BlcyA9IFNjb3BlU2V0LmZyb21TdHJpbmcoY3JlZGVudGlhbC50YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRBY2Nlc3NUb2tlbnMgPSBbXTtcclxuICAgICAgICB0b2tlbktleXMuYWNjZXNzVG9rZW4uZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hY2Nlc3NUb2tlbktleU1hdGNoZXNGaWx0ZXIoa2V5LCBhY2Nlc3NUb2tlbkZpbHRlciwgZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdG9rZW5FbnRpdHkgPSB0aGlzLmdldEFjY2Vzc1Rva2VuQ3JlZGVudGlhbChrZXkpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW5FbnRpdHkgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbE1hdGNoZXNGaWx0ZXIodG9rZW5FbnRpdHksIGFjY2Vzc1Rva2VuRmlsdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5TY29wZVNldCA9IFNjb3BlU2V0LmZyb21TdHJpbmcodG9rZW5FbnRpdHkudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlblNjb3BlU2V0LmludGVyc2VjdGluZ1Njb3BlU2V0cyhjdXJyZW50U2NvcGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRBY2Nlc3NUb2tlbnMucHVzaCh0aGlzLnJlbW92ZUFjY2Vzc1Rva2VuKGtleSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVtb3ZlZEFjY2Vzc1Rva2Vucyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoY3JlZGVudGlhbCwgY29ycmVsYXRpb25JZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGFjY291bnQgZW50aXRpZXMgbWF0Y2hpbmcgYWxsIHByb3ZpZGVkIHRlbmFudC1hZ25vc3RpYyBmaWx0ZXJzOyBpZiBubyBmaWx0ZXIgaXMgc2V0LCBnZXQgYWxsIGFjY291bnQgZW50aXRpZXMgaW4gdGhlIGNhY2hlXHJcbiAgICAgKiBOb3QgY2hlY2tpbmcgZm9yIGNhc2luZyBhcyBrZXlzIGFyZSBhbGwgZ2VuZXJhdGVkIGluIGxvd2VyIGNhc2UsIHJlbWVtYmVyIHRvIGNvbnZlcnQgdG8gbG93ZXIgY2FzZSBpZiBvYmplY3QgcHJvcGVydGllcyBhcmUgY29tcGFyZWRcclxuICAgICAqIEBwYXJhbSBhY2NvdW50RmlsdGVyIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgQWNjb3VudCBwcm9wZXJ0aWVzIHRvIGZpbHRlciBieVxyXG4gICAgICovXHJcbiAgICBnZXRBY2NvdW50c0ZpbHRlcmVkQnkoYWNjb3VudEZpbHRlcikge1xyXG4gICAgICAgIGNvbnN0IGFsbEFjY291bnRLZXlzID0gdGhpcy5nZXRBY2NvdW50S2V5cygpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQWNjb3VudHMgPSBbXTtcclxuICAgICAgICBhbGxBY2NvdW50S2V5cy5mb3JFYWNoKChjYWNoZUtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBY2NvdW50S2V5KGNhY2hlS2V5LCBhY2NvdW50RmlsdGVyLmhvbWVBY2NvdW50SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwYXJzZSB2YWx1ZSBpZiB0aGUga2V5IGRvZXNuJ3QgbWF0Y2ggdGhlIGFjY291bnQgZmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZ2V0QWNjb3VudChjYWNoZUtleSwgdGhpcy5jb21tb25Mb2dnZXIpO1xyXG4gICAgICAgICAgICAvLyBNYXRjaCBiYXNlIGFjY291bnQgZmllbGRzXHJcbiAgICAgICAgICAgIGlmICghZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhYWNjb3VudEZpbHRlci5ob21lQWNjb3VudElkICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaEhvbWVBY2NvdW50SWQoZW50aXR5LCBhY2NvdW50RmlsdGVyLmhvbWVBY2NvdW50SWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhYWNjb3VudEZpbHRlci51c2VybmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hVc2VybmFtZShlbnRpdHkudXNlcm5hbWUsIGFjY291bnRGaWx0ZXIudXNlcm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhYWNjb3VudEZpbHRlci5lbnZpcm9ubWVudCAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hFbnZpcm9ubWVudChlbnRpdHksIGFjY291bnRGaWx0ZXIuZW52aXJvbm1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhYWNjb3VudEZpbHRlci5yZWFsbSAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hSZWFsbShlbnRpdHksIGFjY291bnRGaWx0ZXIucmVhbG0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhYWNjb3VudEZpbHRlci5uYXRpdmVBY2NvdW50SWQgJiZcclxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoTmF0aXZlQWNjb3VudElkKGVudGl0eSwgYWNjb3VudEZpbHRlci5uYXRpdmVBY2NvdW50SWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhYWNjb3VudEZpbHRlci5hdXRob3JpdHlUeXBlICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaEF1dGhvcml0eVR5cGUoZW50aXR5LCBhY2NvdW50RmlsdGVyLmF1dGhvcml0eVR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIHRlbmFudCBwcm9maWxlIG1hdGNoZXMgdGhlIHRlbmFudCBwcm9maWxlIGZpbHRlciwgYWRkIHRoZSBhY2NvdW50IHRvIHRoZSBsaXN0IG9mIG1hdGNoaW5nIGFjY291bnRzXHJcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudFByb2ZpbGVGaWx0ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbEFjY291bnRJZDogYWNjb3VudEZpbHRlcj8ubG9jYWxBY2NvdW50SWQsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBhY2NvdW50RmlsdGVyPy5uYW1lLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ1RlbmFudFByb2ZpbGVzID0gZW50aXR5LnRlbmFudFByb2ZpbGVzPy5maWx0ZXIoKHRlbmFudFByb2ZpbGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbmFudFByb2ZpbGVNYXRjaGVzRmlsdGVyKHRlbmFudFByb2ZpbGUsIHRlbmFudFByb2ZpbGVGaWx0ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVGVuYW50UHJvZmlsZXMgJiYgbWF0Y2hpbmdUZW5hbnRQcm9maWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHRlbmFudCBwcm9maWxlIGZvciB0aGlzIGFjY291bnQgbWF0Y2hlcyBmaWx0ZXIsIGRvbid0IGFkZCB0byBsaXN0IG9mIG1hdGNoaW5nIGFjY291bnRzXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0Y2hpbmdBY2NvdW50cy5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nQWNjb3VudHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4ga2V5IG1hdGNoZXMgb3VyIGFjY291bnQga2V5IHNjaGVtYS4gQWxzbyBtYXRjaGVzIGhvbWVBY2NvdW50SWQgYW5kL29yIHRlbmFudElkIGlmIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0ga2V5XHJcbiAgICAgKiBAcGFyYW0gaG9tZUFjY291bnRJZFxyXG4gICAgICogQHBhcmFtIHRlbmFudElkXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBpc0FjY291bnRLZXkoa2V5LCBob21lQWNjb3VudElkLCB0ZW5hbnRJZCkge1xyXG4gICAgICAgIGlmIChrZXkuc3BsaXQoU2VwYXJhdG9ycy5DQUNIRV9LRVlfU0VQQVJBVE9SKS5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgIC8vIEFjY291bnQgY2FjaGUga2V5cyBjb250YWluIDMgaXRlbXMgc2VwYXJhdGVkIGJ5ICctJyAoZWFjaCBpdGVtIG1heSBhbHNvIGNvbnRhaW4gJy0nKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChob21lQWNjb3VudElkICYmXHJcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhob21lQWNjb3VudElkLnRvTG93ZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRlbmFudElkICYmICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0ZW5hbnRJZC50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdCBjaGVjayBlbnZpcm9ubWVudCBhcyBhbGlhc2luZyBjYW4gY2F1c2UgZmFsc2UgbmVnYXRpdmVzXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4ga2V5IG1hdGNoZXMgb3VyIGNyZWRlbnRpYWwga2V5IHNjaGVtYS5cclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqL1xyXG4gICAgaXNDcmVkZW50aWFsS2V5KGtleSkge1xyXG4gICAgICAgIGlmIChrZXkuc3BsaXQoU2VwYXJhdG9ycy5DQUNIRV9LRVlfU0VQQVJBVE9SKS5sZW5ndGggPCA2KSB7XHJcbiAgICAgICAgICAgIC8vIENyZWRlbnRpYWwgY2FjaGUga2V5cyBjb250YWluIDYgaXRlbXMgc2VwYXJhdGVkIGJ5ICctJyAoZWFjaCBpdGVtIG1heSBhbHNvIGNvbnRhaW4gJy0nKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIENyZWRlbnRpYWwga2V5cyBtdXN0IGluZGljYXRlIHdoYXQgY3JlZGVudGlhbCB0eXBlIHRoZXkgcmVwcmVzZW50XHJcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUtleS5pbmRleE9mKENyZWRlbnRpYWxUeXBlLklEX1RPS0VOLnRvTG93ZXJDYXNlKCkpID09PVxyXG4gICAgICAgICAgICAtMSAmJlxyXG4gICAgICAgICAgICBsb3dlckNhc2VLZXkuaW5kZXhPZihDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU4udG9Mb3dlckNhc2UoKSkgPT09XHJcbiAgICAgICAgICAgICAgICAtMSAmJlxyXG4gICAgICAgICAgICBsb3dlckNhc2VLZXkuaW5kZXhPZihDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEgJiZcclxuICAgICAgICAgICAgbG93ZXJDYXNlS2V5LmluZGV4T2YoQ3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTi50b0xvd2VyQ2FzZSgpKSA9PT1cclxuICAgICAgICAgICAgICAgIC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUtleS5pbmRleE9mKENyZWRlbnRpYWxUeXBlLlJFRlJFU0hfVE9LRU4udG9Mb3dlckNhc2UoKSkgPlxyXG4gICAgICAgICAgICAtMSkge1xyXG4gICAgICAgICAgICAvLyBSZWZyZXNoIHRva2VucyBtdXN0IGNvbnRhaW4gdGhlIGNsaWVudCBpZCBvciBmYW1pbHkgaWRcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50SWRWYWxpZGF0aW9uID0gYCR7Q3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTn0ke1NlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUn0ke3RoaXMuY2xpZW50SWR9JHtTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1J9YDtcclxuICAgICAgICAgICAgY29uc3QgZmFtaWx5SWRWYWxpZGF0aW9uID0gYCR7Q3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTn0ke1NlcGFyYXRvcnMuQ0FDSEVfS0VZX1NFUEFSQVRPUn0ke1RIRV9GQU1JTFlfSUR9JHtTZXBhcmF0b3JzLkNBQ0hFX0tFWV9TRVBBUkFUT1J9YDtcclxuICAgICAgICAgICAgaWYgKGxvd2VyQ2FzZUtleS5pbmRleE9mKGNsaWVudElkVmFsaWRhdGlvbi50b0xvd2VyQ2FzZSgpKSA9PT0gLTEgJiZcclxuICAgICAgICAgICAgICAgIGxvd2VyQ2FzZUtleS5pbmRleE9mKGZhbWlseUlkVmFsaWRhdGlvbi50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsb3dlckNhc2VLZXkuaW5kZXhPZih0aGlzLmNsaWVudElkLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBUb2tlbnMgbXVzdCBjb250YWluIHRoZSBjbGllbnRJZFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBjcmVkZW50aWFsIGVudGl0eSBtYXRjaGVzIHRoZSBmaWx0ZXJcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBmaWx0ZXJcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGNyZWRlbnRpYWxNYXRjaGVzRmlsdGVyKGVudGl0eSwgZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKCEhZmlsdGVyLmNsaWVudElkICYmICF0aGlzLm1hdGNoQ2xpZW50SWQoZW50aXR5LCBmaWx0ZXIuY2xpZW50SWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZmlsdGVyLnVzZXJBc3NlcnRpb25IYXNoICYmXHJcbiAgICAgICAgICAgICF0aGlzLm1hdGNoVXNlckFzc2VydGlvbkhhc2goZW50aXR5LCBmaWx0ZXIudXNlckFzc2VydGlvbkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBob21lQWNjb3VudElkIGNhbiBiZSB1bmRlZmluZWQsIGFuZCB3ZSB3YW50IHRvIGZpbHRlciBvdXQgY2FjaGVkIGl0ZW1zIHRoYXQgaGF2ZSBhIGhvbWVBY2NvdW50SWQgb2YgXCJcIlxyXG4gICAgICAgICAqIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhIGNsaWVudF9jcmVkZW50aWFsIHJlcXVlc3QgdG8gcmV0dXJuIGEgY2FjaGVkIHRva2VuIHRoYXQgaGFzIGEgaG9tZUFjY291bnRJZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyLmhvbWVBY2NvdW50SWQgPT09IFwic3RyaW5nXCIgJiZcclxuICAgICAgICAgICAgIXRoaXMubWF0Y2hIb21lQWNjb3VudElkKGVudGl0eSwgZmlsdGVyLmhvbWVBY2NvdW50SWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZmlsdGVyLmVudmlyb25tZW50ICYmXHJcbiAgICAgICAgICAgICF0aGlzLm1hdGNoRW52aXJvbm1lbnQoZW50aXR5LCBmaWx0ZXIuZW52aXJvbm1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZmlsdGVyLnJlYWxtICYmICF0aGlzLm1hdGNoUmVhbG0oZW50aXR5LCBmaWx0ZXIucmVhbG0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZmlsdGVyLmNyZWRlbnRpYWxUeXBlICYmXHJcbiAgICAgICAgICAgICF0aGlzLm1hdGNoQ3JlZGVudGlhbFR5cGUoZW50aXR5LCBmaWx0ZXIuY3JlZGVudGlhbFR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhZmlsdGVyLmZhbWlseUlkICYmICF0aGlzLm1hdGNoRmFtaWx5SWQoZW50aXR5LCBmaWx0ZXIuZmFtaWx5SWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBpZFRva2VucyBkbyBub3QgaGF2ZSBcInRhcmdldFwiLCB0YXJnZXQgc3BlY2lmaWMgcmVmcmVzaFRva2VucyBkbyBleGlzdCBmb3Igc29tZSB0eXBlcyBvZiBhdXRoZW50aWNhdGlvblxyXG4gICAgICAgICAqIFJlc291cmNlIHNwZWNpZmljIHJlZnJlc2ggdG9rZW5zIGNhc2Ugd2lsbCBiZSBhZGRlZCB3aGVuIHRoZSBzdXBwb3J0IGlzIGRlZW1lZCBuZWNlc3NhcnlcclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoISFmaWx0ZXIudGFyZ2V0ICYmICF0aGlzLm1hdGNoVGFyZ2V0KGVudGl0eSwgZmlsdGVyLnRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiByZXF1ZXN0IE9SIGNhY2hlZCBlbnRpdHkgaGFzIHJlcXVlc3RlZCBDbGFpbXMgSGFzaCwgY2hlY2sgaWYgdGhleSBtYXRjaFxyXG4gICAgICAgIGlmIChmaWx0ZXIucmVxdWVzdGVkQ2xhaW1zSGFzaCB8fCBlbnRpdHkucmVxdWVzdGVkQ2xhaW1zSGFzaCkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBtYXRjaCBpZiBlaXRoZXIgaXMgdW5kZWZpbmVkIG9yIHRoZXkgYXJlIGRpZmZlcmVudFxyXG4gICAgICAgICAgICBpZiAoZW50aXR5LnJlcXVlc3RlZENsYWltc0hhc2ggIT09IGZpbHRlci5yZXF1ZXN0ZWRDbGFpbXNIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWNjZXNzIFRva2VuIHdpdGggQXV0aCBTY2hlbWUgc3BlY2lmaWMgbWF0Y2hpbmdcclxuICAgICAgICBpZiAoZW50aXR5LmNyZWRlbnRpYWxUeXBlID09PVxyXG4gICAgICAgICAgICBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRSkge1xyXG4gICAgICAgICAgICBpZiAoISFmaWx0ZXIudG9rZW5UeXBlICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaFRva2VuVHlwZShlbnRpdHksIGZpbHRlci50b2tlblR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gS2V5SWQgKHNzaEtpZCkgaW4gcmVxdWVzdCBtdXN0IG1hdGNoIGNhY2hlZCBTU0ggY2VydGlmaWNhdGUga2V5SWQgYmVjYXVzZSBTU0ggY2VydCBpcyBib3VuZCB0byBhIHNwZWNpZmljIGtleVxyXG4gICAgICAgICAgICBpZiAoZmlsdGVyLnRva2VuVHlwZSA9PT0gQXV0aGVudGljYXRpb25TY2hlbWUuU1NIKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmtleUlkICYmICF0aGlzLm1hdGNoS2V5SWQoZW50aXR5LCBmaWx0ZXIua2V5SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiByZXRyaWV2ZSBhcHBNZXRhZGF0YSBtYXRjaGluZyBhbGwgcHJvdmlkZWQgZmlsdGVyczsgaWYgbm8gZmlsdGVyIGlzIHNldCwgZ2V0IGFsbCBhcHBNZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIGZpbHRlclxyXG4gICAgICovXHJcbiAgICBnZXRBcHBNZXRhZGF0YUZpbHRlcmVkQnkoZmlsdGVyKSB7XHJcbiAgICAgICAgY29uc3QgYWxsQ2FjaGVLZXlzID0gdGhpcy5nZXRLZXlzKCk7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdBcHBNZXRhZGF0YSA9IHt9O1xyXG4gICAgICAgIGFsbENhY2hlS2V5cy5mb3JFYWNoKChjYWNoZUtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBhbnkgbm9uLWFwcE1ldGFkYXRhIHR5cGUgY2FjaGUgZW50aXRpZXNcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQXBwTWV0YWRhdGEoY2FjaGVLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQXR0ZW1wdCByZXRyaWV2YWxcclxuICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5nZXRBcHBNZXRhZGF0YShjYWNoZUtleSk7XHJcbiAgICAgICAgICAgIGlmICghZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEhZmlsdGVyLmVudmlyb25tZW50ICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaEVudmlyb25tZW50KGVudGl0eSwgZmlsdGVyLmVudmlyb25tZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghIWZpbHRlci5jbGllbnRJZCAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hDbGllbnRJZChlbnRpdHksIGZpbHRlci5jbGllbnRJZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRjaGluZ0FwcE1ldGFkYXRhW2NhY2hlS2V5XSA9IGVudGl0eTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdBcHBNZXRhZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmV0cmlldmUgYXV0aG9yaXR5TWV0YWRhdGEgdGhhdCBjb250YWlucyBhIG1hdGNoaW5nIGFsaWFzXHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyXHJcbiAgICAgKi9cclxuICAgIGdldEF1dGhvcml0eU1ldGFkYXRhQnlBbGlhcyhob3N0KSB7XHJcbiAgICAgICAgY29uc3QgYWxsQ2FjaGVLZXlzID0gdGhpcy5nZXRBdXRob3JpdHlNZXRhZGF0YUtleXMoKTtcclxuICAgICAgICBsZXQgbWF0Y2hlZEVudGl0eSA9IG51bGw7XHJcbiAgICAgICAgYWxsQ2FjaGVLZXlzLmZvckVhY2goKGNhY2hlS2V5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGFueSBub24tYXV0aG9yaXR5TWV0YWRhdGEgdHlwZSBjYWNoZSBlbnRpdGllc1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBdXRob3JpdHlNZXRhZGF0YShjYWNoZUtleSkgfHxcclxuICAgICAgICAgICAgICAgIGNhY2hlS2V5LmluZGV4T2YodGhpcy5jbGllbnRJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQXR0ZW1wdCByZXRyaWV2YWxcclxuICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5nZXRBdXRob3JpdHlNZXRhZGF0YShjYWNoZUtleSk7XHJcbiAgICAgICAgICAgIGlmICghZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudGl0eS5hbGlhc2VzLmluZGV4T2YoaG9zdCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0Y2hlZEVudGl0eSA9IGVudGl0eTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlZEVudGl0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgYWNjb3VudHMgYW5kIHJlbGF0ZWQgdG9rZW5zIGZyb20gY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlbW92ZUFsbEFjY291bnRzKCkge1xyXG4gICAgICAgIGNvbnN0IGFsbEFjY291bnRLZXlzID0gdGhpcy5nZXRBY2NvdW50S2V5cygpO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRBY2NvdW50cyA9IFtdO1xyXG4gICAgICAgIGFsbEFjY291bnRLZXlzLmZvckVhY2goKGNhY2hlS2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHJlbW92ZWRBY2NvdW50cy5wdXNoKHRoaXMucmVtb3ZlQWNjb3VudChjYWNoZUtleSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlbW92ZWRBY2NvdW50cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGFjY291bnQgYW5kIHJlbGF0ZWQgdG9rZW5zIGZvciBhIGdpdmVuIGFjY291bnQga2V5XHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudFxyXG4gICAgICovXHJcbiAgICBhc3luYyByZW1vdmVBY2NvdW50KGFjY291bnRLZXkpIHtcclxuICAgICAgICBjb25zdCBhY2NvdW50ID0gdGhpcy5nZXRBY2NvdW50KGFjY291bnRLZXksIHRoaXMuY29tbW9uTG9nZ2VyKTtcclxuICAgICAgICBpZiAoIWFjY291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUFjY291bnRDb250ZXh0KGFjY291bnQpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShhY2NvdW50S2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBjcmVkZW50aWFscyBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGFjY291bnRcclxuICAgICAqIEBwYXJhbSBhY2NvdW50XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlbW92ZUFjY291bnRDb250ZXh0KGFjY291bnQpIHtcclxuICAgICAgICBjb25zdCBhbGxUb2tlbktleXMgPSB0aGlzLmdldFRva2VuS2V5cygpO1xyXG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IGFjY291bnQuZ2VuZXJhdGVBY2NvdW50SWQoKTtcclxuICAgICAgICBjb25zdCByZW1vdmVkQ3JlZGVudGlhbHMgPSBbXTtcclxuICAgICAgICBhbGxUb2tlbktleXMuaWRUb2tlbi5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKGFjY291bnRJZCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSWRUb2tlbihrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWxsVG9rZW5LZXlzLmFjY2Vzc1Rva2VuLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoYWNjb3VudElkKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENyZWRlbnRpYWxzLnB1c2godGhpcy5yZW1vdmVBY2Nlc3NUb2tlbihrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFsbFRva2VuS2V5cy5yZWZyZXNoVG9rZW4uZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihhY2NvdW50SWQpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlZnJlc2hUb2tlbihrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVtb3ZlZENyZWRlbnRpYWxzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyBhIGJvb2xlYW4gaWYgdGhlIGdpdmVuIGNyZWRlbnRpYWwgaXMgcmVtb3ZlZFxyXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVtb3ZlQWNjZXNzVG9rZW4oa2V5KSB7XHJcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IHRoaXMuZ2V0QWNjZXNzVG9rZW5DcmVkZW50aWFsKGtleSk7XHJcbiAgICAgICAgaWYgKCFjcmVkZW50aWFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIFRva2VuIEJpbmRpbmcgS2V5IGZyb20ga2V5IHN0b3JlIGZvciBQb1AgVG9rZW5zIENyZWRlbnRpYWxzXHJcbiAgICAgICAgaWYgKGNyZWRlbnRpYWwuY3JlZGVudGlhbFR5cGUudG9Mb3dlckNhc2UoKSA9PT1cclxuICAgICAgICAgICAgQ3JlZGVudGlhbFR5cGUuQUNDRVNTX1RPS0VOX1dJVEhfQVVUSF9TQ0hFTUUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbC50b2tlblR5cGUgPT09IEF1dGhlbnRpY2F0aW9uU2NoZW1lLlBPUCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5XaXRoQXV0aFNjaGVtZUVudGl0eSA9IGNyZWRlbnRpYWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBraWQgPSBhY2Nlc3NUb2tlbldpdGhBdXRoU2NoZW1lRW50aXR5LmtleUlkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3J5cHRvSW1wbC5yZW1vdmVUb2tlbkJpbmRpbmdLZXkoa2lkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihiaW5kaW5nS2V5Tm90UmVtb3ZlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUl0ZW0oa2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgYXBwIG1ldGFkYXRhIG9iamVjdHMgZnJvbSBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQXBwTWV0YWRhdGEoKSB7XHJcbiAgICAgICAgY29uc3QgYWxsQ2FjaGVLZXlzID0gdGhpcy5nZXRLZXlzKCk7XHJcbiAgICAgICAgYWxsQ2FjaGVLZXlzLmZvckVhY2goKGNhY2hlS2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXBwTWV0YWRhdGEoY2FjaGVLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oY2FjaGVLZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIEFjY291bnRFbnRpdHkgZnJvbSBjYWNoZVxyXG4gICAgICogQHBhcmFtIGFjY291bnRcclxuICAgICAqL1xyXG4gICAgcmVhZEFjY291bnRGcm9tQ2FjaGUoYWNjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnRLZXkgPSBBY2NvdW50RW50aXR5LmdlbmVyYXRlQWNjb3VudENhY2hlS2V5KGFjY291bnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjY291bnQoYWNjb3VudEtleSwgdGhpcy5jb21tb25Mb2dnZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBJZFRva2VuRW50aXR5IGZyb20gY2FjaGVcclxuICAgICAqIEBwYXJhbSBhY2NvdW50IHtBY2NvdW50SW5mb31cclxuICAgICAqIEBwYXJhbSB0b2tlbktleXMgez9Ub2tlbktleXN9XHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmVhbG0gez9zdHJpbmd9XHJcbiAgICAgKiBAcGFyYW0gcGVyZm9ybWFuY2VDbGllbnQgez9JUGVyZm9ybWFuY2VDbGllbnR9XHJcbiAgICAgKiBAcGFyYW0gY29ycmVsYXRpb25JZCB7P3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZ2V0SWRUb2tlbihhY2NvdW50LCB0b2tlbktleXMsIHRhcmdldFJlYWxtLCBwZXJmb3JtYW5jZUNsaWVudCwgY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLnRyYWNlKFwiQ2FjaGVNYW5hZ2VyIC0gZ2V0SWRUb2tlbiBjYWxsZWRcIik7XHJcbiAgICAgICAgY29uc3QgaWRUb2tlbkZpbHRlciA9IHtcclxuICAgICAgICAgICAgaG9tZUFjY291bnRJZDogYWNjb3VudC5ob21lQWNjb3VudElkLFxyXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogYWNjb3VudC5lbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgY3JlZGVudGlhbFR5cGU6IENyZWRlbnRpYWxUeXBlLklEX1RPS0VOLFxyXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgcmVhbG06IHRhcmdldFJlYWxtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgaWRUb2tlbk1hcCA9IHRoaXMuZ2V0SWRUb2tlbnNCeUZpbHRlcihpZFRva2VuRmlsdGVyLCB0b2tlbktleXMpO1xyXG4gICAgICAgIGNvbnN0IG51bUlkVG9rZW5zID0gaWRUb2tlbk1hcC5zaXplO1xyXG4gICAgICAgIGlmIChudW1JZFRva2VucyA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIuaW5mbyhcIkNhY2hlTWFuYWdlcjpnZXRJZFRva2VuIC0gTm8gdG9rZW4gZm91bmRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1JZFRva2VucyA+IDEpIHtcclxuICAgICAgICAgICAgbGV0IHRva2Vuc1RvQmVSZW1vdmVkID0gaWRUb2tlbk1hcDtcclxuICAgICAgICAgICAgLy8gTXVsdGlwbGUgdGVuYW50IHByb2ZpbGVzIGFuZCBubyB0ZW5hbnQgc3BlY2lmaWVkLCBwaWNrIGhvbWUgYWNjb3VudFxyXG4gICAgICAgICAgICBpZiAoIXRhcmdldFJlYWxtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBob21lSWRUb2tlbk1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgICAgIGlkVG9rZW5NYXAuZm9yRWFjaCgoaWRUb2tlbiwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkVG9rZW4ucmVhbG0gPT09IGFjY291bnQudGVuYW50SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9tZUlkVG9rZW5NYXAuc2V0KGtleSwgaWRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Ib21lSWRUb2tlbnMgPSBob21lSWRUb2tlbk1hcC5zaXplO1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bUhvbWVJZFRva2VucyA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlci5pbmZvKFwiQ2FjaGVNYW5hZ2VyOmdldElkVG9rZW4gLSBNdWx0aXBsZSBJRCB0b2tlbnMgZm91bmQgZm9yIGFjY291bnQgYnV0IG5vbmUgbWF0Y2ggYWNjb3VudCBlbnRpdHkgdGVuYW50IGlkLCByZXR1cm5pbmcgZmlyc3QgcmVzdWx0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZFRva2VuTWFwLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG51bUhvbWVJZFRva2VucyA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXCJDYWNoZU1hbmFnZXI6Z2V0SWRUb2tlbiAtIE11bHRpcGxlIElEIHRva2VucyBmb3VuZCBmb3IgYWNjb3VudCwgZGVmYXVsdGluZyB0byBob21lIHRlbmFudCBwcm9maWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBob21lSWRUb2tlbk1hcC52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aXBsZSBJRCB0b2tlbnMgZm9yIGhvbWUgdGVuYW50IHByb2ZpbGUsIHJlbW92ZSBhbGwgYW5kIHJldHVybiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zVG9CZVJlbW92ZWQgPSBob21lSWRUb2tlbk1hcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNdWx0aXBsZSB0b2tlbnMgZm9yIGEgc2luZ2xlIHRlbmFudCBwcm9maWxlLCByZW1vdmUgYWxsIGFuZCByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlci5pbmZvKFwiQ2FjaGVNYW5hZ2VyOmdldElkVG9rZW4gLSBNdWx0aXBsZSBtYXRjaGluZyBJRCB0b2tlbnMgZm91bmQsIGNsZWFyaW5nIHRoZW1cIik7XHJcbiAgICAgICAgICAgIHRva2Vuc1RvQmVSZW1vdmVkLmZvckVhY2goKGlkVG9rZW4sIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJZFRva2VuKGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2VDbGllbnQgJiYgY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQuYWRkRmllbGRzKHsgbXVsdGlNYXRjaGVkSUQ6IGlkVG9rZW5NYXAuc2l6ZSB9LCBjb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIuaW5mbyhcIkNhY2hlTWFuYWdlcjpnZXRJZFRva2VuIC0gUmV0dXJuaW5nIElEIHRva2VuXCIpO1xyXG4gICAgICAgIHJldHVybiBpZFRva2VuTWFwLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgaWRUb2tlbnMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxyXG4gICAgICogQHBhcmFtIGZpbHRlclxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZ2V0SWRUb2tlbnNCeUZpbHRlcihmaWx0ZXIsIHRva2VuS2V5cykge1xyXG4gICAgICAgIGNvbnN0IGlkVG9rZW5LZXlzID0gKHRva2VuS2V5cyAmJiB0b2tlbktleXMuaWRUb2tlbikgfHwgdGhpcy5nZXRUb2tlbktleXMoKS5pZFRva2VuO1xyXG4gICAgICAgIGNvbnN0IGlkVG9rZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGlkVG9rZW5LZXlzLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaWRUb2tlbktleU1hdGNoZXNGaWx0ZXIoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgICAgIC4uLmZpbHRlcixcclxuICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpZFRva2VuID0gdGhpcy5nZXRJZFRva2VuQ3JlZGVudGlhbChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoaWRUb2tlbiAmJiB0aGlzLmNyZWRlbnRpYWxNYXRjaGVzRmlsdGVyKGlkVG9rZW4sIGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIGlkVG9rZW5zLnNldChrZXksIGlkVG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGlkVG9rZW5zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgY2FjaGUga2V5IGFnYWluc3QgZmlsdGVyIGJlZm9yZSByZXRyaWV2aW5nIGFuZCBwYXJzaW5nIGNhY2hlIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ga2V5XHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBpZFRva2VuS2V5TWF0Y2hlc0ZpbHRlcihpbnB1dEtleSwgZmlsdGVyKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gaW5wdXRLZXkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoZmlsdGVyLmNsaWVudElkICYmXHJcbiAgICAgICAgICAgIGtleS5pbmRleE9mKGZpbHRlci5jbGllbnRJZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyLmhvbWVBY2NvdW50SWQgJiZcclxuICAgICAgICAgICAga2V5LmluZGV4T2YoZmlsdGVyLmhvbWVBY2NvdW50SWQudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaWRUb2tlbiBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICogQHBhcmFtIGtleVxyXG4gICAgICovXHJcbiAgICByZW1vdmVJZFRva2VuKGtleSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHJlZnJlc2ggdG9rZW4gZnJvbSB0aGUgY2FjaGVcclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlUmVmcmVzaFRva2VuKGtleSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBBY2Nlc3NUb2tlbkVudGl0eSBmcm9tIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudCB7QWNjb3VudEluZm99XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCB7QmFzZUF1dGhSZXF1ZXN0fVxyXG4gICAgICogQHBhcmFtIHRva2VuS2V5cyB7P1Rva2VuS2V5c31cclxuICAgICAqIEBwYXJhbSBwZXJmb3JtYW5jZUNsaWVudCB7P0lQZXJmb3JtYW5jZUNsaWVudH1cclxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkIHs/c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXRBY2Nlc3NUb2tlbihhY2NvdW50LCByZXF1ZXN0LCB0b2tlbktleXMsIHRhcmdldFJlYWxtLCBwZXJmb3JtYW5jZUNsaWVudCwgY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLnRyYWNlKFwiQ2FjaGVNYW5hZ2VyIC0gZ2V0QWNjZXNzVG9rZW4gY2FsbGVkXCIpO1xyXG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IFNjb3BlU2V0LmNyZWF0ZVNlYXJjaFNjb3BlcyhyZXF1ZXN0LnNjb3Blcyk7XHJcbiAgICAgICAgY29uc3QgYXV0aFNjaGVtZSA9IHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgfHwgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRGlzdGluZ3Vpc2ggYmV0d2VlbiBCZWFyZXIgYW5kIFBvUC9TU0ggdG9rZW4gY2FjaGUgdHlwZXNcclxuICAgICAgICAgKiBDYXN0IHRvIGxvd2VyY2FzZSB0byBoYW5kbGUgXCJiZWFyZXJcIiBmcm9tIEFERlNcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBjcmVkZW50aWFsVHlwZSA9IGF1dGhTY2hlbWUgJiZcclxuICAgICAgICAgICAgYXV0aFNjaGVtZS50b0xvd2VyQ2FzZSgpICE9PVxyXG4gICAgICAgICAgICAgICAgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgPyBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRVxyXG4gICAgICAgICAgICA6IENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTjtcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbkZpbHRlciA9IHtcclxuICAgICAgICAgICAgaG9tZUFjY291bnRJZDogYWNjb3VudC5ob21lQWNjb3VudElkLFxyXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogYWNjb3VudC5lbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgY3JlZGVudGlhbFR5cGU6IGNyZWRlbnRpYWxUeXBlLFxyXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgcmVhbG06IHRhcmdldFJlYWxtIHx8IGFjY291bnQudGVuYW50SWQsXHJcbiAgICAgICAgICAgIHRhcmdldDogc2NvcGVzLFxyXG4gICAgICAgICAgICB0b2tlblR5cGU6IGF1dGhTY2hlbWUsXHJcbiAgICAgICAgICAgIGtleUlkOiByZXF1ZXN0LnNzaEtpZCxcclxuICAgICAgICAgICAgcmVxdWVzdGVkQ2xhaW1zSGFzaDogcmVxdWVzdC5yZXF1ZXN0ZWRDbGFpbXNIYXNoLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5LZXlzID0gKHRva2VuS2V5cyAmJiB0b2tlbktleXMuYWNjZXNzVG9rZW4pIHx8XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5LZXlzKCkuYWNjZXNzVG9rZW47XHJcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5zID0gW107XHJcbiAgICAgICAgYWNjZXNzVG9rZW5LZXlzLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBrZXlcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW5LZXlNYXRjaGVzRmlsdGVyKGtleSwgYWNjZXNzVG9rZW5GaWx0ZXIsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMuZ2V0QWNjZXNzVG9rZW5DcmVkZW50aWFsKGtleSk7XHJcbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsTWF0Y2hlc0ZpbHRlcihhY2Nlc3NUb2tlbiwgYWNjZXNzVG9rZW5GaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW5zLnB1c2goYWNjZXNzVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbnVtQWNjZXNzVG9rZW5zID0gYWNjZXNzVG9rZW5zLmxlbmd0aDtcclxuICAgICAgICBpZiAobnVtQWNjZXNzVG9rZW5zIDwgMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlci5pbmZvKFwiQ2FjaGVNYW5hZ2VyOmdldEFjY2Vzc1Rva2VuIC0gTm8gdG9rZW4gZm91bmRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1BY2Nlc3NUb2tlbnMgPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXCJDYWNoZU1hbmFnZXI6Z2V0QWNjZXNzVG9rZW4gLSBNdWx0aXBsZSBhY2Nlc3MgdG9rZW5zIGZvdW5kLCBjbGVhcmluZyB0aGVtXCIpO1xyXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbnMuZm9yRWFjaCgoYWNjZXNzVG9rZW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5yZW1vdmVBY2Nlc3NUb2tlbihnZW5lcmF0ZUNyZWRlbnRpYWxLZXkoYWNjZXNzVG9rZW4pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZUNsaWVudCAmJiBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUNsaWVudC5hZGRGaWVsZHMoeyBtdWx0aU1hdGNoZWRBVDogYWNjZXNzVG9rZW5zLmxlbmd0aCB9LCBjb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21tb25Mb2dnZXIuaW5mbyhcIkNhY2hlTWFuYWdlcjpnZXRBY2Nlc3NUb2tlbiAtIFJldHVybmluZyBhY2Nlc3MgdG9rZW5cIik7XHJcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2Vuc1swXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgdGhlIGNhY2hlIGtleSBhZ2FpbnN0IGZpbHRlciBiZWZvcmUgcmV0cmlldmluZyBhbmQgcGFyc2luZyBjYWNoZSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIGtleVxyXG4gICAgICogQHBhcmFtIGZpbHRlclxyXG4gICAgICogQHBhcmFtIGtleU11c3RDb250YWluQWxsU2NvcGVzXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBhY2Nlc3NUb2tlbktleU1hdGNoZXNGaWx0ZXIoaW5wdXRLZXksIGZpbHRlciwga2V5TXVzdENvbnRhaW5BbGxTY29wZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBpbnB1dEtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChmaWx0ZXIuY2xpZW50SWQgJiZcclxuICAgICAgICAgICAga2V5LmluZGV4T2YoZmlsdGVyLmNsaWVudElkLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWx0ZXIuaG9tZUFjY291bnRJZCAmJlxyXG4gICAgICAgICAgICBrZXkuaW5kZXhPZihmaWx0ZXIuaG9tZUFjY291bnRJZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyLnJlYWxtICYmIGtleS5pbmRleE9mKGZpbHRlci5yZWFsbS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyLnJlcXVlc3RlZENsYWltc0hhc2ggJiZcclxuICAgICAgICAgICAga2V5LmluZGV4T2YoZmlsdGVyLnJlcXVlc3RlZENsYWltc0hhc2gudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbHRlci50YXJnZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NvcGVzID0gZmlsdGVyLnRhcmdldC5hc0FycmF5KCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5TXVzdENvbnRhaW5BbGxTY29wZXMgJiZcclxuICAgICAgICAgICAgICAgICAgICAha2V5LmluY2x1ZGVzKHNjb3Blc1tpXS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIGNhY2hlIGxvb2t1cCBhIG1pc3Npbmcgc2NvcGUgd291bGQgYmUgYSBjYWNoZSBtaXNzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWtleU11c3RDb250YWluQWxsU2NvcGVzICYmXHJcbiAgICAgICAgICAgICAgICAgICAga2V5LmluY2x1ZGVzKHNjb3Blc1tpXS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIGNhY2hlIHdyaXRlLCBhbnkgdG9rZW4gd2l0aCBhIHN1YnNldCBvZiByZXF1ZXN0ZWQgc2NvcGVzIHNob3VsZCBiZSByZXBsYWNlZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBhY2Nlc3MgdG9rZW5zIG1hdGNoaW5nIHRoZSBmaWx0ZXJcclxuICAgICAqIEBwYXJhbSBmaWx0ZXJcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGdldEFjY2Vzc1Rva2Vuc0J5RmlsdGVyKGZpbHRlcikge1xyXG4gICAgICAgIGNvbnN0IHRva2VuS2V5cyA9IHRoaXMuZ2V0VG9rZW5LZXlzKCk7XHJcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5zID0gW107XHJcbiAgICAgICAgdG9rZW5LZXlzLmFjY2Vzc1Rva2VuLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjZXNzVG9rZW5LZXlNYXRjaGVzRmlsdGVyKGtleSwgZmlsdGVyLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5nZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxNYXRjaGVzRmlsdGVyKGFjY2Vzc1Rva2VuLCBmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbnMucHVzaChhY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW5zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gcmV0cmlldmUgdGhlIGFwcHJvcHJpYXRlIHJlZnJlc2ggdG9rZW4gZnJvbSBjYWNoZVxyXG4gICAgICogQHBhcmFtIGFjY291bnQge0FjY291bnRJbmZvfVxyXG4gICAgICogQHBhcmFtIGZhbWlseVJUIHtib29sZWFufVxyXG4gICAgICogQHBhcmFtIHRva2VuS2V5cyB7P1Rva2VuS2V5c31cclxuICAgICAqIEBwYXJhbSBwZXJmb3JtYW5jZUNsaWVudCB7P0lQZXJmb3JtYW5jZUNsaWVudH1cclxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkIHs/c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXRSZWZyZXNoVG9rZW4oYWNjb3VudCwgZmFtaWx5UlQsIHRva2VuS2V5cywgcGVyZm9ybWFuY2VDbGllbnQsIGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlci50cmFjZShcIkNhY2hlTWFuYWdlciAtIGdldFJlZnJlc2hUb2tlbiBjYWxsZWRcIik7XHJcbiAgICAgICAgY29uc3QgaWQgPSBmYW1pbHlSVCA/IFRIRV9GQU1JTFlfSUQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuRmlsdGVyID0ge1xyXG4gICAgICAgICAgICBob21lQWNjb3VudElkOiBhY2NvdW50LmhvbWVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBhY2NvdW50LmVudmlyb25tZW50LFxyXG4gICAgICAgICAgICBjcmVkZW50aWFsVHlwZTogQ3JlZGVudGlhbFR5cGUuUkVGUkVTSF9UT0tFTixcclxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXHJcbiAgICAgICAgICAgIGZhbWlseUlkOiBpZCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbktleXMgPSAodG9rZW5LZXlzICYmIHRva2VuS2V5cy5yZWZyZXNoVG9rZW4pIHx8XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5LZXlzKCkucmVmcmVzaFRva2VuO1xyXG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbnMgPSBbXTtcclxuICAgICAgICByZWZyZXNoVG9rZW5LZXlzLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBrZXlcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRva2VuS2V5TWF0Y2hlc0ZpbHRlcihrZXksIHJlZnJlc2hUb2tlbkZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHRoaXMuZ2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoVG9rZW4gJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxNYXRjaGVzRmlsdGVyKHJlZnJlc2hUb2tlbiwgcmVmcmVzaFRva2VuRmlsdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlbnMucHVzaChyZWZyZXNoVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbnVtUmVmcmVzaFRva2VucyA9IHJlZnJlc2hUb2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChudW1SZWZyZXNoVG9rZW5zIDwgMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1vbkxvZ2dlci5pbmZvKFwiQ2FjaGVNYW5hZ2VyOmdldFJlZnJlc2hUb2tlbiAtIE5vIHJlZnJlc2ggdG9rZW4gZm91bmQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkcmVzcyB0aGUgZWxzZSBjYXNlIGFmdGVyIHJlbW92ZSBmdW5jdGlvbnMgYWRkcmVzcyBlbnZpcm9ubWVudCBhbGlhc2VzXHJcbiAgICAgICAgaWYgKG51bVJlZnJlc2hUb2tlbnMgPiAxICYmIHBlcmZvcm1hbmNlQ2xpZW50ICYmIGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQuYWRkRmllbGRzKHsgbXVsdGlNYXRjaGVkUlQ6IG51bVJlZnJlc2hUb2tlbnMgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tbW9uTG9nZ2VyLmluZm8oXCJDYWNoZU1hbmFnZXI6Z2V0UmVmcmVzaFRva2VuIC0gcmV0dXJuaW5nIHJlZnJlc2ggdG9rZW5cIik7XHJcbiAgICAgICAgcmV0dXJuIHJlZnJlc2hUb2tlbnNbMF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBjYWNoZSBrZXkgYWdhaW5zdCBmaWx0ZXIgYmVmb3JlIHJldHJpZXZpbmcgYW5kIHBhcnNpbmcgY2FjaGUgdmFsdWVcclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqIEBwYXJhbSBmaWx0ZXJcclxuICAgICAqL1xyXG4gICAgcmVmcmVzaFRva2VuS2V5TWF0Y2hlc0ZpbHRlcihpbnB1dEtleSwgZmlsdGVyKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gaW5wdXRLZXkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoZmlsdGVyLmZhbWlseUlkICYmXHJcbiAgICAgICAgICAgIGtleS5pbmRleE9mKGZpbHRlci5mYW1pbHlJZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBmYW1pbHlJZCBpcyB1c2VkLCBjbGllbnRJZCBpcyBub3QgaW4gdGhlIGtleVxyXG4gICAgICAgIGlmICghZmlsdGVyLmZhbWlseUlkICYmXHJcbiAgICAgICAgICAgIGZpbHRlci5jbGllbnRJZCAmJlxyXG4gICAgICAgICAgICBrZXkuaW5kZXhPZihmaWx0ZXIuY2xpZW50SWQudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbHRlci5ob21lQWNjb3VudElkICYmXHJcbiAgICAgICAgICAgIGtleS5pbmRleE9mKGZpbHRlci5ob21lQWNjb3VudElkLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBBcHBNZXRhZGF0YUVudGl0eSBmcm9tIGNhY2hlXHJcbiAgICAgKi9cclxuICAgIHJlYWRBcHBNZXRhZGF0YUZyb21DYWNoZShlbnZpcm9ubWVudCkge1xyXG4gICAgICAgIGNvbnN0IGFwcE1ldGFkYXRhRmlsdGVyID0ge1xyXG4gICAgICAgICAgICBlbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YSA9IHRoaXMuZ2V0QXBwTWV0YWRhdGFGaWx0ZXJlZEJ5KGFwcE1ldGFkYXRhRmlsdGVyKTtcclxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YUVudHJpZXMgPSBPYmplY3Qua2V5cyhhcHBNZXRhZGF0YSkubWFwKChrZXkpID0+IGFwcE1ldGFkYXRhW2tleV0pO1xyXG4gICAgICAgIGNvbnN0IG51bUFwcE1ldGFkYXRhID0gYXBwTWV0YWRhdGFFbnRyaWVzLmxlbmd0aDtcclxuICAgICAgICBpZiAobnVtQXBwTWV0YWRhdGEgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1BcHBNZXRhZGF0YSA+IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG11bHRpcGxlTWF0Y2hpbmdBcHBNZXRhZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcHBNZXRhZGF0YUVudHJpZXNbMF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZmFtaWx5X2lkIHZhbHVlIGFzc29jaWF0ZWQgIHdpdGggRk9DSVxyXG4gICAgICogQHBhcmFtIGVudmlyb25tZW50XHJcbiAgICAgKiBAcGFyYW0gY2xpZW50SWRcclxuICAgICAqL1xyXG4gICAgaXNBcHBNZXRhZGF0YUZPQ0koZW52aXJvbm1lbnQpIHtcclxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YSA9IHRoaXMucmVhZEFwcE1ldGFkYXRhRnJvbUNhY2hlKGVudmlyb25tZW50KTtcclxuICAgICAgICByZXR1cm4gISEoYXBwTWV0YWRhdGEgJiYgYXBwTWV0YWRhdGEuZmFtaWx5SWQgPT09IFRIRV9GQU1JTFlfSUQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggYWNjb3VudCBpZHNcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIGhvbWVBY2NvdW50SWRcclxuICAgICAqL1xyXG4gICAgbWF0Y2hIb21lQWNjb3VudElkKGVudGl0eSwgaG9tZUFjY291bnRJZCkge1xyXG4gICAgICAgIHJldHVybiAhISh0eXBlb2YgZW50aXR5LmhvbWVBY2NvdW50SWQgPT09IFwic3RyaW5nXCIgJiZcclxuICAgICAgICAgICAgaG9tZUFjY291bnRJZCA9PT0gZW50aXR5LmhvbWVBY2NvdW50SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggYWNjb3VudCBpZHNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBsb2NhbEFjY291bnRJZFxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgbWF0Y2hMb2NhbEFjY291bnRJZEZyb21Ub2tlbkNsYWltcyh0b2tlbkNsYWltcywgbG9jYWxBY2NvdW50SWQpIHtcclxuICAgICAgICBjb25zdCBpZFRva2VuTG9jYWxBY2NvdW50SWQgPSB0b2tlbkNsYWltcy5vaWQgfHwgdG9rZW5DbGFpbXMuc3ViO1xyXG4gICAgICAgIHJldHVybiBsb2NhbEFjY291bnRJZCA9PT0gaWRUb2tlbkxvY2FsQWNjb3VudElkO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hMb2NhbEFjY291bnRJZEZyb21UZW5hbnRQcm9maWxlKHRlbmFudFByb2ZpbGUsIGxvY2FsQWNjb3VudElkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRlbmFudFByb2ZpbGUubG9jYWxBY2NvdW50SWQgPT09IGxvY2FsQWNjb3VudElkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggbmFtZXNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBkb3duY2FzZWQgbmFtZSBwcm9wZXJ0aWVzIGFyZSBwcmVzZW50IGFuZCBtYXRjaCBpbiB0aGUgZmlsdGVyIGFuZCB0aGUgZW50aXR5XHJcbiAgICAgKi9cclxuICAgIG1hdGNoTmFtZShjbGFpbXMsIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gISEobmFtZS50b0xvd2VyQ2FzZSgpID09PSBjbGFpbXMubmFtZT8udG9Mb3dlckNhc2UoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGhlbHBlciB0byBtYXRjaCB1c2VybmFtZXNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSB1c2VybmFtZVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgbWF0Y2hVc2VybmFtZShjYWNoZWRVc2VybmFtZSwgZmlsdGVyVXNlcm5hbWUpIHtcclxuICAgICAgICByZXR1cm4gISEoY2FjaGVkVXNlcm5hbWUgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGNhY2hlZFVzZXJuYW1lID09PSBcInN0cmluZ1wiICYmXHJcbiAgICAgICAgICAgIGZpbHRlclVzZXJuYW1lPy50b0xvd2VyQ2FzZSgpID09PSBjYWNoZWRVc2VybmFtZS50b0xvd2VyQ2FzZSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogaGVscGVyIHRvIG1hdGNoIGFzc2VydGlvblxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gb2JvQXNzZXJ0aW9uXHJcbiAgICAgKi9cclxuICAgIG1hdGNoVXNlckFzc2VydGlvbkhhc2goZW50aXR5LCB1c2VyQXNzZXJ0aW9uSGFzaCkge1xyXG4gICAgICAgIHJldHVybiAhIShlbnRpdHkudXNlckFzc2VydGlvbkhhc2ggJiZcclxuICAgICAgICAgICAgdXNlckFzc2VydGlvbkhhc2ggPT09IGVudGl0eS51c2VyQXNzZXJ0aW9uSGFzaCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGhlbHBlciB0byBtYXRjaCBlbnZpcm9ubWVudFxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gZW52aXJvbm1lbnRcclxuICAgICAqL1xyXG4gICAgbWF0Y2hFbnZpcm9ubWVudChlbnRpdHksIGVudmlyb25tZW50KSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgc3RhdGljIGF1dGhvcml0eSBvcHRpb25zIGZpcnN0IGZvciBjYXNlcyB3aGVyZSBhdXRob3JpdHkgbWV0YWRhdGEgaGFzIG5vdCBiZWVuIHJlc29sdmVkIGFuZCBjYWNoZWQgeWV0XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGljQXV0aG9yaXR5T3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0aWNBbGlhc2VzID0gZ2V0QWxpYXNlc0Zyb21TdGF0aWNTb3VyY2VzKHRoaXMuc3RhdGljQXV0aG9yaXR5T3B0aW9ucywgdGhpcy5jb21tb25Mb2dnZXIpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGljQWxpYXNlcy5pbmNsdWRlcyhlbnZpcm9ubWVudCkgJiZcclxuICAgICAgICAgICAgICAgIHN0YXRpY0FsaWFzZXMuaW5jbHVkZXMoZW50aXR5LmVudmlyb25tZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUXVlcnkgbWV0YWRhdGEgY2FjaGUgaWYgbm8gc3RhdGljIGF1dGhvcml0eSBjb25maWd1cmF0aW9uIGhhcyBhbGlhc2VzIHRoYXQgbWF0Y2ggZW52aXJvbWVudFxyXG4gICAgICAgIGNvbnN0IGNsb3VkTWV0YWRhdGEgPSB0aGlzLmdldEF1dGhvcml0eU1ldGFkYXRhQnlBbGlhcyhlbnZpcm9ubWVudCk7XHJcbiAgICAgICAgaWYgKGNsb3VkTWV0YWRhdGEgJiZcclxuICAgICAgICAgICAgY2xvdWRNZXRhZGF0YS5hbGlhc2VzLmluZGV4T2YoZW50aXR5LmVudmlyb25tZW50KSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGhlbHBlciB0byBtYXRjaCBjcmVkZW50aWFsIHR5cGVcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFsVHlwZVxyXG4gICAgICovXHJcbiAgICBtYXRjaENyZWRlbnRpYWxUeXBlKGVudGl0eSwgY3JlZGVudGlhbFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gKGVudGl0eS5jcmVkZW50aWFsVHlwZSAmJlxyXG4gICAgICAgICAgICBjcmVkZW50aWFsVHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbnRpdHkuY3JlZGVudGlhbFR5cGUudG9Mb3dlckNhc2UoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGhlbHBlciB0byBtYXRjaCBjbGllbnQgaWRzXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gY2xpZW50SWRcclxuICAgICAqL1xyXG4gICAgbWF0Y2hDbGllbnRJZChlbnRpdHksIGNsaWVudElkKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKGVudGl0eS5jbGllbnRJZCAmJiBjbGllbnRJZCA9PT0gZW50aXR5LmNsaWVudElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogaGVscGVyIHRvIG1hdGNoIGZhbWlseSBpZHNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBmYW1pbHlJZFxyXG4gICAgICovXHJcbiAgICBtYXRjaEZhbWlseUlkKGVudGl0eSwgZmFtaWx5SWQpIHtcclxuICAgICAgICByZXR1cm4gISEoZW50aXR5LmZhbWlseUlkICYmIGZhbWlseUlkID09PSBlbnRpdHkuZmFtaWx5SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggcmVhbG1cclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSByZWFsbVxyXG4gICAgICovXHJcbiAgICBtYXRjaFJlYWxtKGVudGl0eSwgcmVhbG0pIHtcclxuICAgICAgICByZXR1cm4gISEoZW50aXR5LnJlYWxtPy50b0xvd2VyQ2FzZSgpID09PSByZWFsbS50b0xvd2VyQ2FzZSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogaGVscGVyIHRvIG1hdGNoIG5hdGl2ZUFjY291bnRJZFxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICogQHBhcmFtIG5hdGl2ZUFjY291bnRJZFxyXG4gICAgICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIHRoZSBtYXRjaCByZXN1bHRcclxuICAgICAqL1xyXG4gICAgbWF0Y2hOYXRpdmVBY2NvdW50SWQoZW50aXR5LCBuYXRpdmVBY2NvdW50SWQpIHtcclxuICAgICAgICByZXR1cm4gISEoZW50aXR5Lm5hdGl2ZUFjY291bnRJZCAmJiBuYXRpdmVBY2NvdW50SWQgPT09IGVudGl0eS5uYXRpdmVBY2NvdW50SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBoZWxwZXIgdG8gbWF0Y2ggbG9naW5IaW50IHdoaWNoIGNhbiBiZSBlaXRoZXI6XHJcbiAgICAgKiAxLiBsb2dpbl9oaW50IElEIHRva2VuIGNsYWltXHJcbiAgICAgKiAyLiB1c2VybmFtZSBpbiBjYWNoZWQgYWNjb3VudCBvYmplY3RcclxuICAgICAqIDMuIHVwbiBpbiBJRCB0b2tlbiBjbGFpbXNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBsb2dpbkhpbnRcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIG1hdGNoTG9naW5IaW50RnJvbVRva2VuQ2xhaW1zKHRva2VuQ2xhaW1zLCBsb2dpbkhpbnQpIHtcclxuICAgICAgICBpZiAodG9rZW5DbGFpbXMubG9naW5faGludCA9PT0gbG9naW5IaW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5DbGFpbXMucHJlZmVycmVkX3VzZXJuYW1lID09PSBsb2dpbkhpbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbkNsYWltcy51cG4gPT09IGxvZ2luSGludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gbWF0Y2ggc2lkXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gc2lkXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzaWQgY2xhaW0gaXMgcHJlc2VudCBhbmQgbWF0Y2hlcyB0aGUgZmlsdGVyXHJcbiAgICAgKi9cclxuICAgIG1hdGNoU2lkKGlkVG9rZW5DbGFpbXMsIHNpZCkge1xyXG4gICAgICAgIHJldHVybiBpZFRva2VuQ2xhaW1zLnNpZCA9PT0gc2lkO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hBdXRob3JpdHlUeXBlKGVudGl0eSwgYXV0aG9yaXR5VHlwZSkge1xyXG4gICAgICAgIHJldHVybiAhIShlbnRpdHkuYXV0aG9yaXR5VHlwZSAmJlxyXG4gICAgICAgICAgICBhdXRob3JpdHlUeXBlLnRvTG93ZXJDYXNlKCkgPT09IGVudGl0eS5hdXRob3JpdHlUeXBlLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRhcmdldCBzY29wZXMgYXJlIGEgc3Vic2V0IG9mIHRoZSBjdXJyZW50IGVudGl0eSdzIHNjb3BlcywgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICogQHBhcmFtIHRhcmdldFxyXG4gICAgICovXHJcbiAgICBtYXRjaFRhcmdldChlbnRpdHksIHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGlzTm90QWNjZXNzVG9rZW5DcmVkZW50aWFsID0gZW50aXR5LmNyZWRlbnRpYWxUeXBlICE9PSBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU4gJiZcclxuICAgICAgICAgICAgZW50aXR5LmNyZWRlbnRpYWxUeXBlICE9PVxyXG4gICAgICAgICAgICAgICAgQ3JlZGVudGlhbFR5cGUuQUNDRVNTX1RPS0VOX1dJVEhfQVVUSF9TQ0hFTUU7XHJcbiAgICAgICAgaWYgKGlzTm90QWNjZXNzVG9rZW5DcmVkZW50aWFsIHx8ICFlbnRpdHkudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW50aXR5U2NvcGVTZXQgPSBTY29wZVNldC5mcm9tU3RyaW5nKGVudGl0eS50YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiBlbnRpdHlTY29wZVNldC5jb250YWluc1Njb3BlU2V0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3JlZGVudGlhbCdzIHRva2VuVHlwZSBvciBBdXRoZW50aWNhdGlvbiBTY2hlbWUgbWF0Y2hlcyB0aGUgb25lIGluIHRoZSByZXF1ZXN0LCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSB0b2tlblR5cGVcclxuICAgICAqL1xyXG4gICAgbWF0Y2hUb2tlblR5cGUoZW50aXR5LCB0b2tlblR5cGUpIHtcclxuICAgICAgICByZXR1cm4gISEoZW50aXR5LnRva2VuVHlwZSAmJiBlbnRpdHkudG9rZW5UeXBlID09PSB0b2tlblR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNyZWRlbnRpYWwncyBrZXlJZCBtYXRjaGVzIHRoZSBvbmUgaW4gdGhlIHJlcXVlc3QsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICogQHBhcmFtIGtleUlkXHJcbiAgICAgKi9cclxuICAgIG1hdGNoS2V5SWQoZW50aXR5LCBrZXlJZCkge1xyXG4gICAgICAgIHJldHVybiAhIShlbnRpdHkua2V5SWQgJiYgZW50aXR5LmtleUlkID09PSBrZXlJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgaWYgYSBnaXZlbiBjYWNoZSBlbnRpdHkgaXMgb2YgdGhlIHR5cGUgYXBwbWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqL1xyXG4gICAgaXNBcHBNZXRhZGF0YShrZXkpIHtcclxuICAgICAgICByZXR1cm4ga2V5LmluZGV4T2YoQVBQX01FVEFEQVRBKSAhPT0gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgaWYgYSBnaXZlbiBjYWNoZSBlbnRpdHkgaXMgb2YgdGhlIHR5cGUgYXV0aG9yaXR5bWV0YWRhdGFcclxuICAgICAqIEBwYXJhbSBrZXlcclxuICAgICAqL1xyXG4gICAgaXNBdXRob3JpdHlNZXRhZGF0YShrZXkpIHtcclxuICAgICAgICByZXR1cm4ga2V5LmluZGV4T2YoQVVUSE9SSVRZX01FVEFEQVRBX0NPTlNUQU5UUy5DQUNIRV9LRVkpICE9PSAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyBjYWNoZSBrZXkgdXNlZCBmb3IgY2xvdWQgaW5zdGFuY2UgbWV0YWRhdGFcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVBdXRob3JpdHlNZXRhZGF0YUNhY2hlS2V5KGF1dGhvcml0eSkge1xyXG4gICAgICAgIHJldHVybiBgJHtBVVRIT1JJVFlfTUVUQURBVEFfQ09OU1RBTlRTLkNBQ0hFX0tFWX0tJHt0aGlzLmNsaWVudElkfS0ke2F1dGhvcml0eX1gO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gY29udmVydCBzZXJpYWxpemVkIGRhdGEgdG8gb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0ganNvblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdG9PYmplY3Qob2JqLCBqc29uKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4ganNvbikge1xyXG4gICAgICAgICAgICBvYmpbcHJvcGVydHlOYW1lXSA9IGpzb25bcHJvcGVydHlOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG4vKiogQGludGVybmFsICovXHJcbmNsYXNzIERlZmF1bHRTdG9yYWdlQ2xhc3MgZXh0ZW5kcyBDYWNoZU1hbmFnZXIge1xyXG4gICAgYXN5bmMgc2V0QWNjb3VudCgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWNjb3VudCgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0SWRUb2tlbkNyZWRlbnRpYWwoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH1cclxuICAgIGdldElkVG9rZW5DcmVkZW50aWFsKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH1cclxuICAgIGdldEFjY2Vzc1Rva2VuQ3JlZGVudGlhbCgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbCgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbCgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgc2V0QXBwTWV0YWRhdGEoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH1cclxuICAgIGdldEFwcE1ldGFkYXRhKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2ZXJUZWxlbWV0cnkoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH1cclxuICAgIGdldFNlcnZlclRlbGVtZXRyeSgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgc2V0QXV0aG9yaXR5TWV0YWRhdGEoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH1cclxuICAgIGdldEF1dGhvcml0eU1ldGFkYXRhKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9XHJcbiAgICBnZXRBdXRob3JpdHlNZXRhZGF0YUtleXMoKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG1ldGhvZE5vdEltcGxlbWVudGVkKTtcclxuICAgIH1cclxuICAgIHNldFRocm90dGxpbmdDYWNoZSgpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGhyb3R0bGluZ0NhY2hlKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVJdGVtKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9XHJcbiAgICBnZXRLZXlzKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9XHJcbiAgICBnZXRBY2NvdW50S2V5cygpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW5LZXlzKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQ2FjaGVNYW5hZ2VyLCBEZWZhdWx0U3RvcmFnZUNsYXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZU1hbmFnZXIubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OIH0gZnJvbSAnLi4vY3J5cHRvL0lDcnlwdG8ubWpzJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICcuLi9sb2dnZXIvTG9nZ2VyLm1qcyc7XG5pbXBvcnQgeyBERUZBVUxUX1RPS0VOX1JFTkVXQUxfT0ZGU0VUX1NFQywgQ29uc3RhbnRzIH0gZnJvbSAnLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZU1ldGFkYXRhLm1qcyc7XG5pbXBvcnQgeyBBenVyZUNsb3VkSW5zdGFuY2UgfSBmcm9tICcuLi9hdXRob3JpdHkvQXV0aG9yaXR5T3B0aW9ucy5tanMnO1xuaW1wb3J0IHsgRGVmYXVsdFN0b3JhZ2VDbGFzcyB9IGZyb20gJy4uL2NhY2hlL0NhY2hlTWFuYWdlci5tanMnO1xuaW1wb3J0IHsgUHJvdG9jb2xNb2RlIH0gZnJvbSAnLi4vYXV0aG9yaXR5L1Byb3RvY29sTW9kZS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50QXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyBtZXRob2ROb3RJbXBsZW1lbnRlZCB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX1NZU1RFTV9PUFRJT05TID0ge1xyXG4gICAgdG9rZW5SZW5ld2FsT2Zmc2V0U2Vjb25kczogREVGQVVMVF9UT0tFTl9SRU5FV0FMX09GRlNFVF9TRUMsXHJcbiAgICBwcmV2ZW50Q29yc1ByZWZsaWdodDogZmFsc2UsXHJcbn07XHJcbmNvbnN0IERFRkFVTFRfTE9HR0VSX0lNUExFTUVOVEFUSU9OID0ge1xyXG4gICAgbG9nZ2VyQ2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAvLyBhbGxvdyB1c2VycyB0byBub3Qgc2V0IGxvZ2dlckNhbGxiYWNrXHJcbiAgICB9LFxyXG4gICAgcGlpTG9nZ2luZ0VuYWJsZWQ6IGZhbHNlLFxyXG4gICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm8sXHJcbiAgICBjb3JyZWxhdGlvbklkOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG59O1xyXG5jb25zdCBERUZBVUxUX0NBQ0hFX09QVElPTlMgPSB7XHJcbiAgICBjbGFpbXNCYXNlZENhY2hpbmdFbmFibGVkOiBmYWxzZSxcclxufTtcclxuY29uc3QgREVGQVVMVF9ORVRXT1JLX0lNUExFTUVOVEFUSU9OID0ge1xyXG4gICAgYXN5bmMgc2VuZEdldFJlcXVlc3RBc3luYygpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IobWV0aG9kTm90SW1wbGVtZW50ZWQpO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIHNlbmRQb3N0UmVxdWVzdEFzeW5jKCkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihtZXRob2ROb3RJbXBsZW1lbnRlZCk7XHJcbiAgICB9LFxyXG59O1xyXG5jb25zdCBERUZBVUxUX0xJQlJBUllfSU5GTyA9IHtcclxuICAgIHNrdTogQ29uc3RhbnRzLlNLVSxcclxuICAgIHZlcnNpb246IHZlcnNpb24sXHJcbiAgICBjcHU6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICBvczogQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxufTtcclxuY29uc3QgREVGQVVMVF9DTElFTlRfQ1JFREVOVElBTFMgPSB7XHJcbiAgICBjbGllbnRTZWNyZXQ6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICBjbGllbnRBc3NlcnRpb246IHVuZGVmaW5lZCxcclxufTtcclxuY29uc3QgREVGQVVMVF9BWlVSRV9DTE9VRF9PUFRJT05TID0ge1xyXG4gICAgYXp1cmVDbG91ZEluc3RhbmNlOiBBenVyZUNsb3VkSW5zdGFuY2UuTm9uZSxcclxuICAgIHRlbmFudDogYCR7Q29uc3RhbnRzLkRFRkFVTFRfQ09NTU9OX1RFTkFOVH1gLFxyXG59O1xyXG5jb25zdCBERUZBVUxUX1RFTEVNRVRSWV9PUFRJT05TID0ge1xyXG4gICAgYXBwbGljYXRpb246IHtcclxuICAgICAgICBhcHBOYW1lOiBcIlwiLFxyXG4gICAgICAgIGFwcFZlcnNpb246IFwiXCIsXHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogRnVuY3Rpb24gdGhhdCBzZXRzIHRoZSBkZWZhdWx0IG9wdGlvbnMgd2hlbiBub3QgZXhwbGljaXRseSBjb25maWd1cmVkIGZyb20gYXBwIGRldmVsb3BlclxyXG4gKlxyXG4gKiBAcGFyYW0gQ29uZmlndXJhdGlvblxyXG4gKlxyXG4gKiBAcmV0dXJucyBDb25maWd1cmF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZENsaWVudENvbmZpZ3VyYXRpb24oeyBhdXRoT3B0aW9uczogdXNlckF1dGhPcHRpb25zLCBzeXN0ZW1PcHRpb25zOiB1c2VyU3lzdGVtT3B0aW9ucywgbG9nZ2VyT3B0aW9uczogdXNlckxvZ2dlck9wdGlvbiwgY2FjaGVPcHRpb25zOiB1c2VyQ2FjaGVPcHRpb25zLCBzdG9yYWdlSW50ZXJmYWNlOiBzdG9yYWdlSW1wbGVtZW50YXRpb24sIG5ldHdvcmtJbnRlcmZhY2U6IG5ldHdvcmtJbXBsZW1lbnRhdGlvbiwgY3J5cHRvSW50ZXJmYWNlOiBjcnlwdG9JbXBsZW1lbnRhdGlvbiwgY2xpZW50Q3JlZGVudGlhbHM6IGNsaWVudENyZWRlbnRpYWxzLCBsaWJyYXJ5SW5mbzogbGlicmFyeUluZm8sIHRlbGVtZXRyeTogdGVsZW1ldHJ5LCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyOiBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLCBwZXJzaXN0ZW5jZVBsdWdpbjogcGVyc2lzdGVuY2VQbHVnaW4sIHNlcmlhbGl6YWJsZUNhY2hlOiBzZXJpYWxpemFibGVDYWNoZSwgfSkge1xyXG4gICAgY29uc3QgbG9nZ2VyT3B0aW9ucyA9IHtcclxuICAgICAgICAuLi5ERUZBVUxUX0xPR0dFUl9JTVBMRU1FTlRBVElPTixcclxuICAgICAgICAuLi51c2VyTG9nZ2VyT3B0aW9uLFxyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXV0aE9wdGlvbnM6IGJ1aWxkQXV0aE9wdGlvbnModXNlckF1dGhPcHRpb25zKSxcclxuICAgICAgICBzeXN0ZW1PcHRpb25zOiB7IC4uLkRFRkFVTFRfU1lTVEVNX09QVElPTlMsIC4uLnVzZXJTeXN0ZW1PcHRpb25zIH0sXHJcbiAgICAgICAgbG9nZ2VyT3B0aW9uczogbG9nZ2VyT3B0aW9ucyxcclxuICAgICAgICBjYWNoZU9wdGlvbnM6IHsgLi4uREVGQVVMVF9DQUNIRV9PUFRJT05TLCAuLi51c2VyQ2FjaGVPcHRpb25zIH0sXHJcbiAgICAgICAgc3RvcmFnZUludGVyZmFjZTogc3RvcmFnZUltcGxlbWVudGF0aW9uIHx8XHJcbiAgICAgICAgICAgIG5ldyBEZWZhdWx0U3RvcmFnZUNsYXNzKHVzZXJBdXRoT3B0aW9ucy5jbGllbnRJZCwgREVGQVVMVF9DUllQVE9fSU1QTEVNRU5UQVRJT04sIG5ldyBMb2dnZXIobG9nZ2VyT3B0aW9ucykpLFxyXG4gICAgICAgIG5ldHdvcmtJbnRlcmZhY2U6IG5ldHdvcmtJbXBsZW1lbnRhdGlvbiB8fCBERUZBVUxUX05FVFdPUktfSU1QTEVNRU5UQVRJT04sXHJcbiAgICAgICAgY3J5cHRvSW50ZXJmYWNlOiBjcnlwdG9JbXBsZW1lbnRhdGlvbiB8fCBERUZBVUxUX0NSWVBUT19JTVBMRU1FTlRBVElPTixcclxuICAgICAgICBjbGllbnRDcmVkZW50aWFsczogY2xpZW50Q3JlZGVudGlhbHMgfHwgREVGQVVMVF9DTElFTlRfQ1JFREVOVElBTFMsXHJcbiAgICAgICAgbGlicmFyeUluZm86IHsgLi4uREVGQVVMVF9MSUJSQVJZX0lORk8sIC4uLmxpYnJhcnlJbmZvIH0sXHJcbiAgICAgICAgdGVsZW1ldHJ5OiB7IC4uLkRFRkFVTFRfVEVMRU1FVFJZX09QVElPTlMsIC4uLnRlbGVtZXRyeSB9LFxyXG4gICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI6IHNlcnZlclRlbGVtZXRyeU1hbmFnZXIgfHwgbnVsbCxcclxuICAgICAgICBwZXJzaXN0ZW5jZVBsdWdpbjogcGVyc2lzdGVuY2VQbHVnaW4gfHwgbnVsbCxcclxuICAgICAgICBzZXJpYWxpemFibGVDYWNoZTogc2VyaWFsaXphYmxlQ2FjaGUgfHwgbnVsbCxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENvbnN0cnVjdCBhdXRob3B0aW9ucyBmcm9tIHRoZSBjbGllbnQgYW5kIHBsYXRmb3JtIHBhc3NlZCB2YWx1ZXNcclxuICogQHBhcmFtIGF1dGhPcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZEF1dGhPcHRpb25zKGF1dGhPcHRpb25zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsaWVudENhcGFiaWxpdGllczogW10sXHJcbiAgICAgICAgYXp1cmVDbG91ZE9wdGlvbnM6IERFRkFVTFRfQVpVUkVfQ0xPVURfT1BUSU9OUyxcclxuICAgICAgICBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZTogZmFsc2UsXHJcbiAgICAgICAgaW5zdGFuY2VBd2FyZTogZmFsc2UsXHJcbiAgICAgICAgZW5jb2RlRXh0cmFRdWVyeVBhcmFtczogZmFsc2UsXHJcbiAgICAgICAgLi4uYXV0aE9wdGlvbnMsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgY29uZmlnIGhhcyBwcm90b2NvbE1vZGUgc2V0IHRvIFByb3RvY29sTW9kZS5PSURDLCBmYWxzZSBvdGhlcndpc2VcclxuICogQHBhcmFtIENsaWVudENvbmZpZ3VyYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGlzT2lkY1Byb3RvY29sTW9kZShjb25maWcpIHtcclxuICAgIHJldHVybiAoY29uZmlnLmF1dGhPcHRpb25zLmF1dGhvcml0eS5vcHRpb25zLnByb3RvY29sTW9kZSA9PT0gUHJvdG9jb2xNb2RlLk9JREMpO1xyXG59XG5cbmV4cG9ydCB7IERFRkFVTFRfU1lTVEVNX09QVElPTlMsIGJ1aWxkQ2xpZW50Q29uZmlndXJhdGlvbiwgaXNPaWRjUHJvdG9jb2xNb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGllbnRDb25maWd1cmF0aW9uLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgQ2NzQ3JlZGVudGlhbFR5cGUgPSB7XHJcbiAgICBIT01FX0FDQ09VTlRfSUQ6IFwiaG9tZV9hY2NvdW50X2lkXCIsXHJcbiAgICBVUE46IFwiVVBOXCIsXHJcbn07XG5cbmV4cG9ydCB7IENjc0NyZWRlbnRpYWxUeXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DY3NDcmVkZW50aWFsLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBSZXNwb25zZU1vZGUsIE9JRENfREVGQVVMVF9TQ09QRVMsIEhlYWRlck5hbWVzLCBDTElFTlRfSU5GTywgQ2xhaW1zUmVxdWVzdEtleXMsIFBhc3N3b3JkR3JhbnRDb25zdGFudHMsIEF1dGhlbnRpY2F0aW9uU2NoZW1lLCBUaHJvdHRsaW5nQ29uc3RhbnRzIH0gZnJvbSAnLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyBDTElFTlRfSUQsIEJST0tFUl9DTElFTlRfSUQsIFJFRElSRUNUX1VSSSwgUkVTUE9OU0VfVFlQRSwgUkVTUE9OU0VfTU9ERSwgTkFUSVZFX0JST0tFUiwgU0NPUEUsIFBPU1RfTE9HT1VUX1VSSSwgSURfVE9LRU5fSElOVCwgRE9NQUlOX0hJTlQsIExPR0lOX0hJTlQsIFNJRCwgQ0xBSU1TLCBDTElFTlRfUkVRVUVTVF9JRCwgWF9DTElFTlRfU0tVLCBYX0NMSUVOVF9WRVIsIFhfQ0xJRU5UX09TLCBYX0NMSUVOVF9DUFUsIFhfQVBQX05BTUUsIFhfQVBQX1ZFUiwgUFJPTVBULCBTVEFURSwgTk9OQ0UsIENPREVfQ0hBTExFTkdFLCBDT0RFX0NIQUxMRU5HRV9NRVRIT0QsIENPREUsIERFVklDRV9DT0RFLCBSRUZSRVNIX1RPS0VOLCBDT0RFX1ZFUklGSUVSLCBDTElFTlRfU0VDUkVULCBDTElFTlRfQVNTRVJUSU9OLCBDTElFTlRfQVNTRVJUSU9OX1RZUEUsIE9CT19BU1NFUlRJT04sIFJFUVVFU1RFRF9UT0tFTl9VU0UsIEdSQU5UX1RZUEUsIElOU1RBTkNFX0FXQVJFLCBUT0tFTl9UWVBFLCBSRVFfQ05GLCBYX0NMSUVOVF9DVVJSX1RFTEVNLCBYX0NMSUVOVF9MQVNUX1RFTEVNLCBYX01TX0xJQl9DQVBBQklMSVRZLCBMT0dPVVRfSElOVCwgQlJPS0VSX1JFRElSRUNUX1VSSSwgRUFSX0pXSywgRUFSX0pXRV9DUllQVE8gfSBmcm9tICcuLi9jb25zdGFudHMvQUFEU2VydmVyUGFyYW1LZXlzLm1qcyc7XG5pbXBvcnQgeyBTY29wZVNldCB9IGZyb20gJy4vU2NvcGVTZXQubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvci5tanMnO1xuaW1wb3J0IHsgaW52YWxpZENsYWltcywgcGtjZVBhcmFtc01pc3NpbmcgfSBmcm9tICcuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5zdHJ1bWVudEJyb2tlclBhcmFtcyhwYXJhbWV0ZXJzLCBjb3JyZWxhdGlvbklkLCBwZXJmb3JtYW5jZUNsaWVudCkge1xyXG4gICAgaWYgKCFjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2xpZW50SWQgPSBwYXJhbWV0ZXJzLmdldChDTElFTlRfSUQpO1xyXG4gICAgaWYgKGNsaWVudElkICYmIHBhcmFtZXRlcnMuaGFzKEJST0tFUl9DTElFTlRfSUQpKSB7XHJcbiAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyh7XHJcbiAgICAgICAgICAgIGVtYmVkZGVkQ2xpZW50SWQ6IGNsaWVudElkLFxyXG4gICAgICAgICAgICBlbWJlZGRlZFJlZGlyZWN0VXJpOiBwYXJhbWV0ZXJzLmdldChSRURJUkVDVF9VUkkpLFxyXG4gICAgICAgIH0sIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgdGhlIGdpdmVuIHJlc3BvbnNlX3R5cGVcclxuICogQHBhcmFtIHBhcmFtZXRlcnNcclxuICogQHBhcmFtIHJlc3BvbnNlVHlwZVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkUmVzcG9uc2VUeXBlKHBhcmFtZXRlcnMsIHJlc3BvbnNlVHlwZSkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoUkVTUE9OU0VfVFlQRSwgcmVzcG9uc2VUeXBlKTtcclxufVxyXG4vKipcclxuICogYWRkIHJlc3BvbnNlX21vZGUuIGRlZmF1bHRzIHRvIHF1ZXJ5LlxyXG4gKiBAcGFyYW0gcmVzcG9uc2VNb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRSZXNwb25zZU1vZGUocGFyYW1ldGVycywgcmVzcG9uc2VNb2RlKSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChSRVNQT05TRV9NT0RFLCByZXNwb25zZU1vZGUgPyByZXNwb25zZU1vZGUgOiBSZXNwb25zZU1vZGUuUVVFUlkpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgZmxhZyB0byBpbmRpY2F0ZSBTVFMgc2hvdWxkIGF0dGVtcHQgdG8gdXNlIFdBTSBpZiBhdmFpbGFibGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZE5hdGl2ZUJyb2tlcihwYXJhbWV0ZXJzKSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChOQVRJVkVfQlJPS0VSLCBcIjFcIik7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBzY29wZXMuIHNldCBhZGRPaWRjU2NvcGVzIHRvIGZhbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBzY29wZXMgaW4gbm9uLXVzZXIgc2NlbmFyaW9zXHJcbiAqIEBwYXJhbSBzY29wZVNldFxyXG4gKiBAcGFyYW0gYWRkT2lkY1Njb3Blc1xyXG4gKi9cclxuZnVuY3Rpb24gYWRkU2NvcGVzKHBhcmFtZXRlcnMsIHNjb3BlcywgYWRkT2lkY1Njb3BlcyA9IHRydWUsIGRlZmF1bHRTY29wZXMgPSBPSURDX0RFRkFVTFRfU0NPUEVTKSB7XHJcbiAgICAvLyBBbHdheXMgYWRkIG9wZW5pZCB0byB0aGUgc2NvcGVzIHdoZW4gYWRkaW5nIE9JREMgc2NvcGVzXHJcbiAgICBpZiAoYWRkT2lkY1Njb3BlcyAmJlxyXG4gICAgICAgICFkZWZhdWx0U2NvcGVzLmluY2x1ZGVzKFwib3BlbmlkXCIpICYmXHJcbiAgICAgICAgIXNjb3Blcy5pbmNsdWRlcyhcIm9wZW5pZFwiKSkge1xyXG4gICAgICAgIGRlZmF1bHRTY29wZXMucHVzaChcIm9wZW5pZFwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcXVlc3RTY29wZXMgPSBhZGRPaWRjU2NvcGVzXHJcbiAgICAgICAgPyBbLi4uKHNjb3BlcyB8fCBbXSksIC4uLmRlZmF1bHRTY29wZXNdXHJcbiAgICAgICAgOiBzY29wZXMgfHwgW107XHJcbiAgICBjb25zdCBzY29wZVNldCA9IG5ldyBTY29wZVNldChyZXF1ZXN0U2NvcGVzKTtcclxuICAgIHBhcmFtZXRlcnMuc2V0KFNDT1BFLCBzY29wZVNldC5wcmludFNjb3BlcygpKTtcclxufVxyXG4vKipcclxuICogYWRkIGNsaWVudElkXHJcbiAqIEBwYXJhbSBjbGllbnRJZFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ2xpZW50SWQocGFyYW1ldGVycywgY2xpZW50SWQpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KENMSUVOVF9JRCwgY2xpZW50SWQpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGQgcmVkaXJlY3RfdXJpXHJcbiAqIEBwYXJhbSByZWRpcmVjdFVyaVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkUmVkaXJlY3RVcmkocGFyYW1ldGVycywgcmVkaXJlY3RVcmkpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KFJFRElSRUNUX1VSSSwgcmVkaXJlY3RVcmkpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGQgcG9zdCBsb2dvdXQgcmVkaXJlY3RVcmlcclxuICogQHBhcmFtIHJlZGlyZWN0VXJpXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRQb3N0TG9nb3V0UmVkaXJlY3RVcmkocGFyYW1ldGVycywgcmVkaXJlY3RVcmkpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KFBPU1RfTE9HT1VUX1VSSSwgcmVkaXJlY3RVcmkpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGQgaWRfdG9rZW5faGludCB0byBsb2dvdXQgcmVxdWVzdFxyXG4gKiBAcGFyYW0gaWRUb2tlbkhpbnRcclxuICovXHJcbmZ1bmN0aW9uIGFkZElkVG9rZW5IaW50KHBhcmFtZXRlcnMsIGlkVG9rZW5IaW50KSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChJRF9UT0tFTl9ISU5ULCBpZFRva2VuSGludCk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBkb21haW5faGludFxyXG4gKiBAcGFyYW0gZG9tYWluSGludFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkRG9tYWluSGludChwYXJhbWV0ZXJzLCBkb21haW5IaW50KSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChET01BSU5fSElOVCwgZG9tYWluSGludCk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBsb2dpbl9oaW50XHJcbiAqIEBwYXJhbSBsb2dpbkhpbnRcclxuICovXHJcbmZ1bmN0aW9uIGFkZExvZ2luSGludChwYXJhbWV0ZXJzLCBsb2dpbkhpbnQpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KExPR0lOX0hJTlQsIGxvZ2luSGludCk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgdGhlIENDUyAoQ2FjaGUgQ3JlZGVudGlhbCBTZXJ2aWNlKSBxdWVyeSBwYXJhbWV0ZXIgZm9yIGxvZ2luX2hpbnRcclxuICogQHBhcmFtIGxvZ2luSGludFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ2NzVXBuKHBhcmFtZXRlcnMsIGxvZ2luSGludCkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoSGVhZGVyTmFtZXMuQ0NTX0hFQURFUiwgYFVQTjoke2xvZ2luSGludH1gKTtcclxufVxyXG4vKipcclxuICogQWRkcyB0aGUgQ0NTIChDYWNoZSBDcmVkZW50aWFsIFNlcnZpY2UpIHF1ZXJ5IHBhcmFtZXRlciBmb3IgYWNjb3VudCBvYmplY3RcclxuICogQHBhcmFtIGxvZ2luSGludFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ2NzT2lkKHBhcmFtZXRlcnMsIGNsaWVudEluZm8pIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KEhlYWRlck5hbWVzLkNDU19IRUFERVIsIGBPaWQ6JHtjbGllbnRJbmZvLnVpZH1AJHtjbGllbnRJbmZvLnV0aWR9YCk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBzaWRcclxuICogQHBhcmFtIHNpZFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkU2lkKHBhcmFtZXRlcnMsIHNpZCkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoU0lELCBzaWQpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGQgY2xhaW1zXHJcbiAqIEBwYXJhbSBjbGFpbXNcclxuICovXHJcbmZ1bmN0aW9uIGFkZENsYWltcyhwYXJhbWV0ZXJzLCBjbGFpbXMsIGNsaWVudENhcGFiaWxpdGllcykge1xyXG4gICAgY29uc3QgbWVyZ2VkQ2xhaW1zID0gYWRkQ2xpZW50Q2FwYWJpbGl0aWVzVG9DbGFpbXMoY2xhaW1zLCBjbGllbnRDYXBhYmlsaXRpZXMpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBKU09OLnBhcnNlKG1lcmdlZENsYWltcyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihpbnZhbGlkQ2xhaW1zKTtcclxuICAgIH1cclxuICAgIHBhcmFtZXRlcnMuc2V0KENMQUlNUywgbWVyZ2VkQ2xhaW1zKTtcclxufVxyXG4vKipcclxuICogYWRkIGNvcnJlbGF0aW9uSWRcclxuICogQHBhcmFtIGNvcnJlbGF0aW9uSWRcclxuICovXHJcbmZ1bmN0aW9uIGFkZENvcnJlbGF0aW9uSWQocGFyYW1ldGVycywgY29ycmVsYXRpb25JZCkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoQ0xJRU5UX1JFUVVFU1RfSUQsIGNvcnJlbGF0aW9uSWQpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGQgbGlicmFyeSBpbmZvIHF1ZXJ5IHBhcmFtc1xyXG4gKiBAcGFyYW0gbGlicmFyeUluZm9cclxuICovXHJcbmZ1bmN0aW9uIGFkZExpYnJhcnlJbmZvKHBhcmFtZXRlcnMsIGxpYnJhcnlJbmZvKSB7XHJcbiAgICAvLyBUZWxlbWV0cnkgSW5mb1xyXG4gICAgcGFyYW1ldGVycy5zZXQoWF9DTElFTlRfU0tVLCBsaWJyYXJ5SW5mby5za3UpO1xyXG4gICAgcGFyYW1ldGVycy5zZXQoWF9DTElFTlRfVkVSLCBsaWJyYXJ5SW5mby52ZXJzaW9uKTtcclxuICAgIGlmIChsaWJyYXJ5SW5mby5vcykge1xyXG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KFhfQ0xJRU5UX09TLCBsaWJyYXJ5SW5mby5vcyk7XHJcbiAgICB9XHJcbiAgICBpZiAobGlicmFyeUluZm8uY3B1KSB7XHJcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoWF9DTElFTlRfQ1BVLCBsaWJyYXJ5SW5mby5jcHUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgY2xpZW50IHRlbGVtZXRyeSBwYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSBhcHBUZWxlbWV0cnlcclxuICovXHJcbmZ1bmN0aW9uIGFkZEFwcGxpY2F0aW9uVGVsZW1ldHJ5KHBhcmFtZXRlcnMsIGFwcFRlbGVtZXRyeSkge1xyXG4gICAgaWYgKGFwcFRlbGVtZXRyeT8uYXBwTmFtZSkge1xyXG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KFhfQVBQX05BTUUsIGFwcFRlbGVtZXRyeS5hcHBOYW1lKTtcclxuICAgIH1cclxuICAgIGlmIChhcHBUZWxlbWV0cnk/LmFwcFZlcnNpb24pIHtcclxuICAgICAgICBwYXJhbWV0ZXJzLnNldChYX0FQUF9WRVIsIGFwcFRlbGVtZXRyeS5hcHBWZXJzaW9uKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogYWRkIHByb21wdFxyXG4gKiBAcGFyYW0gcHJvbXB0XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRQcm9tcHQocGFyYW1ldGVycywgcHJvbXB0KSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChQUk9NUFQsIHByb21wdCk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBzdGF0ZVxyXG4gKiBAcGFyYW0gc3RhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZFN0YXRlKHBhcmFtZXRlcnMsIHN0YXRlKSB7XHJcbiAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICBwYXJhbWV0ZXJzLnNldChTVEFURSwgc3RhdGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBhZGQgbm9uY2VcclxuICogQHBhcmFtIG5vbmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGROb25jZShwYXJhbWV0ZXJzLCBub25jZSkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoTk9OQ0UsIG5vbmNlKTtcclxufVxyXG4vKipcclxuICogYWRkIGNvZGVfY2hhbGxlbmdlIGFuZCBjb2RlX2NoYWxsZW5nZV9tZXRob2RcclxuICogLSB0aHJvdyBpZiBlaXRoZXIgb2YgdGhlbSBhcmUgbm90IHBhc3NlZFxyXG4gKiBAcGFyYW0gY29kZUNoYWxsZW5nZVxyXG4gKiBAcGFyYW0gY29kZUNoYWxsZW5nZU1ldGhvZFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ29kZUNoYWxsZW5nZVBhcmFtcyhwYXJhbWV0ZXJzLCBjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kKSB7XHJcbiAgICBpZiAoY29kZUNoYWxsZW5nZSAmJiBjb2RlQ2hhbGxlbmdlTWV0aG9kKSB7XHJcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQ09ERV9DSEFMTEVOR0UsIGNvZGVDaGFsbGVuZ2UpO1xyXG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KENPREVfQ0hBTExFTkdFX01FVEhPRCwgY29kZUNoYWxsZW5nZU1ldGhvZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IocGtjZVBhcmFtc01pc3NpbmcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBhZGQgdGhlIGBhdXRob3JpemF0aW9uX2NvZGVgIHBhc3NlZCBieSB0aGUgdXNlciB0byBleGNoYW5nZSBmb3IgYSB0b2tlblxyXG4gKiBAcGFyYW0gY29kZVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbkNvZGUocGFyYW1ldGVycywgY29kZSkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoQ09ERSwgY29kZSk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCB0aGUgYGF1dGhvcml6YXRpb25fY29kZWAgcGFzc2VkIGJ5IHRoZSB1c2VyIHRvIGV4Y2hhbmdlIGZvciBhIHRva2VuXHJcbiAqIEBwYXJhbSBjb2RlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGREZXZpY2VDb2RlKHBhcmFtZXRlcnMsIGNvZGUpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KERFVklDRV9DT0RFLCBjb2RlKTtcclxufVxyXG4vKipcclxuICogYWRkIHRoZSBgcmVmcmVzaFRva2VuYCBwYXNzZWQgYnkgdGhlIHVzZXJcclxuICogQHBhcmFtIHJlZnJlc2hUb2tlblxyXG4gKi9cclxuZnVuY3Rpb24gYWRkUmVmcmVzaFRva2VuKHBhcmFtZXRlcnMsIHJlZnJlc2hUb2tlbikge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoUkVGUkVTSF9UT0tFTiwgcmVmcmVzaFRva2VuKTtcclxufVxyXG4vKipcclxuICogYWRkIHRoZSBgY29kZV92ZXJpZmllcmAgcGFzc2VkIGJ5IHRoZSB1c2VyIHRvIGV4Y2hhbmdlIGZvciBhIHRva2VuXHJcbiAqIEBwYXJhbSBjb2RlVmVyaWZpZXJcclxuICovXHJcbmZ1bmN0aW9uIGFkZENvZGVWZXJpZmllcihwYXJhbWV0ZXJzLCBjb2RlVmVyaWZpZXIpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KENPREVfVkVSSUZJRVIsIGNvZGVWZXJpZmllcik7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBjbGllbnRfc2VjcmV0XHJcbiAqIEBwYXJhbSBjbGllbnRTZWNyZXRcclxuICovXHJcbmZ1bmN0aW9uIGFkZENsaWVudFNlY3JldChwYXJhbWV0ZXJzLCBjbGllbnRTZWNyZXQpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KENMSUVOVF9TRUNSRVQsIGNsaWVudFNlY3JldCk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBjbGllbnRBc3NlcnRpb24gZm9yIGNvbmZpZGVudGlhbCBjbGllbnQgZmxvd3NcclxuICogQHBhcmFtIGNsaWVudEFzc2VydGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ2xpZW50QXNzZXJ0aW9uKHBhcmFtZXRlcnMsIGNsaWVudEFzc2VydGlvbikge1xyXG4gICAgaWYgKGNsaWVudEFzc2VydGlvbikge1xyXG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KENMSUVOVF9BU1NFUlRJT04sIGNsaWVudEFzc2VydGlvbik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBjbGllbnRBc3NlcnRpb25UeXBlIGZvciBjb25maWRlbnRpYWwgY2xpZW50IGZsb3dzXHJcbiAqIEBwYXJhbSBjbGllbnRBc3NlcnRpb25UeXBlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDbGllbnRBc3NlcnRpb25UeXBlKHBhcmFtZXRlcnMsIGNsaWVudEFzc2VydGlvblR5cGUpIHtcclxuICAgIGlmIChjbGllbnRBc3NlcnRpb25UeXBlKSB7XHJcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQ0xJRU5UX0FTU0VSVElPTl9UWVBFLCBjbGllbnRBc3NlcnRpb25UeXBlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogYWRkIE9CTyBhc3NlcnRpb24gZm9yIGNvbmZpZGVudGlhbCBjbGllbnQgZmxvd3NcclxuICogQHBhcmFtIGNsaWVudEFzc2VydGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYWRkT2JvQXNzZXJ0aW9uKHBhcmFtZXRlcnMsIG9ib0Fzc2VydGlvbikge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoT0JPX0FTU0VSVElPTiwgb2JvQXNzZXJ0aW9uKTtcclxufVxyXG4vKipcclxuICogYWRkIGdyYW50IHR5cGVcclxuICogQHBhcmFtIGdyYW50VHlwZVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkUmVxdWVzdFRva2VuVXNlKHBhcmFtZXRlcnMsIHRva2VuVXNlKSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChSRVFVRVNURURfVE9LRU5fVVNFLCB0b2tlblVzZSk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBncmFudCB0eXBlXHJcbiAqIEBwYXJhbSBncmFudFR5cGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZEdyYW50VHlwZShwYXJhbWV0ZXJzLCBncmFudFR5cGUpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KEdSQU5UX1RZUEUsIGdyYW50VHlwZSk7XHJcbn1cclxuLyoqXHJcbiAqIGFkZCBjbGllbnQgaW5mb1xyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChDTElFTlRfSU5GTywgXCIxXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZEluc3RhbmNlQXdhcmUocGFyYW1ldGVycykge1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzLmhhcyhJTlNUQU5DRV9BV0FSRSkpIHtcclxuICAgICAgICBwYXJhbWV0ZXJzLnNldChJTlNUQU5DRV9BV0FSRSwgXCJ0cnVlXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBhZGQgZXh0cmFRdWVyeVBhcmFtc1xyXG4gKiBAcGFyYW0gZVFQYXJhbXNcclxuICovXHJcbmZ1bmN0aW9uIGFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIGVRUGFyYW1zKSB7XHJcbiAgICBPYmplY3QuZW50cmllcyhlUVBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLmhhcyhrZXkpICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFkZENsaWVudENhcGFiaWxpdGllc1RvQ2xhaW1zKGNsYWltcywgY2xpZW50Q2FwYWJpbGl0aWVzKSB7XHJcbiAgICBsZXQgbWVyZ2VkQ2xhaW1zO1xyXG4gICAgLy8gUGFyc2UgcHJvdmlkZWQgY2xhaW1zIGludG8gSlNPTiBvYmplY3Qgb3IgaW5pdGlhbGl6ZSBlbXB0eSBvYmplY3RcclxuICAgIGlmICghY2xhaW1zKSB7XHJcbiAgICAgICAgbWVyZ2VkQ2xhaW1zID0ge307XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBtZXJnZWRDbGFpbXMgPSBKU09OLnBhcnNlKGNsYWltcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihpbnZhbGlkQ2xhaW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoY2xpZW50Q2FwYWJpbGl0aWVzICYmIGNsaWVudENhcGFiaWxpdGllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgaWYgKCFtZXJnZWRDbGFpbXMuaGFzT3duUHJvcGVydHkoQ2xhaW1zUmVxdWVzdEtleXMuQUNDRVNTX1RPS0VOKSkge1xyXG4gICAgICAgICAgICAvLyBBZGQgYWNjZXNzX3Rva2VuIGtleSB0byBjbGFpbXMgb2JqZWN0XHJcbiAgICAgICAgICAgIG1lcmdlZENsYWltc1tDbGFpbXNSZXF1ZXN0S2V5cy5BQ0NFU1NfVE9LRU5dID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCB4bXNfY2MgY2xhaW0gd2l0aCBwcm92aWRlZCBjbGllbnRDYXBhYmlsaXRpZXMgdG8gYWNjZXNzX3Rva2VuIGtleVxyXG4gICAgICAgIG1lcmdlZENsYWltc1tDbGFpbXNSZXF1ZXN0S2V5cy5BQ0NFU1NfVE9LRU5dW0NsYWltc1JlcXVlc3RLZXlzLlhNU19DQ10gPVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNsaWVudENhcGFiaWxpdGllcyxcclxuICAgICAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZXJnZWRDbGFpbXMpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGRzIGB1c2VybmFtZWAgZm9yIFBhc3N3b3JkIEdyYW50IGZsb3dcclxuICogQHBhcmFtIHVzZXJuYW1lXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRVc2VybmFtZShwYXJhbWV0ZXJzLCB1c2VybmFtZSkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoUGFzc3dvcmRHcmFudENvbnN0YW50cy51c2VybmFtZSwgdXNlcm5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGRzIGBwYXNzd29yZGAgZm9yIFBhc3N3b3JkIEdyYW50IGZsb3dcclxuICogQHBhcmFtIHBhc3N3b3JkXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRQYXNzd29yZChwYXJhbWV0ZXJzLCBwYXNzd29yZCkge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoUGFzc3dvcmRHcmFudENvbnN0YW50cy5wYXNzd29yZCwgcGFzc3dvcmQpO1xyXG59XHJcbi8qKlxyXG4gKiBhZGQgcG9wX2p3ayB0byBxdWVyeSBwYXJhbXNcclxuICogQHBhcmFtIGNuZlN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gYWRkUG9wVG9rZW4ocGFyYW1ldGVycywgY25mU3RyaW5nKSB7XHJcbiAgICBpZiAoY25mU3RyaW5nKSB7XHJcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoVE9LRU5fVFlQRSwgQXV0aGVudGljYXRpb25TY2hlbWUuUE9QKTtcclxuICAgICAgICBwYXJhbWV0ZXJzLnNldChSRVFfQ05GLCBjbmZTdHJpbmcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBhZGQgU1NIIEpXSyBhbmQga2V5IElEIHRvIHF1ZXJ5IHBhcmFtc1xyXG4gKi9cclxuZnVuY3Rpb24gYWRkU3NoSndrKHBhcmFtZXRlcnMsIHNzaEp3a1N0cmluZykge1xyXG4gICAgaWYgKHNzaEp3a1N0cmluZykge1xyXG4gICAgICAgIHBhcmFtZXRlcnMuc2V0KFRPS0VOX1RZUEUsIEF1dGhlbnRpY2F0aW9uU2NoZW1lLlNTSCk7XHJcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoUkVRX0NORiwgc3NoSndrU3RyaW5nKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogYWRkIHNlcnZlciB0ZWxlbWV0cnkgZmllbGRzXHJcbiAqIEBwYXJhbSBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRTZXJ2ZXJUZWxlbWV0cnkocGFyYW1ldGVycywgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcikge1xyXG4gICAgcGFyYW1ldGVycy5zZXQoWF9DTElFTlRfQ1VSUl9URUxFTSwgc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5nZW5lcmF0ZUN1cnJlbnRSZXF1ZXN0SGVhZGVyVmFsdWUoKSk7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChYX0NMSUVOVF9MQVNUX1RFTEVNLCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmdlbmVyYXRlTGFzdFJlcXVlc3RIZWFkZXJWYWx1ZSgpKTtcclxufVxyXG4vKipcclxuICogQWRkcyBwYXJhbWV0ZXIgdGhhdCBpbmRpY2F0ZXMgdG8gdGhlIHNlcnZlciB0aGF0IHRocm90dGxpbmcgaXMgc3VwcG9ydGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUaHJvdHRsaW5nKHBhcmFtZXRlcnMpIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KFhfTVNfTElCX0NBUEFCSUxJVFksIFRocm90dGxpbmdDb25zdGFudHMuWF9NU19MSUJfQ0FQQUJJTElUWV9WQUxVRSk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgbG9nb3V0X2hpbnQgcGFyYW1ldGVyIGZvciBcInNpbGVudFwiIGxvZ291dCB3aGljaCBwcmV2ZW50IHNlcnZlciBhY2NvdW50IHBpY2tlclxyXG4gKi9cclxuZnVuY3Rpb24gYWRkTG9nb3V0SGludChwYXJhbWV0ZXJzLCBsb2dvdXRIaW50KSB7XHJcbiAgICBwYXJhbWV0ZXJzLnNldChMT0dPVVRfSElOVCwgbG9nb3V0SGludCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkQnJva2VyUGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBicm9rZXJDbGllbnRJZCwgYnJva2VyUmVkaXJlY3RVcmkpIHtcclxuICAgIGlmICghcGFyYW1ldGVycy5oYXMoQlJPS0VSX0NMSUVOVF9JRCkpIHtcclxuICAgICAgICBwYXJhbWV0ZXJzLnNldChCUk9LRVJfQ0xJRU5UX0lELCBicm9rZXJDbGllbnRJZCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmFtZXRlcnMuaGFzKEJST0tFUl9SRURJUkVDVF9VUkkpKSB7XHJcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoQlJPS0VSX1JFRElSRUNUX1VSSSwgYnJva2VyUmVkaXJlY3RVcmkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgRUFSIChFbmNyeXB0ZWQgQXV0aG9yaXplIFJlc3BvbnNlKSByZXF1ZXN0IHBhcmFtZXRlcnNcclxuICogQHBhcmFtIHBhcmFtZXRlcnNcclxuICogQHBhcmFtIGp3a1xyXG4gKi9cclxuZnVuY3Rpb24gYWRkRUFSUGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBqd2spIHtcclxuICAgIHBhcmFtZXRlcnMuc2V0KEVBUl9KV0ssIGVuY29kZVVSSUNvbXBvbmVudChqd2spKTtcclxuICAgIC8vIGVhcl9qd2VfY3J5cHRvIHdpbGwgYWx3YXlzIGhhdmUgdmFsdWU6IHtcImFsZ1wiOlwiZGlyXCIsXCJlbmNcIjpcIkEyNTZHQ01cIn0gc28gd2UgY2FuIGhhcmRjb2RlIHRoaXNcclxuICAgIGNvbnN0IGp3ZUNyeXB0b0I2NEVuY29kZWQgPSBcImV5SmhiR2NpT2lKa2FYSWlMQ0psYm1NaU9pSkJNalUyUjBOTkluMFwiO1xyXG4gICAgcGFyYW1ldGVycy5zZXQoRUFSX0pXRV9DUllQVE8sIGp3ZUNyeXB0b0I2NEVuY29kZWQpO1xyXG59XG5cbmV4cG9ydCB7IGFkZEFwcGxpY2F0aW9uVGVsZW1ldHJ5LCBhZGRBdXRob3JpemF0aW9uQ29kZSwgYWRkQnJva2VyUGFyYW1ldGVycywgYWRkQ2NzT2lkLCBhZGRDY3NVcG4sIGFkZENsYWltcywgYWRkQ2xpZW50QXNzZXJ0aW9uLCBhZGRDbGllbnRBc3NlcnRpb25UeXBlLCBhZGRDbGllbnRDYXBhYmlsaXRpZXNUb0NsYWltcywgYWRkQ2xpZW50SWQsIGFkZENsaWVudEluZm8sIGFkZENsaWVudFNlY3JldCwgYWRkQ29kZUNoYWxsZW5nZVBhcmFtcywgYWRkQ29kZVZlcmlmaWVyLCBhZGRDb3JyZWxhdGlvbklkLCBhZGREZXZpY2VDb2RlLCBhZGREb21haW5IaW50LCBhZGRFQVJQYXJhbWV0ZXJzLCBhZGRFeHRyYVF1ZXJ5UGFyYW1ldGVycywgYWRkR3JhbnRUeXBlLCBhZGRJZFRva2VuSGludCwgYWRkSW5zdGFuY2VBd2FyZSwgYWRkTGlicmFyeUluZm8sIGFkZExvZ2luSGludCwgYWRkTG9nb3V0SGludCwgYWRkTmF0aXZlQnJva2VyLCBhZGROb25jZSwgYWRkT2JvQXNzZXJ0aW9uLCBhZGRQYXNzd29yZCwgYWRkUG9wVG9rZW4sIGFkZFBvc3RMb2dvdXRSZWRpcmVjdFVyaSwgYWRkUHJvbXB0LCBhZGRSZWRpcmVjdFVyaSwgYWRkUmVmcmVzaFRva2VuLCBhZGRSZXF1ZXN0VG9rZW5Vc2UsIGFkZFJlc3BvbnNlTW9kZSwgYWRkUmVzcG9uc2VUeXBlLCBhZGRTY29wZXMsIGFkZFNlcnZlclRlbGVtZXRyeSwgYWRkU2lkLCBhZGRTc2hKd2ssIGFkZFN0YXRlLCBhZGRUaHJvdHRsaW5nLCBhZGRVc2VybmFtZSwgaW5zdHJ1bWVudEJyb2tlclBhcmFtcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEF1dGhvcml0eSwgZm9ybWF0QXV0aG9yaXR5VXJpIH0gZnJvbSAnLi9BdXRob3JpdHkubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VFdmVudHMgfSBmcm9tICcuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC5tanMnO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMgfSBmcm9tICcuLi91dGlscy9GdW5jdGlvbldyYXBwZXJzLm1qcyc7XG5pbXBvcnQgeyBlbmRwb2ludFJlc29sdXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlIGFuIGF1dGhvcml0eSBvYmplY3Qgb2YgdGhlIGNvcnJlY3QgdHlwZSBiYXNlZCBvbiB0aGUgdXJsXHJcbiAqIFBlcmZvcm1zIGJhc2ljIGF1dGhvcml0eSB2YWxpZGF0aW9uIC0gY2hlY2tzIHRvIHNlZSBpZiB0aGUgYXV0aG9yaXR5IGlzIG9mIGEgdmFsaWQgdHlwZSAoaS5lLiBhYWQsIGIyYywgYWRmcylcclxuICpcclxuICogQWxzbyBwZXJmb3JtcyBlbmRwb2ludCBkaXNjb3ZlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhdXRob3JpdHlVcmlcclxuICogQHBhcmFtIG5ldHdvcmtDbGllbnRcclxuICogQHBhcmFtIHByb3RvY29sTW9kZVxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZShhdXRob3JpdHlVcmksIG5ldHdvcmtDbGllbnQsIGNhY2hlTWFuYWdlciwgYXV0aG9yaXR5T3B0aW9ucywgbG9nZ2VyLCBjb3JyZWxhdGlvbklkLCBwZXJmb3JtYW5jZUNsaWVudCkge1xyXG4gICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXR5RmFjdG9yeUNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICBjb25zdCBhdXRob3JpdHlVcmlGaW5hbCA9IEF1dGhvcml0eS50cmFuc2Zvcm1DSUFNQXV0aG9yaXR5KGZvcm1hdEF1dGhvcml0eVVyaShhdXRob3JpdHlVcmkpKTtcclxuICAgIC8vIEluaXRpYWxpemUgYXV0aG9yaXR5IGFuZCBwZXJmb3JtIGRpc2NvdmVyeSBlbmRwb2ludCBjaGVjay5cclxuICAgIGNvbnN0IGFjcXVpcmVUb2tlbkF1dGhvcml0eSA9IG5ldyBBdXRob3JpdHkoYXV0aG9yaXR5VXJpRmluYWwsIG5ldHdvcmtDbGllbnQsIGNhY2hlTWFuYWdlciwgYXV0aG9yaXR5T3B0aW9ucywgbG9nZ2VyLCBjb3JyZWxhdGlvbklkLCBwZXJmb3JtYW5jZUNsaWVudCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGludm9rZUFzeW5jKGFjcXVpcmVUb2tlbkF1dGhvcml0eS5yZXNvbHZlRW5kcG9pbnRzQXN5bmMuYmluZChhY3F1aXJlVG9rZW5BdXRob3JpdHkpLCBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpdHlSZXNvbHZlRW5kcG9pbnRzQXN5bmMsIGxvZ2dlciwgcGVyZm9ybWFuY2VDbGllbnQsIGNvcnJlbGF0aW9uSWQpKCk7XHJcbiAgICAgICAgcmV0dXJuIGFjcXVpcmVUb2tlbkF1dGhvcml0eTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGVuZHBvaW50UmVzb2x1dGlvbkVycm9yKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBjcmVhdGVEaXNjb3ZlcmVkSW5zdGFuY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml0eUZhY3RvcnkubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZXF1ZXN0VGh1bWJwcmludChjbGllbnRJZCwgcmVxdWVzdCwgaG9tZUFjY291bnRJZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjbGllbnRJZDogY2xpZW50SWQsXHJcbiAgICAgICAgYXV0aG9yaXR5OiByZXF1ZXN0LmF1dGhvcml0eSxcclxuICAgICAgICBzY29wZXM6IHJlcXVlc3Quc2NvcGVzLFxyXG4gICAgICAgIGhvbWVBY2NvdW50SWRlbnRpZmllcjogaG9tZUFjY291bnRJZCxcclxuICAgICAgICBjbGFpbXM6IHJlcXVlc3QuY2xhaW1zLFxyXG4gICAgICAgIGF1dGhlbnRpY2F0aW9uU2NoZW1lOiByZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lLFxyXG4gICAgICAgIHJlc291cmNlUmVxdWVzdE1ldGhvZDogcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RNZXRob2QsXHJcbiAgICAgICAgcmVzb3VyY2VSZXF1ZXN0VXJpOiByZXF1ZXN0LnJlc291cmNlUmVxdWVzdFVyaSxcclxuICAgICAgICBzaHJDbGFpbXM6IHJlcXVlc3Quc2hyQ2xhaW1zLFxyXG4gICAgICAgIHNzaEtpZDogcmVxdWVzdC5zc2hLaWQsXHJcbiAgICAgICAgZW1iZWRkZWRDbGllbnRJZDogcmVxdWVzdC5lbWJlZGRlZENsaWVudElkIHx8IHJlcXVlc3QudG9rZW5Cb2R5UGFyYW1ldGVycz8uY2xpZW50SWQsXHJcbiAgICB9O1xyXG59XG5cbmV4cG9ydCB7IGdldFJlcXVlc3RUaHVtYnByaW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXF1ZXN0VGh1bWJwcmludC5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgVGhyb3R0bGluZ0NvbnN0YW50cywgQ29uc3RhbnRzLCBIZWFkZXJOYW1lcyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgU2VydmVyRXJyb3IgfSBmcm9tICcuLi9lcnJvci9TZXJ2ZXJFcnJvci5tanMnO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdFRodW1icHJpbnQgfSBmcm9tICcuL1JlcXVlc3RUaHVtYnByaW50Lm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogQGludGVybmFsICovXHJcbmNsYXNzIFRocm90dGxpbmdVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIFByZXBhcmVzIGEgUmVxdWVzdFRodW1icHJpbnQgdG8gYmUgc3RvcmVkIGFzIGEga2V5LlxyXG4gICAgICogQHBhcmFtIHRodW1icHJpbnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdlbmVyYXRlVGhyb3R0bGluZ1N0b3JhZ2VLZXkodGh1bWJwcmludCkge1xyXG4gICAgICAgIHJldHVybiBgJHtUaHJvdHRsaW5nQ29uc3RhbnRzLlRIUk9UVExJTkdfUFJFRklYfS4ke0pTT04uc3RyaW5naWZ5KHRodW1icHJpbnQpfWA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIG5lY2Vzc2FyeSB0aHJvdHRsaW5nIGNoZWNrcyBiZWZvcmUgYSBuZXR3b3JrIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gY2FjaGVNYW5hZ2VyXHJcbiAgICAgKiBAcGFyYW0gdGh1bWJwcmludFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcHJlUHJvY2VzcyhjYWNoZU1hbmFnZXIsIHRodW1icHJpbnQpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBUaHJvdHRsaW5nVXRpbHMuZ2VuZXJhdGVUaHJvdHRsaW5nU3RvcmFnZUtleSh0aHVtYnByaW50KTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNhY2hlTWFuYWdlci5nZXRUaHJvdHRsaW5nQ2FjaGUoa2V5KTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnRocm90dGxlVGltZSA8IERhdGUubm93KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlTWFuYWdlci5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKHZhbHVlLmVycm9yQ29kZXM/LmpvaW4oXCIgXCIpIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsIHZhbHVlLmVycm9yTWVzc2FnZSwgdmFsdWUuc3ViRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgbmVjZXNzYXJ5IHRocm90dGxpbmcgY2hlY2tzIGFmdGVyIGEgbmV0d29yayByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIGNhY2hlTWFuYWdlclxyXG4gICAgICogQHBhcmFtIHRodW1icHJpbnRcclxuICAgICAqIEBwYXJhbSByZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcG9zdFByb2Nlc3MoY2FjaGVNYW5hZ2VyLCB0aHVtYnByaW50LCByZXNwb25zZSkge1xyXG4gICAgICAgIGlmIChUaHJvdHRsaW5nVXRpbHMuY2hlY2tSZXNwb25zZVN0YXR1cyhyZXNwb25zZSkgfHxcclxuICAgICAgICAgICAgVGhyb3R0bGluZ1V0aWxzLmNoZWNrUmVzcG9uc2VGb3JSZXRyeUFmdGVyKHJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aHVtYnByaW50VmFsdWUgPSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdHRsZVRpbWU6IFRocm90dGxpbmdVdGlscy5jYWxjdWxhdGVUaHJvdHRsZVRpbWUocGFyc2VJbnQocmVzcG9uc2UuaGVhZGVyc1tIZWFkZXJOYW1lcy5SRVRSWV9BRlRFUl0pKSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiByZXNwb25zZS5ib2R5LmVycm9yLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JDb2RlczogcmVzcG9uc2UuYm9keS5lcnJvcl9jb2RlcyxcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogcmVzcG9uc2UuYm9keS5lcnJvcl9kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICAgIHN1YkVycm9yOiByZXNwb25zZS5ib2R5LnN1YmVycm9yLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYWNoZU1hbmFnZXIuc2V0VGhyb3R0bGluZ0NhY2hlKFRocm90dGxpbmdVdGlscy5nZW5lcmF0ZVRocm90dGxpbmdTdG9yYWdlS2V5KHRodW1icHJpbnQpLCB0aHVtYnByaW50VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGEgTmV0d29ya1Jlc3BvbnNlIG9iamVjdCdzIHN0YXR1cyBjb2RlcyBhZ2FpbnN0IDQyOSBvciA1eHhcclxuICAgICAqIEBwYXJhbSByZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2hlY2tSZXNwb25zZVN0YXR1cyhyZXNwb25zZSkge1xyXG4gICAgICAgIHJldHVybiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkgfHxcclxuICAgICAgICAgICAgKHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNjAwKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBhIE5ldHdvcmtSZXNwb25zZSBvYmplY3QncyBSZXRyeUFmdGVyIGhlYWRlclxyXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjaGVja1Jlc3BvbnNlRm9yUmV0cnlBZnRlcihyZXNwb25zZSkge1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocmVzcG9uc2UuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShIZWFkZXJOYW1lcy5SRVRSWV9BRlRFUikgJiZcclxuICAgICAgICAgICAgICAgIChyZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDMwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIFVuaXgtdGltZSB2YWx1ZSBmb3IgYSB0aHJvdHRsZSB0byBleHBpcmUgZ2l2ZW4gdGhyb3R0bGVUaW1lIGluIHNlY29uZHMuXHJcbiAgICAgKiBAcGFyYW0gdGhyb3R0bGVUaW1lXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjYWxjdWxhdGVUaHJvdHRsZVRpbWUodGhyb3R0bGVUaW1lKSB7XHJcbiAgICAgICAgY29uc3QgdGltZSA9IHRocm90dGxlVGltZSA8PSAwID8gMCA6IHRocm90dGxlVGltZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50U2Vjb25kcyA9IERhdGUubm93KCkgLyAxMDAwO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKGN1cnJlbnRTZWNvbmRzICtcclxuICAgICAgICAgICAgKHRpbWUgfHwgVGhyb3R0bGluZ0NvbnN0YW50cy5ERUZBVUxUX1RIUk9UVExFX1RJTUVfU0VDT05EUyksIGN1cnJlbnRTZWNvbmRzICtcclxuICAgICAgICAgICAgVGhyb3R0bGluZ0NvbnN0YW50cy5ERUZBVUxUX01BWF9USFJPVFRMRV9USU1FX1NFQ09ORFMpICogMTAwMCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcmVtb3ZlVGhyb3R0bGUoY2FjaGVNYW5hZ2VyLCBjbGllbnRJZCwgcmVxdWVzdCwgaG9tZUFjY291bnRJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgY29uc3QgdGh1bWJwcmludCA9IGdldFJlcXVlc3RUaHVtYnByaW50KGNsaWVudElkLCByZXF1ZXN0LCBob21lQWNjb3VudElkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2VuZXJhdGVUaHJvdHRsaW5nU3RvcmFnZUtleSh0aHVtYnByaW50KTtcclxuICAgICAgICBjYWNoZU1hbmFnZXIucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFRocm90dGxpbmdVdGlscyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGhyb3R0bGluZ1V0aWxzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tICcuL0F1dGhFcnJvci5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgbmV0d29yayByZWxhdGVkIGVycm9yc1xyXG4gKi9cclxuY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGVycm9yLCBodHRwU3RhdHVzLCByZXNwb25zZUhlYWRlcnMpIHtcclxuICAgICAgICBzdXBlcihlcnJvci5lcnJvckNvZGUsIGVycm9yLmVycm9yTWVzc2FnZSwgZXJyb3Iuc3ViRXJyb3IpO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBOZXR3b3JrRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIk5ldHdvcmtFcnJvclwiO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB0aGlzLmh0dHBTdGF0dXMgPSBodHRwU3RhdHVzO1xyXG4gICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIE5ldHdvcmtFcnJvciBvYmplY3QgZm9yIGEgZmFpbGVkIG5ldHdvcmsgcmVxdWVzdFxyXG4gKiBAcGFyYW0gZXJyb3IgLSBFcnJvciB0byBiZSB0aHJvd24gYmFjayB0byB0aGUgY2FsbGVyXHJcbiAqIEBwYXJhbSBodHRwU3RhdHVzIC0gU3RhdHVzIGNvZGUgb2YgdGhlIG5ldHdvcmsgcmVxdWVzdFxyXG4gKiBAcGFyYW0gcmVzcG9uc2VIZWFkZXJzIC0gUmVzcG9uc2UgaGVhZGVycyBvZiB0aGUgbmV0d29yayByZXF1ZXN0LCB3aGVuIGF2YWlsYWJsZVxyXG4gKiBAcmV0dXJucyBOZXR3b3JrRXJyb3Igb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVOZXR3b3JrRXJyb3IoZXJyb3IsIGh0dHBTdGF0dXMsIHJlc3BvbnNlSGVhZGVycywgYWRkaXRpb25hbEVycm9yKSB7XHJcbiAgICBlcnJvci5lcnJvck1lc3NhZ2UgPSBgJHtlcnJvci5lcnJvck1lc3NhZ2V9LCBhZGRpdGlvbmFsRXJyb3JJbmZvOiBlcnJvci5uYW1lOiR7YWRkaXRpb25hbEVycm9yPy5uYW1lfSwgZXJyb3IubWVzc2FnZToke2FkZGl0aW9uYWxFcnJvcj8ubWVzc2FnZX1gO1xyXG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrRXJyb3IoZXJyb3IsIGh0dHBTdGF0dXMsIHJlc3BvbnNlSGVhZGVycyk7XHJcbn1cblxuZXhwb3J0IHsgTmV0d29ya0Vycm9yLCBjcmVhdGVOZXR3b3JrRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5ldHdvcmtFcnJvci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgYnVpbGRDbGllbnRDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vY29uZmlnL0NsaWVudENvbmZpZ3VyYXRpb24ubWpzJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlci9Mb2dnZXIubWpzJztcbmltcG9ydCB7IEhlYWRlck5hbWVzLCBDb25zdGFudHMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IG5hbWUsIHZlcnNpb24gfSBmcm9tICcuLi9wYWNrYWdlTWV0YWRhdGEubWpzJztcbmltcG9ydCB7IENjc0NyZWRlbnRpYWxUeXBlIH0gZnJvbSAnLi4vYWNjb3VudC9DY3NDcmVkZW50aWFsLm1qcyc7XG5pbXBvcnQgeyBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZCB9IGZyb20gJy4uL2FjY291bnQvQ2xpZW50SW5mby5tanMnO1xuaW1wb3J0IHsgYWRkQnJva2VyUGFyYW1ldGVycywgYWRkRXh0cmFRdWVyeVBhcmFtZXRlcnMsIGFkZENvcnJlbGF0aW9uSWQsIGluc3RydW1lbnRCcm9rZXJQYXJhbXMgfSBmcm9tICcuLi9yZXF1ZXN0L1JlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLm1qcyc7XG5pbXBvcnQgeyBtYXBUb1F1ZXJ5U3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvVXJsVXRpbHMubWpzJztcbmltcG9ydCB7IGNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZSB9IGZyb20gJy4uL2F1dGhvcml0eS9BdXRob3JpdHlGYWN0b3J5Lm1qcyc7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZUV2ZW50cyB9IGZyb20gJy4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9QZXJmb3JtYW5jZUV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBUaHJvdHRsaW5nVXRpbHMgfSBmcm9tICcuLi9uZXR3b3JrL1Rocm90dGxpbmdVdGlscy5tanMnO1xuaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IE5ldHdvcmtFcnJvciB9IGZyb20gJy4uL2Vycm9yL05ldHdvcmtFcnJvci5tanMnO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMgfSBmcm9tICcuLi91dGlscy9GdW5jdGlvbldyYXBwZXJzLm1qcyc7XG5pbXBvcnQgeyBuZXR3b3JrRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEJhc2UgYXBwbGljYXRpb24gY2xhc3Mgd2hpY2ggd2lsbCBjb25zdHJ1Y3QgcmVxdWVzdHMgdG8gc2VuZCB0byBhbmQgaGFuZGxlIHJlc3BvbnNlcyBmcm9tIHRoZSBNaWNyb3NvZnQgU1RTIHVzaW5nIHRoZSBhdXRob3JpemF0aW9uIGNvZGUgZmxvdy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBCYXNlQ2xpZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIHBlcmZvcm1hbmNlQ2xpZW50KSB7XHJcbiAgICAgICAgLy8gU2V0IHRoZSBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBidWlsZENsaWVudENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbG9nZ2VyXHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2VyKHRoaXMuY29uZmlnLmxvZ2dlck9wdGlvbnMsIG5hbWUsIHZlcnNpb24pO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3J5cHRvXHJcbiAgICAgICAgdGhpcy5jcnlwdG9VdGlscyA9IHRoaXMuY29uZmlnLmNyeXB0b0ludGVyZmFjZTtcclxuICAgICAgICAvLyBJbml0aWFsaXplIHN0b3JhZ2UgaW50ZXJmYWNlXHJcbiAgICAgICAgdGhpcy5jYWNoZU1hbmFnZXIgPSB0aGlzLmNvbmZpZy5zdG9yYWdlSW50ZXJmYWNlO1xyXG4gICAgICAgIC8vIFNldCB0aGUgbmV0d29yayBpbnRlcmZhY2VcclxuICAgICAgICB0aGlzLm5ldHdvcmtDbGllbnQgPSB0aGlzLmNvbmZpZy5uZXR3b3JrSW50ZXJmYWNlO1xyXG4gICAgICAgIC8vIFNldCBUZWxlbWV0cnlNYW5hZ2VyXHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyID0gdGhpcy5jb25maWcuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcjtcclxuICAgICAgICAvLyBzZXQgQXV0aG9yaXR5XHJcbiAgICAgICAgdGhpcy5hdXRob3JpdHkgPSB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5hdXRob3JpdHk7XHJcbiAgICAgICAgLy8gc2V0IHBlcmZvcm1hbmNlIHRlbGVtZXRyeSBjbGllbnRcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50ID0gcGVyZm9ybWFuY2VDbGllbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgZGVmYXVsdCBoZWFkZXJzIGZvciByZXF1ZXN0cyB0byB0b2tlbiBlbmRwb2ludFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVUb2tlblJlcXVlc3RIZWFkZXJzKGNjc0NyZWQpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICAgICAgaGVhZGVyc1tIZWFkZXJOYW1lcy5DT05URU5UX1RZUEVdID0gQ29uc3RhbnRzLlVSTF9GT1JNX0NPTlRFTlRfVFlQRTtcclxuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnN5c3RlbU9wdGlvbnMucHJldmVudENvcnNQcmVmbGlnaHQgJiYgY2NzQ3JlZCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNjc0NyZWQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDY3NDcmVkZW50aWFsVHlwZS5IT01FX0FDQ09VTlRfSUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mb0Zyb21Ib21lQWNjb3VudElkKGNjc0NyZWQuY3JlZGVudGlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVyTmFtZXMuQ0NTX0hFQURFUl0gPSBgT2lkOiR7Y2xpZW50SW5mby51aWR9QCR7Y2xpZW50SW5mby51dGlkfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJDb3VsZCBub3QgcGFyc2UgaG9tZSBhY2NvdW50IElEIGZvciBDQ1MgSGVhZGVyOiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENjc0NyZWRlbnRpYWxUeXBlLlVQTjpcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlck5hbWVzLkNDU19IRUFERVJdID0gYFVQTjogJHtjY3NDcmVkLmNyZWRlbnRpYWx9YDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSHR0cCBwb3N0IHRvIHRva2VuIGVuZHBvaW50XHJcbiAgICAgKiBAcGFyYW0gdG9rZW5FbmRwb2ludFxyXG4gICAgICogQHBhcmFtIHF1ZXJ5U3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gaGVhZGVyc1xyXG4gICAgICogQHBhcmFtIHRodW1icHJpbnRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZXhlY3V0ZVBvc3RUb1Rva2VuRW5kcG9pbnQodG9rZW5FbmRwb2ludCwgcXVlcnlTdHJpbmcsIGhlYWRlcnMsIHRodW1icHJpbnQsIGNvcnJlbGF0aW9uSWQsIHF1ZXVlZEV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHF1ZXVlZEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQocXVldWVkRXZlbnQsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFBvc3RSZXF1ZXN0KHRodW1icHJpbnQsIHRva2VuRW5kcG9pbnQsIHsgYm9keTogcXVlcnlTdHJpbmcsIGhlYWRlcnM6IGhlYWRlcnMgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIgJiZcclxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwICYmXHJcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1cyAhPT0gNDI5KSB7XHJcbiAgICAgICAgICAgIC8vIFRlbGVtZXRyeSBkYXRhIHN1Y2Nlc3NmdWxseSBsb2dnZWQgYnkgc2VydmVyLCBjbGVhciBUZWxlbWV0cnkgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5jbGVhclRlbGVtZXRyeUNhY2hlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHMgc2VuZFBvc3RSZXF1ZXN0QXN5bmMgd2l0aCBuZWNlc3NhcnkgcHJlZmxpZ2h0IGFuZCBwb3N0ZmxpZ2h0IGxvZ2ljXHJcbiAgICAgKiBAcGFyYW0gdGh1bWJwcmludCAtIFJlcXVlc3QgdGh1bWJwcmludCBmb3IgdGhyb3R0bGluZ1xyXG4gICAgICogQHBhcmFtIHRva2VuRW5kcG9pbnQgLSBFbmRwb2ludCB0byBtYWtlIHRoZSBQT1NUIHRvXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEJvZHkgYW5kIEhlYWRlcnMgdG8gaW5jbHVkZSBvbiB0aGUgUE9TVCByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gY29ycmVsYXRpb25JZCAtIENvcnJlbGF0aW9uSWQgZm9yIHRlbGVtZXRyeVxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZW5kUG9zdFJlcXVlc3QodGh1bWJwcmludCwgdG9rZW5FbmRwb2ludCwgb3B0aW9ucywgY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgIFRocm90dGxpbmdVdGlscy5wcmVQcm9jZXNzKHRoaXMuY2FjaGVNYW5hZ2VyLCB0aHVtYnByaW50KTtcclxuICAgICAgICBsZXQgcmVzcG9uc2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBpbnZva2VBc3luYygodGhpcy5uZXR3b3JrQ2xpZW50LnNlbmRQb3N0UmVxdWVzdEFzeW5jLmJpbmQodGhpcy5uZXR3b3JrQ2xpZW50KSksIFBlcmZvcm1hbmNlRXZlbnRzLk5ldHdvcmtDbGllbnRTZW5kUG9zdFJlcXVlc3RBc3luYywgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIGNvcnJlbGF0aW9uSWQpKHRva2VuRW5kcG9pbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzIHx8IHt9O1xyXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoe1xyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuU2l6ZTogcmVzcG9uc2UuYm9keS5yZWZyZXNoX3Rva2VuPy5sZW5ndGggfHwgMCxcclxuICAgICAgICAgICAgICAgIGh0dHBWZXJUb2tlbjogcmVzcG9uc2VIZWFkZXJzW0hlYWRlck5hbWVzLlhfTVNfSFRUUF9WRVJTSU9OXSB8fCBcIlwiLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXNwb25zZUhlYWRlcnNbSGVhZGVyTmFtZXMuWF9NU19SRVFVRVNUX0lEXSB8fCBcIlwiLFxyXG4gICAgICAgICAgICB9LCBjb3JyZWxhdGlvbklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOZXR3b3JrRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGUucmVzcG9uc2VIZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBWZXJUb2tlbjogcmVzcG9uc2VIZWFkZXJzW0hlYWRlck5hbWVzLlhfTVNfSFRUUF9WRVJTSU9OXSB8fCBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlc3BvbnNlSGVhZGVyc1tIZWFkZXJOYW1lcy5YX01TX1JFUVVFU1RfSURdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZUhlYWRlcjogcmVzcG9uc2VIZWFkZXJzW0hlYWRlck5hbWVzLkNPTlRFTlRfVFlQRV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aEhlYWRlcjogcmVzcG9uc2VIZWFkZXJzW0hlYWRlck5hbWVzLkNPTlRFTlRfTEVOR1RIXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwU3RhdHVzOiBlLmh0dHBTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlLmVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQXV0aEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG5ldHdvcmtFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgVGhyb3R0bGluZ1V0aWxzLnBvc3RQcm9jZXNzKHRoaXMuY2FjaGVNYW5hZ2VyLCB0aHVtYnByaW50LCByZXNwb25zZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBhdXRob3JpdHkgb2JqZWN0IG9mIHRoZSBjbGllbnQuIEVuZHBvaW50IGRpc2NvdmVyeSBtdXN0IGJlIGNvbXBsZXRlZC5cclxuICAgICAqIEBwYXJhbSB1cGRhdGVkQXV0aG9yaXR5XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHVwZGF0ZUF1dGhvcml0eShjbG91ZEluc3RhbmNlSG9zdG5hbWUsIGNvcnJlbGF0aW9uSWQpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlVwZGF0ZVRva2VuRW5kcG9pbnRBdXRob3JpdHksIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IGNsb3VkSW5zdGFuY2VBdXRob3JpdHlVcmkgPSBgaHR0cHM6Ly8ke2Nsb3VkSW5zdGFuY2VIb3N0bmFtZX0vJHt0aGlzLmF1dGhvcml0eS50ZW5hbnR9L2A7XHJcbiAgICAgICAgY29uc3QgY2xvdWRJbnN0YW5jZUF1dGhvcml0eSA9IGF3YWl0IGNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZShjbG91ZEluc3RhbmNlQXV0aG9yaXR5VXJpLCB0aGlzLm5ldHdvcmtDbGllbnQsIHRoaXMuY2FjaGVNYW5hZ2VyLCB0aGlzLmF1dGhvcml0eS5vcHRpb25zLCB0aGlzLmxvZ2dlciwgY29ycmVsYXRpb25JZCwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCk7XHJcbiAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBjbG91ZEluc3RhbmNlQXV0aG9yaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHF1ZXJ5IHN0cmluZyBmb3IgdGhlIC90b2tlbiByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVUb2tlblF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBpZiAocmVxdWVzdC5lbWJlZGRlZENsaWVudElkKSB7XHJcbiAgICAgICAgICAgIGFkZEJyb2tlclBhcmFtZXRlcnMocGFyYW1ldGVycywgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLnJlZGlyZWN0VXJpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcXVlc3QudG9rZW5RdWVyeVBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgYWRkRXh0cmFRdWVyeVBhcmFtZXRlcnMocGFyYW1ldGVycywgcmVxdWVzdC50b2tlblF1ZXJ5UGFyYW1ldGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZENvcnJlbGF0aW9uSWQocGFyYW1ldGVycywgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBpbnN0cnVtZW50QnJva2VyUGFyYW1zKHBhcmFtZXRlcnMsIHJlcXVlc3QuY29ycmVsYXRpb25JZCwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIG1hcFRvUXVlcnlTdHJpbmcocGFyYW1ldGVycyk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQmFzZUNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUNsaWVudC5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8vIENvZGVzIGRlZmluZWQgYnkgTVNBTFxyXG5jb25zdCBub1Rva2Vuc0ZvdW5kID0gXCJub190b2tlbnNfZm91bmRcIjtcclxuY29uc3QgbmF0aXZlQWNjb3VudFVuYXZhaWxhYmxlID0gXCJuYXRpdmVfYWNjb3VudF91bmF2YWlsYWJsZVwiO1xyXG5jb25zdCByZWZyZXNoVG9rZW5FeHBpcmVkID0gXCJyZWZyZXNoX3Rva2VuX2V4cGlyZWRcIjtcclxuLy8gQ29kZXMgcG90ZW50aWFsbHkgcmV0dXJuZWQgYnkgc2VydmVyXHJcbmNvbnN0IGludGVyYWN0aW9uUmVxdWlyZWQgPSBcImludGVyYWN0aW9uX3JlcXVpcmVkXCI7XHJcbmNvbnN0IGNvbnNlbnRSZXF1aXJlZCA9IFwiY29uc2VudF9yZXF1aXJlZFwiO1xyXG5jb25zdCBsb2dpblJlcXVpcmVkID0gXCJsb2dpbl9yZXF1aXJlZFwiO1xyXG5jb25zdCBiYWRUb2tlbiA9IFwiYmFkX3Rva2VuXCI7XG5cbmV4cG9ydCB7IGJhZFRva2VuLCBjb25zZW50UmVxdWlyZWQsIGludGVyYWN0aW9uUmVxdWlyZWQsIGxvZ2luUmVxdWlyZWQsIG5hdGl2ZUFjY291bnRVbmF2YWlsYWJsZSwgbm9Ub2tlbnNGb3VuZCwgcmVmcmVzaFRva2VuRXhwaXJlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gJy4vQXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyBub1Rva2Vuc0ZvdW5kLCBuYXRpdmVBY2NvdW50VW5hdmFpbGFibGUsIGJhZFRva2VuLCByZWZyZXNoVG9rZW5FeHBpcmVkLCBpbnRlcmFjdGlvblJlcXVpcmVkLCBjb25zZW50UmVxdWlyZWQsIGxvZ2luUmVxdWlyZWQgfSBmcm9tICcuL0ludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuaW1wb3J0ICogYXMgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzIGZyb20gJy4vSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLm1qcyc7XG5leHBvcnQgeyBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yQ29kZXMgfTtcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbnRlcmFjdGlvblJlcXVpcmVkU2VydmVyRXJyb3JNZXNzYWdlIGNvbnRhaW5zIHN0cmluZyBjb25zdGFudHMgdXNlZCBieSBlcnJvciBjb2RlcyBhbmQgbWVzc2FnZXMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlciBpbmRpY2F0aW5nIGludGVyYWN0aW9uIGlzIHJlcXVpcmVkXHJcbiAqL1xyXG5jb25zdCBJbnRlcmFjdGlvblJlcXVpcmVkU2VydmVyRXJyb3JNZXNzYWdlID0gW1xyXG4gICAgaW50ZXJhY3Rpb25SZXF1aXJlZCxcclxuICAgIGNvbnNlbnRSZXF1aXJlZCxcclxuICAgIGxvZ2luUmVxdWlyZWQsXHJcbiAgICBiYWRUb2tlbixcclxuXTtcclxuY29uc3QgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhTdWJFcnJvck1lc3NhZ2UgPSBbXHJcbiAgICBcIm1lc3NhZ2Vfb25seVwiLFxyXG4gICAgXCJhZGRpdGlvbmFsX2FjdGlvblwiLFxyXG4gICAgXCJiYXNpY19hY3Rpb25cIixcclxuICAgIFwidXNlcl9wYXNzd29yZF9leHBpcmVkXCIsXHJcbiAgICBcImNvbnNlbnRfcmVxdWlyZWRcIixcclxuICAgIFwiYmFkX3Rva2VuXCIsXHJcbl07XHJcbmNvbnN0IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIFtub1Rva2Vuc0ZvdW5kXTogXCJObyByZWZyZXNoIHRva2VuIGZvdW5kIGluIHRoZSBjYWNoZS4gUGxlYXNlIHNpZ24taW4uXCIsXHJcbiAgICBbbmF0aXZlQWNjb3VudFVuYXZhaWxhYmxlXTogXCJUaGUgcmVxdWVzdGVkIGFjY291bnQgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgbmF0aXZlIGJyb2tlci4gSXQgbWF5IGhhdmUgYmVlbiBkZWxldGVkIG9yIGxvZ2dlZCBvdXQuIFBsZWFzZSBzaWduLWluIGFnYWluIHVzaW5nIGFuIGludGVyYWN0aXZlIEFQSS5cIixcclxuICAgIFtyZWZyZXNoVG9rZW5FeHBpcmVkXTogXCJSZWZyZXNoIHRva2VuIGhhcyBleHBpcmVkLlwiLFxyXG4gICAgW2JhZFRva2VuXTogXCJJZGVudGl0eSBwcm92aWRlciByZXR1cm5lZCBiYWRfdG9rZW4gZHVlIHRvIGFuIGV4cGlyZWQgb3IgaW52YWxpZCByZWZyZXNoIHRva2VuLiBQbGVhc2UgaW52b2tlIGFuIGludGVyYWN0aXZlIEFQSSB0byByZXNvbHZlLlwiLFxyXG59O1xyXG4vKipcclxuICogSW50ZXJhY3Rpb24gcmVxdWlyZWQgZXJyb3JzIGRlZmluZWQgYnkgdGhlIFNES1xyXG4gKiBAZGVwcmVjYXRlZCBVc2UgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzIGluc3RlYWRcclxuICovXHJcbmNvbnN0IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JNZXNzYWdlID0ge1xyXG4gICAgbm9Ub2tlbnNGb3VuZEVycm9yOiB7XHJcbiAgICAgICAgY29kZTogbm9Ub2tlbnNGb3VuZCxcclxuICAgICAgICBkZXNjOiBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yTWVzc2FnZXNbbm9Ub2tlbnNGb3VuZF0sXHJcbiAgICB9LFxyXG4gICAgbmF0aXZlX2FjY291bnRfdW5hdmFpbGFibGU6IHtcclxuICAgICAgICBjb2RlOiBuYXRpdmVBY2NvdW50VW5hdmFpbGFibGUsXHJcbiAgICAgICAgZGVzYzogSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvck1lc3NhZ2VzW25hdGl2ZUFjY291bnRVbmF2YWlsYWJsZV0sXHJcbiAgICB9LFxyXG4gICAgYmFkX3Rva2VuOiB7XHJcbiAgICAgICAgY29kZTogYmFkVG9rZW4sXHJcbiAgICAgICAgZGVzYzogSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvck1lc3NhZ2VzW2JhZFRva2VuXSxcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBFcnJvciB0aHJvd24gd2hlbiB1c2VyIGludGVyYWN0aW9uIGlzIHJlcXVpcmVkLlxyXG4gKi9cclxuY2xhc3MgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgc3ViRXJyb3IsIHRpbWVzdGFtcCwgdHJhY2VJZCwgY29ycmVsYXRpb25JZCwgY2xhaW1zLCBlcnJvck5vKSB7XHJcbiAgICAgICAgc3VwZXIoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIHN1YkVycm9yKTtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XHJcbiAgICAgICAgdGhpcy50cmFjZUlkID0gdHJhY2VJZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMuY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORztcclxuICAgICAgICB0aGlzLmNsYWltcyA9IGNsYWltcyB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvclwiO1xyXG4gICAgICAgIHRoaXMuZXJyb3JObyA9IGVycm9yTm87XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciB0aHJvd24gYnkgdGhlIHNlcnZlciByZXF1aXJlcyBpbnRlcmFjdGlvbiB0byByZXNvbHZlXHJcbiAqIEBwYXJhbSBlcnJvckNvZGVcclxuICogQHBhcmFtIGVycm9yU3RyaW5nXHJcbiAqIEBwYXJhbSBzdWJFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblJlcXVpcmVkRXJyb3IoZXJyb3JDb2RlLCBlcnJvclN0cmluZywgc3ViRXJyb3IpIHtcclxuICAgIGNvbnN0IGlzSW50ZXJhY3Rpb25SZXF1aXJlZEVycm9yQ29kZSA9ICEhZXJyb3JDb2RlICYmXHJcbiAgICAgICAgSW50ZXJhY3Rpb25SZXF1aXJlZFNlcnZlckVycm9yTWVzc2FnZS5pbmRleE9mKGVycm9yQ29kZSkgPiAtMTtcclxuICAgIGNvbnN0IGlzSW50ZXJhY3Rpb25SZXF1aXJlZFN1YkVycm9yID0gISFzdWJFcnJvciAmJlxyXG4gICAgICAgIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoU3ViRXJyb3JNZXNzYWdlLmluZGV4T2Yoc3ViRXJyb3IpID4gLTE7XHJcbiAgICBjb25zdCBpc0ludGVyYWN0aW9uUmVxdWlyZWRFcnJvckRlc2MgPSAhIWVycm9yU3RyaW5nICYmXHJcbiAgICAgICAgSW50ZXJhY3Rpb25SZXF1aXJlZFNlcnZlckVycm9yTWVzc2FnZS5zb21lKChpckVycm9yQ29kZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3JTdHJpbmcuaW5kZXhPZihpckVycm9yQ29kZSkgPiAtMTtcclxuICAgICAgICB9KTtcclxuICAgIHJldHVybiAoaXNJbnRlcmFjdGlvblJlcXVpcmVkRXJyb3JDb2RlIHx8XHJcbiAgICAgICAgaXNJbnRlcmFjdGlvblJlcXVpcmVkRXJyb3JEZXNjIHx8XHJcbiAgICAgICAgaXNJbnRlcmFjdGlvblJlcXVpcmVkU3ViRXJyb3IpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IoZXJyb3JDb2RlKSB7XHJcbiAgICByZXR1cm4gbmV3IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IoZXJyb3JDb2RlLCBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSk7XHJcbn1cblxuZXhwb3J0IHsgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvciwgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvck1lc3NhZ2UsIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoU3ViRXJyb3JNZXNzYWdlLCBJbnRlcmFjdGlvblJlcXVpcmVkU2VydmVyRXJyb3JNZXNzYWdlLCBjcmVhdGVJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yLCBpc0ludGVyYWN0aW9uUmVxdWlyZWRFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQ29uc3RhbnRzIH0gZnJvbSAnLi9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgbm9DcnlwdG9PYmplY3QsIGludmFsaWRTdGF0ZSB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ2xhc3Mgd2hpY2ggcHJvdmlkZXMgaGVscGVycyBmb3IgT0F1dGggMi4wIHByb3RvY29sIHNwZWNpZmljIHZhbHVlc1xyXG4gKi9cclxuY2xhc3MgUHJvdG9jb2xVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgdXNlciBzdGF0ZSB3aXRoIHJhbmRvbSBndWlkLCBvciByZXR1cm5zIHJhbmRvbSBndWlkLlxyXG4gICAgICogQHBhcmFtIHVzZXJTdGF0ZVxyXG4gICAgICogQHBhcmFtIHJhbmRvbUd1aWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNldFJlcXVlc3RTdGF0ZShjcnlwdG9PYmosIHVzZXJTdGF0ZSwgbWV0YSkge1xyXG4gICAgICAgIGNvbnN0IGxpYnJhcnlTdGF0ZSA9IFByb3RvY29sVXRpbHMuZ2VuZXJhdGVMaWJyYXJ5U3RhdGUoY3J5cHRvT2JqLCBtZXRhKTtcclxuICAgICAgICByZXR1cm4gdXNlclN0YXRlXHJcbiAgICAgICAgICAgID8gYCR7bGlicmFyeVN0YXRlfSR7Q29uc3RhbnRzLlJFU09VUkNFX0RFTElNfSR7dXNlclN0YXRlfWBcclxuICAgICAgICAgICAgOiBsaWJyYXJ5U3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0aGUgc3RhdGUgdmFsdWUgdXNlZCBieSB0aGUgY29tbW9uIGxpYnJhcnkuXHJcbiAgICAgKiBAcGFyYW0gcmFuZG9tR3VpZFxyXG4gICAgICogQHBhcmFtIGNyeXB0b09ialxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVMaWJyYXJ5U3RhdGUoY3J5cHRvT2JqLCBtZXRhKSB7XHJcbiAgICAgICAgaWYgKCFjcnlwdG9PYmopIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG5vQ3J5cHRvT2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc3RhdGUgb2JqZWN0IGNvbnRhaW5pbmcgYSB1bmlxdWUgaWQgYW5kIHRoZSB0aW1lc3RhbXAgb2YgdGhlIHJlcXVlc3QgY3JlYXRpb25cclxuICAgICAgICBjb25zdCBzdGF0ZU9iaiA9IHtcclxuICAgICAgICAgICAgaWQ6IGNyeXB0b09iai5jcmVhdGVOZXdHdWlkKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobWV0YSkge1xyXG4gICAgICAgICAgICBzdGF0ZU9iai5tZXRhID0gbWV0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShzdGF0ZU9iaik7XHJcbiAgICAgICAgcmV0dXJuIGNyeXB0b09iai5iYXNlNjRFbmNvZGUoc3RhdGVTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIHN0YXRlIGludG8gdGhlIFJlcXVlc3RTdGF0ZU9iamVjdCwgd2hpY2ggY29udGFpbnMgdGhlIExpYnJhcnlTdGF0ZSBpbmZvIGFuZCB0aGUgc3RhdGUgcGFzc2VkIGJ5IHRoZSB1c2VyLlxyXG4gICAgICogQHBhcmFtIHN0YXRlXHJcbiAgICAgKiBAcGFyYW0gY3J5cHRvT2JqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwYXJzZVJlcXVlc3RTdGF0ZShjcnlwdG9PYmosIHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKCFjcnlwdG9PYmopIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKG5vQ3J5cHRvT2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoaW52YWxpZFN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHN0YXRlIGJldHdlZW4gbGlicmFyeSBzdGF0ZSBhbmQgdXNlciBwYXNzZWQgc3RhdGUgYW5kIGRlY29kZSB0aGVtIHNlcGFyYXRlbHlcclxuICAgICAgICAgICAgY29uc3Qgc3BsaXRTdGF0ZSA9IHN0YXRlLnNwbGl0KENvbnN0YW50cy5SRVNPVVJDRV9ERUxJTSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpYnJhcnlTdGF0ZSA9IHNwbGl0U3RhdGVbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJTdGF0ZSA9IHNwbGl0U3RhdGUubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyBzcGxpdFN0YXRlLnNsaWNlKDEpLmpvaW4oQ29uc3RhbnRzLlJFU09VUkNFX0RFTElNKVxyXG4gICAgICAgICAgICAgICAgOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HO1xyXG4gICAgICAgICAgICBjb25zdCBsaWJyYXJ5U3RhdGVTdHJpbmcgPSBjcnlwdG9PYmouYmFzZTY0RGVjb2RlKGxpYnJhcnlTdGF0ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpYnJhcnlTdGF0ZU9iaiA9IEpTT04ucGFyc2UobGlicmFyeVN0YXRlU3RyaW5nKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZXJSZXF1ZXN0U3RhdGU6IHVzZXJTdGF0ZSB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgICAgICAgICAgbGlicmFyeVN0YXRlOiBsaWJyYXJ5U3RhdGVPYmosXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihpbnZhbGlkU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBQcm90b2NvbFV0aWxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm90b2NvbFV0aWxzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBub3dTZWNvbmRzIH0gZnJvbSAnLi4vdXRpbHMvVGltZVV0aWxzLm1qcyc7XG5pbXBvcnQgeyBVcmxTdHJpbmcgfSBmcm9tICcuLi91cmwvVXJsU3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZUV2ZW50cyB9IGZyb20gJy4uL3RlbGVtZXRyeS9wZXJmb3JtYW5jZS9QZXJmb3JtYW5jZUV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBpbnZva2VBc3luYyB9IGZyb20gJy4uL3V0aWxzL0Z1bmN0aW9uV3JhcHBlcnMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEtleUxvY2F0aW9uID0ge1xyXG4gICAgU1c6IFwic3dcIixcclxuICAgIFVIVzogXCJ1aHdcIixcclxufTtcclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5jbGFzcyBQb3BUb2tlbkdlbmVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjcnlwdG9VdGlscywgcGVyZm9ybWFuY2VDbGllbnQpIHtcclxuICAgICAgICB0aGlzLmNyeXB0b1V0aWxzID0gY3J5cHRvVXRpbHM7XHJcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCA9IHBlcmZvcm1hbmNlQ2xpZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHJlcV9jbmYgdmFsaWRhdGVkIGF0IHRoZSBSUCBpbiB0aGUgUE9QIHByb3RvY29sIGZvciBTSFIgcGFyYW1ldGVyc1xyXG4gICAgICogYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleWlkLCB0aGUgZnVsbCByZXFfY25mIHN0cmluZyBhbmQgdGhlIHJlcV9jbmYgc3RyaW5nIGhhc2hcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0XHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBhc3luYyBnZW5lcmF0ZUNuZihyZXF1ZXN0LCBsb2dnZXIpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlBvcFRva2VuR2VuZXJhdGVDbmYsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgY29uc3QgcmVxQ25mID0gYXdhaXQgaW52b2tlQXN5bmModGhpcy5nZW5lcmF0ZUtpZC5iaW5kKHRoaXMpLCBQZXJmb3JtYW5jZUV2ZW50cy5Qb3BUb2tlbkdlbmVyYXRlQ25mLCBsb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkocmVxdWVzdCk7XHJcbiAgICAgICAgY29uc3QgcmVxQ25mU3RyaW5nID0gdGhpcy5jcnlwdG9VdGlscy5iYXNlNjRVcmxFbmNvZGUoSlNPTi5zdHJpbmdpZnkocmVxQ25mKSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2lkOiByZXFDbmYua2lkLFxyXG4gICAgICAgICAgICByZXFDbmZTdHJpbmcsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGtleV9pZCBmb3IgYSBTSFIgdG9rZW4gcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdlbmVyYXRlS2lkKHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlBvcFRva2VuR2VuZXJhdGVLaWQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgY29uc3Qga2lkVGh1bWJwcmludCA9IGF3YWl0IHRoaXMuY3J5cHRvVXRpbHMuZ2V0UHVibGljS2V5VGh1bWJwcmludChyZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBraWQ6IGtpZFRodW1icHJpbnQsXHJcbiAgICAgICAgICAgIHhtc19rc2w6IEtleUxvY2F0aW9uLlNXLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpZ25zIHRoZSBQT1AgYWNjZXNzX3Rva2VuIHdpdGggdGhlIGxvY2FsIGdlbmVyYXRlZCBrZXktcGFpclxyXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2lnblBvcFRva2VuKGFjY2Vzc1Rva2VuLCBrZXlJZCwgcmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25QYXlsb2FkKGFjY2Vzc1Rva2VuLCBrZXlJZCwgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHNpZ25lZCBKV1QgZm9yIGFuIGFjY2Vzc190b2tlblxyXG4gICAgICogQHBhcmFtIHBheWxvYWRcclxuICAgICAqIEBwYXJhbSBraWRcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gY2xhaW1zXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBhc3luYyBzaWduUGF5bG9hZChwYXlsb2FkLCBrZXlJZCwgcmVxdWVzdCwgY2xhaW1zKSB7XHJcbiAgICAgICAgLy8gRGVjb25zdHJ1Y3QgcmVxdWVzdCB0byBleHRyYWN0IFNIUiBwYXJhbWV0ZXJzXHJcbiAgICAgICAgY29uc3QgeyByZXNvdXJjZVJlcXVlc3RNZXRob2QsIHJlc291cmNlUmVxdWVzdFVyaSwgc2hyQ2xhaW1zLCBzaHJOb25jZSwgc2hyT3B0aW9ucywgfSA9IHJlcXVlc3Q7XHJcbiAgICAgICAgY29uc3QgcmVzb3VyY2VVcmxTdHJpbmcgPSByZXNvdXJjZVJlcXVlc3RVcmlcclxuICAgICAgICAgICAgPyBuZXcgVXJsU3RyaW5nKHJlc291cmNlUmVxdWVzdFVyaSlcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcmVzb3VyY2VVcmxDb21wb25lbnRzID0gcmVzb3VyY2VVcmxTdHJpbmc/LmdldFVybENvbXBvbmVudHMoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG9VdGlscy5zaWduSnd0KHtcclxuICAgICAgICAgICAgYXQ6IHBheWxvYWQsXHJcbiAgICAgICAgICAgIHRzOiBub3dTZWNvbmRzKCksXHJcbiAgICAgICAgICAgIG06IHJlc291cmNlUmVxdWVzdE1ldGhvZD8udG9VcHBlckNhc2UoKSxcclxuICAgICAgICAgICAgdTogcmVzb3VyY2VVcmxDb21wb25lbnRzPy5Ib3N0TmFtZUFuZFBvcnQsXHJcbiAgICAgICAgICAgIG5vbmNlOiBzaHJOb25jZSB8fCB0aGlzLmNyeXB0b1V0aWxzLmNyZWF0ZU5ld0d1aWQoKSxcclxuICAgICAgICAgICAgcDogcmVzb3VyY2VVcmxDb21wb25lbnRzPy5BYnNvbHV0ZVBhdGgsXHJcbiAgICAgICAgICAgIHE6IHJlc291cmNlVXJsQ29tcG9uZW50cz8uUXVlcnlTdHJpbmdcclxuICAgICAgICAgICAgICAgID8gW1tdLCByZXNvdXJjZVVybENvbXBvbmVudHMuUXVlcnlTdHJpbmddXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY2xpZW50X2NsYWltczogc2hyQ2xhaW1zIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgLi4uY2xhaW1zLFxyXG4gICAgICAgIH0sIGtleUlkLCBzaHJPcHRpb25zLCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFBvcFRva2VuR2VuZXJhdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3BUb2tlbkdlbmVyYXRvci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGluc3RhbmNlIGhlbHBzIHRyYWNrIHRoZSBtZW1vcnkgY2hhbmdlcyBmYWNpbGl0YXRpbmdcclxuICogZGVjaXNpb25zIHRvIHJlYWQgZnJvbSBhbmQgd3JpdGUgdG8gdGhlIHBlcnNpc3RlbnQgY2FjaGVcclxuICovIGNsYXNzIFRva2VuQ2FjaGVDb250ZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKHRva2VuQ2FjaGUsIGhhc0NoYW5nZWQpIHtcclxuICAgICAgICB0aGlzLmNhY2hlID0gdG9rZW5DYWNoZTtcclxuICAgICAgICB0aGlzLmhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBib29sZWFuIHdoaWNoIGluZGljYXRlcyB0aGUgY2hhbmdlcyBpbiBjYWNoZVxyXG4gICAgICovXHJcbiAgICBnZXQgY2FjaGVIYXNDaGFuZ2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NoYW5nZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGZ1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSB0b2tlbiBjYWNoZVxyXG4gICAgICovXHJcbiAgICBnZXQgdG9rZW5DYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBUb2tlbkNhY2hlQ29udGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5DYWNoZUNvbnRleHQubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudEF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgU2VydmVyRXJyb3IgfSBmcm9tICcuLi9lcnJvci9TZXJ2ZXJFcnJvci5tanMnO1xuaW1wb3J0IHsgU2NvcGVTZXQgfSBmcm9tICcuLi9yZXF1ZXN0L1Njb3BlU2V0Lm1qcyc7XG5pbXBvcnQgeyBBY2NvdW50RW50aXR5IH0gZnJvbSAnLi4vY2FjaGUvZW50aXRpZXMvQWNjb3VudEVudGl0eS5tanMnO1xuaW1wb3J0IHsgaXNJbnRlcmFjdGlvblJlcXVpcmVkRXJyb3IsIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9JbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyBQcm90b2NvbFV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvUHJvdG9jb2xVdGlscy5tanMnO1xuaW1wb3J0IHsgSHR0cFN0YXR1cywgQ29uc3RhbnRzLCBBdXRoZW50aWNhdGlvblNjaGVtZSwgVEhFX0ZBTUlMWV9JRCB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgUG9wVG9rZW5HZW5lcmF0b3IgfSBmcm9tICcuLi9jcnlwdG8vUG9wVG9rZW5HZW5lcmF0b3IubWpzJztcbmltcG9ydCB7IFRva2VuQ2FjaGVDb250ZXh0IH0gZnJvbSAnLi4vY2FjaGUvcGVyc2lzdGVuY2UvVG9rZW5DYWNoZUNvbnRleHQubWpzJztcbmltcG9ydCB7IFBlcmZvcm1hbmNlRXZlbnRzIH0gZnJvbSAnLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL1BlcmZvcm1hbmNlRXZlbnQubWpzJztcbmltcG9ydCB7IGV4dHJhY3RUb2tlbkNsYWltcywgY2hlY2tNYXhBZ2UgfSBmcm9tICcuLi9hY2NvdW50L0F1dGhUb2tlbi5tanMnO1xuaW1wb3J0IHsgZ2V0VGVuYW50SWRGcm9tSWRUb2tlbkNsYWltcyB9IGZyb20gJy4uL2FjY291bnQvVG9rZW5DbGFpbXMubWpzJztcbmltcG9ydCB7IHVwZGF0ZUFjY291bnRUZW5hbnRQcm9maWxlRGF0YSwgYnVpbGRUZW5hbnRQcm9maWxlIH0gZnJvbSAnLi4vYWNjb3VudC9BY2NvdW50SW5mby5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQWNjZXNzVG9rZW5FbnRpdHksIGNyZWF0ZVJlZnJlc2hUb2tlbkVudGl0eSwgY3JlYXRlSWRUb2tlbkVudGl0eSB9IGZyb20gJy4uL2NhY2hlL3V0aWxzL0NhY2hlSGVscGVycy5tanMnO1xuaW1wb3J0IHsgdG9EYXRlRnJvbVNlY29uZHMgfSBmcm9tICcuLi91dGlscy9UaW1lVXRpbHMubWpzJztcbmltcG9ydCB7IG5vbmNlTWlzbWF0Y2gsIGF1dGhUaW1lTm90Rm91bmQsIGludmFsaWRDYWNoZUVudmlyb25tZW50LCBrZXlJZE1pc3NpbmcgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaGFuZGxlcyByZXNwb25zZSBwYXJzaW5nLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlc3BvbnNlSGFuZGxlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgY2FjaGVTdG9yYWdlLCBjcnlwdG9PYmosIGxvZ2dlciwgc2VyaWFsaXphYmxlQ2FjaGUsIHBlcnNpc3RlbmNlUGx1Z2luLCBwZXJmb3JtYW5jZUNsaWVudCkge1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLmNhY2hlU3RvcmFnZSA9IGNhY2hlU3RvcmFnZTtcclxuICAgICAgICB0aGlzLmNyeXB0b09iaiA9IGNyeXB0b09iajtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6YWJsZUNhY2hlID0gc2VyaWFsaXphYmxlQ2FjaGU7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZVBsdWdpbiA9IHBlcnNpc3RlbmNlUGx1Z2luO1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQgPSBwZXJmb3JtYW5jZUNsaWVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gd2hpY2ggdmFsaWRhdGVzIHNlcnZlciBhdXRob3JpemF0aW9uIHRva2VuIHJlc3BvbnNlLlxyXG4gICAgICogQHBhcmFtIHNlcnZlclJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gcmVmcmVzaEFjY2Vzc1Rva2VuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlVG9rZW5SZXNwb25zZShzZXJ2ZXJSZXNwb25zZSwgcmVmcmVzaEFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGVycm9yXHJcbiAgICAgICAgaWYgKHNlcnZlclJlc3BvbnNlLmVycm9yIHx8XHJcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uIHx8XHJcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyclN0cmluZyA9IGBFcnJvcihzKTogJHtzZXJ2ZXJSZXNwb25zZS5lcnJvcl9jb2RlcyB8fCBDb25zdGFudHMuTk9UX0FWQUlMQUJMRX0gLSBUaW1lc3RhbXA6ICR7c2VydmVyUmVzcG9uc2UudGltZXN0YW1wIHx8IENvbnN0YW50cy5OT1RfQVZBSUxBQkxFfSAtIERlc2NyaXB0aW9uOiAke3NlcnZlclJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uIHx8IENvbnN0YW50cy5OT1RfQVZBSUxBQkxFfSAtIENvcnJlbGF0aW9uIElEOiAke3NlcnZlclJlc3BvbnNlLmNvcnJlbGF0aW9uX2lkIHx8IENvbnN0YW50cy5OT1RfQVZBSUxBQkxFfSAtIFRyYWNlIElEOiAke3NlcnZlclJlc3BvbnNlLnRyYWNlX2lkIHx8IENvbnN0YW50cy5OT1RfQVZBSUxBQkxFfWA7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckVycm9yTm8gPSBzZXJ2ZXJSZXNwb25zZS5lcnJvcl9jb2Rlcz8ubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA/IHNlcnZlclJlc3BvbnNlLmVycm9yX2NvZGVzWzBdXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyRXJyb3IgPSBuZXcgU2VydmVyRXJyb3Ioc2VydmVyUmVzcG9uc2UuZXJyb3IsIGVyclN0cmluZywgc2VydmVyUmVzcG9uc2Uuc3ViZXJyb3IsIHNlcnZlckVycm9yTm8sIHNlcnZlclJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIDUwMCBlcnJvclxyXG4gICAgICAgICAgICBpZiAocmVmcmVzaEFjY2Vzc1Rva2VuICYmXHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5zdGF0dXMgJiZcclxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN0YXR1cyA+PSBIdHRwU3RhdHVzLlNFUlZFUl9FUlJPUl9SQU5HRV9TVEFSVCAmJlxyXG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3RhdHVzIDw9IEh0dHBTdGF0dXMuU0VSVkVSX0VSUk9SX1JBTkdFX0VORCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhgZXhlY3V0ZVRva2VuUmVxdWVzdDp2YWxpZGF0ZVRva2VuUmVzcG9uc2UgLSBBQUQgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlIGFuZCB0aGUgYWNjZXNzIHRva2VuIGlzIHVuYWJsZSB0byBiZSByZWZyZXNoZWQuXFxuJHtzZXJ2ZXJFcnJvcn1gKTtcclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHRocm93IGFuIGV4Y2VwdGlvbiwgYnV0IGFsZXJ0IHRoZSB1c2VyIHZpYSBhIGxvZyB0aGF0IHRoZSB0b2tlbiB3YXMgdW5hYmxlIHRvIGJlIHJlZnJlc2hlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgNDAwIGVycm9yXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVmcmVzaEFjY2Vzc1Rva2VuICYmXHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZS5zdGF0dXMgJiZcclxuICAgICAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlLnN0YXR1cyA+PSBIdHRwU3RhdHVzLkNMSUVOVF9FUlJPUl9SQU5HRV9TVEFSVCAmJlxyXG4gICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3RhdHVzIDw9IEh0dHBTdGF0dXMuQ0xJRU5UX0VSUk9SX1JBTkdFX0VORCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybmluZyhgZXhlY3V0ZVRva2VuUmVxdWVzdDp2YWxpZGF0ZVRva2VuUmVzcG9uc2UgLSBBQUQgaXMgY3VycmVudGx5IGF2YWlsYWJsZSBidXQgaXMgdW5hYmxlIHRvIHJlZnJlc2ggdGhlIGFjY2VzcyB0b2tlbi5cXG4ke3NlcnZlckVycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgdGhyb3cgYW4gZXhjZXB0aW9uLCBidXQgYWxlcnQgdGhlIHVzZXIgdmlhIGEgbG9nIHRoYXQgdGhlIHRva2VuIHdhcyB1bmFibGUgdG8gYmUgcmVmcmVzaGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzSW50ZXJhY3Rpb25SZXF1aXJlZEVycm9yKHNlcnZlclJlc3BvbnNlLmVycm9yLCBzZXJ2ZXJSZXNwb25zZS5lcnJvcl9kZXNjcmlwdGlvbiwgc2VydmVyUmVzcG9uc2Uuc3ViZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvcihzZXJ2ZXJSZXNwb25zZS5lcnJvciwgc2VydmVyUmVzcG9uc2UuZXJyb3JfZGVzY3JpcHRpb24sIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yLCBzZXJ2ZXJSZXNwb25zZS50aW1lc3RhbXAgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORywgc2VydmVyUmVzcG9uc2UudHJhY2VfaWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORywgc2VydmVyUmVzcG9uc2UuY29ycmVsYXRpb25faWQgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORywgc2VydmVyUmVzcG9uc2UuY2xhaW1zIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsIHNlcnZlckVycm9yTm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IHNlcnZlckVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvbnN0cnVjdGVkIHRva2VuIHJlc3BvbnNlIGJhc2VkIG9uIGdpdmVuIHN0cmluZy4gQWxzbyBtYW5hZ2VzIHRoZSBjYWNoZSB1cGRhdGVzIGFuZCBjbGVhbnVwcy5cclxuICAgICAqIEBwYXJhbSBzZXJ2ZXJUb2tlblJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGhhbmRsZVNlcnZlclRva2VuUmVzcG9uc2Uoc2VydmVyVG9rZW5SZXNwb25zZSwgYXV0aG9yaXR5LCByZXFUaW1lc3RhbXAsIHJlcXVlc3QsIGF1dGhDb2RlUGF5bG9hZCwgdXNlckFzc2VydGlvbkhhc2gsIGhhbmRsaW5nUmVmcmVzaFRva2VuUmVzcG9uc2UsIGZvcmNlQ2FjaGVSZWZyZXNoVG9rZW5SZXNwb25zZSwgc2VydmVyUmVxdWVzdElkKSB7XHJcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChQZXJmb3JtYW5jZUV2ZW50cy5IYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlLCBzZXJ2ZXJUb2tlblJlc3BvbnNlLmNvcnJlbGF0aW9uX2lkKTtcclxuICAgICAgICAvLyBjcmVhdGUgYW4gaWRUb2tlbiBvYmplY3QgKG5vdCBlbnRpdHkpXHJcbiAgICAgICAgbGV0IGlkVG9rZW5DbGFpbXM7XHJcbiAgICAgICAgaWYgKHNlcnZlclRva2VuUmVzcG9uc2UuaWRfdG9rZW4pIHtcclxuICAgICAgICAgICAgaWRUb2tlbkNsYWltcyA9IGV4dHJhY3RUb2tlbkNsYWltcyhzZXJ2ZXJUb2tlblJlc3BvbnNlLmlkX3Rva2VuIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsIHRoaXMuY3J5cHRvT2JqLmJhc2U2NERlY29kZSk7XHJcbiAgICAgICAgICAgIC8vIHRva2VuIG5vbmNlIGNoZWNrIChUT0RPOiBBZGQgYSB3YXJuaW5nIGlmIG5vIG5vbmNlIGlzIGdpdmVuPylcclxuICAgICAgICAgICAgaWYgKGF1dGhDb2RlUGF5bG9hZCAmJiBhdXRoQ29kZVBheWxvYWQubm9uY2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZFRva2VuQ2xhaW1zLm5vbmNlICE9PSBhdXRoQ29kZVBheWxvYWQubm9uY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3Iobm9uY2VNaXNtYXRjaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdG9rZW4gbWF4X2FnZSBjaGVja1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5tYXhBZ2UgfHwgcmVxdWVzdC5tYXhBZ2UgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhUaW1lID0gaWRUb2tlbkNsYWltcy5hdXRoX3RpbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF1dGhUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGF1dGhUaW1lTm90Rm91bmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hlY2tNYXhBZ2UoYXV0aFRpbWUsIHJlcXVlc3QubWF4QWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBnZW5lcmF0ZSBob21lQWNjb3VudElkXHJcbiAgICAgICAgdGhpcy5ob21lQWNjb3VudElkZW50aWZpZXIgPSBBY2NvdW50RW50aXR5LmdlbmVyYXRlSG9tZUFjY291bnRJZChzZXJ2ZXJUb2tlblJlc3BvbnNlLmNsaWVudF9pbmZvIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsIGF1dGhvcml0eS5hdXRob3JpdHlUeXBlLCB0aGlzLmxvZ2dlciwgdGhpcy5jcnlwdG9PYmosIGlkVG9rZW5DbGFpbXMpO1xyXG4gICAgICAgIC8vIHNhdmUgdGhlIHJlc3BvbnNlIHRva2Vuc1xyXG4gICAgICAgIGxldCByZXF1ZXN0U3RhdGVPYmo7XHJcbiAgICAgICAgaWYgKCEhYXV0aENvZGVQYXlsb2FkICYmICEhYXV0aENvZGVQYXlsb2FkLnN0YXRlKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RTdGF0ZU9iaiA9IFByb3RvY29sVXRpbHMucGFyc2VSZXF1ZXN0U3RhdGUodGhpcy5jcnlwdG9PYmosIGF1dGhDb2RlUGF5bG9hZC5zdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBrZXlJZCBmcm9tIHJlcXVlc3QgdG8gc2VydmVyVG9rZW5SZXNwb25zZSBpZiBkZWZpbmVkXHJcbiAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZS5rZXlfaWQgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJUb2tlblJlc3BvbnNlLmtleV9pZCB8fCByZXF1ZXN0LnNzaEtpZCB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgY2FjaGVSZWNvcmQgPSB0aGlzLmdlbmVyYXRlQ2FjaGVSZWNvcmQoc2VydmVyVG9rZW5SZXNwb25zZSwgYXV0aG9yaXR5LCByZXFUaW1lc3RhbXAsIHJlcXVlc3QsIGlkVG9rZW5DbGFpbXMsIHVzZXJBc3NlcnRpb25IYXNoLCBhdXRoQ29kZVBheWxvYWQpO1xyXG4gICAgICAgIGxldCBjYWNoZUNvbnRleHQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2VQbHVnaW4gJiYgdGhpcy5zZXJpYWxpemFibGVDYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlBlcnNpc3RlbmNlIGVuYWJsZWQsIGNhbGxpbmcgYmVmb3JlQ2FjaGVBY2Nlc3NcIik7XHJcbiAgICAgICAgICAgICAgICBjYWNoZUNvbnRleHQgPSBuZXcgVG9rZW5DYWNoZUNvbnRleHQodGhpcy5zZXJpYWxpemFibGVDYWNoZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlUGx1Z2luLmJlZm9yZUNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogV2hlbiBzYXZpbmcgYSByZWZyZXNoZWQgdG9rZW5zIHRvIHRoZSBjYWNoZSwgaXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgYWNjb3VudCB0aGF0IHdhcyB1c2VkIGlzIHByZXNlbnQgaW4gdGhlIGNhY2hlLlxyXG4gICAgICAgICAgICAgKiBJZiBub3QgcHJlc2VudCwgd2Ugc2hvdWxkIHJldHVybiBudWxsLCBhcyBpdCdzIHRoZSBjYXNlIHRoYXQgYW5vdGhlciBhcHBsaWNhdGlvbiBjYWxsZWQgcmVtb3ZlQWNjb3VudCBpbiBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAqIHRoZSBjYWxscyB0byBnZXRBbGxBY2NvdW50cyBhbmQgYWNxdWlyZVRva2VuU2lsZW50LiBXZSBzaG91bGQgbm90IG92ZXJ3cml0ZSB0aGF0IHJlbW92YWwsIHVubGVzcyBleHBsaWNpdGx5IGZsYWdnZWQgYnlcclxuICAgICAgICAgICAgICogdGhlIGRldmVsb3BlciwgYXMgaW4gdGhlIGNhc2Ugb2YgcmVmcmVzaCB0b2tlbiBmbG93IHVzZWQgaW4gQURBTCBOb2RlIHRvIE1TQUwgTm9kZSBtaWdyYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxpbmdSZWZyZXNoVG9rZW5SZXNwb25zZSAmJlxyXG4gICAgICAgICAgICAgICAgIWZvcmNlQ2FjaGVSZWZyZXNoVG9rZW5SZXNwb25zZSAmJlxyXG4gICAgICAgICAgICAgICAgY2FjaGVSZWNvcmQuYWNjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2FjaGVSZWNvcmQuYWNjb3VudC5nZW5lcmF0ZUFjY291bnRLZXkoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB0aGlzLmNhY2hlU3RvcmFnZS5nZXRBY2NvdW50KGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuaW5nKFwiQWNjb3VudCB1c2VkIHRvIHJlZnJlc2ggdG9rZW5zIG5vdCBpbiBwZXJzaXN0ZW5jZSwgcmVmcmVzaGVkIHRva2VucyB3aWxsIG5vdCBiZSBzdG9yZWQgaW4gdGhlIGNhY2hlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBSZXNwb25zZUhhbmRsZXIuZ2VuZXJhdGVBdXRoZW50aWNhdGlvblJlc3VsdCh0aGlzLmNyeXB0b09iaiwgYXV0aG9yaXR5LCBjYWNoZVJlY29yZCwgZmFsc2UsIHJlcXVlc3QsIGlkVG9rZW5DbGFpbXMsIHJlcXVlc3RTdGF0ZU9iaiwgdW5kZWZpbmVkLCBzZXJ2ZXJSZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FjaGVTdG9yYWdlLnNhdmVDYWNoZVJlY29yZChjYWNoZVJlY29yZCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkLCByZXF1ZXN0LnN0b3JlSW5DYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZVBsdWdpbiAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemFibGVDYWNoZSAmJlxyXG4gICAgICAgICAgICAgICAgY2FjaGVDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiUGVyc2lzdGVuY2UgZW5hYmxlZCwgY2FsbGluZyBhZnRlckNhY2hlQWNjZXNzXCIpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZVBsdWdpbi5hZnRlckNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlc3BvbnNlSGFuZGxlci5nZW5lcmF0ZUF1dGhlbnRpY2F0aW9uUmVzdWx0KHRoaXMuY3J5cHRvT2JqLCBhdXRob3JpdHksIGNhY2hlUmVjb3JkLCBmYWxzZSwgcmVxdWVzdCwgaWRUb2tlbkNsYWltcywgcmVxdWVzdFN0YXRlT2JqLCBzZXJ2ZXJUb2tlblJlc3BvbnNlLCBzZXJ2ZXJSZXF1ZXN0SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgQ2FjaGVSZWNvcmRcclxuICAgICAqIEBwYXJhbSBzZXJ2ZXJUb2tlblJlc3BvbnNlXHJcbiAgICAgKiBAcGFyYW0gaWRUb2tlbk9ialxyXG4gICAgICogQHBhcmFtIGF1dGhvcml0eVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUNhY2hlUmVjb3JkKHNlcnZlclRva2VuUmVzcG9uc2UsIGF1dGhvcml0eSwgcmVxVGltZXN0YW1wLCByZXF1ZXN0LCBpZFRva2VuQ2xhaW1zLCB1c2VyQXNzZXJ0aW9uSGFzaCwgYXV0aENvZGVQYXlsb2FkKSB7XHJcbiAgICAgICAgY29uc3QgZW52ID0gYXV0aG9yaXR5LmdldFByZWZlcnJlZENhY2hlKCk7XHJcbiAgICAgICAgaWYgKCFlbnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGludmFsaWRDYWNoZUVudmlyb25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xhaW1zVGVuYW50SWQgPSBnZXRUZW5hbnRJZEZyb21JZFRva2VuQ2xhaW1zKGlkVG9rZW5DbGFpbXMpO1xyXG4gICAgICAgIC8vIElkVG9rZW46IG5vbiBBQUQgc2NlbmFyaW9zIGNhbiBoYXZlIGVtcHR5IHJlYWxtXHJcbiAgICAgICAgbGV0IGNhY2hlZElkVG9rZW47XHJcbiAgICAgICAgbGV0IGNhY2hlZEFjY291bnQ7XHJcbiAgICAgICAgaWYgKHNlcnZlclRva2VuUmVzcG9uc2UuaWRfdG9rZW4gJiYgISFpZFRva2VuQ2xhaW1zKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZElkVG9rZW4gPSBjcmVhdGVJZFRva2VuRW50aXR5KHRoaXMuaG9tZUFjY291bnRJZGVudGlmaWVyLCBlbnYsIHNlcnZlclRva2VuUmVzcG9uc2UuaWRfdG9rZW4sIHRoaXMuY2xpZW50SWQsIGNsYWltc1RlbmFudElkIHx8IFwiXCIpO1xyXG4gICAgICAgICAgICBjYWNoZWRBY2NvdW50ID0gYnVpbGRBY2NvdW50VG9DYWNoZSh0aGlzLmNhY2hlU3RvcmFnZSwgYXV0aG9yaXR5LCB0aGlzLmhvbWVBY2NvdW50SWRlbnRpZmllciwgdGhpcy5jcnlwdG9PYmouYmFzZTY0RGVjb2RlLCBpZFRva2VuQ2xhaW1zLCBzZXJ2ZXJUb2tlblJlc3BvbnNlLmNsaWVudF9pbmZvLCBlbnYsIGNsYWltc1RlbmFudElkLCBhdXRoQ29kZVBheWxvYWQsIHVuZGVmaW5lZCwgLy8gbmF0aXZlQWNjb3VudElkXHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWNjZXNzVG9rZW5cclxuICAgICAgICBsZXQgY2FjaGVkQWNjZXNzVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIGlmIChzZXJ2ZXJUb2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xyXG4gICAgICAgICAgICAvLyBJZiBzY29wZXMgbm90IHJldHVybmVkIGluIHNlcnZlciByZXNwb25zZSwgdXNlIHJlcXVlc3Qgc2NvcGVzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlU2NvcGVzID0gc2VydmVyVG9rZW5SZXNwb25zZS5zY29wZVxyXG4gICAgICAgICAgICAgICAgPyBTY29wZVNldC5mcm9tU3RyaW5nKHNlcnZlclRva2VuUmVzcG9uc2Uuc2NvcGUpXHJcbiAgICAgICAgICAgICAgICA6IG5ldyBTY29wZVNldChyZXF1ZXN0LnNjb3BlcyB8fCBbXSk7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFVzZSB0aW1lc3RhbXAgY2FsY3VsYXRlZCBiZWZvcmUgcmVxdWVzdFxyXG4gICAgICAgICAgICAgKiBTZXJ2ZXIgbWF5IHJldHVybiB0aW1lc3RhbXBzIGFzIHN0cmluZ3MsIHBhcnNlIHRvIG51bWJlcnMgaWYgc28uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb25zdCBleHBpcmVzSW4gPSAodHlwZW9mIHNlcnZlclRva2VuUmVzcG9uc2UuZXhwaXJlc19pbiA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICAgICAgPyBwYXJzZUludChzZXJ2ZXJUb2tlblJlc3BvbnNlLmV4cGlyZXNfaW4sIDEwKVxyXG4gICAgICAgICAgICAgICAgOiBzZXJ2ZXJUb2tlblJlc3BvbnNlLmV4cGlyZXNfaW4pIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dEV4cGlyZXNJbiA9ICh0eXBlb2Ygc2VydmVyVG9rZW5SZXNwb25zZS5leHRfZXhwaXJlc19pbiA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICAgICAgPyBwYXJzZUludChzZXJ2ZXJUb2tlblJlc3BvbnNlLmV4dF9leHBpcmVzX2luLCAxMClcclxuICAgICAgICAgICAgICAgIDogc2VydmVyVG9rZW5SZXNwb25zZS5leHRfZXhwaXJlc19pbikgfHwgMDtcclxuICAgICAgICAgICAgY29uc3QgcmVmcmVzaEluID0gKHR5cGVvZiBzZXJ2ZXJUb2tlblJlc3BvbnNlLnJlZnJlc2hfaW4gPT09IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX2luLCAxMClcclxuICAgICAgICAgICAgICAgIDogc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX2luKSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuRXhwaXJhdGlvblNlY29uZHMgPSByZXFUaW1lc3RhbXAgKyBleHBpcmVzSW47XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuZGVkVG9rZW5FeHBpcmF0aW9uU2Vjb25kcyA9IHRva2VuRXhwaXJhdGlvblNlY29uZHMgKyBleHRFeHBpcmVzSW47XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hPblNlY29uZHMgPSByZWZyZXNoSW4gJiYgcmVmcmVzaEluID4gMFxyXG4gICAgICAgICAgICAgICAgPyByZXFUaW1lc3RhbXAgKyByZWZyZXNoSW5cclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvLyBub24gQUFEIHNjZW5hcmlvcyBjYW4gaGF2ZSBlbXB0eSByZWFsbVxyXG4gICAgICAgICAgICBjYWNoZWRBY2Nlc3NUb2tlbiA9IGNyZWF0ZUFjY2Vzc1Rva2VuRW50aXR5KHRoaXMuaG9tZUFjY291bnRJZGVudGlmaWVyLCBlbnYsIHNlcnZlclRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuLCB0aGlzLmNsaWVudElkLCBjbGFpbXNUZW5hbnRJZCB8fCBhdXRob3JpdHkudGVuYW50IHx8IFwiXCIsIHJlc3BvbnNlU2NvcGVzLnByaW50U2NvcGVzKCksIHRva2VuRXhwaXJhdGlvblNlY29uZHMsIGV4dGVuZGVkVG9rZW5FeHBpcmF0aW9uU2Vjb25kcywgdGhpcy5jcnlwdG9PYmouYmFzZTY0RGVjb2RlLCByZWZyZXNoT25TZWNvbmRzLCBzZXJ2ZXJUb2tlblJlc3BvbnNlLnRva2VuX3R5cGUsIHVzZXJBc3NlcnRpb25IYXNoLCBzZXJ2ZXJUb2tlblJlc3BvbnNlLmtleV9pZCwgcmVxdWVzdC5jbGFpbXMsIHJlcXVlc3QucmVxdWVzdGVkQ2xhaW1zSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlZnJlc2hUb2tlblxyXG4gICAgICAgIGxldCBjYWNoZWRSZWZyZXNoVG9rZW4gPSBudWxsO1xyXG4gICAgICAgIGlmIChzZXJ2ZXJUb2tlblJlc3BvbnNlLnJlZnJlc2hfdG9rZW4pIHtcclxuICAgICAgICAgICAgbGV0IHJ0RXhwaXJlc09uO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX3Rva2VuX2V4cGlyZXNfaW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJ0RXhwaXJlc0luID0gdHlwZW9mIHNlcnZlclRva2VuUmVzcG9uc2UucmVmcmVzaF90b2tlbl9leHBpcmVzX2luID09PVxyXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICA/IHBhcnNlSW50KHNlcnZlclRva2VuUmVzcG9uc2UucmVmcmVzaF90b2tlbl9leHBpcmVzX2luLCAxMClcclxuICAgICAgICAgICAgICAgICAgICA6IHNlcnZlclRva2VuUmVzcG9uc2UucmVmcmVzaF90b2tlbl9leHBpcmVzX2luO1xyXG4gICAgICAgICAgICAgICAgcnRFeHBpcmVzT24gPSByZXFUaW1lc3RhbXAgKyBydEV4cGlyZXNJbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZWRSZWZyZXNoVG9rZW4gPSBjcmVhdGVSZWZyZXNoVG9rZW5FbnRpdHkodGhpcy5ob21lQWNjb3VudElkZW50aWZpZXIsIGVudiwgc2VydmVyVG9rZW5SZXNwb25zZS5yZWZyZXNoX3Rva2VuLCB0aGlzLmNsaWVudElkLCBzZXJ2ZXJUb2tlblJlc3BvbnNlLmZvY2ksIHVzZXJBc3NlcnRpb25IYXNoLCBydEV4cGlyZXNPbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcE1ldGFkYXRhXHJcbiAgICAgICAgbGV0IGNhY2hlZEFwcE1ldGFkYXRhID0gbnVsbDtcclxuICAgICAgICBpZiAoc2VydmVyVG9rZW5SZXNwb25zZS5mb2NpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZEFwcE1ldGFkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXHJcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudDogZW52LFxyXG4gICAgICAgICAgICAgICAgZmFtaWx5SWQ6IHNlcnZlclRva2VuUmVzcG9uc2UuZm9jaSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWNjb3VudDogY2FjaGVkQWNjb3VudCxcclxuICAgICAgICAgICAgaWRUb2tlbjogY2FjaGVkSWRUb2tlbixcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IGNhY2hlZEFjY2Vzc1Rva2VuLFxyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IGNhY2hlZFJlZnJlc2hUb2tlbixcclxuICAgICAgICAgICAgYXBwTWV0YWRhdGE6IGNhY2hlZEFwcE1ldGFkYXRhLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gQEF1dGhlbnRpY2F0aW9uUmVzdWx0IGZyb20gQENhY2hlUmVjb3JkICwgQElkVG9rZW4gLCBhbmQgYSBib29sZWFuIHRoYXQgc3RhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSByZXN1bHQgaXMgZnJvbSBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBPcHRpb25hbGx5IHRha2VzIGEgc3RhdGUgc3RyaW5nIHRoYXQgaXMgc2V0IGFzLWlzIGluIHRoZSByZXNwb25zZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FjaGVSZWNvcmRcclxuICAgICAqIEBwYXJhbSBpZFRva2VuT2JqXHJcbiAgICAgKiBAcGFyYW0gZnJvbVRva2VuQ2FjaGVcclxuICAgICAqIEBwYXJhbSBzdGF0ZVN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVBdXRoZW50aWNhdGlvblJlc3VsdChjcnlwdG9PYmosIGF1dGhvcml0eSwgY2FjaGVSZWNvcmQsIGZyb21Ub2tlbkNhY2hlLCByZXF1ZXN0LCBpZFRva2VuQ2xhaW1zLCByZXF1ZXN0U3RhdGUsIHNlcnZlclRva2VuUmVzcG9uc2UsIHJlcXVlc3RJZCkge1xyXG4gICAgICAgIGxldCBhY2Nlc3NUb2tlbiA9IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlU2NvcGVzID0gW107XHJcbiAgICAgICAgbGV0IGV4cGlyZXNPbiA9IG51bGw7XHJcbiAgICAgICAgbGV0IGV4dEV4cGlyZXNPbjtcclxuICAgICAgICBsZXQgcmVmcmVzaE9uO1xyXG4gICAgICAgIGxldCBmYW1pbHlJZCA9IENvbnN0YW50cy5FTVBUWV9TVFJJTkc7XHJcbiAgICAgICAgaWYgKGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIGlmIHRoZSByZXF1ZXN0IG9iamVjdCBoYXMgYHBvcEtpZGAgcHJvcGVydHksIGBzaWduUG9wVG9rZW5gIHdpbGwgYmUgc2V0IHRvIGZhbHNlIGFuZFxyXG4gICAgICAgICAgICAgKiB0aGUgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCB1bnNpZ25lZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLnRva2VuVHlwZSA9PT1cclxuICAgICAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLlBPUCAmJlxyXG4gICAgICAgICAgICAgICAgIXJlcXVlc3QucG9wS2lkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3BUb2tlbkdlbmVyYXRvciA9IG5ldyBQb3BUb2tlbkdlbmVyYXRvcihjcnlwdG9PYmopO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWNyZXQsIGtleUlkIH0gPSBjYWNoZVJlY29yZC5hY2Nlc3NUb2tlbjtcclxuICAgICAgICAgICAgICAgIGlmICgha2V5SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3Ioa2V5SWRNaXNzaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gYXdhaXQgcG9wVG9rZW5HZW5lcmF0b3Iuc2lnblBvcFRva2VuKHNlY3JldCwga2V5SWQsIHJlcXVlc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBjYWNoZVJlY29yZC5hY2Nlc3NUb2tlbi5zZWNyZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzcG9uc2VTY29wZXMgPSBTY29wZVNldC5mcm9tU3RyaW5nKGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLnRhcmdldCkuYXNBcnJheSgpO1xyXG4gICAgICAgICAgICAvLyBBY2Nlc3MgdG9rZW4gZXhwaXJlc09uIGNhY2hlZCBpbiBzZWNvbmRzLCBjb252ZXJ0aW5nIHRvIERhdGUgZm9yIEF1dGhlbnRpY2F0aW9uUmVzdWx0XHJcbiAgICAgICAgICAgIGV4cGlyZXNPbiA9IHRvRGF0ZUZyb21TZWNvbmRzKGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLmV4cGlyZXNPbik7XHJcbiAgICAgICAgICAgIGV4dEV4cGlyZXNPbiA9IHRvRGF0ZUZyb21TZWNvbmRzKGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLmV4dGVuZGVkRXhwaXJlc09uKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlUmVjb3JkLmFjY2Vzc1Rva2VuLnJlZnJlc2hPbikge1xyXG4gICAgICAgICAgICAgICAgcmVmcmVzaE9uID0gdG9EYXRlRnJvbVNlY29uZHMoY2FjaGVSZWNvcmQuYWNjZXNzVG9rZW4ucmVmcmVzaE9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FjaGVSZWNvcmQuYXBwTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgZmFtaWx5SWQgPVxyXG4gICAgICAgICAgICAgICAgY2FjaGVSZWNvcmQuYXBwTWV0YWRhdGEuZmFtaWx5SWQgPT09IFRIRV9GQU1JTFlfSURcclxuICAgICAgICAgICAgICAgICAgICA/IFRIRV9GQU1JTFlfSURcclxuICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVpZCA9IGlkVG9rZW5DbGFpbXM/Lm9pZCB8fCBpZFRva2VuQ2xhaW1zPy5zdWIgfHwgXCJcIjtcclxuICAgICAgICBjb25zdCB0aWQgPSBpZFRva2VuQ2xhaW1zPy50aWQgfHwgXCJcIjtcclxuICAgICAgICAvLyBmb3IgaHlicmlkICsgbmF0aXZlIGJyaWRnZSBlbmFibGVtZW50LCBzZW5kIGJhY2sgdGhlIG5hdGl2ZSBhY2NvdW50IElkXHJcbiAgICAgICAgaWYgKHNlcnZlclRva2VuUmVzcG9uc2U/LnNwYV9hY2NvdW50aWQgJiYgISFjYWNoZVJlY29yZC5hY2NvdW50KSB7XHJcbiAgICAgICAgICAgIGNhY2hlUmVjb3JkLmFjY291bnQubmF0aXZlQWNjb3VudElkID1cclxuICAgICAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2U/LnNwYV9hY2NvdW50aWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjY291bnRJbmZvID0gY2FjaGVSZWNvcmQuYWNjb3VudFxyXG4gICAgICAgICAgICA/IHVwZGF0ZUFjY291bnRUZW5hbnRQcm9maWxlRGF0YShjYWNoZVJlY29yZC5hY2NvdW50LmdldEFjY291bnRJbmZvKCksIHVuZGVmaW5lZCwgLy8gdGVuYW50UHJvZmlsZSBvcHRpb25hbFxyXG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zLCBjYWNoZVJlY29yZC5pZFRva2VuPy5zZWNyZXQpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhdXRob3JpdHk6IGF1dGhvcml0eS5jYW5vbmljYWxBdXRob3JpdHksXHJcbiAgICAgICAgICAgIHVuaXF1ZUlkOiB1aWQsXHJcbiAgICAgICAgICAgIHRlbmFudElkOiB0aWQsXHJcbiAgICAgICAgICAgIHNjb3BlczogcmVzcG9uc2VTY29wZXMsXHJcbiAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnRJbmZvLFxyXG4gICAgICAgICAgICBpZFRva2VuOiBjYWNoZVJlY29yZD8uaWRUb2tlbj8uc2VjcmV0IHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXM6IGlkVG9rZW5DbGFpbXMgfHwge30sXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBhY2Nlc3NUb2tlbixcclxuICAgICAgICAgICAgZnJvbUNhY2hlOiBmcm9tVG9rZW5DYWNoZSxcclxuICAgICAgICAgICAgZXhwaXJlc09uOiBleHBpcmVzT24sXHJcbiAgICAgICAgICAgIGV4dEV4cGlyZXNPbjogZXh0RXhwaXJlc09uLFxyXG4gICAgICAgICAgICByZWZyZXNoT246IHJlZnJlc2hPbixcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgICAgICBmYW1pbHlJZDogZmFtaWx5SWQsXHJcbiAgICAgICAgICAgIHRva2VuVHlwZTogY2FjaGVSZWNvcmQuYWNjZXNzVG9rZW4/LnRva2VuVHlwZSB8fCBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgICAgICBzdGF0ZTogcmVxdWVzdFN0YXRlXHJcbiAgICAgICAgICAgICAgICA/IHJlcXVlc3RTdGF0ZS51c2VyUmVxdWVzdFN0YXRlXHJcbiAgICAgICAgICAgICAgICA6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICAgICAgICAgIGNsb3VkR3JhcGhIb3N0TmFtZTogY2FjaGVSZWNvcmQuYWNjb3VudD8uY2xvdWRHcmFwaEhvc3ROYW1lIHx8XHJcbiAgICAgICAgICAgICAgICBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgICAgICBtc0dyYXBoSG9zdDogY2FjaGVSZWNvcmQuYWNjb3VudD8ubXNHcmFwaEhvc3QgfHwgQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgICAgICAgICAgY29kZTogc2VydmVyVG9rZW5SZXNwb25zZT8uc3BhX2NvZGUsXHJcbiAgICAgICAgICAgIGZyb21OYXRpdmVCcm9rZXI6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRBY2NvdW50VG9DYWNoZShjYWNoZVN0b3JhZ2UsIGF1dGhvcml0eSwgaG9tZUFjY291bnRJZCwgYmFzZTY0RGVjb2RlLCBpZFRva2VuQ2xhaW1zLCBjbGllbnRJbmZvLCBlbnZpcm9ubWVudCwgY2xhaW1zVGVuYW50SWQsIGF1dGhDb2RlUGF5bG9hZCwgbmF0aXZlQWNjb3VudElkLCBsb2dnZXIpIHtcclxuICAgIGxvZ2dlcj8udmVyYm9zZShcInNldENhY2hlZEFjY291bnQgY2FsbGVkXCIpO1xyXG4gICAgLy8gQ2hlY2sgaWYgYmFzZSBhY2NvdW50IGlzIGFscmVhZHkgY2FjaGVkXHJcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IGNhY2hlU3RvcmFnZS5nZXRBY2NvdW50S2V5cygpO1xyXG4gICAgY29uc3QgYmFzZUFjY291bnRLZXkgPSBhY2NvdW50S2V5cy5maW5kKChhY2NvdW50S2V5KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGFjY291bnRLZXkuc3RhcnRzV2l0aChob21lQWNjb3VudElkKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IGNhY2hlZEFjY291bnQgPSBudWxsO1xyXG4gICAgaWYgKGJhc2VBY2NvdW50S2V5KSB7XHJcbiAgICAgICAgY2FjaGVkQWNjb3VudCA9IGNhY2hlU3RvcmFnZS5nZXRBY2NvdW50KGJhc2VBY2NvdW50S2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGJhc2VBY2NvdW50ID0gY2FjaGVkQWNjb3VudCB8fFxyXG4gICAgICAgIEFjY291bnRFbnRpdHkuY3JlYXRlQWNjb3VudCh7XHJcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMsXHJcbiAgICAgICAgICAgIGNsaWVudEluZm8sXHJcbiAgICAgICAgICAgIGVudmlyb25tZW50LFxyXG4gICAgICAgICAgICBjbG91ZEdyYXBoSG9zdE5hbWU6IGF1dGhDb2RlUGF5bG9hZD8uY2xvdWRfZ3JhcGhfaG9zdF9uYW1lLFxyXG4gICAgICAgICAgICBtc0dyYXBoSG9zdDogYXV0aENvZGVQYXlsb2FkPy5tc2dyYXBoX2hvc3QsXHJcbiAgICAgICAgICAgIG5hdGl2ZUFjY291bnRJZDogbmF0aXZlQWNjb3VudElkLFxyXG4gICAgICAgIH0sIGF1dGhvcml0eSwgYmFzZTY0RGVjb2RlKTtcclxuICAgIGNvbnN0IHRlbmFudFByb2ZpbGVzID0gYmFzZUFjY291bnQudGVuYW50UHJvZmlsZXMgfHwgW107XHJcbiAgICBjb25zdCB0ZW5hbnRJZCA9IGNsYWltc1RlbmFudElkIHx8IGJhc2VBY2NvdW50LnJlYWxtO1xyXG4gICAgaWYgKHRlbmFudElkICYmXHJcbiAgICAgICAgIXRlbmFudFByb2ZpbGVzLmZpbmQoKHRlbmFudFByb2ZpbGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbmFudFByb2ZpbGUudGVuYW50SWQgPT09IHRlbmFudElkO1xyXG4gICAgICAgIH0pKSB7XHJcbiAgICAgICAgY29uc3QgbmV3VGVuYW50UHJvZmlsZSA9IGJ1aWxkVGVuYW50UHJvZmlsZShob21lQWNjb3VudElkLCBiYXNlQWNjb3VudC5sb2NhbEFjY291bnRJZCwgdGVuYW50SWQsIGlkVG9rZW5DbGFpbXMpO1xyXG4gICAgICAgIHRlbmFudFByb2ZpbGVzLnB1c2gobmV3VGVuYW50UHJvZmlsZSk7XHJcbiAgICB9XHJcbiAgICBiYXNlQWNjb3VudC50ZW5hbnRQcm9maWxlcyA9IHRlbmFudFByb2ZpbGVzO1xyXG4gICAgcmV0dXJuIGJhc2VBY2NvdW50O1xyXG59XG5cbmV4cG9ydCB7IFJlc3BvbnNlSGFuZGxlciwgYnVpbGRBY2NvdW50VG9DYWNoZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzcG9uc2VIYW5kbGVyLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3IubWpzJztcbmltcG9ydCB7IENvZGVDaGFsbGVuZ2VNZXRob2RWYWx1ZXMsIFByb21wdFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyByZWRpcmVjdFVyaUVtcHR5LCBpbnZhbGlkUHJvbXB0VmFsdWUsIGludmFsaWRDbGFpbXMsIHBrY2VQYXJhbXNNaXNzaW5nLCBpbnZhbGlkQ29kZUNoYWxsZW5nZU1ldGhvZCB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVmFsaWRhdGVzIHNlcnZlciBjb25zdW1hYmxlIHBhcmFtcyBmcm9tIHRoZSBcInJlcXVlc3RcIiBvYmplY3RzXHJcbiAqL1xyXG5jbGFzcyBSZXF1ZXN0VmFsaWRhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogVXRpbGl0eSB0byBjaGVjayBpZiB0aGUgYHJlZGlyZWN0VXJpYCBpbiB0aGUgcmVxdWVzdCBpcyBhIG5vbi1udWxsIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gcmVkaXJlY3RVcmlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHZhbGlkYXRlUmVkaXJlY3RVcmkocmVkaXJlY3RVcmkpIHtcclxuICAgICAgICBpZiAoIXJlZGlyZWN0VXJpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihyZWRpcmVjdFVyaUVtcHR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFV0aWxpdHkgdG8gdmFsaWRhdGUgcHJvbXB0IHNlbnQgYnkgdGhlIHVzZXIgaW4gdGhlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSBwcm9tcHRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHZhbGlkYXRlUHJvbXB0KHByb21wdCkge1xyXG4gICAgICAgIGNvbnN0IHByb21wdFZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgaW4gUHJvbXB0VmFsdWUpIHtcclxuICAgICAgICAgICAgcHJvbXB0VmFsdWVzLnB1c2goUHJvbXB0VmFsdWVbdmFsdWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb21wdFZhbHVlcy5pbmRleE9mKHByb21wdCkgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihpbnZhbGlkUHJvbXB0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyB2YWxpZGF0ZUNsYWltcyhjbGFpbXMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBKU09OLnBhcnNlKGNsYWltcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvcihpbnZhbGlkQ2xhaW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFV0aWxpdHkgdG8gdmFsaWRhdGUgY29kZV9jaGFsbGVuZ2UgYW5kIGNvZGVfY2hhbGxlbmdlX21ldGhvZFxyXG4gICAgICogQHBhcmFtIGNvZGVDaGFsbGVuZ2VcclxuICAgICAqIEBwYXJhbSBjb2RlQ2hhbGxlbmdlTWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB2YWxpZGF0ZUNvZGVDaGFsbGVuZ2VQYXJhbXMoY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZCkge1xyXG4gICAgICAgIGlmICghY29kZUNoYWxsZW5nZSB8fCAhY29kZUNoYWxsZW5nZU1ldGhvZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IocGtjZVBhcmFtc01pc3NpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvZGVDaGFsbGVuZ2VNZXRob2QoY29kZUNoYWxsZW5nZU1ldGhvZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVdGlsaXR5IHRvIHZhbGlkYXRlIGNvZGVfY2hhbGxlbmdlX21ldGhvZFxyXG4gICAgICogQHBhcmFtIGNvZGVDaGFsbGVuZ2VNZXRob2RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHZhbGlkYXRlQ29kZUNoYWxsZW5nZU1ldGhvZChjb2RlQ2hhbGxlbmdlTWV0aG9kKSB7XHJcbiAgICAgICAgaWYgKFtcclxuICAgICAgICAgICAgQ29kZUNoYWxsZW5nZU1ldGhvZFZhbHVlcy5QTEFJTixcclxuICAgICAgICAgICAgQ29kZUNoYWxsZW5nZU1ldGhvZFZhbHVlcy5TMjU2LFxyXG4gICAgICAgIF0uaW5kZXhPZihjb2RlQ2hhbGxlbmdlTWV0aG9kKSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKGludmFsaWRDb2RlQ2hhbGxlbmdlTWV0aG9kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgUmVxdWVzdFZhbGlkYXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVxdWVzdFZhbGlkYXRvci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtY29tbW9uIHYxNS43LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldENsaWVudEFzc2VydGlvbihjbGllbnRBc3NlcnRpb24sIGNsaWVudElkLCB0b2tlbkVuZHBvaW50KSB7XHJcbiAgICBpZiAodHlwZW9mIGNsaWVudEFzc2VydGlvbiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb247XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIGNsaWVudElkOiBjbGllbnRJZCxcclxuICAgICAgICAgICAgdG9rZW5FbmRwb2ludDogdG9rZW5FbmRwb2ludCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb24oY29uZmlnKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBnZXRDbGllbnRBc3NlcnRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsaWVudEFzc2VydGlvblV0aWxzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBCYXNlQ2xpZW50IH0gZnJvbSAnLi9CYXNlQ2xpZW50Lm1qcyc7XG5pbXBvcnQgeyBhZGRDbGllbnRJZCwgYWRkUmVkaXJlY3RVcmksIGFkZFNjb3BlcywgYWRkQXV0aG9yaXphdGlvbkNvZGUsIGFkZExpYnJhcnlJbmZvLCBhZGRBcHBsaWNhdGlvblRlbGVtZXRyeSwgYWRkVGhyb3R0bGluZywgYWRkU2VydmVyVGVsZW1ldHJ5LCBhZGRDb2RlVmVyaWZpZXIsIGFkZENsaWVudFNlY3JldCwgYWRkQ2xpZW50QXNzZXJ0aW9uLCBhZGRDbGllbnRBc3NlcnRpb25UeXBlLCBhZGRHcmFudFR5cGUsIGFkZENsaWVudEluZm8sIGFkZFBvcFRva2VuLCBhZGRTc2hKd2ssIGFkZENsYWltcywgYWRkQ2NzVXBuLCBhZGRDY3NPaWQsIGFkZEJyb2tlclBhcmFtZXRlcnMsIGFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzLCBpbnN0cnVtZW50QnJva2VyUGFyYW1zLCBhZGRQb3N0TG9nb3V0UmVkaXJlY3RVcmksIGFkZENvcnJlbGF0aW9uSWQsIGFkZElkVG9rZW5IaW50LCBhZGRTdGF0ZSwgYWRkTG9nb3V0SGludCwgYWRkSW5zdGFuY2VBd2FyZSB9IGZyb20gJy4uL3JlcXVlc3QvUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIubWpzJztcbmltcG9ydCB7IG1hcFRvUXVlcnlTdHJpbmcgfSBmcm9tICcuLi91dGlscy9VcmxVdGlscy5tanMnO1xuaW1wb3J0IHsgU2VwYXJhdG9ycywgR3JhbnRUeXBlLCBBdXRoZW50aWNhdGlvblNjaGVtZSwgSGVhZGVyTmFtZXMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IENMSUVOVF9JRCwgUkVUVVJOX1NQQV9DT0RFIH0gZnJvbSAnLi4vY29uc3RhbnRzL0FBRFNlcnZlclBhcmFtS2V5cy5tanMnO1xuaW1wb3J0IHsgaXNPaWRjUHJvdG9jb2xNb2RlIH0gZnJvbSAnLi4vY29uZmlnL0NsaWVudENvbmZpZ3VyYXRpb24ubWpzJztcbmltcG9ydCB7IFJlc3BvbnNlSGFuZGxlciB9IGZyb20gJy4uL3Jlc3BvbnNlL1Jlc3BvbnNlSGFuZGxlci5tanMnO1xuaW1wb3J0IHsgU3RyaW5nVXRpbHMgfSBmcm9tICcuLi91dGlscy9TdHJpbmdVdGlscy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50QXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyBVcmxTdHJpbmcgfSBmcm9tICcuLi91cmwvVXJsU3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBQb3BUb2tlbkdlbmVyYXRvciB9IGZyb20gJy4uL2NyeXB0by9Qb3BUb2tlbkdlbmVyYXRvci5tanMnO1xuaW1wb3J0IHsgbm93U2Vjb25kcyB9IGZyb20gJy4uL3V0aWxzL1RpbWVVdGlscy5tanMnO1xuaW1wb3J0IHsgYnVpbGRDbGllbnRJbmZvLCBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZCB9IGZyb20gJy4uL2FjY291bnQvQ2xpZW50SW5mby5tanMnO1xuaW1wb3J0IHsgQ2NzQ3JlZGVudGlhbFR5cGUgfSBmcm9tICcuLi9hY2NvdW50L0Njc0NyZWRlbnRpYWwubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvci5tanMnO1xuaW1wb3J0IHsgUmVxdWVzdFZhbGlkYXRvciB9IGZyb20gJy4uL3JlcXVlc3QvUmVxdWVzdFZhbGlkYXRvci5tanMnO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VFdmVudHMgfSBmcm9tICcuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC5tanMnO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMgfSBmcm9tICcuLi91dGlscy9GdW5jdGlvbldyYXBwZXJzLm1qcyc7XG5pbXBvcnQgeyBnZXRDbGllbnRBc3NlcnRpb24gfSBmcm9tICcuLi91dGlscy9DbGllbnRBc3NlcnRpb25VdGlscy5tanMnO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdFRodW1icHJpbnQgfSBmcm9tICcuLi9uZXR3b3JrL1JlcXVlc3RUaHVtYnByaW50Lm1qcyc7XG5pbXBvcnQgeyByZXF1ZXN0Q2Fubm90QmVNYWRlIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yQ29kZXMubWpzJztcbmltcG9ydCB7IGxvZ291dFJlcXVlc3RFbXB0eSwgbWlzc2luZ1NzaEp3ayB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogT2F1dGgyLjAgQXV0aG9yaXphdGlvbiBDb2RlIGNsaWVudFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEF1dGhvcml6YXRpb25Db2RlQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBwZXJmb3JtYW5jZUNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb24sIHBlcmZvcm1hbmNlQ2xpZW50KTtcclxuICAgICAgICAvLyBGbGFnIHRvIGluZGljYXRlIGlmIGNsaWVudCBpcyBmb3IgaHlicmlkIHNwYSBhdXRoIGNvZGUgcmVkZW1wdGlvblxyXG4gICAgICAgIHRoaXMuaW5jbHVkZVJlZGlyZWN0VXJpID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm9pZGNEZWZhdWx0U2NvcGVzID1cclxuICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuYXV0aG9yaXR5Lm9wdGlvbnMuT0lEQ09wdGlvbnM/LmRlZmF1bHRTY29wZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFQSSB0byBhY3F1aXJlIGEgdG9rZW4gaW4gZXhjaGFuZ2Ugb2YgJ2F1dGhvcml6YXRpb25fY29kZWAgYWNxdWlyZWQgYnkgdGhlIHVzZXIgaW4gdGhlIGZpcnN0IGxlZyBvZiB0aGVcclxuICAgICAqIGF1dGhvcml6YXRpb25fY29kZV9ncmFudFxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuKHJlcXVlc3QsIGF1dGhDb2RlUGF5bG9hZCkge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuQXV0aENsaWVudEFjcXVpcmVUb2tlbiwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBpZiAoIXJlcXVlc3QuY29kZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IocmVxdWVzdENhbm5vdEJlTWFkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcVRpbWVzdGFtcCA9IG5vd1NlY29uZHMoKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMuZXhlY3V0ZVRva2VuUmVxdWVzdC5iaW5kKHRoaXMpLCBQZXJmb3JtYW5jZUV2ZW50cy5BdXRoQ2xpZW50RXhlY3V0ZVRva2VuUmVxdWVzdCwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkodGhpcy5hdXRob3JpdHksIHJlcXVlc3QpO1xyXG4gICAgICAgIC8vIFJldHJpZXZlIHJlcXVlc3RJZCBmcm9tIHJlc3BvbnNlIGhlYWRlcnNcclxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXNwb25zZS5oZWFkZXJzPy5bSGVhZGVyTmFtZXMuWF9NU19SRVFVRVNUX0lEXTtcclxuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSBuZXcgUmVzcG9uc2VIYW5kbGVyKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCB0aGlzLmNhY2hlTWFuYWdlciwgdGhpcy5jcnlwdG9VdGlscywgdGhpcy5sb2dnZXIsIHRoaXMuY29uZmlnLnNlcmlhbGl6YWJsZUNhY2hlLCB0aGlzLmNvbmZpZy5wZXJzaXN0ZW5jZVBsdWdpbiwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCk7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVzcG9uc2UuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIGEgc2VydmVyIGVycm9yIGlmIGFuIGVycm9yIGlzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnZhbGlkYXRlVG9rZW5SZXNwb25zZShyZXNwb25zZS5ib2R5KTtcclxuICAgICAgICByZXR1cm4gaW52b2tlQXN5bmMocmVzcG9uc2VIYW5kbGVyLmhhbmRsZVNlcnZlclRva2VuUmVzcG9uc2UuYmluZChyZXNwb25zZUhhbmRsZXIpLCBQZXJmb3JtYW5jZUV2ZW50cy5IYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlLCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKShyZXNwb25zZS5ib2R5LCB0aGlzLmF1dGhvcml0eSwgcmVxVGltZXN0YW1wLCByZXF1ZXN0LCBhdXRoQ29kZVBheWxvYWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHJlcXVlc3RJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gbG9nIG91dCB0aGUgY3VycmVudCB1c2VyLCBhbmQgcmVkaXJlY3QgdGhlIHVzZXIgdG8gdGhlIHBvc3RMb2dvdXRSZWRpcmVjdFVyaS5cclxuICAgICAqIERlZmF1bHQgYmVoYXZpb3VyIGlzIHRvIHJlZGlyZWN0IHRoZSB1c2VyIHRvIGB3aW5kb3cubG9jYXRpb24uaHJlZmAuXHJcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5VXJpXHJcbiAgICAgKi9cclxuICAgIGdldExvZ291dFVyaShsb2dvdXRSZXF1ZXN0KSB7XHJcbiAgICAgICAgLy8gVGhyb3cgZXJyb3IgaWYgbG9nb3V0UmVxdWVzdCBpcyBudWxsL3VuZGVmaW5lZFxyXG4gICAgICAgIGlmICghbG9nb3V0UmVxdWVzdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IobG9nb3V0UmVxdWVzdEVtcHR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSB0aGlzLmNyZWF0ZUxvZ291dFVybFF1ZXJ5U3RyaW5nKGxvZ291dFJlcXVlc3QpO1xyXG4gICAgICAgIC8vIENvbnN0cnVjdCBsb2dvdXQgVVJJXHJcbiAgICAgICAgcmV0dXJuIFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyh0aGlzLmF1dGhvcml0eS5lbmRTZXNzaW9uRW5kcG9pbnQsIHF1ZXJ5U3RyaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgUE9TVCByZXF1ZXN0IHRvIHRva2VuIGVuZHBvaW50XHJcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBleGVjdXRlVG9rZW5SZXF1ZXN0KGF1dGhvcml0eSwgcmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuQXV0aENsaWVudEV4ZWN1dGVUb2tlblJlcXVlc3QsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5jcmVhdGVUb2tlblF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBlbmRwb2ludCA9IFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyhhdXRob3JpdHkudG9rZW5FbmRwb2ludCwgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keS5iaW5kKHRoaXMpLCBQZXJmb3JtYW5jZUV2ZW50cy5BdXRoQ2xpZW50Q3JlYXRlVG9rZW5SZXF1ZXN0Qm9keSwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkocmVxdWVzdCk7XHJcbiAgICAgICAgbGV0IGNjc0NyZWRlbnRpYWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QuY2xpZW50SW5mbykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGJ1aWxkQ2xpZW50SW5mbyhyZXF1ZXN0LmNsaWVudEluZm8sIHRoaXMuY3J5cHRvVXRpbHMuYmFzZTY0RGVjb2RlKTtcclxuICAgICAgICAgICAgICAgIGNjc0NyZWRlbnRpYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbDogYCR7Y2xpZW50SW5mby51aWR9JHtTZXBhcmF0b3JzLkNMSUVOVF9JTkZPX1NFUEFSQVRPUn0ke2NsaWVudEluZm8udXRpZH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IENjc0NyZWRlbnRpYWxUeXBlLkhPTUVfQUNDT1VOVF9JRCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJDb3VsZCBub3QgcGFyc2UgY2xpZW50IGluZm8gZm9yIENDUyBIZWFkZXI6IFwiICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0SGVhZGVycyhjY3NDcmVkZW50aWFsIHx8IHJlcXVlc3QuY2NzQ3JlZGVudGlhbCk7XHJcbiAgICAgICAgY29uc3QgdGh1bWJwcmludCA9IGdldFJlcXVlc3RUaHVtYnByaW50KHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCByZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4gaW52b2tlQXN5bmModGhpcy5leGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludC5iaW5kKHRoaXMpLCBQZXJmb3JtYW5jZUV2ZW50cy5BdXRob3JpemF0aW9uQ29kZUNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50LCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKShlbmRwb2ludCwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHRodW1icHJpbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCwgUGVyZm9ybWFuY2VFdmVudHMuQXV0aG9yaXphdGlvbkNvZGVDbGllbnRFeGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIG1hcCBmb3IgYWxsIHRoZSBwYXJhbXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmljZVxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChQZXJmb3JtYW5jZUV2ZW50cy5BdXRoQ2xpZW50Q3JlYXRlVG9rZW5SZXF1ZXN0Qm9keSwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGFkZENsaWVudElkKHBhcmFtZXRlcnMsIHJlcXVlc3QuZW1iZWRkZWRDbGllbnRJZCB8fFxyXG4gICAgICAgICAgICByZXF1ZXN0LnRva2VuQm9keVBhcmFtZXRlcnM/LltDTElFTlRfSURdIHx8XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEZvciBoeWJyaWQgc3BhIGZsb3csIHRoZXJlIHdpbGwgYmUgYSBjb2RlIGJ1dCBubyB2ZXJpZmllclxyXG4gICAgICAgICAqIEluIHRoaXMgc2NlbmFyaW8sIGRvbid0IGluY2x1ZGUgcmVkaXJlY3QgdXJpIGFzIGF1dGggY29kZSB3aWxsIG5vdCBiZSBib3VuZCB0byByZWRpcmVjdCBVUklcclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZVJlZGlyZWN0VXJpKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgdmFsaWRhdGVcclxuICAgICAgICAgICAgUmVxdWVzdFZhbGlkYXRvci52YWxpZGF0ZVJlZGlyZWN0VXJpKHJlcXVlc3QucmVkaXJlY3RVcmkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgYW5kIGluY2x1ZGUgcmVkaXJlY3QgdXJpXHJcbiAgICAgICAgICAgIGFkZFJlZGlyZWN0VXJpKHBhcmFtZXRlcnMsIHJlcXVlc3QucmVkaXJlY3RVcmkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgc2NvcGUgYXJyYXksIHBhcmFtZXRlciBidWlsZGVyIHdpbGwgYWRkIGRlZmF1bHQgc2NvcGVzIGFuZCBkZWR1cGVcclxuICAgICAgICBhZGRTY29wZXMocGFyYW1ldGVycywgcmVxdWVzdC5zY29wZXMsIHRydWUsIHRoaXMub2lkY0RlZmF1bHRTY29wZXMpO1xyXG4gICAgICAgIC8vIGFkZCBjb2RlOiB1c2VyIHNldCwgbm90IHZhbGlkYXRlZFxyXG4gICAgICAgIGFkZEF1dGhvcml6YXRpb25Db2RlKHBhcmFtZXRlcnMsIHJlcXVlc3QuY29kZSk7XHJcbiAgICAgICAgLy8gQWRkIGxpYnJhcnkgbWV0YWRhdGFcclxuICAgICAgICBhZGRMaWJyYXJ5SW5mbyhwYXJhbWV0ZXJzLCB0aGlzLmNvbmZpZy5saWJyYXJ5SW5mbyk7XHJcbiAgICAgICAgYWRkQXBwbGljYXRpb25UZWxlbWV0cnkocGFyYW1ldGVycywgdGhpcy5jb25maWcudGVsZW1ldHJ5LmFwcGxpY2F0aW9uKTtcclxuICAgICAgICBhZGRUaHJvdHRsaW5nKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIgJiYgIWlzT2lkY1Byb3RvY29sTW9kZSh0aGlzLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgYWRkU2VydmVyVGVsZW1ldHJ5KHBhcmFtZXRlcnMsIHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCBjb2RlX3ZlcmlmaWVyIGlmIHBhc3NlZFxyXG4gICAgICAgIGlmIChyZXF1ZXN0LmNvZGVWZXJpZmllcikge1xyXG4gICAgICAgICAgICBhZGRDb2RlVmVyaWZpZXIocGFyYW1ldGVycywgcmVxdWVzdC5jb2RlVmVyaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KSB7XHJcbiAgICAgICAgICAgIGFkZENsaWVudFNlY3JldChwYXJhbWV0ZXJzLCB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50QXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEFzc2VydGlvbiA9IHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudEFzc2VydGlvbjtcclxuICAgICAgICAgICAgYWRkQ2xpZW50QXNzZXJ0aW9uKHBhcmFtZXRlcnMsIGF3YWl0IGdldENsaWVudEFzc2VydGlvbihjbGllbnRBc3NlcnRpb24uYXNzZXJ0aW9uLCB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCwgcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RVcmkpKTtcclxuICAgICAgICAgICAgYWRkQ2xpZW50QXNzZXJ0aW9uVHlwZShwYXJhbWV0ZXJzLCBjbGllbnRBc3NlcnRpb24uYXNzZXJ0aW9uVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZEdyYW50VHlwZShwYXJhbWV0ZXJzLCBHcmFudFR5cGUuQVVUSE9SSVpBVElPTl9DT0RFX0dSQU5UKTtcclxuICAgICAgICBhZGRDbGllbnRJbmZvKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lID09PSBBdXRoZW50aWNhdGlvblNjaGVtZS5QT1ApIHtcclxuICAgICAgICAgICAgY29uc3QgcG9wVG9rZW5HZW5lcmF0b3IgPSBuZXcgUG9wVG9rZW5HZW5lcmF0b3IodGhpcy5jcnlwdG9VdGlscywgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCk7XHJcbiAgICAgICAgICAgIGxldCByZXFDbmZEYXRhO1xyXG4gICAgICAgICAgICBpZiAoIXJlcXVlc3QucG9wS2lkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRSZXFDbmZEYXRhID0gYXdhaXQgaW52b2tlQXN5bmMocG9wVG9rZW5HZW5lcmF0b3IuZ2VuZXJhdGVDbmYuYmluZChwb3BUb2tlbkdlbmVyYXRvciksIFBlcmZvcm1hbmNlRXZlbnRzLlBvcFRva2VuR2VuZXJhdGVDbmYsIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpKHJlcXVlc3QsIHRoaXMubG9nZ2VyKTtcclxuICAgICAgICAgICAgICAgIHJlcUNuZkRhdGEgPSBnZW5lcmF0ZWRSZXFDbmZEYXRhLnJlcUNuZlN0cmluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlcUNuZkRhdGEgPSB0aGlzLmNyeXB0b1V0aWxzLmVuY29kZUtpZChyZXF1ZXN0LnBvcEtpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU1BBIFBvUCByZXF1aXJlcyBmdWxsIEJhc2U2NFVybCBlbmNvZGVkIHJlcV9jbmYgc3RyaW5nICh1bmhhc2hlZClcclxuICAgICAgICAgICAgYWRkUG9wVG9rZW4ocGFyYW1ldGVycywgcmVxQ25mRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgPT09IEF1dGhlbnRpY2F0aW9uU2NoZW1lLlNTSCkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zc2hKd2spIHtcclxuICAgICAgICAgICAgICAgIGFkZFNzaEp3ayhwYXJhbWV0ZXJzLCByZXF1ZXN0LnNzaEp3ayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRDb25maWd1cmF0aW9uRXJyb3IobWlzc2luZ1NzaEp3ayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFTdHJpbmdVdGlscy5pc0VtcHR5T2JqKHJlcXVlc3QuY2xhaW1zKSB8fFxyXG4gICAgICAgICAgICAodGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgYWRkQ2xhaW1zKHBhcmFtZXRlcnMsIHJlcXVlc3QuY2xhaW1zLCB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY2NzQ3JlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAocmVxdWVzdC5jbGllbnRJbmZvKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvKHJlcXVlc3QuY2xpZW50SW5mbywgdGhpcy5jcnlwdG9VdGlscy5iYXNlNjREZWNvZGUpO1xyXG4gICAgICAgICAgICAgICAgY2NzQ3JlZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsOiBgJHtjbGllbnRJbmZvLnVpZH0ke1NlcGFyYXRvcnMuQ0xJRU5UX0lORk9fU0VQQVJBVE9SfSR7Y2xpZW50SW5mby51dGlkfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2NzQ3JlZGVudGlhbFR5cGUuSE9NRV9BQ0NPVU5UX0lELFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIkNvdWxkIG5vdCBwYXJzZSBjbGllbnQgaW5mbyBmb3IgQ0NTIEhlYWRlcjogXCIgKyBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2NzQ3JlZCA9IHJlcXVlc3QuY2NzQ3JlZGVudGlhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkcyB0aGVzZSBhcyBwYXJhbWV0ZXJzIGluIHRoZSByZXF1ZXN0IGluc3RlYWQgb2YgaGVhZGVycyB0byBwcmV2ZW50IENPUlMgcHJlZmxpZ2h0IHJlcXVlc3RcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy5wcmV2ZW50Q29yc1ByZWZsaWdodCAmJiBjY3NDcmVkKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY2NzQ3JlZC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENjc0NyZWRlbnRpYWxUeXBlLkhPTUVfQUNDT1VOVF9JRDpcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRJbmZvID0gYnVpbGRDbGllbnRJbmZvRnJvbUhvbWVBY2NvdW50SWQoY2NzQ3JlZC5jcmVkZW50aWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2NzT2lkKHBhcmFtZXRlcnMsIGNsaWVudEluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiQ291bGQgbm90IHBhcnNlIGhvbWUgYWNjb3VudCBJRCBmb3IgQ0NTIEhlYWRlcjogXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDY3NDcmVkZW50aWFsVHlwZS5VUE46XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2NzVXBuKHBhcmFtZXRlcnMsIGNjc0NyZWQuY3JlZGVudGlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcXVlc3QuZW1iZWRkZWRDbGllbnRJZCkge1xyXG4gICAgICAgICAgICBhZGRCcm9rZXJQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5yZWRpcmVjdFVyaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXF1ZXN0LnRva2VuQm9keVBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgYWRkRXh0cmFRdWVyeVBhcmFtZXRlcnMocGFyYW1ldGVycywgcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGh5YnJpZCBzcGEgcGFyYW1ldGVycyBpZiBub3QgYWxyZWFkeSBwcm92aWRlZFxyXG4gICAgICAgIGlmIChyZXF1ZXN0LmVuYWJsZVNwYUF1dGhvcml6YXRpb25Db2RlICYmXHJcbiAgICAgICAgICAgICghcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzIHx8XHJcbiAgICAgICAgICAgICAgICAhcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzW1JFVFVSTl9TUEFfQ09ERV0pKSB7XHJcbiAgICAgICAgICAgIGFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHtcclxuICAgICAgICAgICAgICAgIFtSRVRVUk5fU1BBX0NPREVdOiBcIjFcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RydW1lbnRCcm9rZXJQYXJhbXMocGFyYW1ldGVycywgcmVxdWVzdC5jb3JyZWxhdGlvbklkLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50KTtcclxuICAgICAgICByZXR1cm4gbWFwVG9RdWVyeVN0cmluZyhwYXJhbWV0ZXJzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBBUEkgdmFsaWRhdGVzIHRoZSBgRW5kU2Vzc2lvblJlcXVlc3RgIGFuZCBjcmVhdGVzIGEgVVJMXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVMb2dvdXRVcmxRdWVyeVN0cmluZyhyZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBpZiAocmVxdWVzdC5wb3N0TG9nb3V0UmVkaXJlY3RVcmkpIHtcclxuICAgICAgICAgICAgYWRkUG9zdExvZ291dFJlZGlyZWN0VXJpKHBhcmFtZXRlcnMsIHJlcXVlc3QucG9zdExvZ291dFJlZGlyZWN0VXJpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcXVlc3QuY29ycmVsYXRpb25JZCkge1xyXG4gICAgICAgICAgICBhZGRDb3JyZWxhdGlvbklkKHBhcmFtZXRlcnMsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXF1ZXN0LmlkVG9rZW5IaW50KSB7XHJcbiAgICAgICAgICAgIGFkZElkVG9rZW5IaW50KHBhcmFtZXRlcnMsIHJlcXVlc3QuaWRUb2tlbkhpbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0ZSkge1xyXG4gICAgICAgICAgICBhZGRTdGF0ZShwYXJhbWV0ZXJzLCByZXF1ZXN0LnN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcXVlc3QubG9nb3V0SGludCkge1xyXG4gICAgICAgICAgICBhZGRMb2dvdXRIaW50KHBhcmFtZXRlcnMsIHJlcXVlc3QubG9nb3V0SGludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIGFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHJlcXVlc3QuZXh0cmFRdWVyeVBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0aE9wdGlvbnMuaW5zdGFuY2VBd2FyZSkge1xyXG4gICAgICAgICAgICBhZGRJbnN0YW5jZUF3YXJlKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFwVG9RdWVyeVN0cmluZyhwYXJhbWV0ZXJzLCB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5lbmNvZGVFeHRyYVF1ZXJ5UGFyYW1zLCByZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBBdXRob3JpemF0aW9uQ29kZUNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aG9yaXphdGlvbkNvZGVDbGllbnQubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGlzT2lkY1Byb3RvY29sTW9kZSB9IGZyb20gJy4uL2NvbmZpZy9DbGllbnRDb25maWd1cmF0aW9uLm1qcyc7XG5pbXBvcnQgeyBCYXNlQ2xpZW50IH0gZnJvbSAnLi9CYXNlQ2xpZW50Lm1qcyc7XG5pbXBvcnQgeyBhZGRDbGllbnRJZCwgYWRkUmVkaXJlY3RVcmksIGFkZFNjb3BlcywgYWRkR3JhbnRUeXBlLCBhZGRDbGllbnRJbmZvLCBhZGRMaWJyYXJ5SW5mbywgYWRkQXBwbGljYXRpb25UZWxlbWV0cnksIGFkZFRocm90dGxpbmcsIGFkZFNlcnZlclRlbGVtZXRyeSwgYWRkUmVmcmVzaFRva2VuLCBhZGRDbGllbnRTZWNyZXQsIGFkZENsaWVudEFzc2VydGlvbiwgYWRkQ2xpZW50QXNzZXJ0aW9uVHlwZSwgYWRkUG9wVG9rZW4sIGFkZFNzaEp3aywgYWRkQ2xhaW1zLCBhZGRDY3NVcG4sIGFkZENjc09pZCwgYWRkQnJva2VyUGFyYW1ldGVycywgYWRkRXh0cmFRdWVyeVBhcmFtZXRlcnMsIGluc3RydW1lbnRCcm9rZXJQYXJhbXMgfSBmcm9tICcuLi9yZXF1ZXN0L1JlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLm1qcyc7XG5pbXBvcnQgeyBtYXBUb1F1ZXJ5U3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvVXJsVXRpbHMubWpzJztcbmltcG9ydCB7IEdyYW50VHlwZSwgQXV0aGVudGljYXRpb25TY2hlbWUsIEhlYWRlck5hbWVzLCBFcnJvcnMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IENMSUVOVF9JRCB9IGZyb20gJy4uL2NvbnN0YW50cy9BQURTZXJ2ZXJQYXJhbUtleXMubWpzJztcbmltcG9ydCB7IFJlc3BvbnNlSGFuZGxlciB9IGZyb20gJy4uL3Jlc3BvbnNlL1Jlc3BvbnNlSGFuZGxlci5tanMnO1xuaW1wb3J0IHsgUG9wVG9rZW5HZW5lcmF0b3IgfSBmcm9tICcuLi9jcnlwdG8vUG9wVG9rZW5HZW5lcmF0b3IubWpzJztcbmltcG9ydCB7IFN0cmluZ1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMvU3RyaW5nVXRpbHMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9yL0NsaWVudENvbmZpZ3VyYXRpb25FcnJvci5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50QXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyBTZXJ2ZXJFcnJvciB9IGZyb20gJy4uL2Vycm9yL1NlcnZlckVycm9yLm1qcyc7XG5pbXBvcnQgeyBub3dTZWNvbmRzLCBpc1Rva2VuRXhwaXJlZCB9IGZyb20gJy4uL3V0aWxzL1RpbWVVdGlscy5tanMnO1xuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSAnLi4vdXJsL1VybFN0cmluZy5tanMnO1xuaW1wb3J0IHsgQ2NzQ3JlZGVudGlhbFR5cGUgfSBmcm9tICcuLi9hY2NvdW50L0Njc0NyZWRlbnRpYWwubWpzJztcbmltcG9ydCB7IGJ1aWxkQ2xpZW50SW5mb0Zyb21Ib21lQWNjb3VudElkIH0gZnJvbSAnLi4vYWNjb3VudC9DbGllbnRJbmZvLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yLCBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VFdmVudHMgfSBmcm9tICcuLi90ZWxlbWV0cnkvcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VFdmVudC5tanMnO1xuaW1wb3J0IHsgaW52b2tlQXN5bmMsIGludm9rZSB9IGZyb20gJy4uL3V0aWxzL0Z1bmN0aW9uV3JhcHBlcnMubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlQ3JlZGVudGlhbEtleSB9IGZyb20gJy4uL2NhY2hlL3V0aWxzL0NhY2hlSGVscGVycy5tanMnO1xuaW1wb3J0IHsgZ2V0Q2xpZW50QXNzZXJ0aW9uIH0gZnJvbSAnLi4vdXRpbHMvQ2xpZW50QXNzZXJ0aW9uVXRpbHMubWpzJztcbmltcG9ydCB7IGdldFJlcXVlc3RUaHVtYnByaW50IH0gZnJvbSAnLi4vbmV0d29yay9SZXF1ZXN0VGh1bWJwcmludC5tanMnO1xuaW1wb3J0IHsgdG9rZW5SZXF1ZXN0RW1wdHksIG1pc3NpbmdTc2hKd2sgfSBmcm9tICcuLi9lcnJvci9DbGllbnRDb25maWd1cmF0aW9uRXJyb3JDb2Rlcy5tanMnO1xuaW1wb3J0IHsgbm9BY2NvdW50SW5TaWxlbnRSZXF1ZXN0IH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yQ29kZXMubWpzJztcbmltcG9ydCB7IG5vVG9rZW5zRm91bmQsIHJlZnJlc2hUb2tlbkV4cGlyZWQsIGJhZFRva2VuIH0gZnJvbSAnLi4vZXJyb3IvSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX1JFRlJFU0hfVE9LRU5fRVhQSVJBVElPTl9PRkZTRVRfU0VDT05EUyA9IDMwMDsgLy8gNSBNaW51dGVzXHJcbi8qKlxyXG4gKiBPQXV0aDIuMCByZWZyZXNoIHRva2VuIGNsaWVudFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlZnJlc2hUb2tlbkNsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgcGVyZm9ybWFuY2VDbGllbnQpIHtcclxuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uLCBwZXJmb3JtYW5jZUNsaWVudCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBhY3F1aXJlVG9rZW4ocmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZFF1ZXVlTWVhc3VyZW1lbnQoUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuLCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IHJlcVRpbWVzdGFtcCA9IG5vd1NlY29uZHMoKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMuZXhlY3V0ZVRva2VuUmVxdWVzdC5iaW5kKHRoaXMpLCBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRFeGVjdXRlVG9rZW5SZXF1ZXN0LCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKShyZXF1ZXN0LCB0aGlzLmF1dGhvcml0eSk7XHJcbiAgICAgICAgLy8gUmV0cmlldmUgcmVxdWVzdElkIGZyb20gcmVzcG9uc2UgaGVhZGVyc1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlc3BvbnNlLmhlYWRlcnM/LltIZWFkZXJOYW1lcy5YX01TX1JFUVVFU1RfSURdO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IG5ldyBSZXNwb25zZUhhbmRsZXIodGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsIHRoaXMuY2FjaGVNYW5hZ2VyLCB0aGlzLmNyeXB0b1V0aWxzLCB0aGlzLmxvZ2dlciwgdGhpcy5jb25maWcuc2VyaWFsaXphYmxlQ2FjaGUsIHRoaXMuY29uZmlnLnBlcnNpc3RlbmNlUGx1Z2luKTtcclxuICAgICAgICByZXNwb25zZUhhbmRsZXIudmFsaWRhdGVUb2tlblJlc3BvbnNlKHJlc3BvbnNlLmJvZHkpO1xyXG4gICAgICAgIHJldHVybiBpbnZva2VBc3luYyhyZXNwb25zZUhhbmRsZXIuaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZS5iaW5kKHJlc3BvbnNlSGFuZGxlciksIFBlcmZvcm1hbmNlRXZlbnRzLkhhbmRsZVNlcnZlclRva2VuUmVzcG9uc2UsIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpKHJlc3BvbnNlLmJvZHksIHRoaXMuYXV0aG9yaXR5LCByZXFUaW1lc3RhbXAsIHJlcXVlc3QsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCByZXF1ZXN0LmZvcmNlQ2FjaGUsIHJlcXVlc3RJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgY2FjaGVkIHJlZnJlc2ggdG9rZW4gYW5kIGF0dGFjaGVzIHRvIHJlcXVlc3QsIHRoZW4gY2FsbHMgYWNxdWlyZVRva2VuIEFQSVxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuQnlSZWZyZXNoVG9rZW4ocmVxdWVzdCkge1xyXG4gICAgICAgIC8vIENhbm5vdCByZW5ldyB0b2tlbiBpZiBubyByZXF1ZXN0IG9iamVjdCBpcyBnaXZlbi5cclxuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKHRva2VuUmVxdWVzdEVtcHR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNsaWVudD8uYWRkUXVldWVNZWFzdXJlbWVudChQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRBY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbiwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAvLyBXZSBjdXJyZW50bHkgZG8gbm90IHN1cHBvcnQgc2lsZW50IGZsb3cgZm9yIGFjY291bnQgPT09IG51bGwgdXNlIGNhc2VzOyBUaGlzIHdpbGwgYmUgcmV2aXNpdGVkIGZvciBjb25maWRlbnRpYWwgZmxvdyB1c2VjYXNlc1xyXG4gICAgICAgIGlmICghcmVxdWVzdC5hY2NvdW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihub0FjY291bnRJblNpbGVudFJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cnkgY2hlY2tpbmcgaWYgRk9DSSBpcyBlbmFibGVkIGZvciB0aGUgZ2l2ZW4gYXBwbGljYXRpb25cclxuICAgICAgICBjb25zdCBpc0ZPQ0kgPSB0aGlzLmNhY2hlTWFuYWdlci5pc0FwcE1ldGFkYXRhRk9DSShyZXF1ZXN0LmFjY291bnQuZW52aXJvbm1lbnQpO1xyXG4gICAgICAgIC8vIGlmIHRoZSBhcHAgaXMgcGFydCBvZiB0aGUgZmFtaWx5LCByZXRyaXZlIGEgRmFtaWx5IHJlZnJlc2ggdG9rZW4gaWYgcHJlc2VudCBhbmQgbWFrZSBhIHJlZnJlc2hUb2tlblJlcXVlc3RcclxuICAgICAgICBpZiAoaXNGT0NJKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgaW52b2tlQXN5bmModGhpcy5hY3F1aXJlVG9rZW5XaXRoQ2FjaGVkUmVmcmVzaFRva2VuLmJpbmQodGhpcyksIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbldpdGhDYWNoZWRSZWZyZXNoVG9rZW4sIHRoaXMubG9nZ2VyLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpKHJlcXVlc3QsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub0ZhbWlseVJUSW5DYWNoZSA9IGUgaW5zdGFuY2VvZiBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZS5lcnJvckNvZGUgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vVG9rZW5zRm91bmQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRNaXNtYXRjaEVycm9yV2l0aEZhbWlseVJUID0gZSBpbnN0YW5jZW9mIFNlcnZlckVycm9yICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZS5lcnJvckNvZGUgPT09IEVycm9ycy5JTlZBTElEX0dSQU5UX0VSUk9SICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdWJFcnJvciA9PT0gRXJyb3JzLkNMSUVOVF9NSVNNQVRDSF9FUlJPUjtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGZhbWlseSBSZWZyZXNoIFRva2VuIChGUlQpIGNhY2hlIGFjcXVpc2l0aW9uIGZhaWxzIG9yIGlmIGNsaWVudF9taXNtYXRjaCBlcnJvciBpcyBzZWVuIHdpdGggRlJULCByZWF0dGVtcHQgd2l0aCBhcHBsaWNhdGlvbiBSZWZyZXNoIFRva2VuIChBUlQpXHJcbiAgICAgICAgICAgICAgICBpZiAobm9GYW1pbHlSVEluQ2FjaGUgfHwgY2xpZW50TWlzbWF0Y2hFcnJvcldpdGhGYW1pbHlSVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2VBc3luYyh0aGlzLmFjcXVpcmVUb2tlbldpdGhDYWNoZWRSZWZyZXNoVG9rZW4uYmluZCh0aGlzKSwgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbiwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkocmVxdWVzdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93IGluIGFsbCBvdGhlciBjYXNlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gYXBwbGljYXRpb24gcmVmcmVzaCB0b2tlbiBhY3F1aXNpdGlvblxyXG4gICAgICAgIHJldHVybiBpbnZva2VBc3luYyh0aGlzLmFjcXVpcmVUb2tlbldpdGhDYWNoZWRSZWZyZXNoVG9rZW4uYmluZCh0aGlzKSwgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuV2l0aENhY2hlZFJlZnJlc2hUb2tlbiwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkocmVxdWVzdCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBtYWtlcyBhIG5ldHdvcmsgY2FsbCB0byBhY3F1aXJlIHRva2VucyBieSBleGNoYW5naW5nIFJlZnJlc2hUb2tlbiBhdmFpbGFibGUgaW4gdXNlckNhY2hlOyB0aHJvd3MgaWYgcmVmcmVzaCB0b2tlbiBpcyBub3QgY2FjaGVkXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBhY3F1aXJlVG9rZW5XaXRoQ2FjaGVkUmVmcmVzaFRva2VuKHJlcXVlc3QsIGZvY2kpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEFjcXVpcmVUb2tlbldpdGhDYWNoZWRSZWZyZXNoVG9rZW4sIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgLy8gZmV0Y2hlcyBmYW1pbHkgUlQgb3IgYXBwbGljYXRpb24gUlQgYmFzZWQgb24gRk9DSSB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGludm9rZSh0aGlzLmNhY2hlTWFuYWdlci5nZXRSZWZyZXNoVG9rZW4uYmluZCh0aGlzLmNhY2hlTWFuYWdlciksIFBlcmZvcm1hbmNlRXZlbnRzLkNhY2hlTWFuYWdlckdldFJlZnJlc2hUb2tlbiwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkocmVxdWVzdC5hY2NvdW50LCBmb2NpLCB1bmRlZmluZWQsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvcihub1Rva2Vuc0ZvdW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZnJlc2hUb2tlbi5leHBpcmVzT24gJiZcclxuICAgICAgICAgICAgaXNUb2tlbkV4cGlyZWQocmVmcmVzaFRva2VuLmV4cGlyZXNPbiwgcmVxdWVzdC5yZWZyZXNoVG9rZW5FeHBpcmF0aW9uT2Zmc2V0U2Vjb25kcyB8fFxyXG4gICAgICAgICAgICAgICAgREVGQVVMVF9SRUZSRVNIX1RPS0VOX0VYUElSQVRJT05fT0ZGU0VUX1NFQ09ORFMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyh7IHJ0RXhwaXJlc09uTXM6IE51bWJlcihyZWZyZXNoVG9rZW4uZXhwaXJlc09uKSB9LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yKHJlZnJlc2hUb2tlbkV4cGlyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhdHRhY2ggY2FjaGVkIFJUIHNpemUgdG8gdGhlIGN1cnJlbnQgbWVhc3VyZW1lbnRcclxuICAgICAgICBjb25zdCByZWZyZXNoVG9rZW5SZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IHJlZnJlc2hUb2tlbi5zZWNyZXQsXHJcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uU2NoZW1lOiByZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lIHx8IEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUixcclxuICAgICAgICAgICAgY2NzQ3JlZGVudGlhbDoge1xyXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbDogcmVxdWVzdC5hY2NvdW50LmhvbWVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBDY3NDcmVkZW50aWFsVHlwZS5IT01FX0FDQ09VTlRfSUQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaW52b2tlQXN5bmModGhpcy5hY3F1aXJlVG9rZW4uYmluZCh0aGlzKSwgUGVyZm9ybWFuY2VFdmVudHMuUmVmcmVzaFRva2VuQ2xpZW50QWNxdWlyZVRva2VuLCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKShyZWZyZXNoVG9rZW5SZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBJbnRlcmFjdGlvblJlcXVpcmVkQXV0aEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoeyBydEV4cGlyZXNPbk1zOiBOdW1iZXIocmVmcmVzaFRva2VuLmV4cGlyZXNPbikgfSwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLnN1YkVycm9yID09PSBiYWRUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBiYWQgcmVmcmVzaCB0b2tlbiBmcm9tIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcImFjcXVpcmVUb2tlbldpdGhSZWZyZXNoVG9rZW46IGJhZCByZWZyZXNoIHRva2VuLCByZW1vdmluZyBmcm9tIGNhY2hlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhZFJlZnJlc2hUb2tlbktleSA9IGdlbmVyYXRlQ3JlZGVudGlhbEtleShyZWZyZXNoVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVNYW5hZ2VyLnJlbW92ZVJlZnJlc2hUb2tlbihiYWRSZWZyZXNoVG9rZW5LZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIHRoZSBuZXR3b3JrIG1lc3NhZ2UgYW5kIG1ha2VzIGEgTlcgY2FsbCB0byB0aGUgdW5kZXJseWluZyBzZWN1cmUgdG9rZW4gc2VydmljZVxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHlcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZXhlY3V0ZVRva2VuUmVxdWVzdChyZXF1ZXN0LCBhdXRob3JpdHkpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVUb2tlblJlcXVlc3QsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5jcmVhdGVUb2tlblF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBlbmRwb2ludCA9IFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyhhdXRob3JpdHkudG9rZW5FbmRwb2ludCwgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGF3YWl0IGludm9rZUFzeW5jKHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keS5iaW5kKHRoaXMpLCBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRDcmVhdGVUb2tlblJlcXVlc3RCb2R5LCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKShyZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5jcmVhdGVUb2tlblJlcXVlc3RIZWFkZXJzKHJlcXVlc3QuY2NzQ3JlZGVudGlhbCk7XHJcbiAgICAgICAgY29uc3QgdGh1bWJwcmludCA9IGdldFJlcXVlc3RUaHVtYnByaW50KHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCByZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4gaW52b2tlQXN5bmModGhpcy5leGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludC5iaW5kKHRoaXMpLCBQZXJmb3JtYW5jZUV2ZW50cy5SZWZyZXNoVG9rZW5DbGllbnRFeGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludCwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkoZW5kcG9pbnQsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB0aHVtYnByaW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQsIFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudEV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgdG9rZW4gcmVxdWVzdCBib2R5XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGVUb2tlblJlcXVlc3RCb2R5KHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlJlZnJlc2hUb2tlbkNsaWVudENyZWF0ZVRva2VuUmVxdWVzdEJvZHksIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBhZGRDbGllbnRJZChwYXJhbWV0ZXJzLCByZXF1ZXN0LmVtYmVkZGVkQ2xpZW50SWQgfHxcclxuICAgICAgICAgICAgcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzPy5bQ0xJRU5UX0lEXSB8fFxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCk7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QucmVkaXJlY3RVcmkpIHtcclxuICAgICAgICAgICAgYWRkUmVkaXJlY3RVcmkocGFyYW1ldGVycywgcmVxdWVzdC5yZWRpcmVjdFVyaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZFNjb3BlcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LnNjb3BlcywgdHJ1ZSwgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuYXV0aG9yaXR5Lm9wdGlvbnMuT0lEQ09wdGlvbnM/LmRlZmF1bHRTY29wZXMpO1xyXG4gICAgICAgIGFkZEdyYW50VHlwZShwYXJhbWV0ZXJzLCBHcmFudFR5cGUuUkVGUkVTSF9UT0tFTl9HUkFOVCk7XHJcbiAgICAgICAgYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKTtcclxuICAgICAgICBhZGRMaWJyYXJ5SW5mbyhwYXJhbWV0ZXJzLCB0aGlzLmNvbmZpZy5saWJyYXJ5SW5mbyk7XHJcbiAgICAgICAgYWRkQXBwbGljYXRpb25UZWxlbWV0cnkocGFyYW1ldGVycywgdGhpcy5jb25maWcudGVsZW1ldHJ5LmFwcGxpY2F0aW9uKTtcclxuICAgICAgICBhZGRUaHJvdHRsaW5nKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIgJiYgIWlzT2lkY1Byb3RvY29sTW9kZSh0aGlzLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgYWRkU2VydmVyVGVsZW1ldHJ5KHBhcmFtZXRlcnMsIHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZFJlZnJlc2hUb2tlbihwYXJhbWV0ZXJzLCByZXF1ZXN0LnJlZnJlc2hUb2tlbik7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudFNlY3JldCkge1xyXG4gICAgICAgICAgICBhZGRDbGllbnRTZWNyZXQocGFyYW1ldGVycywgdGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudEFzc2VydGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb24gPSB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRBc3NlcnRpb247XHJcbiAgICAgICAgICAgIGFkZENsaWVudEFzc2VydGlvbihwYXJhbWV0ZXJzLCBhd2FpdCBnZXRDbGllbnRBc3NlcnRpb24oY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvbiwgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsIHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpKSk7XHJcbiAgICAgICAgICAgIGFkZENsaWVudEFzc2VydGlvblR5cGUocGFyYW1ldGVycywgY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvblR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSA9PT0gQXV0aGVudGljYXRpb25TY2hlbWUuUE9QKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvcFRva2VuR2VuZXJhdG9yID0gbmV3IFBvcFRva2VuR2VuZXJhdG9yKHRoaXMuY3J5cHRvVXRpbHMsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQpO1xyXG4gICAgICAgICAgICBsZXQgcmVxQ25mRGF0YTtcclxuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LnBvcEtpZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUmVxQ25mRGF0YSA9IGF3YWl0IGludm9rZUFzeW5jKHBvcFRva2VuR2VuZXJhdG9yLmdlbmVyYXRlQ25mLmJpbmQocG9wVG9rZW5HZW5lcmF0b3IpLCBQZXJmb3JtYW5jZUV2ZW50cy5Qb3BUb2tlbkdlbmVyYXRlQ25mLCB0aGlzLmxvZ2dlciwgdGhpcy5wZXJmb3JtYW5jZUNsaWVudCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKShyZXF1ZXN0LCB0aGlzLmxvZ2dlcik7XHJcbiAgICAgICAgICAgICAgICByZXFDbmZEYXRhID0gZ2VuZXJhdGVkUmVxQ25mRGF0YS5yZXFDbmZTdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXFDbmZEYXRhID0gdGhpcy5jcnlwdG9VdGlscy5lbmNvZGVLaWQocmVxdWVzdC5wb3BLaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNQQSBQb1AgcmVxdWlyZXMgZnVsbCBCYXNlNjRVcmwgZW5jb2RlZCByZXFfY25mIHN0cmluZyAodW5oYXNoZWQpXHJcbiAgICAgICAgICAgIGFkZFBvcFRva2VuKHBhcmFtZXRlcnMsIHJlcUNuZkRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lID09PSBBdXRoZW50aWNhdGlvblNjaGVtZS5TU0gpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3NoSndrKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRTc2hKd2socGFyYW1ldGVycywgcmVxdWVzdC5zc2hKd2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKG1pc3NpbmdTc2hKd2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghU3RyaW5nVXRpbHMuaXNFbXB0eU9iaihyZXF1ZXN0LmNsYWltcykgfHxcclxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgICAgIGFkZENsYWltcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LmNsYWltcywgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnN5c3RlbU9wdGlvbnMucHJldmVudENvcnNQcmVmbGlnaHQgJiZcclxuICAgICAgICAgICAgcmVxdWVzdC5jY3NDcmVkZW50aWFsKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocmVxdWVzdC5jY3NDcmVkZW50aWFsLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2NzQ3JlZGVudGlhbFR5cGUuSE9NRV9BQ0NPVU5UX0lEOlxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudEluZm8gPSBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZChyZXF1ZXN0LmNjc0NyZWRlbnRpYWwuY3JlZGVudGlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENjc09pZChwYXJhbWV0ZXJzLCBjbGllbnRJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIkNvdWxkIG5vdCBwYXJzZSBob21lIGFjY291bnQgSUQgZm9yIENDUyBIZWFkZXI6IFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2NzQ3JlZGVudGlhbFR5cGUuVVBOOlxyXG4gICAgICAgICAgICAgICAgICAgIGFkZENjc1VwbihwYXJhbWV0ZXJzLCByZXF1ZXN0LmNjc0NyZWRlbnRpYWwuY3JlZGVudGlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcXVlc3QuZW1iZWRkZWRDbGllbnRJZCkge1xyXG4gICAgICAgICAgICBhZGRCcm9rZXJQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5yZWRpcmVjdFVyaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXF1ZXN0LnRva2VuQm9keVBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgYWRkRXh0cmFRdWVyeVBhcmFtZXRlcnMocGFyYW1ldGVycywgcmVxdWVzdC50b2tlbkJvZHlQYXJhbWV0ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdHJ1bWVudEJyb2tlclBhcmFtcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQpO1xyXG4gICAgICAgIHJldHVybiBtYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFJlZnJlc2hUb2tlbkNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVmcmVzaFRva2VuQ2xpZW50Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1jb21tb24gdjE1LjcuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBCYXNlQ2xpZW50IH0gZnJvbSAnLi9CYXNlQ2xpZW50Lm1qcyc7XG5pbXBvcnQgeyB3YXNDbG9ja1R1cm5lZEJhY2ssIGlzVG9rZW5FeHBpcmVkIH0gZnJvbSAnLi4vdXRpbHMvVGltZVV0aWxzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IFJlc3BvbnNlSGFuZGxlciB9IGZyb20gJy4uL3Jlc3BvbnNlL1Jlc3BvbnNlSGFuZGxlci5tanMnO1xuaW1wb3J0IHsgQ2FjaGVPdXRjb21lIH0gZnJvbSAnLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyBTdHJpbmdVdGlscyB9IGZyb20gJy4uL3V0aWxzL1N0cmluZ1V0aWxzLm1qcyc7XG5pbXBvcnQgeyBleHRyYWN0VG9rZW5DbGFpbXMsIGNoZWNrTWF4QWdlIH0gZnJvbSAnLi4vYWNjb3VudC9BdXRoVG9rZW4ubWpzJztcbmltcG9ydCB7IFBlcmZvcm1hbmNlRXZlbnRzIH0gZnJvbSAnLi4vdGVsZW1ldHJ5L3BlcmZvcm1hbmNlL1BlcmZvcm1hbmNlRXZlbnQubWpzJztcbmltcG9ydCB7IGludm9rZUFzeW5jIH0gZnJvbSAnLi4vdXRpbHMvRnVuY3Rpb25XcmFwcGVycy5tanMnO1xuaW1wb3J0IHsgZ2V0VGVuYW50RnJvbUF1dGhvcml0eVN0cmluZyB9IGZyb20gJy4uL2F1dGhvcml0eS9BdXRob3JpdHkubWpzJztcbmltcG9ydCB7IHRva2VuUmVmcmVzaFJlcXVpcmVkLCBub0FjY291bnRJblNpbGVudFJlcXVlc3QsIGF1dGhUaW1lTm90Rm91bmQgfSBmcm9tICcuLi9lcnJvci9DbGllbnRBdXRoRXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5jbGFzcyBTaWxlbnRGbG93Q2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBwZXJmb3JtYW5jZUNsaWVudCkge1xyXG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb24sIHBlcmZvcm1hbmNlQ2xpZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRva2VuIGZyb20gY2FjaGUgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IG11c3QgYmUgcmVmcmVzaGVkLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZUNhY2hlZFRva2VuKHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlNpbGVudEZsb3dDbGllbnRBY3F1aXJlQ2FjaGVkVG9rZW4sIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgbGV0IGxhc3RDYWNoZU91dGNvbWUgPSBDYWNoZU91dGNvbWUuTk9UX0FQUExJQ0FCTEU7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QuZm9yY2VSZWZyZXNoIHx8XHJcbiAgICAgICAgICAgICghdGhpcy5jb25maWcuY2FjaGVPcHRpb25zLmNsYWltc0Jhc2VkQ2FjaGluZ0VuYWJsZWQgJiZcclxuICAgICAgICAgICAgICAgICFTdHJpbmdVdGlscy5pc0VtcHR5T2JqKHJlcXVlc3QuY2xhaW1zKSkpIHtcclxuICAgICAgICAgICAgLy8gTXVzdCByZWZyZXNoIGR1ZSB0byBwcmVzZW50IGZvcmNlX3JlZnJlc2ggZmxhZy5cclxuICAgICAgICAgICAgdGhpcy5zZXRDYWNoZU91dGNvbWUoQ2FjaGVPdXRjb21lLkZPUkNFX1JFRlJFU0hfT1JfQ0xBSU1TLCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IodG9rZW5SZWZyZXNoUmVxdWlyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBjdXJyZW50bHkgZG8gbm90IHN1cHBvcnQgc2lsZW50IGZsb3cgZm9yIGFjY291bnQgPT09IG51bGwgdXNlIGNhc2VzOyBUaGlzIHdpbGwgYmUgcmV2aXNpdGVkIGZvciBjb25maWRlbnRpYWwgZmxvdyB1c2VjYXNlc1xyXG4gICAgICAgIGlmICghcmVxdWVzdC5hY2NvdW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihub0FjY291bnRJblNpbGVudFJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0VGVuYW50SWQgPSByZXF1ZXN0LmFjY291bnQudGVuYW50SWQgfHxcclxuICAgICAgICAgICAgZ2V0VGVuYW50RnJvbUF1dGhvcml0eVN0cmluZyhyZXF1ZXN0LmF1dGhvcml0eSk7XHJcbiAgICAgICAgY29uc3QgdG9rZW5LZXlzID0gdGhpcy5jYWNoZU1hbmFnZXIuZ2V0VG9rZW5LZXlzKCk7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkQWNjZXNzVG9rZW4gPSB0aGlzLmNhY2hlTWFuYWdlci5nZXRBY2Nlc3NUb2tlbihyZXF1ZXN0LmFjY291bnQsIHJlcXVlc3QsIHRva2VuS2V5cywgcmVxdWVzdFRlbmFudElkLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGlmICghY2FjaGVkQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gbXVzdCByZWZyZXNoIGR1ZSB0byBub24tZXhpc3RlbnQgYWNjZXNzX3Rva2VuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FjaGVPdXRjb21lKENhY2hlT3V0Y29tZS5OT19DQUNIRURfQUNDRVNTX1RPS0VOLCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IodG9rZW5SZWZyZXNoUmVxdWlyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3YXNDbG9ja1R1cm5lZEJhY2soY2FjaGVkQWNjZXNzVG9rZW4uY2FjaGVkQXQpIHx8XHJcbiAgICAgICAgICAgIGlzVG9rZW5FeHBpcmVkKGNhY2hlZEFjY2Vzc1Rva2VuLmV4cGlyZXNPbiwgdGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy50b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzKSkge1xyXG4gICAgICAgICAgICAvLyBtdXN0IHJlZnJlc2ggZHVlIHRvIHRoZSBleHBpcmVzX2luIHZhbHVlXHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FjaGVPdXRjb21lKENhY2hlT3V0Y29tZS5DQUNIRURfQUNDRVNTX1RPS0VOX0VYUElSRUQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcih0b2tlblJlZnJlc2hSZXF1aXJlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNhY2hlZEFjY2Vzc1Rva2VuLnJlZnJlc2hPbiAmJlxyXG4gICAgICAgICAgICBpc1Rva2VuRXhwaXJlZChjYWNoZWRBY2Nlc3NUb2tlbi5yZWZyZXNoT24sIDApKSB7XHJcbiAgICAgICAgICAgIC8vIG11c3QgcmVmcmVzaCAoaW4gdGhlIGJhY2tncm91bmQpIGR1ZSB0byB0aGUgcmVmcmVzaF9pbiB2YWx1ZVxyXG4gICAgICAgICAgICBsYXN0Q2FjaGVPdXRjb21lID0gQ2FjaGVPdXRjb21lLlBST0FDVElWRUxZX1JFRlJFU0hFRDtcclxuICAgICAgICAgICAgLy8gZG9uJ3QgdGhyb3cgQ2xpZW50QXV0aEVycm9yLmNyZWF0ZVJlZnJlc2hSZXF1aXJlZEVycm9yKCksIHJldHVybiBjYWNoZWQgdG9rZW4gaW5zdGVhZFxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbnZpcm9ubWVudCA9IHJlcXVlc3QuYXV0aG9yaXR5IHx8IHRoaXMuYXV0aG9yaXR5LmdldFByZWZlcnJlZENhY2hlKCk7XHJcbiAgICAgICAgY29uc3QgY2FjaGVSZWNvcmQgPSB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuY2FjaGVNYW5hZ2VyLnJlYWRBY2NvdW50RnJvbUNhY2hlKHJlcXVlc3QuYWNjb3VudCksXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBjYWNoZWRBY2Nlc3NUb2tlbixcclxuICAgICAgICAgICAgaWRUb2tlbjogdGhpcy5jYWNoZU1hbmFnZXIuZ2V0SWRUb2tlbihyZXF1ZXN0LmFjY291bnQsIHRva2VuS2V5cywgcmVxdWVzdFRlbmFudElkLCB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpLFxyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IG51bGwsXHJcbiAgICAgICAgICAgIGFwcE1ldGFkYXRhOiB0aGlzLmNhY2hlTWFuYWdlci5yZWFkQXBwTWV0YWRhdGFGcm9tQ2FjaGUoZW52aXJvbm1lbnQpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXRDYWNoZU91dGNvbWUobGFzdENhY2hlT3V0Y29tZSwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmluY3JlbWVudENhY2hlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBhd2FpdCBpbnZva2VBc3luYyh0aGlzLmdlbmVyYXRlUmVzdWx0RnJvbUNhY2hlUmVjb3JkLmJpbmQodGhpcyksIFBlcmZvcm1hbmNlRXZlbnRzLlNpbGVudEZsb3dDbGllbnRHZW5lcmF0ZVJlc3VsdEZyb21DYWNoZVJlY29yZCwgdGhpcy5sb2dnZXIsIHRoaXMucGVyZm9ybWFuY2VDbGllbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCkoY2FjaGVSZWNvcmQsIHJlcXVlc3QpLFxyXG4gICAgICAgICAgICBsYXN0Q2FjaGVPdXRjb21lLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBzZXRDYWNoZU91dGNvbWUoY2FjaGVPdXRjb21lLCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyPy5zZXRDYWNoZU91dGNvbWUoY2FjaGVPdXRjb21lKTtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoe1xyXG4gICAgICAgICAgICBjYWNoZU91dGNvbWU6IGNhY2hlT3V0Y29tZSxcclxuICAgICAgICB9LCBjb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBpZiAoY2FjaGVPdXRjb21lICE9PSBDYWNoZU91dGNvbWUuTk9UX0FQUExJQ0FCTEUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgVG9rZW4gcmVmcmVzaCBpcyByZXF1aXJlZCBkdWUgdG8gY2FjaGUgb3V0Y29tZTogJHtjYWNoZU91dGNvbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYnVpbGQgcmVzcG9uc2Ugb2JqZWN0IGZyb20gdGhlIENhY2hlUmVjb3JkXHJcbiAgICAgKiBAcGFyYW0gY2FjaGVSZWNvcmRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2VuZXJhdGVSZXN1bHRGcm9tQ2FjaGVSZWNvcmQoY2FjaGVSZWNvcmQsIHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlQ2xpZW50Py5hZGRRdWV1ZU1lYXN1cmVtZW50KFBlcmZvcm1hbmNlRXZlbnRzLlNpbGVudEZsb3dDbGllbnRHZW5lcmF0ZVJlc3VsdEZyb21DYWNoZVJlY29yZCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBsZXQgaWRUb2tlbkNsYWltcztcclxuICAgICAgICBpZiAoY2FjaGVSZWNvcmQuaWRUb2tlbikge1xyXG4gICAgICAgICAgICBpZFRva2VuQ2xhaW1zID0gZXh0cmFjdFRva2VuQ2xhaW1zKGNhY2hlUmVjb3JkLmlkVG9rZW4uc2VjcmV0LCB0aGlzLmNvbmZpZy5jcnlwdG9JbnRlcmZhY2UuYmFzZTY0RGVjb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdG9rZW4gbWF4X2FnZSBjaGVja1xyXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1heEFnZSB8fCByZXF1ZXN0Lm1heEFnZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBhdXRoVGltZSA9IGlkVG9rZW5DbGFpbXM/LmF1dGhfdGltZTtcclxuICAgICAgICAgICAgaWYgKCFhdXRoVGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGF1dGhUaW1lTm90Rm91bmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoZWNrTWF4QWdlKGF1dGhUaW1lLCByZXF1ZXN0Lm1heEFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZXNwb25zZUhhbmRsZXIuZ2VuZXJhdGVBdXRoZW50aWNhdGlvblJlc3VsdCh0aGlzLmNyeXB0b1V0aWxzLCB0aGlzLmF1dGhvcml0eSwgY2FjaGVSZWNvcmQsIHRydWUsIHJlcXVlc3QsIGlkVG9rZW5DbGFpbXMpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFNpbGVudEZsb3dDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbGVudEZsb3dDbGllbnQubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBOZXR3b3JrVXRpbHMge1xyXG4gICAgc3RhdGljIGdldE5ldHdvcmtSZXNwb25zZShoZWFkZXJzLCBib2R5LCBzdGF0dXNDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcclxuICAgICAgICAgICAgYm9keTogYm9keSxcclxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXNDb2RlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGEgVVJMIG9iamVjdCBpbnRvIGFuIG9yZGluYXJ5IG9wdGlvbnMgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZVxyXG4gICAgICogaHR0cC5yZXF1ZXN0IGFuZCBodHRwcy5yZXF1ZXN0IEFQSXMuXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYWluL2xpYi9pbnRlcm5hbC91cmwuanMjTDEwOTBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVybFRvSHR0cE9wdGlvbnModXJsKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgcHJvdG9jb2w6IHVybC5wcm90b2NvbCxcclxuICAgICAgICAgICAgaG9zdG5hbWU6IHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuc3RhcnRzV2l0aChcIltcIilcclxuICAgICAgICAgICAgICAgID8gdXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxyXG4gICAgICAgICAgICAgICAgOiB1cmwuaG9zdG5hbWUsXHJcbiAgICAgICAgICAgIGhhc2g6IHVybC5oYXNoLFxyXG4gICAgICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXHJcbiAgICAgICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXHJcbiAgICAgICAgICAgIHBhdGg6IGAke3VybC5wYXRobmFtZSB8fCBcIlwifSR7dXJsLnNlYXJjaCB8fCBcIlwifWAsXHJcbiAgICAgICAgICAgIGhyZWY6IHVybC5ocmVmLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHVybC5wb3J0ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IE51bWJlcih1cmwucG9ydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cmwudXNlcm5hbWUgfHwgdXJsLnBhc3N3b3JkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYXV0aCA9IGAke2RlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpfToke2RlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IE5ldHdvcmtVdGlscyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0d29ya1V0aWxzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBIdHRwU3RhdHVzIH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuaW1wb3J0IHsgUHJveHlTdGF0dXMsIENvbnN0YW50cywgSHR0cE1ldGhvZCB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgTmV0d29ya1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMvTmV0d29ya1V0aWxzLm1qcyc7XG5pbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBBUEkgZm9yIG5ldHdvcmsgcmVxdWVzdHMuXHJcbiAqL1xyXG5jbGFzcyBIdHRwQ2xpZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3h5VXJsLCBjdXN0b21BZ2VudE9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnByb3h5VXJsID0gcHJveHlVcmwgfHwgXCJcIjtcclxuICAgICAgICB0aGlzLmN1c3RvbUFnZW50T3B0aW9ucyA9IGN1c3RvbUFnZW50T3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSHR0cCBHZXQgcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHVybFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2VuZEdldFJlcXVlc3RBc3luYyh1cmwsIG9wdGlvbnMsIHRpbWVvdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm94eVVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV0d29ya1JlcXVlc3RWaWFQcm94eSh1cmwsIHRoaXMucHJveHlVcmwsIEh0dHBNZXRob2QuR0VULCBvcHRpb25zLCB0aGlzLmN1c3RvbUFnZW50T3B0aW9ucywgdGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV0d29ya1JlcXVlc3RWaWFIdHRwcyh1cmwsIEh0dHBNZXRob2QuR0VULCBvcHRpb25zLCB0aGlzLmN1c3RvbUFnZW50T3B0aW9ucywgdGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIdHRwIFBvc3QgcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHVybFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2VuZFBvc3RSZXF1ZXN0QXN5bmModXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJveHlVcmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtSZXF1ZXN0VmlhUHJveHkodXJsLCB0aGlzLnByb3h5VXJsLCBIdHRwTWV0aG9kLlBPU1QsIG9wdGlvbnMsIHRoaXMuY3VzdG9tQWdlbnRPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrUmVxdWVzdFZpYUh0dHBzKHVybCwgSHR0cE1ldGhvZC5QT1NULCBvcHRpb25zLCB0aGlzLmN1c3RvbUFnZW50T3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IG5ldHdvcmtSZXF1ZXN0VmlhUHJveHkgPSAoZGVzdGluYXRpb25VcmxTdHJpbmcsIHByb3h5VXJsU3RyaW5nLCBodHRwTWV0aG9kLCBvcHRpb25zLCBhZ2VudE9wdGlvbnMsIHRpbWVvdXQpID0+IHtcclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uVXJsID0gbmV3IFVSTChkZXN0aW5hdGlvblVybFN0cmluZyk7XHJcbiAgICBjb25zdCBwcm94eVVybCA9IG5ldyBVUkwocHJveHlVcmxTdHJpbmcpO1xyXG4gICAgLy8gXCJtZXRob2Q6IGNvbm5lY3RcIiBtdXN0IGJlIHVzZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byB0aGUgcHJveHlcclxuICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zPy5oZWFkZXJzIHx8IHt9O1xyXG4gICAgY29uc3QgdHVubmVsUmVxdWVzdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgaG9zdDogcHJveHlVcmwuaG9zdG5hbWUsXHJcbiAgICAgICAgcG9ydDogcHJveHlVcmwucG9ydCxcclxuICAgICAgICBtZXRob2Q6IFwiQ09OTkVDVFwiLFxyXG4gICAgICAgIHBhdGg6IGRlc3RpbmF0aW9uVXJsLmhvc3RuYW1lLFxyXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXHJcbiAgICB9O1xyXG4gICAgaWYgKGFnZW50T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhhZ2VudE9wdGlvbnMpLmxlbmd0aCkge1xyXG4gICAgICAgIHR1bm5lbFJlcXVlc3RPcHRpb25zLmFnZW50ID0gbmV3IGh0dHAuQWdlbnQoYWdlbnRPcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8vIGNvbXBvc2UgYSByZXF1ZXN0IHN0cmluZyBmb3IgdGhlIHNvY2tldFxyXG4gICAgbGV0IHBvc3RSZXF1ZXN0U3RyaW5nQ29udGVudCA9IFwiXCI7XHJcbiAgICBpZiAoaHR0cE1ldGhvZCA9PT0gSHR0cE1ldGhvZC5QT1NUKSB7XHJcbiAgICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnM/LmJvZHkgfHwgXCJcIjtcclxuICAgICAgICBwb3N0UmVxdWVzdFN0cmluZ0NvbnRlbnQgPVxyXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxyXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgYENvbnRlbnQtTGVuZ3RoOiAke2JvZHkubGVuZ3RofVxcclxcbmAgK1xyXG4gICAgICAgICAgICAgICAgYFxcclxcbiR7Ym9keX1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gb3B0aW9uYWwgdGltZW91dCBpcyBvbmx5IGZvciBnZXQgcmVxdWVzdHMgKHJlZ2lvbkRpc2NvdmVyeSwgZm9yIGV4YW1wbGUpXHJcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcclxuICAgICAgICAgICAgdHVubmVsUmVxdWVzdE9wdGlvbnMudGltZW91dCA9IHRpbWVvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0Z29pbmdSZXF1ZXN0U3RyaW5nID0gYCR7aHR0cE1ldGhvZC50b1VwcGVyQ2FzZSgpfSAke2Rlc3RpbmF0aW9uVXJsLmhyZWZ9IEhUVFAvMS4xXFxyXFxuYCArXHJcbiAgICAgICAgYEhvc3Q6ICR7ZGVzdGluYXRpb25VcmwuaG9zdH1cXHJcXG5gICtcclxuICAgICAgICBcIkNvbm5lY3Rpb246IGNsb3NlXFxyXFxuXCIgK1xyXG4gICAgICAgIHBvc3RSZXF1ZXN0U3RyaW5nQ29udGVudCArXHJcbiAgICAgICAgXCJcXHJcXG5cIjtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGh0dHAucmVxdWVzdCh0dW5uZWxSZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbihcInRpbWVvdXRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCB0aW1lIG91dFwiKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xyXG4gICAgICAgIC8vIGVzdGFibGlzaCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eVxyXG4gICAgICAgIHJlcXVlc3Qub24oXCJjb25uZWN0XCIsIChyZXNwb25zZSwgc29ja2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5U3RhdHVzQ29kZSA9IHJlc3BvbnNlPy5zdGF0dXNDb2RlIHx8IFByb3h5U3RhdHVzLlNFUlZFUl9FUlJPUjtcclxuICAgICAgICAgICAgaWYgKHByb3h5U3RhdHVzQ29kZSA8IFByb3h5U3RhdHVzLlNVQ0NFU1NfUkFOR0VfU1RBUlQgfHxcclxuICAgICAgICAgICAgICAgIHByb3h5U3RhdHVzQ29kZSA+IFByb3h5U3RhdHVzLlNVQ0NFU1NfUkFOR0VfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBFcnJvciBjb25uZWN0aW5nIHRvIHByb3h5LiBIdHRwIHN0YXR1cyBjb2RlOiAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9LiBIdHRwIHN0YXR1cyBtZXNzYWdlOiAke3Jlc3BvbnNlPy5zdGF0dXNNZXNzYWdlIHx8IFwiVW5rbm93blwifWApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtYWtlIGEgcmVxdWVzdCBvdmVyIGFuIEhUVFAgdHVubmVsXHJcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShvdXRnb2luZ1JlcXVlc3RTdHJpbmcpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XHJcbiAgICAgICAgICAgIHNvY2tldC5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc29ja2V0Lm9uKFwiZW5kXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbWJpbmUgYWxsIHJlY2VpdmVkIGJ1ZmZlciBzdHJlYW1zIGludG8gb25lIGJ1ZmZlciwgYW5kIHRoZW4gaW50byBhIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVN0cmluZyA9IEJ1ZmZlci5jb25jYXQoWy4uLmRhdGFdKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgZWFjaCBsaW5lIGludG8gaXQncyBvd24gZW50cnkgaW4gYW4gYXJyeVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVN0cmluZ0FycmF5ID0gZGF0YVN0cmluZy5zcGxpdChcIlxcclxcblwiKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBlbnRyeSB3aWxsIGNvbnRhaW4gdGhlIHN0YXR1c0NvZGUgYW5kIHN0YXR1c01lc3NhZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGh0dHBTdGF0dXNDb2RlID0gcGFyc2VJbnQoZGF0YVN0cmluZ0FycmF5WzBdLnNwbGl0KFwiIFwiKVsxXSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgXCJIVFRQLzEuMVwiIGFuZCB0aGUgc3RhdHVzIGNvZGUgdG8gZ2V0IHRoZSBzdGF0dXMgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IGRhdGFTdHJpbmdBcnJheVswXVxyXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdChcIiBcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMilcclxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBlbnRyeSB3aWxsIGNvbnRhaW4gdGhlIGJvZHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkYXRhU3RyaW5nQXJyYXlbZGF0YVN0cmluZ0FycmF5Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBlbnRyaWVzIGFyZSB0aGUgaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyc0FycmF5ID0gZGF0YVN0cmluZ0FycmF5LnNsaWNlKDEsIGRhdGFTdHJpbmdBcnJheS5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGFuIG9iamVjdCBvdXQgb2YgYWxsIHRoZSBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc0FycmF5LmZvckVhY2goKGhlYWRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBoZWFkZXIgbWlnaHQgbG9vayBsaWtlIFwiQ29udGVudC1MZW5ndGg6IDE1MzFcIiwgYnV0IHRoYXQgaXMganVzdCBhIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAqIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIGtleS92YWx1ZSBwYWlyXHJcbiAgICAgICAgICAgICAgICAgICAgICogc3BsaXQgdGhlIHN0cmluZyBhdCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgXCI6XCJcclxuICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBcIjpcIiBpZiB0aGUgdmFsdWUgb2YgdGhlIGhlYWRlciBpcyBzdXBwb3NlZCB0byBiZSBhIEpTT04gb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyS2V5VmFsdWUgPSBoZWFkZXIuc3BsaXQobmV3IFJlZ0V4cCgvOlxccyguKikvcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcktleSA9IGhlYWRlcktleVZhbHVlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXJWYWx1ZSA9IGhlYWRlcktleVZhbHVlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyIGlzIHN1cHBvc2VkIHRvIGJlIGEgSlNPTiBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmplY3QgPSBKU09OLnBhcnNlKGhlYWRlclZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMsIHRoZW4gY29udmVydCBpdCBmcm9tIGEgc3RyaW5nIHRvIGEgSlNPTiBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZSA9IG9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGxlYXZlIGl0IGFzIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMuc2V0KGhlYWRlcktleSwgaGVhZGVyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrUmVzcG9uc2UgPSBOZXR3b3JrVXRpbHMuZ2V0TmV0d29ya1Jlc3BvbnNlKHBhcnNlZEhlYWRlcnMsIHBhcnNlQm9keShodHRwU3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgcGFyc2VkSGVhZGVycywgYm9keSksIGh0dHBTdGF0dXNDb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmICgoaHR0cFN0YXR1c0NvZGUgPCBIdHRwU3RhdHVzLlNVQ0NFU1NfUkFOR0VfU1RBUlQgfHxcclxuICAgICAgICAgICAgICAgICAgICBodHRwU3RhdHVzQ29kZSA+IEh0dHBTdGF0dXMuU1VDQ0VTU19SQU5HRV9FTkQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGRlc3Ryb3kgdGhlIHJlcXVlc3QgZm9yIHRoZSBkZXZpY2UgY29kZSBmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Jlc3BvbnNlLmJvZHlbXCJlcnJvclwiXSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29uc3RhbnRzLkFVVEhPUklaQVRJT05fUEVORElORykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrUmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGNodW5rLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVxdWVzdC5vbihcImVycm9yXCIsIChjaHVuaykgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihjaHVuay50b1N0cmluZygpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgbmV0d29ya1JlcXVlc3RWaWFIdHRwcyA9ICh1cmxTdHJpbmcsIGh0dHBNZXRob2QsIG9wdGlvbnMsIGFnZW50T3B0aW9ucywgdGltZW91dCkgPT4ge1xyXG4gICAgY29uc3QgaXNQb3N0UmVxdWVzdCA9IGh0dHBNZXRob2QgPT09IEh0dHBNZXRob2QuUE9TVDtcclxuICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zPy5ib2R5IHx8IFwiXCI7XHJcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVybFN0cmluZyk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucz8uaGVhZGVycyB8fCB7fTtcclxuICAgIGNvbnN0IGN1c3RvbU9wdGlvbnMgPSB7XHJcbiAgICAgICAgbWV0aG9kOiBodHRwTWV0aG9kLFxyXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXHJcbiAgICAgICAgLi4uTmV0d29ya1V0aWxzLnVybFRvSHR0cE9wdGlvbnModXJsKSxcclxuICAgIH07XHJcbiAgICBpZiAoYWdlbnRPcHRpb25zICYmIE9iamVjdC5rZXlzKGFnZW50T3B0aW9ucykubGVuZ3RoKSB7XHJcbiAgICAgICAgY3VzdG9tT3B0aW9ucy5hZ2VudCA9IG5ldyBodHRwcy5BZ2VudChhZ2VudE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUG9zdFJlcXVlc3QpIHtcclxuICAgICAgICAvLyBuZWVkZWQgZm9yIHBvc3QgcmVxdWVzdCB0byB3b3JrXHJcbiAgICAgICAgY3VzdG9tT3B0aW9ucy5oZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAuLi5jdXN0b21PcHRpb25zLmhlYWRlcnMsXHJcbiAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogYm9keS5sZW5ndGgsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG9wdGlvbmFsIHRpbWVvdXQgaXMgb25seSBmb3IgZ2V0IHJlcXVlc3RzIChyZWdpb25EaXNjb3ZlcnksIGZvciBleGFtcGxlKVxyXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGN1c3RvbU9wdGlvbnMudGltZW91dCA9IHRpbWVvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgcmVxdWVzdDtcclxuICAgICAgICAvLyBtYW5hZ2VkIGlkZW50aXR5IHNvdXJjZXMgdXNlIGh0dHAgaW5zdGVhZCBvZiBodHRwc1xyXG4gICAgICAgIGlmIChjdXN0b21PcHRpb25zLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IGh0dHAucmVxdWVzdChjdXN0b21PcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGN1c3RvbU9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNQb3N0UmVxdWVzdCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LndyaXRlKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uKFwidGltZW91dFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0IHRpbWUgb3V0XCIpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgICAgICAgcmVxdWVzdC5vbihcInJlc3BvbnNlXCIsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c01lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNNZXNzYWdlO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XHJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHVuayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21iaW5lIGFsbCByZWNlaXZlZCBidWZmZXIgc3RyZWFtcyBpbnRvIG9uZSBidWZmZXIsIGFuZCB0aGVuIGludG8gYSBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBCdWZmZXIuY29uY2F0KFsuLi5kYXRhXSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhlYWRlcnMgPSBoZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV0d29ya1Jlc3BvbnNlID0gTmV0d29ya1V0aWxzLmdldE5ldHdvcmtSZXNwb25zZShwYXJzZWRIZWFkZXJzLCBwYXJzZUJvZHkoc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgcGFyc2VkSGVhZGVycywgYm9keSksIHN0YXR1c0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChzdGF0dXNDb2RlIDwgSHR0cFN0YXR1cy5TVUNDRVNTX1JBTkdFX1NUQVJUIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA+IEh0dHBTdGF0dXMuU1VDQ0VTU19SQU5HRV9FTkQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGRlc3Ryb3kgdGhlIHJlcXVlc3QgZm9yIHRoZSBkZXZpY2UgY29kZSBmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya1Jlc3BvbnNlLmJvZHlbXCJlcnJvclwiXSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29uc3RhbnRzLkFVVEhPUklaQVRJT05fUEVORElORykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrUmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGNodW5rLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG4vKipcclxuICogQ2hlY2sgaWYgZXh0cmEgcGFyc2luZyBpcyBuZWVkZWQgb24gdGhlIHJlcHNvbnNlIGZyb20gdGhlIHNlcnZlclxyXG4gKiBAcGFyYW0gc3RhdHVzQ29kZSB7bnVtYmVyfSB0aGUgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxyXG4gKiBAcGFyYW0gc3RhdHVzTWVzc2FnZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB0aGUgc3RhdHVzIG1lc3NhZ2Ugb2YgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxyXG4gKiBAcGFyYW0gaGVhZGVycyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gdGhlIGhlYWRlcnMgb2YgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxyXG4gKiBAcGFyYW0gYm9keSB7c3RyaW5nfSB0aGUgYm9keSBmcm9tIHRoZSByZXNwb25zZSBvZiB0aGUgc2VydmVyXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IEpTT04gcGFyc2VkIGJvZHkgb3IgZXJyb3Igb2JqZWN0XHJcbiAqL1xyXG5jb25zdCBwYXJzZUJvZHkgPSAoc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSkgPT4ge1xyXG4gICAgLypcclxuICAgICAqIEluZm9ybWF0aW9uYWwgcmVzcG9uc2VzICgxMDAg4oCTIDE5OSlcclxuICAgICAqIFN1Y2Nlc3NmdWwgcmVzcG9uc2VzICgyMDAg4oCTIDI5OSlcclxuICAgICAqIFJlZGlyZWN0aW9uIG1lc3NhZ2VzICgzMDAg4oCTIDM5OSlcclxuICAgICAqIENsaWVudCBlcnJvciByZXNwb25zZXMgKDQwMCDigJMgNDk5KVxyXG4gICAgICogU2VydmVyIGVycm9yIHJlc3BvbnNlcyAoNTAwIOKAkyA1OTkpXHJcbiAgICAgKi9cclxuICAgIGxldCBwYXJzZWRCb2R5O1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxldCBlcnJvclR5cGU7XHJcbiAgICAgICAgbGV0IGVycm9yRGVzY3JpcHRpb25IZWxwZXI7XHJcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gSHR0cFN0YXR1cy5DTElFTlRfRVJST1JfUkFOR0VfU1RBUlQgJiZcclxuICAgICAgICAgICAgc3RhdHVzQ29kZSA8PSBIdHRwU3RhdHVzLkNMSUVOVF9FUlJPUl9SQU5HRV9FTkQpIHtcclxuICAgICAgICAgICAgZXJyb3JUeXBlID0gXCJjbGllbnRfZXJyb3JcIjtcclxuICAgICAgICAgICAgZXJyb3JEZXNjcmlwdGlvbkhlbHBlciA9IFwiQSBjbGllbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzQ29kZSA+PSBIdHRwU3RhdHVzLlNFUlZFUl9FUlJPUl9SQU5HRV9TVEFSVCAmJlxyXG4gICAgICAgICAgICBzdGF0dXNDb2RlIDw9IEh0dHBTdGF0dXMuU0VSVkVSX0VSUk9SX1JBTkdFX0VORCkge1xyXG4gICAgICAgICAgICBlcnJvclR5cGUgPSBcInNlcnZlcl9lcnJvclwiO1xyXG4gICAgICAgICAgICBlcnJvckRlc2NyaXB0aW9uSGVscGVyID0gXCJBIHNlcnZlclwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JUeXBlID0gXCJ1bmtub3duX2Vycm9yXCI7XHJcbiAgICAgICAgICAgIGVycm9yRGVzY3JpcHRpb25IZWxwZXIgPSBcIkFuIHVua25vd25cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyc2VkQm9keSA9IHtcclxuICAgICAgICAgICAgZXJyb3I6IGVycm9yVHlwZSxcclxuICAgICAgICAgICAgZXJyb3JfZGVzY3JpcHRpb246IGAke2Vycm9yRGVzY3JpcHRpb25IZWxwZXJ9IGVycm9yIG9jY3VyZWQuXFxuSHR0cCBzdGF0dXMgY29kZTogJHtzdGF0dXNDb2RlfVxcbkh0dHAgc3RhdHVzIG1lc3NhZ2U6ICR7c3RhdHVzTWVzc2FnZSB8fCBcIlVua25vd25cIn1cXG5IZWFkZXJzOiAke0pTT04uc3RyaW5naWZ5KGhlYWRlcnMpfWAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWRCb2R5O1xyXG59O1xuXG5leHBvcnQgeyBIdHRwQ2xpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdHRwQ2xpZW50Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGludmFsaWRGaWxlRXh0ZW5zaW9uID0gXCJpbnZhbGlkX2ZpbGVfZXh0ZW5zaW9uXCI7XHJcbmNvbnN0IGludmFsaWRGaWxlUGF0aCA9IFwiaW52YWxpZF9maWxlX3BhdGhcIjtcclxuY29uc3QgaW52YWxpZE1hbmFnZWRJZGVudGl0eUlkVHlwZSA9IFwiaW52YWxpZF9tYW5hZ2VkX2lkZW50aXR5X2lkX3R5cGVcIjtcclxuY29uc3QgaW52YWxpZFNlY3JldCA9IFwiaW52YWxpZF9zZWNyZXRcIjtcclxuY29uc3QgbWlzc2luZ0lkID0gXCJtaXNzaW5nX2NsaWVudF9pZFwiO1xyXG5jb25zdCBuZXR3b3JrVW5hdmFpbGFibGUgPSBcIm5ldHdvcmtfdW5hdmFpbGFibGVcIjtcclxuY29uc3QgcGxhdGZvcm1Ob3RTdXBwb3J0ZWQgPSBcInBsYXRmb3JtX25vdF9zdXBwb3J0ZWRcIjtcclxuY29uc3QgdW5hYmxlVG9DcmVhdGVBenVyZUFyYyA9IFwidW5hYmxlX3RvX2NyZWF0ZV9henVyZV9hcmNcIjtcclxuY29uc3QgdW5hYmxlVG9DcmVhdGVDbG91ZFNoZWxsID0gXCJ1bmFibGVfdG9fY3JlYXRlX2Nsb3VkX3NoZWxsXCI7XHJcbmNvbnN0IHVuYWJsZVRvQ3JlYXRlU291cmNlID0gXCJ1bmFibGVfdG9fY3JlYXRlX3NvdXJjZVwiO1xyXG5jb25zdCB1bmFibGVUb1JlYWRTZWNyZXRGaWxlID0gXCJ1bmFibGVfdG9fcmVhZF9zZWNyZXRfZmlsZVwiO1xyXG5jb25zdCB1c2VyQXNzaWduZWROb3RBdmFpbGFibGVBdFJ1bnRpbWUgPSBcInVzZXJfYXNzaWduZWRfbm90X2F2YWlsYWJsZV9hdF9ydW50aW1lXCI7XHJcbmNvbnN0IHd3d0F1dGhlbnRpY2F0ZUhlYWRlck1pc3NpbmcgPSBcInd3d19hdXRoZW50aWNhdGVfaGVhZGVyX21pc3NpbmdcIjtcclxuY29uc3Qgd3d3QXV0aGVudGljYXRlSGVhZGVyVW5zdXBwb3J0ZWRGb3JtYXQgPSBcInd3d19hdXRoZW50aWNhdGVfaGVhZGVyX3Vuc3VwcG9ydGVkX2Zvcm1hdFwiO1xyXG5jb25zdCBNc2lFbnZpcm9ubWVudFZhcmlhYmxlVXJsTWFsZm9ybWVkRXJyb3JDb2RlcyA9IHtcclxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NUXTogXCJhenVyZV9wb2RfaWRlbnRpdHlfYXV0aG9yaXR5X2hvc3RfdXJsX21hbGZvcm1lZFwiLFxyXG4gICAgW01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JREVOVElUWV9FTkRQT0lOVF06IFwiaWRlbnRpdHlfZW5kcG9pbnRfdXJsX21hbGZvcm1lZFwiLFxyXG4gICAgW01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JTURTX0VORFBPSU5UXTogXCJpbWRzX2VuZHBvaW50X3VybF9tYWxmb3JtZWRcIixcclxuICAgIFtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuTVNJX0VORFBPSU5UXTogXCJtc2lfZW5kcG9pbnRfdXJsX21hbGZvcm1lZFwiLFxyXG59O1xuXG5leHBvcnQgeyBNc2lFbnZpcm9ubWVudFZhcmlhYmxlVXJsTWFsZm9ybWVkRXJyb3JDb2RlcywgaW52YWxpZEZpbGVFeHRlbnNpb24sIGludmFsaWRGaWxlUGF0aCwgaW52YWxpZE1hbmFnZWRJZGVudGl0eUlkVHlwZSwgaW52YWxpZFNlY3JldCwgbWlzc2luZ0lkLCBuZXR3b3JrVW5hdmFpbGFibGUsIHBsYXRmb3JtTm90U3VwcG9ydGVkLCB1bmFibGVUb0NyZWF0ZUF6dXJlQXJjLCB1bmFibGVUb0NyZWF0ZUNsb3VkU2hlbGwsIHVuYWJsZVRvQ3JlYXRlU291cmNlLCB1bmFibGVUb1JlYWRTZWNyZXRGaWxlLCB1c2VyQXNzaWduZWROb3RBdmFpbGFibGVBdFJ1bnRpbWUsIHd3d0F1dGhlbnRpY2F0ZUhlYWRlck1pc3NpbmcsIHd3d0F1dGhlbnRpY2F0ZUhlYWRlclVuc3VwcG9ydGVkRm9ybWF0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBpbnZhbGlkRmlsZUV4dGVuc2lvbiwgaW52YWxpZEZpbGVQYXRoLCBpbnZhbGlkTWFuYWdlZElkZW50aXR5SWRUeXBlLCBpbnZhbGlkU2VjcmV0LCBwbGF0Zm9ybU5vdFN1cHBvcnRlZCwgbWlzc2luZ0lkLCBNc2lFbnZpcm9ubWVudFZhcmlhYmxlVXJsTWFsZm9ybWVkRXJyb3JDb2RlcywgbmV0d29ya1VuYXZhaWxhYmxlLCB1bmFibGVUb0NyZWF0ZUF6dXJlQXJjLCB1bmFibGVUb0NyZWF0ZUNsb3VkU2hlbGwsIHVuYWJsZVRvQ3JlYXRlU291cmNlLCB1bmFibGVUb1JlYWRTZWNyZXRGaWxlLCB1c2VyQXNzaWduZWROb3RBdmFpbGFibGVBdFJ1bnRpbWUsIHd3d0F1dGhlbnRpY2F0ZUhlYWRlck1pc3NpbmcsIHd3d0F1dGhlbnRpY2F0ZUhlYWRlclVuc3VwcG9ydGVkRm9ybWF0IH0gZnJvbSAnLi9NYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLm1qcyc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNYW5hZ2VkSWRlbnRpdHlFcnJvck1lc3NhZ2UgY2xhc3MgY29udGFpbmluZyBzdHJpbmcgY29uc3RhbnRzIHVzZWQgYnkgZXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxyXG4gKi9cclxuY29uc3QgTWFuYWdlZElkZW50aXR5RXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIFtpbnZhbGlkRmlsZUV4dGVuc2lvbl06IFwiVGhlIGZpbGUgcGF0aCBpbiB0aGUgV1dXLUF1dGhlbnRpY2F0ZSBoZWFkZXIgZG9lcyBub3QgY29udGFpbiBhIC5rZXkgZmlsZS5cIixcclxuICAgIFtpbnZhbGlkRmlsZVBhdGhdOiBcIlRoZSBmaWxlIHBhdGggaW4gdGhlIFdXVy1BdXRoZW50aWNhdGUgaGVhZGVyIGlzIG5vdCBpbiBhIHZhbGlkIFdpbmRvd3Mgb3IgTGludXggRm9ybWF0LlwiLFxyXG4gICAgW2ludmFsaWRNYW5hZ2VkSWRlbnRpdHlJZFR5cGVdOiBcIk1vcmUgdGhhbiBvbmUgTWFuYWdlZElkZW50aXR5SWRUeXBlIHdhcyBwcm92aWRlZC5cIixcclxuICAgIFtpbnZhbGlkU2VjcmV0XTogXCJUaGUgc2VjcmV0IGluIHRoZSBmaWxlIG9uIHRoZSBmaWxlIHBhdGggaW4gdGhlIFdXVy1BdXRoZW50aWNhdGUgaGVhZGVyIGlzIGdyZWF0ZXIgdGhhbiA0MDk2IGJ5dGVzLlwiLFxyXG4gICAgW3BsYXRmb3JtTm90U3VwcG9ydGVkXTogXCJUaGUgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZCBieSBBenVyZSBBcmMuIEF6dXJlIEFyYyBvbmx5IHN1cHBvcnRzIFdpbmRvd3MgYW5kIExpbnV4LlwiLFxyXG4gICAgW21pc3NpbmdJZF06IFwiQSBNYW5hZ2VkSWRlbnRpdHlJZCBpZCB3YXMgbm90IHByb3ZpZGVkLlwiLFxyXG4gICAgW01zaUVudmlyb25tZW50VmFyaWFibGVVcmxNYWxmb3JtZWRFcnJvckNvZGVzXHJcbiAgICAgICAgLkFaVVJFX1BPRF9JREVOVElUWV9BVVRIT1JJVFlfSE9TVF06IGBUaGUgTWFuYWdlZCBJZGVudGl0eSdzICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1R9JyBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtYWxmb3JtZWQuYCxcclxuICAgIFtNc2lFbnZpcm9ubWVudFZhcmlhYmxlVXJsTWFsZm9ybWVkRXJyb3JDb2Rlc1xyXG4gICAgICAgIC5JREVOVElUWV9FTkRQT0lOVF06IGBUaGUgTWFuYWdlZCBJZGVudGl0eSdzICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JREVOVElUWV9FTkRQT0lOVH0nIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1hbGZvcm1lZC5gLFxyXG4gICAgW01zaUVudmlyb25tZW50VmFyaWFibGVVcmxNYWxmb3JtZWRFcnJvckNvZGVzXHJcbiAgICAgICAgLklNRFNfRU5EUE9JTlRdOiBgVGhlIE1hbmFnZWQgSWRlbnRpdHkncyAnJHtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSU1EU19FTkRQT0lOVH0nIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1hbGZvcm1lZC5gLFxyXG4gICAgW01zaUVudmlyb25tZW50VmFyaWFibGVVcmxNYWxmb3JtZWRFcnJvckNvZGVzXHJcbiAgICAgICAgLk1TSV9FTkRQT0lOVF06IGBUaGUgTWFuYWdlZCBJZGVudGl0eSdzICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5NU0lfRU5EUE9JTlR9JyBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtYWxmb3JtZWQuYCxcclxuICAgIFtuZXR3b3JrVW5hdmFpbGFibGVdOiBcIkF1dGhlbnRpY2F0aW9uIHVuYXZhaWxhYmxlLiBUaGUgcmVxdWVzdCB0byB0aGUgbWFuYWdlZCBpZGVudGl0eSBlbmRwb2ludCB0aW1lZCBvdXQuXCIsXHJcbiAgICBbdW5hYmxlVG9DcmVhdGVBenVyZUFyY106IFwiQXp1cmUgQXJjIE1hbmFnZWQgSWRlbnRpdGllcyBjYW4gb25seSBiZSBzeXN0ZW0gYXNzaWduZWQuXCIsXHJcbiAgICBbdW5hYmxlVG9DcmVhdGVDbG91ZFNoZWxsXTogXCJDbG91ZCBTaGVsbCBNYW5hZ2VkIElkZW50aXRpZXMgY2FuIG9ubHkgYmUgc3lzdGVtIGFzc2lnbmVkLlwiLFxyXG4gICAgW3VuYWJsZVRvQ3JlYXRlU291cmNlXTogXCJVbmFibGUgdG8gY3JlYXRlIGEgTWFuYWdlZCBJZGVudGl0eSBzb3VyY2UgYmFzZWQgb24gZW52aXJvbm1lbnQgdmFyaWFibGVzLlwiLFxyXG4gICAgW3VuYWJsZVRvUmVhZFNlY3JldEZpbGVdOiBcIlVuYWJsZSB0byByZWFkIHRoZSBzZWNyZXQgZmlsZS5cIixcclxuICAgIFt1c2VyQXNzaWduZWROb3RBdmFpbGFibGVBdFJ1bnRpbWVdOiBcIlNlcnZpY2UgRmFicmljIHVzZXIgYXNzaWduZWQgbWFuYWdlZCBpZGVudGl0eSBDbGllbnRJZCBvciBSZXNvdXJjZUlkIGlzIG5vdCBjb25maWd1cmFibGUgYXQgcnVudGltZS5cIixcclxuICAgIFt3d3dBdXRoZW50aWNhdGVIZWFkZXJNaXNzaW5nXTogXCJBIDQwMSByZXNwb25zZSB3YXMgcmVjZWl2ZWQgZm9ybSB0aGUgQXp1cmUgQXJjIE1hbmFnZWQgSWRlbnRpdHksIGJ1dCB0aGUgd3d3LWF1dGhlbnRpY2F0ZSBoZWFkZXIgaXMgbWlzc2luZy5cIixcclxuICAgIFt3d3dBdXRoZW50aWNhdGVIZWFkZXJVbnN1cHBvcnRlZEZvcm1hdF06IFwiQSA0MDEgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkIGZvcm0gdGhlIEF6dXJlIEFyYyBNYW5hZ2VkIElkZW50aXR5LCBidXQgdGhlIHd3dy1hdXRoZW50aWNhdGUgaGVhZGVyIGlzIGluIGFuIHVuc3VwcG9ydGVkIGZvcm1hdC5cIixcclxufTtcclxuY2xhc3MgTWFuYWdlZElkZW50aXR5RXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlKSB7XHJcbiAgICAgICAgc3VwZXIoZXJyb3JDb2RlLCBNYW5hZ2VkSWRlbnRpdHlFcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0pO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiTWFuYWdlZElkZW50aXR5RXJyb3JcIjtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWFuYWdlZElkZW50aXR5RXJyb3IucHJvdG90eXBlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvcihlcnJvckNvZGUpIHtcclxuICAgIHJldHVybiBuZXcgTWFuYWdlZElkZW50aXR5RXJyb3IoZXJyb3JDb2RlKTtcclxufVxuXG5leHBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlFcnJvciwgTWFuYWdlZElkZW50aXR5RXJyb3JNZXNzYWdlcywgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hbmFnZWRJZGVudGl0eUVycm9yLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvciB9IGZyb20gJy4uL2Vycm9yL01hbmFnZWRJZGVudGl0eUVycm9yLm1qcyc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUsIERFRkFVTFRfTUFOQUdFRF9JREVOVElUWV9JRCB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgaW52YWxpZE1hbmFnZWRJZGVudGl0eUlkVHlwZSB9IGZyb20gJy4uL2Vycm9yL01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE1hbmFnZWRJZGVudGl0eUlkIHtcclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgaWQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlkVHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faWRUeXBlO1xyXG4gICAgfVxyXG4gICAgc2V0IGlkVHlwZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2lkVHlwZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IobWFuYWdlZElkZW50aXR5SWRQYXJhbXMpIHtcclxuICAgICAgICBjb25zdCB1c2VyQXNzaWduZWRDbGllbnRJZCA9IG1hbmFnZWRJZGVudGl0eUlkUGFyYW1zPy51c2VyQXNzaWduZWRDbGllbnRJZDtcclxuICAgICAgICBjb25zdCB1c2VyQXNzaWduZWRSZXNvdXJjZUlkID0gbWFuYWdlZElkZW50aXR5SWRQYXJhbXM/LnVzZXJBc3NpZ25lZFJlc291cmNlSWQ7XHJcbiAgICAgICAgY29uc3QgdXNlckFzc2lnbmVkT2JqZWN0SWQgPSBtYW5hZ2VkSWRlbnRpdHlJZFBhcmFtcz8udXNlckFzc2lnbmVkT2JqZWN0SWQ7XHJcbiAgICAgICAgaWYgKHVzZXJBc3NpZ25lZENsaWVudElkKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VyQXNzaWduZWRSZXNvdXJjZUlkIHx8IHVzZXJBc3NpZ25lZE9iamVjdElkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvcihpbnZhbGlkTWFuYWdlZElkZW50aXR5SWRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlkID0gdXNlckFzc2lnbmVkQ2xpZW50SWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaWRUeXBlID0gTWFuYWdlZElkZW50aXR5SWRUeXBlLlVTRVJfQVNTSUdORURfQ0xJRU5UX0lEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh1c2VyQXNzaWduZWRSZXNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VyQXNzaWduZWRDbGllbnRJZCB8fCB1c2VyQXNzaWduZWRPYmplY3RJZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IoaW52YWxpZE1hbmFnZWRJZGVudGl0eUlkVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pZCA9IHVzZXJBc3NpZ25lZFJlc291cmNlSWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaWRUeXBlID0gTWFuYWdlZElkZW50aXR5SWRUeXBlLlVTRVJfQVNTSUdORURfUkVTT1VSQ0VfSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHVzZXJBc3NpZ25lZE9iamVjdElkKSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VyQXNzaWduZWRDbGllbnRJZCB8fCB1c2VyQXNzaWduZWRSZXNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvcihpbnZhbGlkTWFuYWdlZElkZW50aXR5SWRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlkID0gdXNlckFzc2lnbmVkT2JqZWN0SWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaWRUeXBlID0gTWFuYWdlZElkZW50aXR5SWRUeXBlLlVTRVJfQVNTSUdORURfT0JKRUNUX0lEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IERFRkFVTFRfTUFOQUdFRF9JREVOVElUWV9JRDtcclxuICAgICAgICAgICAgdGhpcy5pZFR5cGUgPSBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUuU1lTVEVNX0FTU0lHTkVEO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlJZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFuYWdlZElkZW50aXR5SWQubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbi9ub2RlJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBOb2RlQXV0aEVycm9yTWVzc2FnZSBjbGFzcyBjb250YWluaW5nIHN0cmluZyBjb25zdGFudHMgdXNlZCBieSBlcnJvciBjb2RlcyBhbmQgbWVzc2FnZXMuXHJcbiAqL1xyXG5jb25zdCBOb2RlQXV0aEVycm9yTWVzc2FnZSA9IHtcclxuICAgIGludmFsaWRMb29wYmFja0FkZHJlc3NUeXBlOiB7XHJcbiAgICAgICAgY29kZTogXCJpbnZhbGlkX2xvb3BiYWNrX3NlcnZlcl9hZGRyZXNzX3R5cGVcIixcclxuICAgICAgICBkZXNjOiBcIkxvb3BiYWNrIHNlcnZlciBhZGRyZXNzIGlzIG5vdCB0eXBlIHN0cmluZy4gVGhpcyBpcyB1bmV4cGVjdGVkLlwiLFxyXG4gICAgfSxcclxuICAgIHVuYWJsZVRvTG9hZFJlZGlyZWN0VXJpOiB7XHJcbiAgICAgICAgY29kZTogXCJ1bmFibGVfdG9fbG9hZF9yZWRpcmVjdFVybFwiLFxyXG4gICAgICAgIGRlc2M6IFwiTG9vcGJhY2sgc2VydmVyIGNhbGxiYWNrIHdhcyBpbnZva2VkIHdpdGhvdXQgYSB1cmwuIFRoaXMgaXMgdW5leHBlY3RlZC5cIixcclxuICAgIH0sXHJcbiAgICBub0F1dGhDb2RlSW5SZXNwb25zZToge1xyXG4gICAgICAgIGNvZGU6IFwibm9fYXV0aF9jb2RlX2luX3Jlc3BvbnNlXCIsXHJcbiAgICAgICAgZGVzYzogXCJObyBhdXRoIGNvZGUgZm91bmQgaW4gdGhlIHNlcnZlciByZXNwb25zZS4gUGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayB0cmFjZSB0byBkZXRlcm1pbmUgd2hhdCBoYXBwZW5lZC5cIixcclxuICAgIH0sXHJcbiAgICBub0xvb3BiYWNrU2VydmVyRXhpc3RzOiB7XHJcbiAgICAgICAgY29kZTogXCJub19sb29wYmFja19zZXJ2ZXJfZXhpc3RzXCIsXHJcbiAgICAgICAgZGVzYzogXCJObyBsb29wYmFjayBzZXJ2ZXIgZXhpc3RzIHlldC5cIixcclxuICAgIH0sXHJcbiAgICBsb29wYmFja1NlcnZlckFscmVhZHlFeGlzdHM6IHtcclxuICAgICAgICBjb2RlOiBcImxvb3BiYWNrX3NlcnZlcl9hbHJlYWR5X2V4aXN0c1wiLFxyXG4gICAgICAgIGRlc2M6IFwiTG9vcGJhY2sgc2VydmVyIGFscmVhZHkgZXhpc3RzLiBDYW5ub3QgY3JlYXRlIGFub3RoZXIuXCIsXHJcbiAgICB9LFxyXG4gICAgbG9vcGJhY2tTZXJ2ZXJUaW1lb3V0OiB7XHJcbiAgICAgICAgY29kZTogXCJsb29wYmFja19zZXJ2ZXJfdGltZW91dFwiLFxyXG4gICAgICAgIGRlc2M6IFwiVGltZWQgb3V0IHdhaXRpbmcgZm9yIGF1dGggY29kZSBsaXN0ZW5lciB0byBiZSByZWdpc3RlcmVkLlwiLFxyXG4gICAgfSxcclxuICAgIHN0YXRlTm90Rm91bmRFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IFwic3RhdGVfbm90X2ZvdW5kXCIsXHJcbiAgICAgICAgZGVzYzogXCJTdGF0ZSBub3QgZm91bmQuIFBsZWFzZSB2ZXJpZnkgdGhhdCB0aGUgcmVxdWVzdCBvcmlnaW5hdGVkIGZyb20gbXNhbC5cIixcclxuICAgIH0sXHJcbiAgICB0aHVtYnByaW50TWlzc2luZzoge1xyXG4gICAgICAgIGNvZGU6IFwidGh1bWJwcmludF9taXNzaW5nX2Zyb21fY2xpZW50X2NlcnRpZmljYXRlXCIsXHJcbiAgICAgICAgZGVzYzogXCJDbGllbnQgY2VydGlmaWNhdGUgZG9lcyBub3QgY29udGFpbiBhIFNIQS0xIG9yIFNIQS0yNTYgdGh1bWJwcmludC5cIixcclxuICAgIH0sXHJcbn07XHJcbmNsYXNzIE5vZGVBdXRoRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcihlcnJvckNvZGUsIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOb2RlQXV0aEVycm9yXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIGxvb3BiYWNrIHNlcnZlciBhZGRyZXNzIGlzIG9mIHR5cGUgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlSW52YWxpZExvb3BiYWNrQWRkcmVzc1R5cGVFcnJvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5vZGVBdXRoRXJyb3IoTm9kZUF1dGhFcnJvck1lc3NhZ2UuaW52YWxpZExvb3BiYWNrQWRkcmVzc1R5cGUuY29kZSwgYCR7Tm9kZUF1dGhFcnJvck1lc3NhZ2UuaW52YWxpZExvb3BiYWNrQWRkcmVzc1R5cGUuZGVzY31gKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gaWYgdGhlIGxvb3BiYWNrIHNlcnZlciBpcyB1bmFibGUgdG8gZ2V0IGEgdXJsLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlVW5hYmxlVG9Mb2FkUmVkaXJlY3RVcmxFcnJvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5vZGVBdXRoRXJyb3IoTm9kZUF1dGhFcnJvck1lc3NhZ2UudW5hYmxlVG9Mb2FkUmVkaXJlY3RVcmkuY29kZSwgYCR7Tm9kZUF1dGhFcnJvck1lc3NhZ2UudW5hYmxlVG9Mb2FkUmVkaXJlY3RVcmkuZGVzY31gKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gaWYgdGhlIHNlcnZlciByZXNwb25zZSBkb2VzIG5vdCBjb250YWluIGFuIGF1dGggY29kZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZU5vQXV0aENvZGVJblJlc3BvbnNlRXJyb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQXV0aEVycm9yKE5vZGVBdXRoRXJyb3JNZXNzYWdlLm5vQXV0aENvZGVJblJlc3BvbnNlLmNvZGUsIGAke05vZGVBdXRoRXJyb3JNZXNzYWdlLm5vQXV0aENvZGVJblJlc3BvbnNlLmRlc2N9YCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIHRoZSBsb29wYmFjayBzZXJ2ZXIgaGFzIG5vdCBiZWVuIHNwdW4gdXAgeWV0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlTm9Mb29wYmFja1NlcnZlckV4aXN0c0Vycm9yKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTm9kZUF1dGhFcnJvcihOb2RlQXV0aEVycm9yTWVzc2FnZS5ub0xvb3BiYWNrU2VydmVyRXhpc3RzLmNvZGUsIGAke05vZGVBdXRoRXJyb3JNZXNzYWdlLm5vTG9vcGJhY2tTZXJ2ZXJFeGlzdHMuZGVzY31gKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gaWYgYSBsb29wYmFjayBzZXJ2ZXIgYWxyZWFkeSBleGlzdHMgd2hlbiBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhbm90aGVyIG9uZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUxvb3BiYWNrU2VydmVyQWxyZWFkeUV4aXN0c0Vycm9yKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTm9kZUF1dGhFcnJvcihOb2RlQXV0aEVycm9yTWVzc2FnZS5sb29wYmFja1NlcnZlckFscmVhZHlFeGlzdHMuY29kZSwgYCR7Tm9kZUF1dGhFcnJvck1lc3NhZ2UubG9vcGJhY2tTZXJ2ZXJBbHJlYWR5RXhpc3RzLmRlc2N9YCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXJyb3IgdGhyb3duIGlmIHRoZSBsb29wYmFjayBzZXJ2ZXIgdGltZXMgb3V0IHJlZ2lzdGVyaW5nIHRoZSBhdXRoIGNvZGUgbGlzdGVuZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVMb29wYmFja1NlcnZlclRpbWVvdXRFcnJvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5vZGVBdXRoRXJyb3IoTm9kZUF1dGhFcnJvck1lc3NhZ2UubG9vcGJhY2tTZXJ2ZXJUaW1lb3V0LmNvZGUsIGAke05vZGVBdXRoRXJyb3JNZXNzYWdlLmxvb3BiYWNrU2VydmVyVGltZW91dC5kZXNjfWApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIHRocm93biB3aGVuIHRoZSBzdGF0ZSBpcyBub3QgcHJlc2VudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVN0YXRlTm90Rm91bmRFcnJvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5vZGVBdXRoRXJyb3IoTm9kZUF1dGhFcnJvck1lc3NhZ2Uuc3RhdGVOb3RGb3VuZEVycm9yLmNvZGUsIE5vZGVBdXRoRXJyb3JNZXNzYWdlLnN0YXRlTm90Rm91bmRFcnJvci5kZXNjKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciB0aHJvd24gd2hlbiBjbGllbnQgY2VydGlmaWNhdGUgd2FzIHByb3ZpZGVkLCBidXQgbmVpdGhlciB0aGUgU0hBLTEgb3IgU0hBLTI1NiB0aHVtYnByaW50cyB3ZXJlIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVUaHVtYnByaW50TWlzc2luZ0Vycm9yKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTm9kZUF1dGhFcnJvcihOb2RlQXV0aEVycm9yTWVzc2FnZS50aHVtYnByaW50TWlzc2luZy5jb2RlLCBOb2RlQXV0aEVycm9yTWVzc2FnZS50aHVtYnByaW50TWlzc2luZy5kZXNjKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBOb2RlQXV0aEVycm9yLCBOb2RlQXV0aEVycm9yTWVzc2FnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9kZUF1dGhFcnJvci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBQcm90b2NvbE1vZGUsIEF6dXJlQ2xvdWRJbnN0YW5jZSwgTG9nTGV2ZWwgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnLi4vbmV0d29yay9IdHRwQ2xpZW50Lm1qcyc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlJZCB9IGZyb20gJy4vTWFuYWdlZElkZW50aXR5SWQubWpzJztcbmltcG9ydCB7IE5vZGVBdXRoRXJyb3IgfSBmcm9tICcuLi9lcnJvci9Ob2RlQXV0aEVycm9yLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUyA9IHtcclxuICAgIGNsaWVudElkOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgYXV0aG9yaXR5OiBDb25zdGFudHMuREVGQVVMVF9BVVRIT1JJVFksXHJcbiAgICBjbGllbnRTZWNyZXQ6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICBjbGllbnRBc3NlcnRpb246IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICBjbGllbnRDZXJ0aWZpY2F0ZToge1xyXG4gICAgICAgIHRodW1icHJpbnQ6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICAgICAgdGh1bWJwcmludFNoYTI1NjogQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgICAgICBwcml2YXRlS2V5OiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgIHg1YzogQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgIH0sXHJcbiAgICBrbm93bkF1dGhvcml0aWVzOiBbXSxcclxuICAgIGNsb3VkRGlzY292ZXJ5TWV0YWRhdGE6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICBhdXRob3JpdHlNZXRhZGF0YTogQ29uc3RhbnRzLkVNUFRZX1NUUklORyxcclxuICAgIGNsaWVudENhcGFiaWxpdGllczogW10sXHJcbiAgICBwcm90b2NvbE1vZGU6IFByb3RvY29sTW9kZS5BQUQsXHJcbiAgICBhenVyZUNsb3VkT3B0aW9uczoge1xyXG4gICAgICAgIGF6dXJlQ2xvdWRJbnN0YW5jZTogQXp1cmVDbG91ZEluc3RhbmNlLk5vbmUsXHJcbiAgICAgICAgdGVuYW50OiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgfSxcclxuICAgIHNraXBBdXRob3JpdHlNZXRhZGF0YUNhY2hlOiBmYWxzZSxcclxuICAgIGVuY29kZUV4dHJhUXVlcnlQYXJhbXM6IGZhbHNlLFxyXG59O1xyXG5jb25zdCBERUZBVUxUX0NBQ0hFX09QVElPTlMgPSB7XHJcbiAgICBjbGFpbXNCYXNlZENhY2hpbmdFbmFibGVkOiBmYWxzZSxcclxufTtcclxuY29uc3QgREVGQVVMVF9MT0dHRVJfT1BUSU9OUyA9IHtcclxuICAgIGxvZ2dlckNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgLy8gYWxsb3cgdXNlcnMgdG8gbm90IHNldCBsb2dnZXIgY2FsbCBiYWNrXHJcbiAgICB9LFxyXG4gICAgcGlpTG9nZ2luZ0VuYWJsZWQ6IGZhbHNlLFxyXG4gICAgbG9nTGV2ZWw6IExvZ0xldmVsLkluZm8sXHJcbn07XHJcbmNvbnN0IERFRkFVTFRfU1lTVEVNX09QVElPTlMgPSB7XHJcbiAgICBsb2dnZXJPcHRpb25zOiBERUZBVUxUX0xPR0dFUl9PUFRJT05TLFxyXG4gICAgbmV0d29ya0NsaWVudDogbmV3IEh0dHBDbGllbnQoKSxcclxuICAgIHByb3h5VXJsOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgY3VzdG9tQWdlbnRPcHRpb25zOiB7fSxcclxuICAgIGRpc2FibGVJbnRlcm5hbFJldHJpZXM6IGZhbHNlLFxyXG59O1xyXG5jb25zdCBERUZBVUxUX1RFTEVNRVRSWV9PUFRJT05TID0ge1xyXG4gICAgYXBwbGljYXRpb246IHtcclxuICAgICAgICBhcHBOYW1lOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgIGFwcFZlcnNpb246IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogU2V0cyB0aGUgZGVmYXVsdCBvcHRpb25zIHdoZW4gbm90IGV4cGxpY2l0bHkgY29uZmlndXJlZCBmcm9tIGFwcCBkZXZlbG9wZXJcclxuICpcclxuICogQHBhcmFtIGF1dGggLSBBdXRoZW50aWNhdGlvbiBvcHRpb25zXHJcbiAqIEBwYXJhbSBjYWNoZSAtIENhY2hlIG9wdGlvbnNcclxuICogQHBhcmFtIHN5c3RlbSAtIFN5c3RlbSBvcHRpb25zXHJcbiAqIEBwYXJhbSB0ZWxlbWV0cnkgLSBUZWxlbWV0cnkgb3B0aW9uc1xyXG4gKlxyXG4gKiBAcmV0dXJucyBDb25maWd1cmF0aW9uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRBcHBDb25maWd1cmF0aW9uKHsgYXV0aCwgYnJva2VyLCBjYWNoZSwgc3lzdGVtLCB0ZWxlbWV0cnksIH0pIHtcclxuICAgIGNvbnN0IHN5c3RlbU9wdGlvbnMgPSB7XHJcbiAgICAgICAgLi4uREVGQVVMVF9TWVNURU1fT1BUSU9OUyxcclxuICAgICAgICBuZXR3b3JrQ2xpZW50OiBuZXcgSHR0cENsaWVudChzeXN0ZW0/LnByb3h5VXJsLCBzeXN0ZW0/LmN1c3RvbUFnZW50T3B0aW9ucyksXHJcbiAgICAgICAgbG9nZ2VyT3B0aW9uczogc3lzdGVtPy5sb2dnZXJPcHRpb25zIHx8IERFRkFVTFRfTE9HR0VSX09QVElPTlMsXHJcbiAgICAgICAgZGlzYWJsZUludGVybmFsUmV0cmllczogc3lzdGVtPy5kaXNhYmxlSW50ZXJuYWxSZXRyaWVzIHx8IGZhbHNlLFxyXG4gICAgfTtcclxuICAgIC8vIGlmIGNsaWVudCBjZXJ0aWZpY2F0ZSB3YXMgcHJvdmlkZWQsIGVuc3VyZSB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgU0hBLTEgb3IgU0hBLTI1NiB0aHVtYnByaW50cyB3ZXJlIHByb3ZpZGVkXHJcbiAgICBpZiAoISFhdXRoLmNsaWVudENlcnRpZmljYXRlICYmXHJcbiAgICAgICAgISEhYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZS50aHVtYnByaW50ICYmXHJcbiAgICAgICAgISEhYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZS50aHVtYnByaW50U2hhMjU2KSB7XHJcbiAgICAgICAgdGhyb3cgTm9kZUF1dGhFcnJvci5jcmVhdGVTdGF0ZU5vdEZvdW5kRXJyb3IoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXV0aDogeyAuLi5ERUZBVUxUX0FVVEhfT1BUSU9OUywgLi4uYXV0aCB9LFxyXG4gICAgICAgIGJyb2tlcjogeyAuLi5icm9rZXIgfSxcclxuICAgICAgICBjYWNoZTogeyAuLi5ERUZBVUxUX0NBQ0hFX09QVElPTlMsIC4uLmNhY2hlIH0sXHJcbiAgICAgICAgc3lzdGVtOiB7IC4uLnN5c3RlbU9wdGlvbnMsIC4uLnN5c3RlbSB9LFxyXG4gICAgICAgIHRlbGVtZXRyeTogeyAuLi5ERUZBVUxUX1RFTEVNRVRSWV9PUFRJT05TLCAuLi50ZWxlbWV0cnkgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRNYW5hZ2VkSWRlbnRpdHlDb25maWd1cmF0aW9uKHsgY2xpZW50Q2FwYWJpbGl0aWVzLCBtYW5hZ2VkSWRlbnRpdHlJZFBhcmFtcywgc3lzdGVtLCB9KSB7XHJcbiAgICBjb25zdCBtYW5hZ2VkSWRlbnRpdHlJZCA9IG5ldyBNYW5hZ2VkSWRlbnRpdHlJZChtYW5hZ2VkSWRlbnRpdHlJZFBhcmFtcyk7XHJcbiAgICBjb25zdCBsb2dnZXJPcHRpb25zID0gc3lzdGVtPy5sb2dnZXJPcHRpb25zIHx8IERFRkFVTFRfTE9HR0VSX09QVElPTlM7XHJcbiAgICBsZXQgbmV0d29ya0NsaWVudDtcclxuICAgIC8vIHVzZSBkZXZlbG9wZXIgcHJvdmlkZWQgbmV0d29yayBjbGllbnQgaWYgcGFzc2VkIGluXHJcbiAgICBpZiAoc3lzdGVtPy5uZXR3b3JrQ2xpZW50KSB7XHJcbiAgICAgICAgbmV0d29ya0NsaWVudCA9IHN5c3RlbS5uZXR3b3JrQ2xpZW50O1xyXG4gICAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IG9uZVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbmV0d29ya0NsaWVudCA9IG5ldyBIdHRwQ2xpZW50KHN5c3RlbT8ucHJveHlVcmwsIHN5c3RlbT8uY3VzdG9tQWdlbnRPcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xpZW50Q2FwYWJpbGl0aWVzOiBjbGllbnRDYXBhYmlsaXRpZXMgfHwgW10sXHJcbiAgICAgICAgbWFuYWdlZElkZW50aXR5SWQ6IG1hbmFnZWRJZGVudGl0eUlkLFxyXG4gICAgICAgIHN5c3RlbToge1xyXG4gICAgICAgICAgICBsb2dnZXJPcHRpb25zLFxyXG4gICAgICAgICAgICBuZXR3b3JrQ2xpZW50LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzYWJsZUludGVybmFsUmV0cmllczogc3lzdGVtPy5kaXNhYmxlSW50ZXJuYWxSZXRyaWVzIHx8IGZhbHNlLFxyXG4gICAgfTtcclxufVxuXG5leHBvcnQgeyBidWlsZEFwcENvbmZpZ3VyYXRpb24sIGJ1aWxkTWFuYWdlZElkZW50aXR5Q29uZmlndXJhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uZmlndXJhdGlvbi5tanMubWFwXG4iLCJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5cbmxldCBwb29sUHRyID0gcm5kczhQb29sLmxlbmd0aDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKHBvb2xQdHIgPiBybmRzOFBvb2wubGVuZ3RoIC0gMTYpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczhQb29sKTtcbiAgICBwb29sUHRyID0gMDtcbiAgfVxuXG4gIHJldHVybiBybmRzOFBvb2wuc2xpY2UocG9vbFB0ciwgcG9vbFB0ciArPSAxNik7XG59IiwiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgY29uc3QgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyB2NCB9IGZyb20gJ3V1aWQnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgR3VpZEdlbmVyYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBSRkM0MTIyOiBUaGUgdmVyc2lvbiA0IFVVSUQgaXMgbWVhbnQgZm9yIGdlbmVyYXRpbmcgVVVJRHMgZnJvbSB0cnVseS1yYW5kb20gb3IgcHNldWRvLXJhbmRvbSBudW1iZXJzLlxyXG4gICAgICogdXVpZHY0IGdlbmVyYXRlcyBndWlkcyBmcm9tIGNyeXBydG9ncmFwaGljYWxseS1zdHJpbmcgcmFuZG9tXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlR3VpZCgpIHtcclxuICAgICAgICByZXR1cm4gdjQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogdmVyaWZpZXMgaWYgYSBzdHJpbmcgaXMgIEdVSURcclxuICAgICAqIEBwYXJhbSBndWlkXHJcbiAgICAgKi9cclxuICAgIGlzR3VpZChndWlkKSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXhHdWlkID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaTtcclxuICAgICAgICByZXR1cm4gcmVnZXhHdWlkLnRlc3QoZ3VpZCk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgR3VpZEdlbmVyYXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3VpZEdlbmVyYXRvci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgRW5jb2RpbmdUeXBlcywgQ29uc3RhbnRzIH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRW5jb2RpbmdVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqICd1dGY4JzogTXVsdGlieXRlIGVuY29kZWQgVW5pY29kZSBjaGFyYWN0ZXJzLiBNYW55IHdlYiBwYWdlcyBhbmQgb3RoZXIgZG9jdW1lbnQgZm9ybWF0cyB1c2UgVVRGLTguXHJcbiAgICAgKiAnYmFzZTY0JzogQmFzZTY0IGVuY29kaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHIgdGV4dFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYmFzZTY0RW5jb2RlKHN0ciwgZW5jb2RpbmcpIHtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBlbmNvZGluZykudG9TdHJpbmcoRW5jb2RpbmdUeXBlcy5CQVNFNjQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBlbmNvZGUgYSBVUkxcclxuICAgICAqIEBwYXJhbSBzdHJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJhc2U2NEVuY29kZVVybChzdHIsIGVuY29kaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RW5jb2RlKHN0ciwgZW5jb2RpbmcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC89L2csIENvbnN0YW50cy5FTVBUWV9TVFJJTkcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAndXRmOCc6IE11bHRpYnl0ZSBlbmNvZGVkIFVuaWNvZGUgY2hhcmFjdGVycy4gTWFueSB3ZWIgcGFnZXMgYW5kIG90aGVyIGRvY3VtZW50IGZvcm1hdHMgdXNlIFVURi04LlxyXG4gICAgICogJ2Jhc2U2NCc6IEJhc2U2NCBlbmNvZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmFzZTY0U3RyIEJhc2U2NCBlbmNvZGVkIHRleHRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJhc2U2NERlY29kZShiYXNlNjRTdHIpIHtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYmFzZTY0U3RyLCBFbmNvZGluZ1R5cGVzLkJBU0U2NCkudG9TdHJpbmcoXCJ1dGY4XCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYmFzZTY0U3RyIEJhc2U2NCBlbmNvZGVkIFVybFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYmFzZTY0RGVjb2RlVXJsKGJhc2U2NFN0cikge1xyXG4gICAgICAgIGxldCBzdHIgPSBiYXNlNjRTdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XHJcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggJSA0KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSBcIj1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RGVjb2RlKHN0cik7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgRW5jb2RpbmdVdGlscyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW5jb2RpbmdVdGlscy5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgSGFzaCB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgSGFzaFV0aWxzIHtcclxuICAgIC8qKlxyXG4gICAgICogZ2VuZXJhdGUgJ1NIQTI1NicgaGFzaFxyXG4gICAgICogQHBhcmFtIGJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBzaGEyNTYoYnVmZmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKEhhc2guU0hBMjU2KS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBIYXNoVXRpbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhhc2hVdGlscy5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgRW5jb2RpbmdUeXBlcywgQ29uc3RhbnRzIH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuaW1wb3J0IHsgUkFORE9NX09DVEVUX1NJWkUsIENoYXJTZXQgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IEVuY29kaW5nVXRpbHMgfSBmcm9tICcuLi91dGlscy9FbmNvZGluZ1V0aWxzLm1qcyc7XG5pbXBvcnQgeyBIYXNoVXRpbHMgfSBmcm9tICcuL0hhc2hVdGlscy5tanMnO1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NjM2I3BhZ2UtOFxyXG4gKi9cclxuY2xhc3MgUGtjZUdlbmVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmhhc2hVdGlscyA9IG5ldyBIYXNoVXRpbHMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZ2VuZXJhdGVzIHRoZSBjb2RlVmVyZmllciBhbmQgdGhlIGNoYWxsZW5nZSBmcm9tIHRoZSBjb2RlVmVyZmllclxyXG4gICAgICogcmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzYzNiNzZWN0aW9uLTQuMSBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc2MzYjc2VjdGlvbi00LjJcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2VuZXJhdGVQa2NlQ29kZXMoKSB7XHJcbiAgICAgICAgY29uc3QgdmVyaWZpZXIgPSB0aGlzLmdlbmVyYXRlQ29kZVZlcmlmaWVyKCk7XHJcbiAgICAgICAgY29uc3QgY2hhbGxlbmdlID0gdGhpcy5nZW5lcmF0ZUNvZGVDaGFsbGVuZ2VGcm9tVmVyaWZpZXIodmVyaWZpZXIpO1xyXG4gICAgICAgIHJldHVybiB7IHZlcmlmaWVyLCBjaGFsbGVuZ2UgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZ2VuZXJhdGVzIHRoZSBjb2RlVmVyZmllcjsgcmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzYzNiNzZWN0aW9uLTQuMVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUNvZGVWZXJpZmllcigpIHtcclxuICAgICAgICBjb25zdCBjaGFyQXJyID0gW107XHJcbiAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMjU2IC0gKDI1NiAlIENoYXJTZXQuQ1ZfQ0hBUlNFVC5sZW5ndGgpO1xyXG4gICAgICAgIHdoaWxlIChjaGFyQXJyLmxlbmd0aCA8PSBSQU5ET01fT0NURVRfU0laRSkge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDEpWzBdO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZSA+PSBtYXhOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBJZ25vcmUgdGhpcyBudW1iZXIgdG8gbWFpbnRhaW4gcmFuZG9tbmVzcy5cclxuICAgICAgICAgICAgICAgICAqIEluY2x1ZGluZyBpdCB3b3VsZCByZXN1bHQgaW4gYW4gdW5lcXVhbCBkaXN0cmlidXRpb24gb2YgY2hhcmFjdGVycyBhZnRlciBkb2luZyB0aGUgbW9kdWxvXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYnl0ZSAlIENoYXJTZXQuQ1ZfQ0hBUlNFVC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNoYXJBcnIucHVzaChDaGFyU2V0LkNWX0NIQVJTRVRbaW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmVyaWZpZXIgPSBjaGFyQXJyLmpvaW4oQ29uc3RhbnRzLkVNUFRZX1NUUklORyk7XHJcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RW5jb2RlVXJsKHZlcmlmaWVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZ2VuZXJhdGUgdGhlIGNoYWxsZW5nZSBmcm9tIHRoZSBjb2RlVmVyZmllcjsgcmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzYzNiNzZWN0aW9uLTQuMlxyXG4gICAgICogQHBhcmFtIGNvZGVWZXJpZmllclxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUNvZGVDaGFsbGVuZ2VGcm9tVmVyaWZpZXIoY29kZVZlcmlmaWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RW5jb2RlVXJsKHRoaXMuaGFzaFV0aWxzLnNoYTI1Nihjb2RlVmVyaWZpZXIpLnRvU3RyaW5nKEVuY29kaW5nVHlwZXMuQkFTRTY0KSwgRW5jb2RpbmdUeXBlcy5CQVNFNjQpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFBrY2VHZW5lcmF0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBrY2VHZW5lcmF0b3IubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEVuY29kaW5nVHlwZXMgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBHdWlkR2VuZXJhdG9yIH0gZnJvbSAnLi9HdWlkR2VuZXJhdG9yLm1qcyc7XG5pbXBvcnQgeyBFbmNvZGluZ1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMvRW5jb2RpbmdVdGlscy5tanMnO1xuaW1wb3J0IHsgUGtjZUdlbmVyYXRvciB9IGZyb20gJy4vUGtjZUdlbmVyYXRvci5tanMnO1xuaW1wb3J0IHsgSGFzaFV0aWxzIH0gZnJvbSAnLi9IYXNoVXRpbHMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgTVNBTCBub2RlJ3MgY3J5cHRvIGludGVyZmFjZSwgd2hpY2ggYWxsb3dzIGl0IHRvIHBlcmZvcm0gYmFzZTY0IGVuY29kaW5nIGFuZCBkZWNvZGluZywgZ2VuZXJhdGluZyBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gR1VJRHMgYW5kXHJcbiAqIGltcGxlbWVudGluZyBQcm9vZiBLZXkgZm9yIENvZGUgRXhjaGFuZ2Ugc3BlY3MgZm9yIHRoZSBPQXV0aCBBdXRob3JpemF0aW9uIENvZGUgRmxvdyB1c2luZyBQS0NFIChyZmMgaGVyZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc2MzYpLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBDcnlwdG9Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBCcm93c2VyIGNyeXB0byBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgZmlyc3QgYmVmb3JlIGFueSBvdGhlciBjbGFzc2VzIGNhbiBiZSBzZXQuXHJcbiAgICAgICAgdGhpcy5wa2NlR2VuZXJhdG9yID0gbmV3IFBrY2VHZW5lcmF0b3IoKTtcclxuICAgICAgICB0aGlzLmd1aWRHZW5lcmF0b3IgPSBuZXcgR3VpZEdlbmVyYXRvcigpO1xyXG4gICAgICAgIHRoaXMuaGFzaFV0aWxzID0gbmV3IEhhc2hVdGlscygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBiYXNlNjQgVVJMIHNhZmUgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgYmFzZTY0VXJsRW5jb2RlKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpbmdpZmllcyBhbmQgYmFzZTY0VXJsIGVuY29kZXMgaW5wdXQgcHVibGljIGtleVxyXG4gICAgICogQHBhcmFtIGlucHV0S2lkIC0gcHVibGljIGtleSBpZFxyXG4gICAgICogQHJldHVybnMgQmFzZTY0VXJsIGVuY29kZWQgcHVibGljIGtleVxyXG4gICAgICovXHJcbiAgICBlbmNvZGVLaWQoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmFuZG9tIEdVSUQgLSB1c2VkIHRvIHBvcHVsYXRlIHN0YXRlIGFuZCBub25jZS5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyAoR1VJRClcclxuICAgICAqL1xyXG4gICAgY3JlYXRlTmV3R3VpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ndWlkR2VuZXJhdG9yLmdlbmVyYXRlR3VpZCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIGlucHV0IHN0cmluZyB0byBiYXNlNjQuXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgLSBzdHJpbmcgdG8gYmUgZW5jb2RlZFxyXG4gICAgICovXHJcbiAgICBiYXNlNjRFbmNvZGUoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gRW5jb2RpbmdVdGlscy5iYXNlNjRFbmNvZGUoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGlucHV0IHN0cmluZyBmcm9tIGJhc2U2NC5cclxuICAgICAqIEBwYXJhbSBpbnB1dCAtIHN0cmluZyB0byBiZSBkZWNvZGVkXHJcbiAgICAgKi9cclxuICAgIGJhc2U2NERlY29kZShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBFbmNvZGluZ1V0aWxzLmJhc2U2NERlY29kZShpbnB1dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBQS0NFIGNvZGVzIHVzZWQgaW4gQXV0aG9yaXphdGlvbiBDb2RlIEZsb3cuXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlUGtjZUNvZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBrY2VHZW5lcmF0b3IuZ2VuZXJhdGVQa2NlQ29kZXMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEga2V5cGFpciwgc3RvcmVzIGl0IGFuZCByZXR1cm5zIGEgdGh1bWJwcmludCAtIG5vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIG5vZGVcclxuICAgICAqL1xyXG4gICAgZ2V0UHVibGljS2V5VGh1bWJwcmludCgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBjcnlwdG9ncmFwaGljIGtleXBhaXIgZnJvbSBrZXkgc3RvcmUgbWF0Y2hpbmcgdGhlIGtleUlkIHBhc3NlZCBpblxyXG4gICAgICogQHBhcmFtIGtpZCAtIHB1YmxpYyBrZXkgaWRcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVG9rZW5CaW5kaW5nS2V5KCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBjcnlwdG9ncmFwaGljIGtleXMgZnJvbSBLZXlzdG9yZVxyXG4gICAgICovXHJcbiAgICBjbGVhcktleXN0b3JlKCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWducyB0aGUgZ2l2ZW4gb2JqZWN0IGFzIGEgand0IHBheWxvYWQgd2l0aCBwcml2YXRlIGtleSByZXRyaWV2ZWQgYnkgZ2l2ZW4ga2lkIC0gY3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZCBmb3Igbm9kZVxyXG4gICAgICovXHJcbiAgICBzaWduSnd0KCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBTSEEtMjU2IGhhc2ggb2YgYW4gaW5wdXQgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGhhc2hTdHJpbmcocGxhaW5UZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIEVuY29kaW5nVXRpbHMuYmFzZTY0RW5jb2RlVXJsKHRoaXMuaGFzaFV0aWxzLnNoYTI1NihwbGFpblRleHQpLnRvU3RyaW5nKEVuY29kaW5nVHlwZXMuQkFTRTY0KSwgRW5jb2RpbmdUeXBlcy5CQVNFNjQpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENyeXB0b1Byb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DcnlwdG9Qcm92aWRlci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQWNjb3VudEVudGl0eSwgQ2FjaGVNYW5hZ2VyIH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZGVzZXJpYWxpemVzIGNhY2hlIGVudGl0aWVzIHJlYWQgZnJvbSB0aGUgZmlsZSBpbnRvIGluLW1lbW9yeSBvYmplY3QgdHlwZXMgZGVmaW5lZCBpbnRlcm5hbGx5XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRGVzZXJpYWxpemVyIHtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgdGhlIEpTT04gYmxvYiBpbiBtZW1vcnkgYW5kIGRlc2VyaWFsaXplIHRoZSBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0gY2FjaGVkSnNvbiAtIEpTT04gYmxvYiBjYWNoZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVzZXJpYWxpemVKU09OQmxvYihqc29uRmlsZSkge1xyXG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZENhY2hlID0gIWpzb25GaWxlID8ge30gOiBKU09OLnBhcnNlKGpzb25GaWxlKTtcclxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVkQ2FjaGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc2VyaWFsaXplcyBhY2NvdW50cyB0byBBY2NvdW50RW50aXR5IG9iamVjdHNcclxuICAgICAqIEBwYXJhbSBhY2NvdW50cyAtIGFjY291bnRzIG9mIHR5cGUgU2VyaWFsaXplZEFjY291bnRFbnRpdHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlc2VyaWFsaXplQWNjb3VudHMoYWNjb3VudHMpIHtcclxuICAgICAgICBjb25zdCBhY2NvdW50T2JqZWN0cyA9IHt9O1xyXG4gICAgICAgIGlmIChhY2NvdW50cykge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhY2NvdW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBY2MgPSBhY2NvdW50c1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkQWNjID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHNlcmlhbGl6ZWRBY2MuaG9tZV9hY2NvdW50X2lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBzZXJpYWxpemVkQWNjLmVudmlyb25tZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWxtOiBzZXJpYWxpemVkQWNjLnJlYWxtLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQWNjb3VudElkOiBzZXJpYWxpemVkQWNjLmxvY2FsX2FjY291bnRfaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHNlcmlhbGl6ZWRBY2MudXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0aG9yaXR5VHlwZTogc2VyaWFsaXplZEFjYy5hdXRob3JpdHlfdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXJpYWxpemVkQWNjLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SW5mbzogc2VyaWFsaXplZEFjYy5jbGllbnRfaW5mbyxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpY2F0aW9uVGltZTogc2VyaWFsaXplZEFjYy5sYXN0X21vZGlmaWNhdGlvbl90aW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb2RpZmljYXRpb25BcHA6IHNlcmlhbGl6ZWRBY2MubGFzdF9tb2RpZmljYXRpb25fYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbmFudFByb2ZpbGVzOiBzZXJpYWxpemVkQWNjLnRlbmFudFByb2ZpbGVzPy5tYXAoKHNlcmlhbGl6ZWRUZW5hbnRQcm9maWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWRUZW5hbnRQcm9maWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gbmV3IEFjY291bnRFbnRpdHkoKTtcclxuICAgICAgICAgICAgICAgIENhY2hlTWFuYWdlci50b09iamVjdChhY2NvdW50LCBtYXBwZWRBY2MpO1xyXG4gICAgICAgICAgICAgICAgYWNjb3VudE9iamVjdHNba2V5XSA9IGFjY291bnQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjb3VudE9iamVjdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc2VyaWFsaXplcyBpZCB0b2tlbnMgdG8gSWRUb2tlbkVudGl0eSBvYmplY3RzXHJcbiAgICAgKiBAcGFyYW0gaWRUb2tlbnMgLSBjcmVkZW50aWFscyBvZiB0eXBlIFNlcmlhbGl6ZWRJZFRva2VuRW50aXR5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZUlkVG9rZW5zKGlkVG9rZW5zKSB7XHJcbiAgICAgICAgY29uc3QgaWRPYmplY3RzID0ge307XHJcbiAgICAgICAgaWYgKGlkVG9rZW5zKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGlkVG9rZW5zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZElkVCA9IGlkVG9rZW5zW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZFRva2VuID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHNlcmlhbGl6ZWRJZFQuaG9tZV9hY2NvdW50X2lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBzZXJpYWxpemVkSWRULmVudmlyb25tZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOiBzZXJpYWxpemVkSWRULmNyZWRlbnRpYWxfdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogc2VyaWFsaXplZElkVC5jbGllbnRfaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0OiBzZXJpYWxpemVkSWRULnNlY3JldCxcclxuICAgICAgICAgICAgICAgICAgICByZWFsbTogc2VyaWFsaXplZElkVC5yZWFsbSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZE9iamVjdHNba2V5XSA9IGlkVG9rZW47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWRPYmplY3RzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNlcmlhbGl6ZXMgYWNjZXNzIHRva2VucyB0byBBY2Nlc3NUb2tlbkVudGl0eSBvYmplY3RzXHJcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW5zIC0gYWNjZXNzIHRva2VucyBvZiB0eXBlIFNlcmlhbGl6ZWRBY2Nlc3NUb2tlbkVudGl0eVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVzZXJpYWxpemVBY2Nlc3NUb2tlbnMoYWNjZXNzVG9rZW5zKSB7XHJcbiAgICAgICAgY29uc3QgYXRPYmplY3RzID0ge307XHJcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2Vucykge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhY2Nlc3NUb2tlbnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQVQgPSBhY2Nlc3NUb2tlbnNba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IHNlcmlhbGl6ZWRBVC5ob21lX2FjY291bnRfaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHNlcmlhbGl6ZWRBVC5lbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsVHlwZTogc2VyaWFsaXplZEFULmNyZWRlbnRpYWxfdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogc2VyaWFsaXplZEFULmNsaWVudF9pZCxcclxuICAgICAgICAgICAgICAgICAgICBzZWNyZXQ6IHNlcmlhbGl6ZWRBVC5zZWNyZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhbG06IHNlcmlhbGl6ZWRBVC5yZWFsbSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNlcmlhbGl6ZWRBVC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkQXQ6IHNlcmlhbGl6ZWRBVC5jYWNoZWRfYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlc09uOiBzZXJpYWxpemVkQVQuZXhwaXJlc19vbixcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZEV4cGlyZXNPbjogc2VyaWFsaXplZEFULmV4dGVuZGVkX2V4cGlyZXNfb24sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaE9uOiBzZXJpYWxpemVkQVQucmVmcmVzaF9vbixcclxuICAgICAgICAgICAgICAgICAgICBrZXlJZDogc2VyaWFsaXplZEFULmtleV9pZCxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGU6IHNlcmlhbGl6ZWRBVC50b2tlbl90eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZENsYWltczogc2VyaWFsaXplZEFULnJlcXVlc3RlZENsYWltcyxcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRDbGFpbXNIYXNoOiBzZXJpYWxpemVkQVQucmVxdWVzdGVkQ2xhaW1zSGFzaCxcclxuICAgICAgICAgICAgICAgICAgICB1c2VyQXNzZXJ0aW9uSGFzaDogc2VyaWFsaXplZEFULnVzZXJBc3NlcnRpb25IYXNoLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGF0T2JqZWN0c1trZXldID0gYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXRPYmplY3RzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNlcmlhbGl6ZXMgcmVmcmVzaCB0b2tlbnMgdG8gUmVmcmVzaFRva2VuRW50aXR5IG9iamVjdHNcclxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW5zIC0gcmVmcmVzaCB0b2tlbnMgb2YgdHlwZSBTZXJpYWxpemVkUmVmcmVzaFRva2VuRW50aXR5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZVJlZnJlc2hUb2tlbnMocmVmcmVzaFRva2Vucykge1xyXG4gICAgICAgIGNvbnN0IHJ0T2JqZWN0cyA9IHt9O1xyXG4gICAgICAgIGlmIChyZWZyZXNoVG9rZW5zKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlZnJlc2hUb2tlbnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkUlQgPSByZWZyZXNoVG9rZW5zW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9tZUFjY291bnRJZDogc2VyaWFsaXplZFJULmhvbWVfYWNjb3VudF9pZCxcclxuICAgICAgICAgICAgICAgICAgICBlbnZpcm9ubWVudDogc2VyaWFsaXplZFJULmVudmlyb25tZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOiBzZXJpYWxpemVkUlQuY3JlZGVudGlhbF90eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBzZXJpYWxpemVkUlQuY2xpZW50X2lkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlY3JldDogc2VyaWFsaXplZFJULnNlY3JldCxcclxuICAgICAgICAgICAgICAgICAgICBmYW1pbHlJZDogc2VyaWFsaXplZFJULmZhbWlseV9pZCxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNlcmlhbGl6ZWRSVC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhbG06IHNlcmlhbGl6ZWRSVC5yZWFsbSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBydE9iamVjdHNba2V5XSA9IHJlZnJlc2hUb2tlbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBydE9iamVjdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc2VyaWFsaXplcyBhcHBNZXRhZGF0YSB0byBBcHBNZXRhRGF0YSBvYmplY3RzXHJcbiAgICAgKiBAcGFyYW0gYXBwTWV0YWRhdGEgLSBhcHAgbWV0YWRhdGEgb2YgdHlwZSBTZXJpYWxpemVkQXBwTWV0YWRhdGFFbnRpdHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlc2VyaWFsaXplQXBwTWV0YWRhdGEoYXBwTWV0YWRhdGEpIHtcclxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YU9iamVjdHMgPSB7fTtcclxuICAgICAgICBpZiAoYXBwTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXBwTWV0YWRhdGEpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkQW1kdCA9IGFwcE1ldGFkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICBhcHBNZXRhZGF0YU9iamVjdHNba2V5XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogc2VyaWFsaXplZEFtZHQuY2xpZW50X2lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBzZXJpYWxpemVkQW1kdC5lbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgICAgICAgICBmYW1pbHlJZDogc2VyaWFsaXplZEFtZHQuZmFtaWx5X2lkLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcHBNZXRhZGF0YU9iamVjdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc2VyaWFsaXplIGFuIGluTWVtb3J5IENhY2hlXHJcbiAgICAgKiBAcGFyYW0ganNvbkNhY2hlIC0gSlNPTiBibG9iIGNhY2hlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZUFsbENhY2hlKGpzb25DYWNoZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFjY291bnRzOiBqc29uQ2FjaGUuQWNjb3VudFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRlc2VyaWFsaXplQWNjb3VudHMoanNvbkNhY2hlLkFjY291bnQpXHJcbiAgICAgICAgICAgICAgICA6IHt9LFxyXG4gICAgICAgICAgICBpZFRva2VuczoganNvbkNhY2hlLklkVG9rZW5cclxuICAgICAgICAgICAgICAgID8gdGhpcy5kZXNlcmlhbGl6ZUlkVG9rZW5zKGpzb25DYWNoZS5JZFRva2VuKVxyXG4gICAgICAgICAgICAgICAgOiB7fSxcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW5zOiBqc29uQ2FjaGUuQWNjZXNzVG9rZW5cclxuICAgICAgICAgICAgICAgID8gdGhpcy5kZXNlcmlhbGl6ZUFjY2Vzc1Rva2Vucyhqc29uQ2FjaGUuQWNjZXNzVG9rZW4pXHJcbiAgICAgICAgICAgICAgICA6IHt9LFxyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW5zOiBqc29uQ2FjaGUuUmVmcmVzaFRva2VuXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZGVzZXJpYWxpemVSZWZyZXNoVG9rZW5zKGpzb25DYWNoZS5SZWZyZXNoVG9rZW4pXHJcbiAgICAgICAgICAgICAgICA6IHt9LFxyXG4gICAgICAgICAgICBhcHBNZXRhZGF0YToganNvbkNhY2hlLkFwcE1ldGFkYXRhXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuZGVzZXJpYWxpemVBcHBNZXRhZGF0YShqc29uQ2FjaGUuQXBwTWV0YWRhdGEpXHJcbiAgICAgICAgICAgICAgICA6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgRGVzZXJpYWxpemVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXNlcmlhbGl6ZXIubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBzZXJpYWxpemVzIGNhY2hlIGVudGl0aWVzIHRvIGJlIHNhdmVkIGludG8gaW4tbWVtb3J5IG9iamVjdCB0eXBlcyBkZWZpbmVkIGludGVybmFsbHlcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBTZXJpYWxpemVyIHtcclxuICAgIC8qKlxyXG4gICAgICogc2VyaWFsaXplIHRoZSBKU09OIGJsb2JcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gSlNPTiBibG9iIGNhY2hlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZXJpYWxpemVKU09OQmxvYihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJpYWxpemUgQWNjb3VudHNcclxuICAgICAqIEBwYXJhbSBhY2NDYWNoZSAtIGNhY2hlIG9mIGFjY291bnRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZXJpYWxpemVBY2NvdW50cyhhY2NDYWNoZSkge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnRzID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMoYWNjQ2FjaGUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRFbnRpdHkgPSBhY2NDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBhY2NvdW50c1trZXldID0ge1xyXG4gICAgICAgICAgICAgICAgaG9tZV9hY2NvdW50X2lkOiBhY2NvdW50RW50aXR5LmhvbWVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudDogYWNjb3VudEVudGl0eS5lbnZpcm9ubWVudCxcclxuICAgICAgICAgICAgICAgIHJlYWxtOiBhY2NvdW50RW50aXR5LnJlYWxtLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxfYWNjb3VudF9pZDogYWNjb3VudEVudGl0eS5sb2NhbEFjY291bnRJZCxcclxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBhY2NvdW50RW50aXR5LnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5X3R5cGU6IGFjY291bnRFbnRpdHkuYXV0aG9yaXR5VHlwZSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGFjY291bnRFbnRpdHkubmFtZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudF9pbmZvOiBhY2NvdW50RW50aXR5LmNsaWVudEluZm8sXHJcbiAgICAgICAgICAgICAgICBsYXN0X21vZGlmaWNhdGlvbl90aW1lOiBhY2NvdW50RW50aXR5Lmxhc3RNb2RpZmljYXRpb25UaW1lLFxyXG4gICAgICAgICAgICAgICAgbGFzdF9tb2RpZmljYXRpb25fYXBwOiBhY2NvdW50RW50aXR5Lmxhc3RNb2RpZmljYXRpb25BcHAsXHJcbiAgICAgICAgICAgICAgICB0ZW5hbnRQcm9maWxlczogYWNjb3VudEVudGl0eS50ZW5hbnRQcm9maWxlcz8ubWFwKCh0ZW5hbnRQcm9maWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRlbmFudFByb2ZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjY291bnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJpYWxpemUgSWRUb2tlbnNcclxuICAgICAqIEBwYXJhbSBpZFRDYWNoZSAtIGNhY2hlIG9mIElEIHRva2Vuc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2VyaWFsaXplSWRUb2tlbnMoaWRUQ2FjaGUpIHtcclxuICAgICAgICBjb25zdCBpZFRva2VucyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGlkVENhY2hlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBpZFRFbnRpdHkgPSBpZFRDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZFRva2Vuc1trZXldID0ge1xyXG4gICAgICAgICAgICAgICAgaG9tZV9hY2NvdW50X2lkOiBpZFRFbnRpdHkuaG9tZUFjY291bnRJZCxcclxuICAgICAgICAgICAgICAgIGVudmlyb25tZW50OiBpZFRFbnRpdHkuZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3R5cGU6IGlkVEVudGl0eS5jcmVkZW50aWFsVHlwZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudF9pZDogaWRURW50aXR5LmNsaWVudElkLFxyXG4gICAgICAgICAgICAgICAgc2VjcmV0OiBpZFRFbnRpdHkuc2VjcmV0LFxyXG4gICAgICAgICAgICAgICAgcmVhbG06IGlkVEVudGl0eS5yZWFsbSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaWRUb2tlbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlcmlhbGl6ZXMgQWNjZXNzVG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gYXRDYWNoZSAtIGNhY2hlIG9mIGFjY2VzcyB0b2tlbnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNlcmlhbGl6ZUFjY2Vzc1Rva2VucyhhdENhY2hlKSB7XHJcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5zID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMoYXRDYWNoZSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgY29uc3QgYXRFbnRpdHkgPSBhdENhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2Vuc1trZXldID0ge1xyXG4gICAgICAgICAgICAgICAgaG9tZV9hY2NvdW50X2lkOiBhdEVudGl0eS5ob21lQWNjb3VudElkLFxyXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGF0RW50aXR5LmVudmlyb25tZW50LFxyXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbF90eXBlOiBhdEVudGl0eS5jcmVkZW50aWFsVHlwZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudF9pZDogYXRFbnRpdHkuY2xpZW50SWQsXHJcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IGF0RW50aXR5LnNlY3JldCxcclxuICAgICAgICAgICAgICAgIHJlYWxtOiBhdEVudGl0eS5yZWFsbSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogYXRFbnRpdHkudGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgY2FjaGVkX2F0OiBhdEVudGl0eS5jYWNoZWRBdCxcclxuICAgICAgICAgICAgICAgIGV4cGlyZXNfb246IGF0RW50aXR5LmV4cGlyZXNPbixcclxuICAgICAgICAgICAgICAgIGV4dGVuZGVkX2V4cGlyZXNfb246IGF0RW50aXR5LmV4dGVuZGVkRXhwaXJlc09uLFxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaF9vbjogYXRFbnRpdHkucmVmcmVzaE9uLFxyXG4gICAgICAgICAgICAgICAga2V5X2lkOiBhdEVudGl0eS5rZXlJZCxcclxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6IGF0RW50aXR5LnRva2VuVHlwZSxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZENsYWltczogYXRFbnRpdHkucmVxdWVzdGVkQ2xhaW1zLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkQ2xhaW1zSGFzaDogYXRFbnRpdHkucmVxdWVzdGVkQ2xhaW1zSGFzaCxcclxuICAgICAgICAgICAgICAgIHVzZXJBc3NlcnRpb25IYXNoOiBhdEVudGl0eS51c2VyQXNzZXJ0aW9uSGFzaCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW5zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJpYWxpemUgcmVmcmVzaFRva2Vuc1xyXG4gICAgICogQHBhcmFtIHJ0Q2FjaGUgLSBjYWNoZSBvZiByZWZyZXNoIHRva2Vuc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2VyaWFsaXplUmVmcmVzaFRva2VucyhydENhY2hlKSB7XHJcbiAgICAgICAgY29uc3QgcmVmcmVzaFRva2VucyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHJ0Q2FjaGUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ0RW50aXR5ID0gcnRDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW5zW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICBob21lX2FjY291bnRfaWQ6IHJ0RW50aXR5LmhvbWVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudDogcnRFbnRpdHkuZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3R5cGU6IHJ0RW50aXR5LmNyZWRlbnRpYWxUeXBlLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiBydEVudGl0eS5jbGllbnRJZCxcclxuICAgICAgICAgICAgICAgIHNlY3JldDogcnRFbnRpdHkuc2VjcmV0LFxyXG4gICAgICAgICAgICAgICAgZmFtaWx5X2lkOiBydEVudGl0eS5mYW1pbHlJZCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcnRFbnRpdHkudGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgcmVhbG06IHJ0RW50aXR5LnJlYWxtLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZWZyZXNoVG9rZW5zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJpYWxpemUgYW1kdENhY2hlXHJcbiAgICAgKiBAcGFyYW0gYW1kdENhY2hlIC0gY2FjaGUgb2YgYXBwIG1ldGFkYXRhXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZXJpYWxpemVBcHBNZXRhZGF0YShhbWR0Q2FjaGUpIHtcclxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGFtZHRDYWNoZSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgY29uc3QgYW1kdEVudGl0eSA9IGFtZHRDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBhcHBNZXRhZGF0YVtrZXldID0ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiBhbWR0RW50aXR5LmNsaWVudElkLFxyXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGFtZHRFbnRpdHkuZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICAgICAgICBmYW1pbHlfaWQ6IGFtZHRFbnRpdHkuZmFtaWx5SWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFwcE1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJpYWxpemUgdGhlIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gaW5NZW1DYWNoZSAtIGl0ZW1pc2VkIGNhY2hlIHJlYWQgZnJvbSB0aGUgSlNPTlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2VyaWFsaXplQWxsQ2FjaGUoaW5NZW1DYWNoZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIEFjY291bnQ6IHRoaXMuc2VyaWFsaXplQWNjb3VudHMoaW5NZW1DYWNoZS5hY2NvdW50cyksXHJcbiAgICAgICAgICAgIElkVG9rZW46IHRoaXMuc2VyaWFsaXplSWRUb2tlbnMoaW5NZW1DYWNoZS5pZFRva2VucyksXHJcbiAgICAgICAgICAgIEFjY2Vzc1Rva2VuOiB0aGlzLnNlcmlhbGl6ZUFjY2Vzc1Rva2Vucyhpbk1lbUNhY2hlLmFjY2Vzc1Rva2VucyksXHJcbiAgICAgICAgICAgIFJlZnJlc2hUb2tlbjogdGhpcy5zZXJpYWxpemVSZWZyZXNoVG9rZW5zKGluTWVtQ2FjaGUucmVmcmVzaFRva2VucyksXHJcbiAgICAgICAgICAgIEFwcE1ldGFkYXRhOiB0aGlzLnNlcmlhbGl6ZUFwcE1ldGFkYXRhKGluTWVtQ2FjaGUuYXBwTWV0YWRhdGEpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgU2VyaWFsaXplciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VyaWFsaXplci5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQ2FjaGVNYW5hZ2VyLCBBY2NvdW50RW50aXR5LCBDYWNoZUhlbHBlcnMgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBEZXNlcmlhbGl6ZXIgfSBmcm9tICcuL3NlcmlhbGl6ZXIvRGVzZXJpYWxpemVyLm1qcyc7XG5pbXBvcnQgeyBTZXJpYWxpemVyIH0gZnJvbSAnLi9zZXJpYWxpemVyL1NlcmlhbGl6ZXIubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgU3RvcmFnZSBmb3Igbm9kZSwgcmVhZGluZyBjYWNoZSBmcm9tIHVzZXIgc3BlY2lmaWVkIHN0b3JhZ2UgbG9jYXRpb24gb3IgYW4gIGV4dGVuc2lvbiBsaWJyYXJ5XHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIE5vZGVTdG9yYWdlIGV4dGVuZHMgQ2FjaGVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvZ2dlciwgY2xpZW50SWQsIGNyeXB0b0ltcGwsIHN0YXRpY0F1dGhvcml0eU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihjbGllbnRJZCwgY3J5cHRvSW1wbCwgbG9nZ2VyLCBzdGF0aWNBdXRob3JpdHlPcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNhY2hlID0ge307XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VFbWl0dGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWV1ZSB1cCBjYWxsYmFja3NcclxuICAgICAqIEBwYXJhbSBmdW5jIC0gYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgY2FjaGUgY2hhbmdlIGluZGljYXRpb25cclxuICAgICAqL1xyXG4gICAgcmVnaXN0ZXJDaGFuZ2VFbWl0dGVyKGZ1bmMpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZUVtaXR0ZXJzLnB1c2goZnVuYyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2hlbiBjYWNoZSBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIGVtaXRDaGFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VFbWl0dGVycy5mb3JFYWNoKChmdW5jKSA9PiBmdW5jLmNhbGwobnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBjYWNoZUtWU3RvcmUgdG8gSW5NZW1vcnlDYWNoZVxyXG4gICAgICogQHBhcmFtIGNhY2hlIC0ga2V5IHZhbHVlIHN0b3JlXHJcbiAgICAgKi9cclxuICAgIGNhY2hlVG9Jbk1lbW9yeUNhY2hlKGNhY2hlKSB7XHJcbiAgICAgICAgY29uc3QgaW5NZW1vcnlDYWNoZSA9IHtcclxuICAgICAgICAgICAgYWNjb3VudHM6IHt9LFxyXG4gICAgICAgICAgICBpZFRva2Vuczoge30sXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2Vuczoge30sXHJcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbnM6IHt9LFxyXG4gICAgICAgICAgICBhcHBNZXRhZGF0YToge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFjY291bnRFbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgIGluTWVtb3J5Q2FjaGUuYWNjb3VudHNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKENhY2hlSGVscGVycy5pc0lkVG9rZW5FbnRpdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbk1lbW9yeUNhY2hlLmlkVG9rZW5zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChDYWNoZUhlbHBlcnMuaXNBY2Nlc3NUb2tlbkVudGl0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGluTWVtb3J5Q2FjaGUuYWNjZXNzVG9rZW5zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChDYWNoZUhlbHBlcnMuaXNSZWZyZXNoVG9rZW5FbnRpdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbk1lbW9yeUNhY2hlLnJlZnJlc2hUb2tlbnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKENhY2hlSGVscGVycy5pc0FwcE1ldGFkYXRhRW50aXR5KGtleSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbk1lbW9yeUNhY2hlLmFwcE1ldGFkYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbk1lbW9yeUNhY2hlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBjb252ZXJ0cyBpbk1lbW9yeUNhY2hlIHRvIENhY2hlS1ZTdG9yZVxyXG4gICAgICogQHBhcmFtIGluTWVtb3J5Q2FjaGUgLSBrdnN0b3JlIG1hcCBmb3IgaW5tZW1vcnlcclxuICAgICAqL1xyXG4gICAgaW5NZW1vcnlDYWNoZVRvQ2FjaGUoaW5NZW1vcnlDYWNoZSkge1xyXG4gICAgICAgIC8vIGNvbnZlcnQgaW4gbWVtb3J5IGNhY2hlIHRvIGEgZmxhdCBLZXktVmFsdWUgbWFwXHJcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5nZXRDYWNoZSgpO1xyXG4gICAgICAgIGNhY2hlID0ge1xyXG4gICAgICAgICAgICAuLi5jYWNoZSxcclxuICAgICAgICAgICAgLi4uaW5NZW1vcnlDYWNoZS5hY2NvdW50cyxcclxuICAgICAgICAgICAgLi4uaW5NZW1vcnlDYWNoZS5pZFRva2VucyxcclxuICAgICAgICAgICAgLi4uaW5NZW1vcnlDYWNoZS5hY2Nlc3NUb2tlbnMsXHJcbiAgICAgICAgICAgIC4uLmluTWVtb3J5Q2FjaGUucmVmcmVzaFRva2VucyxcclxuICAgICAgICAgICAgLi4uaW5NZW1vcnlDYWNoZS5hcHBNZXRhZGF0YSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNvbnZlcnQgaW4gbWVtb3J5IGNhY2hlIHRvIGEgZmxhdCBLZXktVmFsdWUgbWFwXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXRzIHRoZSBjdXJyZW50IGluIG1lbW9yeSBjYWNoZSBmb3IgdGhlIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBnZXRJbk1lbW9yeUNhY2hlKCkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiR2V0dGluZyBpbi1tZW1vcnkgY2FjaGVcIik7XHJcbiAgICAgICAgLy8gY29udmVydCB0aGUgY2FjaGUga2V5IHZhbHVlIHN0b3JlIHRvIGluTWVtb3J5Q2FjaGVcclxuICAgICAgICBjb25zdCBpbk1lbW9yeUNhY2hlID0gdGhpcy5jYWNoZVRvSW5NZW1vcnlDYWNoZSh0aGlzLmdldENhY2hlKCkpO1xyXG4gICAgICAgIHJldHVybiBpbk1lbW9yeUNhY2hlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXRzIHRoZSBjdXJyZW50IGluIG1lbW9yeSBjYWNoZSBmb3IgdGhlIGNsaWVudFxyXG4gICAgICogQHBhcmFtIGluTWVtb3J5Q2FjaGUgLSBrZXkgdmFsdWUgbWFwIGluIG1lbW9yeVxyXG4gICAgICovXHJcbiAgICBzZXRJbk1lbW9yeUNhY2hlKGluTWVtb3J5Q2FjaGUpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlNldHRpbmcgaW4tbWVtb3J5IGNhY2hlXCIpO1xyXG4gICAgICAgIC8vIGNvbnZlcnQgYW5kIGFwcGVuZCB0aGUgaW5NZW1vcnlDYWNoZSB0byBjYWNoZUtWU3RvcmVcclxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuaW5NZW1vcnlDYWNoZVRvQ2FjaGUoaW5NZW1vcnlDYWNoZSk7XHJcbiAgICAgICAgdGhpcy5zZXRDYWNoZShjYWNoZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldCB0aGUgY3VycmVudCBjYWNoZSBrZXktdmFsdWUgc3RvcmVcclxuICAgICAqL1xyXG4gICAgZ2V0Q2FjaGUoKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJHZXR0aW5nIGNhY2hlIGtleS12YWx1ZSBzdG9yZVwiKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0cyB0aGUgY3VycmVudCBjYWNoZSAoa2V5IHZhbHVlIHN0b3JlKVxyXG4gICAgICogQHBhcmFtIGNhY2hlTWFwIC0ga2V5IHZhbHVlIG1hcFxyXG4gICAgICovXHJcbiAgICBzZXRDYWNoZShjYWNoZSkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2V0dGluZyBjYWNoZSBrZXkgdmFsdWUgc3RvcmVcIik7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xyXG4gICAgICAgIC8vIG1hcmsgY2hhbmdlIGluIGNhY2hlXHJcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgY2FjaGUgaXRlbSB3aXRoIGdpdmVuIGtleS5cclxuICAgICAqIEBwYXJhbSBrZXkgLSBsb29rdXAga2V5IGZvciB0aGUgY2FjaGUgZW50cnlcclxuICAgICAqL1xyXG4gICAgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZVBpaShgSXRlbSBrZXk6ICR7a2V5fWApO1xyXG4gICAgICAgIC8vIHJlYWQgY2FjaGVcclxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoKTtcclxuICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBjYWNoZSBpdGVtIHdpdGggZ2l2ZW4ga2V5LXZhbHVlXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gbG9va3VwIGtleSBmb3IgdGhlIGNhY2hlIGVudHJ5XHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSBvZiB0aGUgY2FjaGUgZW50cnlcclxuICAgICAqL1xyXG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2VQaWkoYEl0ZW0ga2V5OiAke2tleX1gKTtcclxuICAgICAgICAvLyByZWFkIGNhY2hlXHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmdldENhY2hlKCk7XHJcbiAgICAgICAgY2FjaGVba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIC8vIHdyaXRlIHRvIGNhY2hlXHJcbiAgICAgICAgdGhpcy5zZXRDYWNoZShjYWNoZSk7XHJcbiAgICB9XHJcbiAgICBnZXRBY2NvdW50S2V5cygpIHtcclxuICAgICAgICBjb25zdCBpbk1lbW9yeUNhY2hlID0gdGhpcy5nZXRJbk1lbW9yeUNhY2hlKCk7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudEtleXMgPSBPYmplY3Qua2V5cyhpbk1lbW9yeUNhY2hlLmFjY291bnRzKTtcclxuICAgICAgICByZXR1cm4gYWNjb3VudEtleXM7XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbktleXMoKSB7XHJcbiAgICAgICAgY29uc3QgaW5NZW1vcnlDYWNoZSA9IHRoaXMuZ2V0SW5NZW1vcnlDYWNoZSgpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuS2V5cyA9IHtcclxuICAgICAgICAgICAgaWRUb2tlbjogT2JqZWN0LmtleXMoaW5NZW1vcnlDYWNoZS5pZFRva2VucyksXHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBPYmplY3Qua2V5cyhpbk1lbW9yeUNhY2hlLmFjY2Vzc1Rva2VucyksXHJcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbjogT2JqZWN0LmtleXMoaW5NZW1vcnlDYWNoZS5yZWZyZXNoVG9rZW5zKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0b2tlbktleXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFjY291bnQgZnJvbSBjYWNoZSwgYnVpbGRzIGl0IGludG8gYW4gYWNjb3VudCBlbnRpdHkgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudEtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBBY2NvdW50RW50aXR5XHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBnZXRBY2NvdW50KGFjY291bnRLZXkpIHtcclxuICAgICAgICBjb25zdCBjYWNoZWRBY2NvdW50ID0gdGhpcy5nZXRJdGVtKGFjY291bnRLZXkpO1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRBY2NvdW50XHJcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihuZXcgQWNjb3VudEVudGl0eSgpLCB0aGlzLmdldEl0ZW0oYWNjb3VudEtleSkpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGFjY291bnQgZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudCAtIGNhY2hlIHZhbHVlIHRvIGJlIHNldCBvZiB0eXBlIEFjY291bnRFbnRpdHlcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2V0QWNjb3VudChhY2NvdW50KSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudEtleSA9IGFjY291bnQuZ2VuZXJhdGVBY2NvdW50S2V5KCk7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKGFjY291bnRLZXksIGFjY291bnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBmZXRjaCB0aGUgaWRUb2tlbiBjcmVkZW50aWFsXHJcbiAgICAgKiBAcGFyYW0gaWRUb2tlbktleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBJZFRva2VuRW50aXR5XHJcbiAgICAgKi9cclxuICAgIGdldElkVG9rZW5DcmVkZW50aWFsKGlkVG9rZW5LZXkpIHtcclxuICAgICAgICBjb25zdCBpZFRva2VuID0gdGhpcy5nZXRJdGVtKGlkVG9rZW5LZXkpO1xyXG4gICAgICAgIGlmIChDYWNoZUhlbHBlcnMuaXNJZFRva2VuRW50aXR5KGlkVG9rZW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZFRva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGlkVG9rZW4gY3JlZGVudGlhbFxyXG4gICAgICogQHBhcmFtIGlkVG9rZW4gLSBjYWNoZSB2YWx1ZSB0byBiZSBzZXQgb2YgdHlwZSBJZFRva2VuRW50aXR5XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHNldElkVG9rZW5DcmVkZW50aWFsKGlkVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBpZFRva2VuS2V5ID0gQ2FjaGVIZWxwZXJzLmdlbmVyYXRlQ3JlZGVudGlhbEtleShpZFRva2VuKTtcclxuICAgICAgICB0aGlzLnNldEl0ZW0oaWRUb2tlbktleSwgaWRUb2tlbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGZldGNoIHRoZSBhY2Nlc3NUb2tlbiBjcmVkZW50aWFsXHJcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW5LZXkgLSBsb29rdXAga2V5IHRvIGZldGNoIGNhY2hlIHR5cGUgQWNjZXNzVG9rZW5FbnRpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0QWNjZXNzVG9rZW5DcmVkZW50aWFsKGFjY2Vzc1Rva2VuS2V5KSB7XHJcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSB0aGlzLmdldEl0ZW0oYWNjZXNzVG9rZW5LZXkpO1xyXG4gICAgICAgIGlmIChDYWNoZUhlbHBlcnMuaXNBY2Nlc3NUb2tlbkVudGl0eShhY2Nlc3NUb2tlbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGFjY2Vzc1Rva2VuIGNyZWRlbnRpYWxcclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtICBjYWNoZSB2YWx1ZSB0byBiZSBzZXQgb2YgdHlwZSBBY2Nlc3NUb2tlbkVudGl0eVxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZXRBY2Nlc3NUb2tlbkNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbktleSA9IENhY2hlSGVscGVycy5nZW5lcmF0ZUNyZWRlbnRpYWxLZXkoYWNjZXNzVG9rZW4pO1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbShhY2Nlc3NUb2tlbktleSwgYWNjZXNzVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBmZXRjaCB0aGUgcmVmcmVzaFRva2VuIGNyZWRlbnRpYWxcclxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW5LZXkgLSBsb29rdXAga2V5IHRvIGZldGNoIGNhY2hlIHR5cGUgUmVmcmVzaFRva2VuRW50aXR5XHJcbiAgICAgKi9cclxuICAgIGdldFJlZnJlc2hUb2tlbkNyZWRlbnRpYWwocmVmcmVzaFRva2VuS2V5KSB7XHJcbiAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gdGhpcy5nZXRJdGVtKHJlZnJlc2hUb2tlbktleSk7XHJcbiAgICAgICAgaWYgKENhY2hlSGVscGVycy5pc1JlZnJlc2hUb2tlbkVudGl0eShyZWZyZXNoVG9rZW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWZyZXNoVG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgcmVmcmVzaFRva2VuIGNyZWRlbnRpYWxcclxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gLSBjYWNoZSB2YWx1ZSB0byBiZSBzZXQgb2YgdHlwZSBSZWZyZXNoVG9rZW5FbnRpdHlcclxuICAgICAqL1xyXG4gICAgYXN5bmMgc2V0UmVmcmVzaFRva2VuQ3JlZGVudGlhbChyZWZyZXNoVG9rZW4pIHtcclxuICAgICAgICBjb25zdCByZWZyZXNoVG9rZW5LZXkgPSBDYWNoZUhlbHBlcnMuZ2VuZXJhdGVDcmVkZW50aWFsS2V5KHJlZnJlc2hUb2tlbik7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKHJlZnJlc2hUb2tlbktleSwgcmVmcmVzaFRva2VuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZmV0Y2ggYXBwTWV0YWRhdGEgZW50aXR5IGZyb20gdGhlIHBsYXRmb3JtIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gYXBwTWV0YWRhdGFLZXkgLSBsb29rdXAga2V5IHRvIGZldGNoIGNhY2hlIHR5cGUgQXBwTWV0YWRhdGFFbnRpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0QXBwTWV0YWRhdGEoYXBwTWV0YWRhdGFLZXkpIHtcclxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YSA9IHRoaXMuZ2V0SXRlbShhcHBNZXRhZGF0YUtleSk7XHJcbiAgICAgICAgaWYgKENhY2hlSGVscGVycy5pc0FwcE1ldGFkYXRhRW50aXR5KGFwcE1ldGFkYXRhS2V5LCBhcHBNZXRhZGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFwcE1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0IGFwcE1ldGFkYXRhIGVudGl0eSB0byB0aGUgcGxhdGZvcm0gY2FjaGVcclxuICAgICAqIEBwYXJhbSBhcHBNZXRhZGF0YSAtIGNhY2hlIHZhbHVlIHRvIGJlIHNldCBvZiB0eXBlIEFwcE1ldGFkYXRhRW50aXR5XHJcbiAgICAgKi9cclxuICAgIHNldEFwcE1ldGFkYXRhKGFwcE1ldGFkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgYXBwTWV0YWRhdGFLZXkgPSBDYWNoZUhlbHBlcnMuZ2VuZXJhdGVBcHBNZXRhZGF0YUtleShhcHBNZXRhZGF0YSk7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKGFwcE1ldGFkYXRhS2V5LCBhcHBNZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGZldGNoIHNlcnZlciB0ZWxlbWV0cnkgZW50aXR5IGZyb20gdGhlIHBsYXRmb3JtIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gc2VydmVyVGVsZW1ldHJ5a2V5IC0gbG9va3VwIGtleSB0byBmZXRjaCBjYWNoZSB0eXBlIFNlcnZlclRlbGVtZXRyeUVudGl0eVxyXG4gICAgICovXHJcbiAgICBnZXRTZXJ2ZXJUZWxlbWV0cnkoc2VydmVyVGVsZW1ldHJ5a2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyVGVsZW1ldHJ5RW50aXR5ID0gdGhpcy5nZXRJdGVtKHNlcnZlclRlbGVtZXRyeWtleSk7XHJcbiAgICAgICAgaWYgKHNlcnZlclRlbGVtZXRyeUVudGl0eSAmJlxyXG4gICAgICAgICAgICBDYWNoZUhlbHBlcnMuaXNTZXJ2ZXJUZWxlbWV0cnlFbnRpdHkoc2VydmVyVGVsZW1ldHJ5a2V5LCBzZXJ2ZXJUZWxlbWV0cnlFbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJUZWxlbWV0cnlFbnRpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgc2VydmVyIHRlbGVtZXRyeSBlbnRpdHkgdG8gdGhlIHBsYXRmb3JtIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gc2VydmVyVGVsZW1ldHJ5S2V5IC0gbG9va3VwIGtleSB0byBmZXRjaCBjYWNoZSB0eXBlIFNlcnZlclRlbGVtZXRyeUVudGl0eVxyXG4gICAgICogQHBhcmFtIHNlcnZlclRlbGVtZXRyeSAtIGNhY2hlIHZhbHVlIHRvIGJlIHNldCBvZiB0eXBlIFNlcnZlclRlbGVtZXRyeUVudGl0eVxyXG4gICAgICovXHJcbiAgICBzZXRTZXJ2ZXJUZWxlbWV0cnkoc2VydmVyVGVsZW1ldHJ5S2V5LCBzZXJ2ZXJUZWxlbWV0cnkpIHtcclxuICAgICAgICB0aGlzLnNldEl0ZW0oc2VydmVyVGVsZW1ldHJ5S2V5LCBzZXJ2ZXJUZWxlbWV0cnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBmZXRjaCBhdXRob3JpdHkgbWV0YWRhdGEgZW50aXR5IGZyb20gdGhlIHBsYXRmb3JtIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gbG9va3VwIGtleSB0byBmZXRjaCBjYWNoZSB0eXBlIEF1dGhvcml0eU1ldGFkYXRhRW50aXR5XHJcbiAgICAgKi9cclxuICAgIGdldEF1dGhvcml0eU1ldGFkYXRhKGtleSkge1xyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eU1ldGFkYXRhRW50aXR5ID0gdGhpcy5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgaWYgKGF1dGhvcml0eU1ldGFkYXRhRW50aXR5ICYmXHJcbiAgICAgICAgICAgIENhY2hlSGVscGVycy5pc0F1dGhvcml0eU1ldGFkYXRhRW50aXR5KGtleSwgYXV0aG9yaXR5TWV0YWRhdGFFbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdXRob3JpdHlNZXRhZGF0YUVudGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgYXV0aG9yaXR5IG1ldGFkYXRhIGtleXNcclxuICAgICAqL1xyXG4gICAgZ2V0QXV0aG9yaXR5TWV0YWRhdGFLZXlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleXMoKS5maWx0ZXIoKGtleSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0F1dGhvcml0eU1ldGFkYXRhKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHNldCBhdXRob3JpdHkgbWV0YWRhdGEgZW50aXR5IHRvIHRoZSBwbGF0Zm9ybSBjYWNoZVxyXG4gICAgICogQHBhcmFtIGtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBBdXRob3JpdHlNZXRhZGF0YUVudGl0eVxyXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIC0gY2FjaGUgdmFsdWUgdG8gYmUgc2V0IG9mIHR5cGUgQXV0aG9yaXR5TWV0YWRhdGFFbnRpdHlcclxuICAgICAqL1xyXG4gICAgc2V0QXV0aG9yaXR5TWV0YWRhdGEoa2V5LCBtZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbShrZXksIG1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZmV0Y2ggdGhyb3R0bGluZyBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGVcclxuICAgICAqIEBwYXJhbSB0aHJvdHRsaW5nQ2FjaGVLZXkgLSBsb29rdXAga2V5IHRvIGZldGNoIGNhY2hlIHR5cGUgVGhyb3R0bGluZ0VudGl0eVxyXG4gICAgICovXHJcbiAgICBnZXRUaHJvdHRsaW5nQ2FjaGUodGhyb3R0bGluZ0NhY2hlS2V5KSB7XHJcbiAgICAgICAgY29uc3QgdGhyb3R0bGluZ0NhY2hlID0gdGhpcy5nZXRJdGVtKHRocm90dGxpbmdDYWNoZUtleSk7XHJcbiAgICAgICAgaWYgKHRocm90dGxpbmdDYWNoZSAmJlxyXG4gICAgICAgICAgICBDYWNoZUhlbHBlcnMuaXNUaHJvdHRsaW5nRW50aXR5KHRocm90dGxpbmdDYWNoZUtleSwgdGhyb3R0bGluZ0NhY2hlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhyb3R0bGluZ0NhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0IHRocm90dGxpbmcgZW50aXR5IHRvIHRoZSBwbGF0Zm9ybSBjYWNoZVxyXG4gICAgICogQHBhcmFtIHRocm90dGxpbmdDYWNoZUtleSAtIGxvb2t1cCBrZXkgdG8gZmV0Y2ggY2FjaGUgdHlwZSBUaHJvdHRsaW5nRW50aXR5XHJcbiAgICAgKiBAcGFyYW0gdGhyb3R0bGluZ0NhY2hlIC0gY2FjaGUgdmFsdWUgdG8gYmUgc2V0IG9mIHR5cGUgVGhyb3R0bGluZ0VudGl0eVxyXG4gICAgICovXHJcbiAgICBzZXRUaHJvdHRsaW5nQ2FjaGUodGhyb3R0bGluZ0NhY2hlS2V5LCB0aHJvdHRsaW5nQ2FjaGUpIHtcclxuICAgICAgICB0aGlzLnNldEl0ZW0odGhyb3R0bGluZ0NhY2hlS2V5LCB0aHJvdHRsaW5nQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBjYWNoZSBpdGVtIGZyb20gbWVtb3J5IHdpdGggdGhlIGdpdmVuIGtleS5cclxuICAgICAqIEBwYXJhbSBrZXkgLSBsb29rdXAga2V5IHRvIHJlbW92ZSBhIGNhY2hlIGVudGl0eVxyXG4gICAgICogQHBhcmFtIGluTWVtb3J5IC0ga2V5IHZhbHVlIG1hcCBvZiB0aGUgY2FjaGVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZVBpaShgSXRlbSBrZXk6ICR7a2V5fWApO1xyXG4gICAgICAgIC8vIHJlYWQgaW5NZW1vcnlDYWNoZVxyXG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoKTtcclxuICAgICAgICBpZiAoISFjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3cml0ZSB0byB0aGUgY2FjaGUgYWZ0ZXIgcmVtb3ZhbFxyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDYWNoZShjYWNoZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWNjb3VudCBlbnRpdHkgZnJvbSB0aGUgcGxhdGZvcm0gY2FjaGUgaWYgaXQncyBvdXRkYXRlZFxyXG4gICAgICogQHBhcmFtIGFjY291bnRLZXkgLSBsb29rdXAga2V5IHRvIGZldGNoIGNhY2hlIHR5cGUgQWNjb3VudEVudGl0eVxyXG4gICAgICovXHJcbiAgICByZW1vdmVPdXRkYXRlZEFjY291bnQoYWNjb3VudEtleSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShhY2NvdW50S2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIga2V5IGlzIGluIGNhY2hlLlxyXG4gICAgICogQHBhcmFtIGtleSAtIGxvb2sgdXAga2V5IGZvciBhIGNhY2hlIGVudGl0eVxyXG4gICAgICovXHJcbiAgICBjb250YWluc0tleShrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlzKCkuaW5jbHVkZXMoa2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwga2V5cyBpbiB3aW5kb3cuXHJcbiAgICAgKi9cclxuICAgIGdldEtleXMoKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJSZXRyaWV2aW5nIGFsbCBjYWNoZSBrZXlzXCIpO1xyXG4gICAgICAgIC8vIHJlYWQgY2FjaGVcclxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoKTtcclxuICAgICAgICByZXR1cm4gWy4uLk9iamVjdC5rZXlzKGNhY2hlKV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgY2FjaGUgZW50cmllcyBjcmVhdGVkIGJ5IE1TQUwgKGV4Y2VwdCB0b2tlbnMpLlxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkNsZWFyaW5nIGNhY2hlIGVudHJpZXMgY3JlYXRlZCBieSBNU0FMXCIpO1xyXG4gICAgICAgIC8vIHJlYWQgaW5NZW1vcnlDYWNoZVxyXG4gICAgICAgIGNvbnN0IGNhY2hlS2V5cyA9IHRoaXMuZ2V0S2V5cygpO1xyXG4gICAgICAgIC8vIGRlbGV0ZSBlYWNoIGVsZW1lbnRcclxuICAgICAgICBjYWNoZUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGluIG1lbW9yeSBjYWNoZSBmcm9tIGFuIGV4aXNpdGluZyBjYWNoZSB2YXVsdFxyXG4gICAgICogQHBhcmFtIGNhY2hlIC0gYmxvYiBmb3JtYXR0ZWQgY2FjaGUgKEpTT04pXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUluTWVtb3J5Q2FjaGUoY2FjaGUpIHtcclxuICAgICAgICByZXR1cm4gRGVzZXJpYWxpemVyLmRlc2VyaWFsaXplQWxsQ2FjaGUoRGVzZXJpYWxpemVyLmRlc2VyaWFsaXplSlNPTkJsb2IoY2FjaGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmV0cmlldmVzIHRoZSBmaW5hbCBKU09OXHJcbiAgICAgKiBAcGFyYW0gaW5NZW1vcnlDYWNoZSAtIGl0ZW1pc2VkIGNhY2hlIHJlYWQgZnJvbSB0aGUgSlNPTlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVKc29uQ2FjaGUoaW5NZW1vcnlDYWNoZSkge1xyXG4gICAgICAgIHJldHVybiBTZXJpYWxpemVyLnNlcmlhbGl6ZUFsbENhY2hlKGluTWVtb3J5Q2FjaGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGEgY3JlZGVudGlhbCdzIGNhY2hlIGtleSBpZiB0aGUgY3VycmVudCBjYWNoZSBrZXkgaXMgb3V0ZGF0ZWRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ3JlZGVudGlhbENhY2hlS2V5KGN1cnJlbnRDYWNoZUtleSwgY3JlZGVudGlhbCkge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDYWNoZUtleSA9IENhY2hlSGVscGVycy5nZW5lcmF0ZUNyZWRlbnRpYWxLZXkoY3JlZGVudGlhbCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDYWNoZUtleSAhPT0gdXBkYXRlZENhY2hlS2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlSXRlbSA9IHRoaXMuZ2V0SXRlbShjdXJyZW50Q2FjaGVLZXkpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oY3VycmVudENhY2hlS2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SXRlbSh1cGRhdGVkQ2FjaGVLZXksIGNhY2hlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKGBVcGRhdGVkIGFuIG91dGRhdGVkICR7Y3JlZGVudGlhbC5jcmVkZW50aWFsVHlwZX0gY2FjaGUga2V5YCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZENhY2hlS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEF0dGVtcHRlZCB0byB1cGRhdGUgYW4gb3V0ZGF0ZWQgJHtjcmVkZW50aWFsLmNyZWRlbnRpYWxUeXBlfSBjYWNoZSBrZXkgYnV0IG5vIGl0ZW0gbWF0Y2hpbmcgdGhlIG91dGRhdGVkIGtleSB3YXMgZm91bmQgaW4gc3RvcmFnZWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FjaGVLZXk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTm9kZVN0b3JhZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vZGVTdG9yYWdlLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBOb2RlU3RvcmFnZSB9IGZyb20gJy4vTm9kZVN0b3JhZ2UubWpzJztcbmltcG9ydCB7IFRva2VuQ2FjaGVDb250ZXh0LCBBY2NvdW50RW50aXR5IH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuaW1wb3J0IHsgRGVzZXJpYWxpemVyIH0gZnJvbSAnLi9zZXJpYWxpemVyL0Rlc2VyaWFsaXplci5tanMnO1xuaW1wb3J0IHsgU2VyaWFsaXplciB9IGZyb20gJy4vc2VyaWFsaXplci9TZXJpYWxpemVyLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0U2VyaWFsaXplZENhY2hlID0ge1xyXG4gICAgQWNjb3VudDoge30sXHJcbiAgICBJZFRva2VuOiB7fSxcclxuICAgIEFjY2Vzc1Rva2VuOiB7fSxcclxuICAgIFJlZnJlc2hUb2tlbjoge30sXHJcbiAgICBBcHBNZXRhZGF0YToge30sXHJcbn07XHJcbi8qKlxyXG4gKiBJbi1tZW1vcnkgdG9rZW4gY2FjaGUgbWFuYWdlclxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBUb2tlbkNhY2hlIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIGxvZ2dlciwgY2FjaGVQbHVnaW4pIHtcclxuICAgICAgICB0aGlzLmNhY2hlSGFzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlLnJlZ2lzdGVyQ2hhbmdlRW1pdHRlcih0aGlzLmhhbmRsZUNoYW5nZUV2ZW50LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChjYWNoZVBsdWdpbikge1xyXG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gY2FjaGVQbHVnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiBjYWNoZSBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IHRpbWUgc2VyaWFsaXplIG9yIHdyaXRlVG9QZXJzaXN0ZW5jZSB3YXMgY2FsbGVkXHJcbiAgICAgKi9cclxuICAgIGhhc0NoYW5nZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVIYXNDaGFuZ2VkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJpYWxpemVzIGluIG1lbW9yeSBjYWNoZSB0byBKU09OXHJcbiAgICAgKi9cclxuICAgIHNlcmlhbGl6ZSgpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlNlcmlhbGl6aW5nIGluLW1lbW9yeSBjYWNoZVwiKTtcclxuICAgICAgICBsZXQgZmluYWxTdGF0ZSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQWxsQ2FjaGUodGhpcy5zdG9yYWdlLmdldEluTWVtb3J5Q2FjaGUoKSk7XHJcbiAgICAgICAgLy8gaWYgY2FjaGVTbmFwc2hvdCBub3QgbnVsbCBvciBlbXB0eSwgbWVyZ2VcclxuICAgICAgICBpZiAodGhpcy5jYWNoZVNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiUmVhZGluZyBjYWNoZSBzbmFwc2hvdCBmcm9tIGRpc2tcIik7XHJcbiAgICAgICAgICAgIGZpbmFsU3RhdGUgPSB0aGlzLm1lcmdlU3RhdGUoSlNPTi5wYXJzZSh0aGlzLmNhY2hlU25hcHNob3QpLCBmaW5hbFN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiTm8gY2FjaGUgc25hcHNob3QgdG8gbWVyZ2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FjaGVIYXNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGZpbmFsU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNlcmlhbGl6ZXMgSlNPTiB0byBpbi1tZW1vcnkgY2FjaGUuIEpTT04gc2hvdWxkIGJlIGluIE1TQUwgY2FjaGUgc2NoZW1hIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIGNhY2hlIC0gYmxvYiBmb3JtYXR0ZWQgY2FjaGVcclxuICAgICAqL1xyXG4gICAgZGVzZXJpYWxpemUoY2FjaGUpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkRlc2VyaWFsaXppbmcgSlNPTiB0byBpbi1tZW1vcnkgY2FjaGVcIik7XHJcbiAgICAgICAgdGhpcy5jYWNoZVNuYXBzaG90ID0gY2FjaGU7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlJlYWRpbmcgY2FjaGUgc25hcHNob3QgZnJvbSBkaXNrXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRDYWNoZSA9IERlc2VyaWFsaXplci5kZXNlcmlhbGl6ZUFsbENhY2hlKHRoaXMub3ZlcmxheURlZmF1bHRzKEpTT04ucGFyc2UodGhpcy5jYWNoZVNuYXBzaG90KSkpO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SW5NZW1vcnlDYWNoZShkZXNlcmlhbGl6ZWRDYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIk5vIGNhY2hlIHNuYXBzaG90IHRvIGRlc2VyaWFsaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyB0aGUgY2FjaGUga2V5LXZhbHVlIG1hcFxyXG4gICAgICovXHJcbiAgICBnZXRLVlN0b3JlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0Q2FjaGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBjYWNoZSBzbmFwc2hvdCBpbiBDYWNoZUtWU3RvcmUgZm9ybWF0XHJcbiAgICAgKi9cclxuICAgIGdldENhY2hlU25hcHNob3QoKSB7XHJcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkUGVyc2lzdGVudFN0b3JhZ2UgPSBOb2RlU3RvcmFnZS5nZW5lcmF0ZUluTWVtb3J5Q2FjaGUodGhpcy5jYWNoZVNuYXBzaG90KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmluTWVtb3J5Q2FjaGVUb0NhY2hlKGRlc2VyaWFsaXplZFBlcnNpc3RlbnRTdG9yYWdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQVBJIHRoYXQgcmV0cmlldmVzIGFsbCBhY2NvdW50cyBjdXJyZW50bHkgaW4gY2FjaGUgdG8gdGhlIHVzZXJcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QWxsQWNjb3VudHMoKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJnZXRBbGxBY2NvdW50cyBjYWxsZWRcIik7XHJcbiAgICAgICAgbGV0IGNhY2hlQ29udGV4dDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVDb250ZXh0ID0gbmV3IFRva2VuQ2FjaGVDb250ZXh0KHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuYmVmb3JlQ2FjaGVBY2Nlc3MoY2FjaGVDb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldEFsbEFjY291bnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZSAmJiBjYWNoZUNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuYWZ0ZXJDYWNoZUFjY2VzcyhjYWNoZUNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduZWQgaW4gYWNjb3VudCBtYXRjaGluZyBob21lQWNjb3VudElkLlxyXG4gICAgICogKHRoZSBhY2NvdW50IG9iamVjdCBpcyBjcmVhdGVkIGF0IHRoZSB0aW1lIG9mIHN1Y2Nlc3NmdWwgbG9naW4pXHJcbiAgICAgKiBvciBudWxsIHdoZW4gbm8gbWF0Y2hpbmcgYWNjb3VudCBpcyBmb3VuZFxyXG4gICAgICogQHBhcmFtIGhvbWVBY2NvdW50SWQgLSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYW4gYWNjb3VudCAodWlkLnV0aWQpXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEFjY291bnRCeUhvbWVJZChob21lQWNjb3VudElkKSB7XHJcbiAgICAgICAgY29uc3QgYWxsQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFsbEFjY291bnRzKCk7XHJcbiAgICAgICAgaWYgKGhvbWVBY2NvdW50SWQgJiYgYWxsQWNjb3VudHMgJiYgYWxsQWNjb3VudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYWxsQWNjb3VudHMuZmlsdGVyKChhY2NvdW50T2JqKSA9PiBhY2NvdW50T2JqLmhvbWVBY2NvdW50SWQgPT09IGhvbWVBY2NvdW50SWQpWzBdIHx8IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduZWQgaW4gYWNjb3VudCBtYXRjaGluZyBsb2NhbEFjY291bnRJZC5cclxuICAgICAqICh0aGUgYWNjb3VudCBvYmplY3QgaXMgY3JlYXRlZCBhdCB0aGUgdGltZSBvZiBzdWNjZXNzZnVsIGxvZ2luKVxyXG4gICAgICogb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIGFjY291bnQgaXMgZm91bmRcclxuICAgICAqIEBwYXJhbSBsb2NhbEFjY291bnRJZCAtIHVuaXF1ZSBpZGVudGlmaWVyIG9mIGFuIGFjY291bnQgKHN1Yi9vYmogd2hlbiBob21lQWNjb3VudElkIGNhbm5vdCBiZSBwb3B1bGF0ZWQpXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEFjY291bnRCeUxvY2FsSWQobG9jYWxBY2NvdW50SWQpIHtcclxuICAgICAgICBjb25zdCBhbGxBY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0QWxsQWNjb3VudHMoKTtcclxuICAgICAgICBpZiAobG9jYWxBY2NvdW50SWQgJiYgYWxsQWNjb3VudHMgJiYgYWxsQWNjb3VudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYWxsQWNjb3VudHMuZmlsdGVyKChhY2NvdW50T2JqKSA9PiBhY2NvdW50T2JqLmxvY2FsQWNjb3VudElkID09PSBsb2NhbEFjY291bnRJZClbMF0gfHwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFQSSB0byByZW1vdmUgYSBzcGVjaWZpYyBhY2NvdW50IGFuZCB0aGUgcmVsZXZhbnQgZGF0YSBmcm9tIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudCAtIEFjY291bnRJbmZvIHBhc3NlZCBieSB0aGUgdXNlclxyXG4gICAgICovXHJcbiAgICBhc3luYyByZW1vdmVBY2NvdW50KGFjY291bnQpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcInJlbW92ZUFjY291bnQgY2FsbGVkXCIpO1xyXG4gICAgICAgIGxldCBjYWNoZUNvbnRleHQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2UpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlQ29udGV4dCA9IG5ldyBUb2tlbkNhY2hlQ29udGV4dCh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2UuYmVmb3JlQ2FjaGVBY2Nlc3MoY2FjaGVDb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JhZ2UucmVtb3ZlQWNjb3VudChBY2NvdW50RW50aXR5LmdlbmVyYXRlQWNjb3VudENhY2hlS2V5KGFjY291bnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlICYmIGNhY2hlQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5hZnRlckNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJ3cml0ZXMgaW4tbWVtb3J5IGNhY2hlIHdpdGggcGVyc2lzdGVudCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBhc3luYyBvdmVyd3JpdGVDYWNoZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGVyc2lzdGVuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIk5vIHBlcnNpc3RlbmNlIGxheWVyIHNwZWNpZmllZCwgY2FjaGUgY2Fubm90IGJlIG92ZXJ3cml0dGVuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJPdmVyd3JpdGluZyBpbi1tZW1vcnkgY2FjaGUgd2l0aCBwZXJzaXN0ZW50IGNhY2hlXCIpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlQ29udGV4dCA9IG5ldyBUb2tlbkNhY2hlQ29udGV4dCh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5iZWZvcmVDYWNoZUFjY2VzcyhjYWNoZUNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlU25hcHNob3QgPSB0aGlzLmdldENhY2hlU25hcHNob3QoKTtcclxuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0Q2FjaGUoY2FjaGVTbmFwc2hvdCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5hZnRlckNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjYWNoZSBoYXMgY2hhbmdlZCBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlQ2hhbmdlRXZlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZUhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXJnZSBpbiBtZW1vcnkgY2FjaGUgd2l0aCB0aGUgY2FjaGUgc25hcHNob3QuXHJcbiAgICAgKiBAcGFyYW0gb2xkU3RhdGUgLSBjYWNoZSBiZWZvcmUgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIGN1cnJlbnRTdGF0ZSAtIGN1cnJlbnQgY2FjaGUgc3RhdGUgaW4gdGhlIGxpYnJhcnlcclxuICAgICAqL1xyXG4gICAgbWVyZ2VTdGF0ZShvbGRTdGF0ZSwgY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJNZXJnaW5nIGluLW1lbW9yeSBjYWNoZSB3aXRoIGNhY2hlIHNuYXBzaG90XCIpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlQWZ0ZXJSZW1vdmFsID0gdGhpcy5tZXJnZVJlbW92YWxzKG9sZFN0YXRlLCBjdXJyZW50U3RhdGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlVXBkYXRlcyhzdGF0ZUFmdGVyUmVtb3ZhbCwgY3VycmVudFN0YXRlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVlcCB1cGRhdGUgb2Ygb2xkU3RhdGUgYmFzZWQgb24gbmV3U3RhdGUgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0gb2xkU3RhdGUgLSBjYWNoZSBiZWZvcmUgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIC0gdXBkYXRlZCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBtZXJnZVVwZGF0ZXMob2xkU3RhdGUsIG5ld1N0YXRlKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMobmV3U3RhdGUpLmZvckVhY2goKG5ld0tleSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ld1N0YXRlW25ld0tleV07XHJcbiAgICAgICAgICAgIC8vIGlmIG9sZFN0YXRlIGRvZXMgbm90IGNvbnRhaW4gdmFsdWUgYnV0IG5ld1ZhbHVlIGRvZXMsIGFkZCBpdFxyXG4gICAgICAgICAgICBpZiAoIW9sZFN0YXRlLmhhc093blByb3BlcnR5KG5ld0tleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlW25ld0tleV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGJvdGggb2xkU3RhdGUgYW5kIG5ld1N0YXRlIGNvbnRhaW4gdGhlIGtleSwgZG8gZGVlcCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlTm90TnVsbCA9IG5ld1ZhbHVlICE9PSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWVJc09iamVjdCA9IHR5cGVvZiBuZXdWYWx1ZSA9PT0gXCJvYmplY3RcIjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlSXNOb3RBcnJheSA9ICFBcnJheS5pc0FycmF5KG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFN0YXRlTm90VW5kZWZpbmVkT3JOdWxsID0gdHlwZW9mIG9sZFN0YXRlW25ld0tleV0gIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZVtuZXdLZXldICE9PSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlTm90TnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlSXNPYmplY3QgJiZcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZUlzTm90QXJyYXkgJiZcclxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZU5vdFVuZGVmaW5lZE9yTnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VVcGRhdGVzKG9sZFN0YXRlW25ld0tleV0sIG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlW25ld0tleV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvbGRTdGF0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBlbnRpdGllcyBpbiBvbGRTdGF0ZSB0aGF0IHRoZSB3ZXJlIHJlbW92ZWQgZnJvbSBuZXdTdGF0ZS4gSWYgdGhlcmUgYXJlIGFueSB1bmtub3duIHZhbHVlcyBpbiByb290IG9mXHJcbiAgICAgKiBvbGRTdGF0ZSB0aGF0IGFyZSBub3QgcmVjb2duaXplZCwgdGhleSBhcmUgbGVmdCB1bnRvdWNoZWQuXHJcbiAgICAgKiBAcGFyYW0gb2xkU3RhdGUgLSBjYWNoZSBiZWZvcmUgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIC0gdXBkYXRlZCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBtZXJnZVJlbW92YWxzKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiUmVtb3ZlIHVwZGF0ZWQgZW50cmllcyBpbiBjYWNoZVwiKTtcclxuICAgICAgICBjb25zdCBhY2NvdW50cyA9IG9sZFN0YXRlLkFjY291bnRcclxuICAgICAgICAgICAgPyB0aGlzLm1lcmdlUmVtb3ZhbHNEaWN0KG9sZFN0YXRlLkFjY291bnQsIG5ld1N0YXRlLkFjY291bnQpXHJcbiAgICAgICAgICAgIDogb2xkU3RhdGUuQWNjb3VudDtcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbnMgPSBvbGRTdGF0ZS5BY2Nlc3NUb2tlblxyXG4gICAgICAgICAgICA/IHRoaXMubWVyZ2VSZW1vdmFsc0RpY3Qob2xkU3RhdGUuQWNjZXNzVG9rZW4sIG5ld1N0YXRlLkFjY2Vzc1Rva2VuKVxyXG4gICAgICAgICAgICA6IG9sZFN0YXRlLkFjY2Vzc1Rva2VuO1xyXG4gICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbnMgPSBvbGRTdGF0ZS5SZWZyZXNoVG9rZW5cclxuICAgICAgICAgICAgPyB0aGlzLm1lcmdlUmVtb3ZhbHNEaWN0KG9sZFN0YXRlLlJlZnJlc2hUb2tlbiwgbmV3U3RhdGUuUmVmcmVzaFRva2VuKVxyXG4gICAgICAgICAgICA6IG9sZFN0YXRlLlJlZnJlc2hUb2tlbjtcclxuICAgICAgICBjb25zdCBpZFRva2VucyA9IG9sZFN0YXRlLklkVG9rZW5cclxuICAgICAgICAgICAgPyB0aGlzLm1lcmdlUmVtb3ZhbHNEaWN0KG9sZFN0YXRlLklkVG9rZW4sIG5ld1N0YXRlLklkVG9rZW4pXHJcbiAgICAgICAgICAgIDogb2xkU3RhdGUuSWRUb2tlbjtcclxuICAgICAgICBjb25zdCBhcHBNZXRhZGF0YSA9IG9sZFN0YXRlLkFwcE1ldGFkYXRhXHJcbiAgICAgICAgICAgID8gdGhpcy5tZXJnZVJlbW92YWxzRGljdChvbGRTdGF0ZS5BcHBNZXRhZGF0YSwgbmV3U3RhdGUuQXBwTWV0YWRhdGEpXHJcbiAgICAgICAgICAgIDogb2xkU3RhdGUuQXBwTWV0YWRhdGE7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4ub2xkU3RhdGUsXHJcbiAgICAgICAgICAgIEFjY291bnQ6IGFjY291bnRzLFxyXG4gICAgICAgICAgICBBY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW5zLFxyXG4gICAgICAgICAgICBSZWZyZXNoVG9rZW46IHJlZnJlc2hUb2tlbnMsXHJcbiAgICAgICAgICAgIElkVG9rZW46IGlkVG9rZW5zLFxyXG4gICAgICAgICAgICBBcHBNZXRhZGF0YTogYXBwTWV0YWRhdGEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIHRvIG1lcmdlIG5ldyBjYWNoZSB3aXRoIHRoZSBvbGQgb25lXHJcbiAgICAgKiBAcGFyYW0gb2xkU3RhdGUgLSBjYWNoZSBiZWZvcmUgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIC0gdXBkYXRlZCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBtZXJnZVJlbW92YWxzRGljdChvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcclxuICAgICAgICBjb25zdCBmaW5hbFN0YXRlID0geyAuLi5vbGRTdGF0ZSB9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9sZFN0YXRlKS5mb3JFYWNoKChvbGRLZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZSB8fCAhbmV3U3RhdGUuaGFzT3duUHJvcGVydHkob2xkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGZpbmFsU3RhdGVbb2xkS2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaW5hbFN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gb3ZlcmxheSBhcyBhIHBhcnQgb2YgY2FjaGUgbWVyZ2VcclxuICAgICAqIEBwYXJhbSBwYXNzZWRJbkNhY2hlIC0gY2FjaGUgcmVhZCBmcm9tIHRoZSBibG9iXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXlEZWZhdWx0cyhwYXNzZWRJbkNhY2hlKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJPdmVybGF5aW5nIGlucHV0IGNhY2hlIHdpdGggdGhlIGRlZmF1bHQgY2FjaGVcIik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgQWNjb3VudDoge1xyXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdFNlcmlhbGl6ZWRDYWNoZS5BY2NvdW50LFxyXG4gICAgICAgICAgICAgICAgLi4ucGFzc2VkSW5DYWNoZS5BY2NvdW50LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBJZFRva2VuOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0U2VyaWFsaXplZENhY2hlLklkVG9rZW4sXHJcbiAgICAgICAgICAgICAgICAuLi5wYXNzZWRJbkNhY2hlLklkVG9rZW4sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEFjY2Vzc1Rva2VuOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0U2VyaWFsaXplZENhY2hlLkFjY2Vzc1Rva2VuLFxyXG4gICAgICAgICAgICAgICAgLi4ucGFzc2VkSW5DYWNoZS5BY2Nlc3NUb2tlbixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgUmVmcmVzaFRva2VuOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0U2VyaWFsaXplZENhY2hlLlJlZnJlc2hUb2tlbixcclxuICAgICAgICAgICAgICAgIC4uLnBhc3NlZEluQ2FjaGUuUmVmcmVzaFRva2VuLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBBcHBNZXRhZGF0YToge1xyXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdFNlcmlhbGl6ZWRDYWNoZS5BcHBNZXRhZGF0YSxcclxuICAgICAgICAgICAgICAgIC4uLnBhc3NlZEluQ2FjaGUuQXBwTWV0YWRhdGEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBUb2tlbkNhY2hlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlbkNhY2hlLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRBdXRoRXJyb3IsIENsaWVudEF1dGhFcnJvckNvZGVzLCBUaW1lVXRpbHMsIEVuY29kaW5nVHlwZXMsIENvbnN0YW50cyB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbi9ub2RlJztcbmltcG9ydCB7IEVuY29kaW5nVXRpbHMgfSBmcm9tICcuLi91dGlscy9FbmNvZGluZ1V0aWxzLm1qcyc7XG5pbXBvcnQgeyBKd3RDb25zdGFudHMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDbGllbnQgYXNzZXJ0aW9uIG9mIHR5cGUgand0LWJlYXJlciB1c2VkIGluIGNvbmZpZGVudGlhbCBjbGllbnQgZmxvd3NcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQ2xpZW50QXNzZXJ0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgQ2xpZW50QXNzZXJ0aW9uIGNsYXNzIGZyb20gdGhlIGNsaWVudEFzc2VydGlvbiBwYXNzZWQgYnkgdGhlIHVzZXJcclxuICAgICAqIEBwYXJhbSBhc3NlcnRpb24gLSByZWZlciBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUyMVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUFzc2VydGlvbihhc3NlcnRpb24pIHtcclxuICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb24gPSBuZXcgQ2xpZW50QXNzZXJ0aW9uKCk7XHJcbiAgICAgICAgY2xpZW50QXNzZXJ0aW9uLmp3dCA9IGFzc2VydGlvbjtcclxuICAgICAgICByZXR1cm4gY2xpZW50QXNzZXJ0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgZnJvbUNlcnRpZmljYXRlV2l0aFNoYTI1NlRodW1icHJpbnQgaW5zdGVhZCwgd2l0aCBhIFNIQS0yNTYgdGh1bXByaW50XHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBDbGllbnRBc3NlcnRpb24gY2xhc3MgZnJvbSB0aGUgY2VydGlmaWNhdGUgcGFzc2VkIGJ5IHRoZSB1c2VyXHJcbiAgICAgKiBAcGFyYW0gdGh1bWJwcmludCAtIGlkZW50aWZpZXIgb2YgYSBjZXJ0aWZpY2F0ZVxyXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgLSBzZWNyZXQga2V5XHJcbiAgICAgKiBAcGFyYW0gcHVibGljQ2VydGlmaWNhdGUgLSBlbGVjdHJvbmljIGRvY3VtZW50IHByb3ZpZGVkIHRvIHByb3ZlIHRoZSBvd25lcnNoaXAgb2YgdGhlIHB1YmxpYyBrZXlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21DZXJ0aWZpY2F0ZSh0aHVtYnByaW50LCBwcml2YXRlS2V5LCBwdWJsaWNDZXJ0aWZpY2F0ZSkge1xyXG4gICAgICAgIGNvbnN0IGNsaWVudEFzc2VydGlvbiA9IG5ldyBDbGllbnRBc3NlcnRpb24oKTtcclxuICAgICAgICBjbGllbnRBc3NlcnRpb24ucHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XHJcbiAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnRodW1icHJpbnQgPSB0aHVtYnByaW50O1xyXG4gICAgICAgIGNsaWVudEFzc2VydGlvbi51c2VTaGEyNTYgPSBmYWxzZTtcclxuICAgICAgICBpZiAocHVibGljQ2VydGlmaWNhdGUpIHtcclxuICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnB1YmxpY0NlcnRpZmljYXRlID1cclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VDZXJ0aWZpY2F0ZShwdWJsaWNDZXJ0aWZpY2F0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIENsaWVudEFzc2VydGlvbiBjbGFzcyBmcm9tIHRoZSBjZXJ0aWZpY2F0ZSBwYXNzZWQgYnkgdGhlIHVzZXJcclxuICAgICAqIEBwYXJhbSB0aHVtYnByaW50IC0gaWRlbnRpZmllciBvZiBhIGNlcnRpZmljYXRlXHJcbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSAtIHNlY3JldCBrZXlcclxuICAgICAqIEBwYXJhbSBwdWJsaWNDZXJ0aWZpY2F0ZSAtIGVsZWN0cm9uaWMgZG9jdW1lbnQgcHJvdmlkZWQgdG8gcHJvdmUgdGhlIG93bmVyc2hpcCBvZiB0aGUgcHVibGljIGtleVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUNlcnRpZmljYXRlV2l0aFNoYTI1NlRodW1icHJpbnQodGh1bWJwcmludCwgcHJpdmF0ZUtleSwgcHVibGljQ2VydGlmaWNhdGUpIHtcclxuICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb24gPSBuZXcgQ2xpZW50QXNzZXJ0aW9uKCk7XHJcbiAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xyXG4gICAgICAgIGNsaWVudEFzc2VydGlvbi50aHVtYnByaW50ID0gdGh1bWJwcmludDtcclxuICAgICAgICBjbGllbnRBc3NlcnRpb24udXNlU2hhMjU2ID0gdHJ1ZTtcclxuICAgICAgICBpZiAocHVibGljQ2VydGlmaWNhdGUpIHtcclxuICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uLnB1YmxpY0NlcnRpZmljYXRlID1cclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VDZXJ0aWZpY2F0ZShwdWJsaWNDZXJ0aWZpY2F0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGllbnRBc3NlcnRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBKV1QgZm9yIGNlcnRpZmljYXRlIGJhc2VkIGNsaWVudEFzc2VydGlvbiwgaWYgcGFzc2VkIGJ5IHRoZSB1c2VyLCB1c2VzIGl0IGFzIGlzXHJcbiAgICAgKiBAcGFyYW0gY3J5cHRvUHJvdmlkZXIgLSBsaWJyYXJ5J3MgY3J5cHRvIGhlbHBlclxyXG4gICAgICogQHBhcmFtIGlzc3VlciAtIGlzcyBjbGFpbVxyXG4gICAgICogQHBhcmFtIGp3dEF1ZGllbmNlIC0gYXVkIGNsYWltXHJcbiAgICAgKi9cclxuICAgIGdldEp3dChjcnlwdG9Qcm92aWRlciwgaXNzdWVyLCBqd3RBdWRpZW5jZSkge1xyXG4gICAgICAgIC8vIGlmIGFzc2VydGlvbiB3YXMgY3JlYXRlZCBmcm9tIGNlcnRpZmljYXRlLCBjaGVjayBpZiBqd3QgaXMgZXhwaXJlZCBhbmQgY3JlYXRlIG5ldyBvbmUuXHJcbiAgICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleSAmJiB0aGlzLnRodW1icHJpbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuand0ICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0V4cGlyZWQoKSAmJlxyXG4gICAgICAgICAgICAgICAgaXNzdWVyID09PSB0aGlzLmlzc3VlciAmJlxyXG4gICAgICAgICAgICAgICAgand0QXVkaWVuY2UgPT09IHRoaXMuand0QXVkaWVuY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmp3dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVKd3QoY3J5cHRvUHJvdmlkZXIsIGlzc3Vlciwgand0QXVkaWVuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIGlmIGFzc2VydGlvbiB3YXMgY3JlYXRlZCBieSBjYWxsZXIsIHRoZW4gd2UganVzdCBhcHBlbmQgaXQuIEl0IGlzIHVwIHRvIHRoZSBjYWxsZXIgdG9cclxuICAgICAgICAgKiBlbnN1cmUgdGhhdCBpdCBjb250YWlucyBuZWNlc3NhcnkgY2xhaW1zIGFuZCB0aGF0IGl0IGlzIG5vdCBleHBpcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLmp3dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5qd3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQXNzZXJ0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSldUIGZvcm1hdCBhbmQgcmVxdWlyZWQgY2xhaW1zIHNwZWNpZmllZDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MjMjc2VjdGlvbi0zXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUp3dChjcnlwdG9Qcm92aWRlciwgaXNzdWVyLCBqd3RBdWRpZW5jZSkge1xyXG4gICAgICAgIHRoaXMuaXNzdWVyID0gaXNzdWVyO1xyXG4gICAgICAgIHRoaXMuand0QXVkaWVuY2UgPSBqd3RBdWRpZW5jZTtcclxuICAgICAgICBjb25zdCBpc3N1ZWRBdCA9IFRpbWVVdGlscy5ub3dTZWNvbmRzKCk7XHJcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IGlzc3VlZEF0ICsgNjAwO1xyXG4gICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IHRoaXMudXNlU2hhMjU2XHJcbiAgICAgICAgICAgID8gSnd0Q29uc3RhbnRzLlBTU18yNTZcclxuICAgICAgICAgICAgOiBKd3RDb25zdGFudHMuUlNBXzI1NjtcclxuICAgICAgICBjb25zdCBoZWFkZXIgPSB7XHJcbiAgICAgICAgICAgIGFsZzogYWxnb3JpdGhtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdGh1bWJwcmludEhlYWRlciA9IHRoaXMudXNlU2hhMjU2XHJcbiAgICAgICAgICAgID8gSnd0Q29uc3RhbnRzLlg1VF8yNTZcclxuICAgICAgICAgICAgOiBKd3RDb25zdGFudHMuWDVUO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVyLCB7XHJcbiAgICAgICAgICAgIFt0aHVtYnByaW50SGVhZGVyXTogRW5jb2RpbmdVdGlscy5iYXNlNjRFbmNvZGVVcmwodGhpcy50aHVtYnByaW50LCBFbmNvZGluZ1R5cGVzLkhFWCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMucHVibGljQ2VydGlmaWNhdGUpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXIsIHtcclxuICAgICAgICAgICAgICAgIFtKd3RDb25zdGFudHMuWDVDXTogdGhpcy5wdWJsaWNDZXJ0aWZpY2F0ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgIFtKd3RDb25zdGFudHMuQVVESUVOQ0VdOiB0aGlzLmp3dEF1ZGllbmNlLFxyXG4gICAgICAgICAgICBbSnd0Q29uc3RhbnRzLkVYUElSQVRJT05fVElNRV06IHRoaXMuZXhwaXJhdGlvblRpbWUsXHJcbiAgICAgICAgICAgIFtKd3RDb25zdGFudHMuSVNTVUVSXTogdGhpcy5pc3N1ZXIsXHJcbiAgICAgICAgICAgIFtKd3RDb25zdGFudHMuU1VCSkVDVF06IHRoaXMuaXNzdWVyLFxyXG4gICAgICAgICAgICBbSnd0Q29uc3RhbnRzLk5PVF9CRUZPUkVdOiBpc3N1ZWRBdCxcclxuICAgICAgICAgICAgW0p3dENvbnN0YW50cy5KV1RfSURdOiBjcnlwdG9Qcm92aWRlci5jcmVhdGVOZXdHdWlkKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmp3dCA9IGp3dC5zaWduKHBheWxvYWQsIHRoaXMucHJpdmF0ZUtleSwgeyBoZWFkZXIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuand0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVdGlsaXR5IEFQSSB0byBjaGVjayBleHBpcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIGlzRXhwaXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9uVGltZSA8IFRpbWVVdGlscy5ub3dTZWNvbmRzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHRoZSByYXcgY2VydHMgZnJvbSBhIGdpdmVuIGNlcnRpZmljYXRlIHN0cmluZyBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHB1YmxpY0NlcnRpZmljYXRlIC0gZWxlY3Ryb25pYyBkb2N1bWVudCBwcm92aWRlZCB0byBwcm92ZSB0aGUgb3duZXJzaGlwIG9mIHRoZSBwdWJsaWMga2V5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwYXJzZUNlcnRpZmljYXRlKHB1YmxpY0NlcnRpZmljYXRlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyByZWdleCB0byBpZGVudGlmeSB0aGUgY2VydHMgaW4gYSBnaXZlbiBjZXJ0aWZpY2F0ZSBzdHJpbmcuXHJcbiAgICAgICAgICogV2Ugd2FudCB0byBsb29rIGZvciB0aGUgY29udGVudHMgYmV0d2VlbiB0aGUgQkVHSU4gYW5kIEVORCBjZXJ0aWZpY2F0ZSBzdHJpbmdzLCB3aXRob3V0IHRoZSBhc3NvY2lhdGVkIG5ld2xpbmVzLlxyXG4gICAgICAgICAqIFRoZSBpbmZvcm1hdGlvbiBpbiBwYXJlbnMgXCIoLis/KVwiIGlzIHRoZSBjYXB0dXJlIGdyb3VwIHRvIHJlcHJlc2VudCB0aGUgY2VydCB3ZSB3YW50IGlzb2xhdGVkLlxyXG4gICAgICAgICAqIFwiLlwiIG1lYW5zIGFueSBzdHJpbmcgY2hhcmFjdGVyLCBcIitcIiBtZWFucyBtYXRjaCAxIG9yIG1vcmUgdGltZXMsIGFuZCBcIj9cIiBtZWFucyB0aGUgc2hvcnRlc3QgbWF0Y2guXHJcbiAgICAgICAgICogVGhlIFwiZ1wiIGF0IHRoZSBlbmQgb2YgdGhlIHJlZ2V4IG1lYW5zIHNlYXJjaCB0aGUgc3RyaW5nIGdsb2JhbGx5LCBhbmQgdGhlIFwic1wiIGVuYWJsZXMgdGhlIFwiLlwiIHRvIG1hdGNoIG5ld2xpbmVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4VG9GaW5kQ2VydHMgPSAvLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXFxyKlxcbiguKz8pXFxyKlxcbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0vZ3M7XHJcbiAgICAgICAgY29uc3QgY2VydHMgPSBbXTtcclxuICAgICAgICBsZXQgbWF0Y2hlcztcclxuICAgICAgICB3aGlsZSAoKG1hdGNoZXMgPSByZWdleFRvRmluZENlcnRzLmV4ZWMocHVibGljQ2VydGlmaWNhdGUpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBtYXRjaGVzWzFdIHJlcHJlc2VudHMgdGhlIGZpcnN0IHBhcmVucyBjYXB0dXJlIGdyb3VwIGluIHRoZSByZWdleC5cclxuICAgICAgICAgICAgY2VydHMucHVzaChtYXRjaGVzWzFdLnJlcGxhY2UoL1xccipcXG4vZywgQ29uc3RhbnRzLkVNUFRZX1NUUklORykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2VydHM7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQ2xpZW50QXNzZXJ0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGllbnRBc3NlcnRpb24ubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIGhlYWRlci9oZWFkZXIgKi9cclxuY29uc3QgbmFtZSA9IFwiQGF6dXJlL21zYWwtbm9kZVwiO1xyXG5jb25zdCB2ZXJzaW9uID0gXCIzLjYuMFwiO1xuXG5leHBvcnQgeyBuYW1lLCB2ZXJzaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWNrYWdlTWV0YWRhdGEubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEJhc2VDbGllbnQsIFRpbWVVdGlscywgUmVzcG9uc2VIYW5kbGVyLCBVcmxTdHJpbmcsIENjc0NyZWRlbnRpYWxUeXBlLCBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlciwgT0F1dGhSZXNwb25zZVR5cGUsIEdyYW50VHlwZSwgZ2V0Q2xpZW50QXNzZXJ0aW9uLCBTdHJpbmdVdGlscywgVXJsVXRpbHMgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogT2F1dGgyLjAgUGFzc3dvcmQgZ3JhbnQgY2xpZW50XHJcbiAqIE5vdGU6IFdlIGFyZSBvbmx5IHN1cHBvcnRpbmcgcHVibGljIGNsaWVudHMgZm9yIHBhc3N3b3JkIGdyYW50IGFuZCBmb3IgcHVyZWx5IHRlc3RpbmcgcHVycG9zZXNcclxuICogQHB1YmxpY1xyXG4gKiBAZGVwcmVjYXRlZCAtIFVzZSBhIG1vcmUgc2VjdXJlIGZsb3cgaW5zdGVhZFxyXG4gKi9cclxuY2xhc3MgVXNlcm5hbWVQYXNzd29yZENsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBUEkgdG8gYWNxdWlyZSBhIHRva2VuIGJ5IHBhc3NpbmcgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCB0byB0aGUgc2VydmljZSBpbiBleGNoYWdlIG9mIGNyZWRlbnRpYWxzXHJcbiAgICAgKiBwYXNzd29yZF9ncmFudFxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBDb21tb25Vc2VybmFtZVBhc3N3b3JkUmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBhY3F1aXJlVG9rZW4ocmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJpbiBhY3F1aXJlVG9rZW4gY2FsbCBpbiB1c2VybmFtZS1wYXNzd29yZCBjbGllbnRcIik7XHJcbiAgICAgICAgY29uc3QgcmVxVGltZXN0YW1wID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVRva2VuUmVxdWVzdCh0aGlzLmF1dGhvcml0eSwgcmVxdWVzdCk7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gbmV3IFJlc3BvbnNlSGFuZGxlcih0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCwgdGhpcy5jYWNoZU1hbmFnZXIsIHRoaXMuY3J5cHRvVXRpbHMsIHRoaXMubG9nZ2VyLCB0aGlzLmNvbmZpZy5zZXJpYWxpemFibGVDYWNoZSwgdGhpcy5jb25maWcucGVyc2lzdGVuY2VQbHVnaW4pO1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIHJlc3BvbnNlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBhIHNlcnZlciBlcnJvciBpZiBhbiBlcnJvciBpcyByZXR1cm5lZCBieSB0aGUgc2VydmVyLlxyXG4gICAgICAgIHJlc3BvbnNlSGFuZGxlci52YWxpZGF0ZVRva2VuUmVzcG9uc2UocmVzcG9uc2UuYm9keSk7XHJcbiAgICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IHJlc3BvbnNlSGFuZGxlci5oYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlKHJlc3BvbnNlLmJvZHksIHRoaXMuYXV0aG9yaXR5LCByZXFUaW1lc3RhbXAsIHJlcXVlc3QpO1xyXG4gICAgICAgIHJldHVybiB0b2tlblJlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyBQT1NUIHJlcXVlc3QgdG8gdG9rZW4gZW5kcG9pbnRcclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHkgLSBhdXRob3JpdHkgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIENvbW1vblVzZXJuYW1lUGFzc3dvcmRSZXF1ZXN0IHByb3ZpZGVkIGJ5IHRoZSBkZXZlbG9wZXJcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZXhlY3V0ZVRva2VuUmVxdWVzdChhdXRob3JpdHksIHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnNTdHJpbmcgPSB0aGlzLmNyZWF0ZVRva2VuUXVlcnlQYXJhbWV0ZXJzKHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gVXJsU3RyaW5nLmFwcGVuZFF1ZXJ5U3RyaW5nKGF1dGhvcml0eS50b2tlbkVuZHBvaW50LCBxdWVyeVBhcmFtZXRlcnNTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gYXdhaXQgdGhpcy5jcmVhdGVUb2tlblJlcXVlc3RCb2R5KHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdEhlYWRlcnMoe1xyXG4gICAgICAgICAgICBjcmVkZW50aWFsOiByZXF1ZXN0LnVzZXJuYW1lLFxyXG4gICAgICAgICAgICB0eXBlOiBDY3NDcmVkZW50aWFsVHlwZS5VUE4sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgdGh1bWJwcmludCA9IHtcclxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxyXG4gICAgICAgICAgICBhdXRob3JpdHk6IGF1dGhvcml0eS5jYW5vbmljYWxBdXRob3JpdHksXHJcbiAgICAgICAgICAgIHNjb3BlczogcmVxdWVzdC5zY29wZXMsXHJcbiAgICAgICAgICAgIGNsYWltczogcmVxdWVzdC5jbGFpbXMsXHJcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uU2NoZW1lOiByZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lLFxyXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RNZXRob2Q6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0TWV0aG9kLFxyXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RVcmk6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpLFxyXG4gICAgICAgICAgICBzaHJDbGFpbXM6IHJlcXVlc3Quc2hyQ2xhaW1zLFxyXG4gICAgICAgICAgICBzc2hLaWQ6IHJlcXVlc3Quc3NoS2lkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVBvc3RUb1Rva2VuRW5kcG9pbnQoZW5kcG9pbnQsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB0aHVtYnByaW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBtYXAgZm9yIGFsbCB0aGUgcGFyYW1zIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZpY2VcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gQ29tbW9uVXNlcm5hbWVQYXNzd29yZFJlcXVlc3QgcHJvdmlkZWQgYnkgdGhlIGRldmVsb3BlclxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGVUb2tlblJlcXVlc3RCb2R5KHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudElkKHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRVc2VybmFtZShwYXJhbWV0ZXJzLCByZXF1ZXN0LnVzZXJuYW1lKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRQYXNzd29yZChwYXJhbWV0ZXJzLCByZXF1ZXN0LnBhc3N3b3JkKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTY29wZXMocGFyYW1ldGVycywgcmVxdWVzdC5zY29wZXMpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFJlc3BvbnNlVHlwZShwYXJhbWV0ZXJzLCBPQXV0aFJlc3BvbnNlVHlwZS5JRFRPS0VOX1RPS0VOKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRHcmFudFR5cGUocGFyYW1ldGVycywgR3JhbnRUeXBlLlJFU09VUkNFX09XTkVSX1BBU1NXT1JEX0dSQU5UKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRJbmZvKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZExpYnJhcnlJbmZvKHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLmxpYnJhcnlJbmZvKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRBcHBsaWNhdGlvblRlbGVtZXRyeShwYXJhbWV0ZXJzLCB0aGlzLmNvbmZpZy50ZWxlbWV0cnkuYXBwbGljYXRpb24pO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFRocm90dGxpbmcocGFyYW1ldGVycyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcikge1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTZXJ2ZXJUZWxlbWV0cnkocGFyYW1ldGVycywgdGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29ycmVsYXRpb25JZCA9IHJlcXVlc3QuY29ycmVsYXRpb25JZCB8fFxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jcnlwdG9JbnRlcmZhY2UuY3JlYXRlTmV3R3VpZCgpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENvcnJlbGF0aW9uSWQocGFyYW1ldGVycywgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudFNlY3JldCkge1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRTZWNyZXQocGFyYW1ldGVycywgdGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xpZW50QXNzZXJ0aW9uID0gdGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50QXNzZXJ0aW9uO1xyXG4gICAgICAgIGlmIChjbGllbnRBc3NlcnRpb24pIHtcclxuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50QXNzZXJ0aW9uKHBhcmFtZXRlcnMsIGF3YWl0IGdldENsaWVudEFzc2VydGlvbihjbGllbnRBc3NlcnRpb24uYXNzZXJ0aW9uLCB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRJZCwgcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RVcmkpKTtcclxuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50QXNzZXJ0aW9uVHlwZShwYXJhbWV0ZXJzLCBjbGllbnRBc3NlcnRpb24uYXNzZXJ0aW9uVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghU3RyaW5nVXRpbHMuaXNFbXB0eU9iaihyZXF1ZXN0LmNsYWltcykgfHxcclxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsYWltcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LmNsYWltcywgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnN5c3RlbU9wdGlvbnMucHJldmVudENvcnNQcmVmbGlnaHQgJiZcclxuICAgICAgICAgICAgcmVxdWVzdC51c2VybmFtZSkge1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDY3NVcG4ocGFyYW1ldGVycywgcmVxdWVzdC51c2VybmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFVzZXJuYW1lUGFzc3dvcmRDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVzZXJuYW1lUGFzc3dvcmRDbGllbnQubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLWNvbW1vbiB2MTUuNy4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGFkZENsaWVudElkLCBhZGRTY29wZXMsIGFkZFJlZGlyZWN0VXJpLCBhZGRDb3JyZWxhdGlvbklkLCBhZGRSZXNwb25zZU1vZGUsIGFkZENsaWVudEluZm8sIGFkZFByb21wdCwgYWRkRG9tYWluSGludCwgYWRkU2lkLCBhZGRMb2dpbkhpbnQsIGFkZENjc09pZCwgYWRkQ2NzVXBuLCBhZGROb25jZSwgYWRkU3RhdGUsIGFkZENsYWltcywgYWRkQnJva2VyUGFyYW1ldGVycywgYWRkSW5zdGFuY2VBd2FyZSB9IGZyb20gJy4uL3JlcXVlc3QvUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIubWpzJztcbmltcG9ydCB7IENMSUVOVF9JRCwgSU5TVEFOQ0VfQVdBUkUgfSBmcm9tICcuLi9jb25zdGFudHMvQUFEU2VydmVyUGFyYW1LZXlzLm1qcyc7XG5pbXBvcnQgeyBQcm9tcHRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgYnVpbGRDbGllbnRJbmZvRnJvbUhvbWVBY2NvdW50SWQgfSBmcm9tICcuLi9hY2NvdW50L0NsaWVudEluZm8ubWpzJztcbmltcG9ydCB7IG1hcFRvUXVlcnlTdHJpbmcgfSBmcm9tICcuLi91dGlscy9VcmxVdGlscy5tanMnO1xuaW1wb3J0IHsgVXJsU3RyaW5nIH0gZnJvbSAnLi4vdXJsL1VybFN0cmluZy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50QXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yLm1qcyc7XG5pbXBvcnQgeyBpc0ludGVyYWN0aW9uUmVxdWlyZWRFcnJvciwgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL0ludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IFNlcnZlckVycm9yIH0gZnJvbSAnLi4vZXJyb3IvU2VydmVyRXJyb3IubWpzJztcbmltcG9ydCB7IGF1dGhvcml6YXRpb25Db2RlTWlzc2luZ0Zyb21TZXJ2ZXJSZXNwb25zZSwgc3RhdGVOb3RGb3VuZCwgaW52YWxpZFN0YXRlLCBzdGF0ZU1pc21hdGNoIH0gZnJvbSAnLi4vZXJyb3IvQ2xpZW50QXV0aEVycm9yQ29kZXMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIG1hcCBvZiBwYXJhbWV0ZXJzIHRoYXQgYXJlIGFwcGxpY2FibGUgdG8gYWxsIGNhbGxzIHRvIC9hdXRob3JpemUgd2hldGhlciB1c2luZyBQS0NFIG9yIEVBUlxyXG4gKiBAcGFyYW0gY29uZmlnXHJcbiAqIEBwYXJhbSByZXF1ZXN0XHJcbiAqIEBwYXJhbSBsb2dnZXJcclxuICogQHBhcmFtIHBlcmZvcm1hbmNlQ2xpZW50XHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdGFuZGFyZEF1dGhvcml6ZVJlcXVlc3RQYXJhbWV0ZXJzKGF1dGhPcHRpb25zLCByZXF1ZXN0LCBsb2dnZXIsIHBlcmZvcm1hbmNlQ2xpZW50KSB7XHJcbiAgICAvLyBnZW5lcmF0ZSB0aGUgY29ycmVsYXRpb25JZCBpZiBub3Qgc2V0IGJ5IHRoZSB1c2VyIGFuZCBhZGRcclxuICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSByZXF1ZXN0LmNvcnJlbGF0aW9uSWQ7XHJcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgYWRkQ2xpZW50SWQocGFyYW1ldGVycywgcmVxdWVzdC5lbWJlZGRlZENsaWVudElkIHx8XHJcbiAgICAgICAgcmVxdWVzdC5leHRyYVF1ZXJ5UGFyYW1ldGVycz8uW0NMSUVOVF9JRF0gfHxcclxuICAgICAgICBhdXRoT3B0aW9ucy5jbGllbnRJZCk7XHJcbiAgICBjb25zdCByZXF1ZXN0U2NvcGVzID0gW1xyXG4gICAgICAgIC4uLihyZXF1ZXN0LnNjb3BlcyB8fCBbXSksXHJcbiAgICAgICAgLi4uKHJlcXVlc3QuZXh0cmFTY29wZXNUb0NvbnNlbnQgfHwgW10pLFxyXG4gICAgXTtcclxuICAgIGFkZFNjb3BlcyhwYXJhbWV0ZXJzLCByZXF1ZXN0U2NvcGVzLCB0cnVlLCBhdXRoT3B0aW9ucy5hdXRob3JpdHkub3B0aW9ucy5PSURDT3B0aW9ucz8uZGVmYXVsdFNjb3Blcyk7XHJcbiAgICBhZGRSZWRpcmVjdFVyaShwYXJhbWV0ZXJzLCByZXF1ZXN0LnJlZGlyZWN0VXJpKTtcclxuICAgIGFkZENvcnJlbGF0aW9uSWQocGFyYW1ldGVycywgY29ycmVsYXRpb25JZCk7XHJcbiAgICAvLyBhZGQgcmVzcG9uc2VfbW9kZS4gSWYgbm90IHBhc3NlZCBpbiBpdCBkZWZhdWx0cyB0byBxdWVyeS5cclxuICAgIGFkZFJlc3BvbnNlTW9kZShwYXJhbWV0ZXJzLCByZXF1ZXN0LnJlc3BvbnNlTW9kZSk7XHJcbiAgICAvLyBhZGQgY2xpZW50X2luZm89MVxyXG4gICAgYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKTtcclxuICAgIGlmIChyZXF1ZXN0LnByb21wdCkge1xyXG4gICAgICAgIGFkZFByb21wdChwYXJhbWV0ZXJzLCByZXF1ZXN0LnByb21wdCk7XHJcbiAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyh7IHByb21wdDogcmVxdWVzdC5wcm9tcHQgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdC5kb21haW5IaW50KSB7XHJcbiAgICAgICAgYWRkRG9tYWluSGludChwYXJhbWV0ZXJzLCByZXF1ZXN0LmRvbWFpbkhpbnQpO1xyXG4gICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoeyBkb21haW5IaW50RnJvbVJlcXVlc3Q6IHRydWUgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgc2lkIG9yIGxvZ2luSGludCB3aXRoIHByZWZlcmVuY2UgZm9yIGxvZ2luX2hpbnQgY2xhaW0gKGluIHJlcXVlc3QpIC0+IHNpZCAtPiBsb2dpbkhpbnQgKHVwbi9lbWFpbCkgLT4gdXNlcm5hbWUgb2YgQWNjb3VudEluZm8gb2JqZWN0XHJcbiAgICBpZiAocmVxdWVzdC5wcm9tcHQgIT09IFByb21wdFZhbHVlLlNFTEVDVF9BQ0NPVU5UKSB7XHJcbiAgICAgICAgLy8gQUFEIHdpbGwgdGhyb3cgaWYgcHJvbXB0PXNlbGVjdF9hY2NvdW50IGlzIHBhc3NlZCB3aXRoIGFuIGFjY291bnQgaGludFxyXG4gICAgICAgIGlmIChyZXF1ZXN0LnNpZCAmJiByZXF1ZXN0LnByb21wdCA9PT0gUHJvbXB0VmFsdWUuTk9ORSkge1xyXG4gICAgICAgICAgICAvLyBTZXNzaW9uSUQgaXMgb25seSB1c2VkIGluIHNpbGVudCBjYWxsc1xyXG4gICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IFByb21wdCBpcyBub25lLCBhZGRpbmcgc2lkIGZyb20gcmVxdWVzdFwiKTtcclxuICAgICAgICAgICAgYWRkU2lkKHBhcmFtZXRlcnMsIHJlcXVlc3Quc2lkKTtcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyh7IHNpZEZyb21SZXF1ZXN0OiB0cnVlIH0sIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LmFjY291bnQpIHtcclxuICAgICAgICAgICAgY29uc3QgYWNjb3VudFNpZCA9IGV4dHJhY3RBY2NvdW50U2lkKHJlcXVlc3QuYWNjb3VudCk7XHJcbiAgICAgICAgICAgIGxldCBhY2NvdW50TG9naW5IaW50Q2xhaW0gPSBleHRyYWN0TG9naW5IaW50KHJlcXVlc3QuYWNjb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChhY2NvdW50TG9naW5IaW50Q2xhaW0gJiYgcmVxdWVzdC5kb21haW5IaW50KSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybmluZyhgQXV0aG9yaXphdGlvbkNvZGVDbGllbnQuY3JlYXRlQXV0aENvZGVVcmxRdWVyeVN0cmluZzogXCJkb21haW5IaW50XCIgcGFyYW0gaXMgc2V0LCBza2lwcGluZyBvcGFxdWUgXCJsb2dpbl9oaW50XCIgY2xhaW0uIFBsZWFzZSBjb25zaWRlciBub3QgcGFzc2luZyBkb21haW5IaW50YCk7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50TG9naW5IaW50Q2xhaW0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIGxvZ2luX2hpbnQgY2xhaW0gaXMgcHJlc2VudCwgdXNlIGl0IG92ZXIgc2lkL3VzZXJuYW1lXHJcbiAgICAgICAgICAgIGlmIChhY2NvdW50TG9naW5IaW50Q2xhaW0pIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci52ZXJib3NlKFwiY3JlYXRlQXV0aENvZGVVcmxRdWVyeVN0cmluZzogbG9naW5faGludCBjbGFpbSBwcmVzZW50IG9uIGFjY291bnRcIik7XHJcbiAgICAgICAgICAgICAgICBhZGRMb2dpbkhpbnQocGFyYW1ldGVycywgYWNjb3VudExvZ2luSGludENsYWltKTtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoeyBsb2dpbkhpbnRGcm9tQ2xhaW06IHRydWUgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudEluZm8gPSBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZChyZXF1ZXN0LmFjY291bnQuaG9tZUFjY291bnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2NzT2lkKHBhcmFtZXRlcnMsIGNsaWVudEluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IENvdWxkIG5vdCBwYXJzZSBob21lIGFjY291bnQgSUQgZm9yIENDUyBIZWFkZXJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjb3VudFNpZCAmJiByZXF1ZXN0LnByb21wdCA9PT0gUHJvbXB0VmFsdWUuTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIElmIGFjY291bnQgYW5kIGxvZ2luSGludCBhcmUgcHJvdmlkZWQsIHdlIHdpbGwgY2hlY2sgYWNjb3VudCBmaXJzdCBmb3Igc2lkIGJlZm9yZSBhZGRpbmcgbG9naW5IaW50XHJcbiAgICAgICAgICAgICAgICAgKiBTZXNzaW9uSWQgaXMgb25seSB1c2VkIGluIHNpbGVudCBjYWxsc1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IFByb21wdCBpcyBub25lLCBhZGRpbmcgc2lkIGZyb20gYWNjb3VudFwiKTtcclxuICAgICAgICAgICAgICAgIGFkZFNpZChwYXJhbWV0ZXJzLCBhY2NvdW50U2lkKTtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoeyBzaWRGcm9tQ2xhaW06IHRydWUgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudEluZm8gPSBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZChyZXF1ZXN0LmFjY291bnQuaG9tZUFjY291bnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2NzT2lkKHBhcmFtZXRlcnMsIGNsaWVudEluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IENvdWxkIG5vdCBwYXJzZSBob21lIGFjY291bnQgSUQgZm9yIENDUyBIZWFkZXJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5sb2dpbkhpbnQpIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlci52ZXJib3NlKFwiY3JlYXRlQXV0aENvZGVVcmxRdWVyeVN0cmluZzogQWRkaW5nIGxvZ2luX2hpbnQgZnJvbSByZXF1ZXN0XCIpO1xyXG4gICAgICAgICAgICAgICAgYWRkTG9naW5IaW50KHBhcmFtZXRlcnMsIHJlcXVlc3QubG9naW5IaW50KTtcclxuICAgICAgICAgICAgICAgIGFkZENjc1VwbihwYXJhbWV0ZXJzLCByZXF1ZXN0LmxvZ2luSGludCk7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUNsaWVudD8uYWRkRmllbGRzKHsgbG9naW5IaW50RnJvbVJlcXVlc3Q6IHRydWUgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5hY2NvdW50LnVzZXJuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBhY2NvdW50IHVzZXJuYW1lIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IEFkZGluZyBsb2dpbl9oaW50IGZyb20gYWNjb3VudFwiKTtcclxuICAgICAgICAgICAgICAgIGFkZExvZ2luSGludChwYXJhbWV0ZXJzLCByZXF1ZXN0LmFjY291bnQudXNlcm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2VDbGllbnQ/LmFkZEZpZWxkcyh7IGxvZ2luSGludEZyb21VcG46IHRydWUgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudEluZm8gPSBidWlsZENsaWVudEluZm9Gcm9tSG9tZUFjY291bnRJZChyZXF1ZXN0LmFjY291bnQuaG9tZUFjY291bnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2NzT2lkKHBhcmFtZXRlcnMsIGNsaWVudEluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IENvdWxkIG5vdCBwYXJzZSBob21lIGFjY291bnQgSUQgZm9yIENDUyBIZWFkZXJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5sb2dpbkhpbnQpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoXCJjcmVhdGVBdXRoQ29kZVVybFF1ZXJ5U3RyaW5nOiBObyBhY2NvdW50LCBhZGRpbmcgbG9naW5faGludCBmcm9tIHJlcXVlc3RcIik7XHJcbiAgICAgICAgICAgIGFkZExvZ2luSGludChwYXJhbWV0ZXJzLCByZXF1ZXN0LmxvZ2luSGludCk7XHJcbiAgICAgICAgICAgIGFkZENjc1VwbihwYXJhbWV0ZXJzLCByZXF1ZXN0LmxvZ2luSGludCk7XHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlQ2xpZW50Py5hZGRGaWVsZHMoeyBsb2dpbkhpbnRGcm9tUmVxdWVzdDogdHJ1ZSB9LCBjb3JyZWxhdGlvbklkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsb2dnZXIudmVyYm9zZShcImNyZWF0ZUF1dGhDb2RlVXJsUXVlcnlTdHJpbmc6IFByb21wdCBpcyBzZWxlY3RfYWNjb3VudCwgaWdub3JpbmcgYWNjb3VudCBoaW50c1wiKTtcclxuICAgIH1cclxuICAgIGlmIChyZXF1ZXN0Lm5vbmNlKSB7XHJcbiAgICAgICAgYWRkTm9uY2UocGFyYW1ldGVycywgcmVxdWVzdC5ub25jZSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdC5zdGF0ZSkge1xyXG4gICAgICAgIGFkZFN0YXRlKHBhcmFtZXRlcnMsIHJlcXVlc3Quc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlcXVlc3QuY2xhaW1zIHx8XHJcbiAgICAgICAgKGF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxyXG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICBhZGRDbGFpbXMocGFyYW1ldGVycywgcmVxdWVzdC5jbGFpbXMsIGF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVxdWVzdC5lbWJlZGRlZENsaWVudElkKSB7XHJcbiAgICAgICAgYWRkQnJva2VyUGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBhdXRoT3B0aW9ucy5jbGllbnRJZCwgYXV0aE9wdGlvbnMucmVkaXJlY3RVcmkpO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgZXh0cmFRdWVyeVBhcmFtZXRlcnMgaW5jbHVkZXMgaW5zdGFuY2VfYXdhcmUgaXRzIHZhbHVlIHdpbGwgYmUgYWRkZWQgd2hlbiBleHRyYVF1ZXJ5UGFyYW1ldGVycyBhcmUgYWRkZWRcclxuICAgIGlmIChhdXRoT3B0aW9ucy5pbnN0YW5jZUF3YXJlICYmXHJcbiAgICAgICAgKCFyZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzIHx8XHJcbiAgICAgICAgICAgICFPYmplY3Qua2V5cyhyZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzKS5pbmNsdWRlcyhJTlNUQU5DRV9BV0FSRSkpKSB7XHJcbiAgICAgICAgYWRkSW5zdGFuY2VBd2FyZShwYXJhbWV0ZXJzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGF1dGhvcml6ZSBlbmRwb2ludCB3aXRoIGdpdmVuIHJlcXVlc3QgcGFyYW1ldGVycyBpbiB0aGUgcXVlcnkgc3RyaW5nXHJcbiAqIEBwYXJhbSBhdXRob3JpdHlcclxuICogQHBhcmFtIHJlcXVlc3RQYXJhbWV0ZXJzXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBdXRob3JpemVVcmwoYXV0aG9yaXR5LCByZXF1ZXN0UGFyYW1ldGVycywgZW5jb2RlUGFyYW1zLCBleHRyYVF1ZXJ5UGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBtYXBUb1F1ZXJ5U3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBlbmNvZGVQYXJhbXMsIGV4dHJhUXVlcnlQYXJhbWV0ZXJzKTtcclxuICAgIHJldHVybiBVcmxTdHJpbmcuYXBwZW5kUXVlcnlTdHJpbmcoYXV0aG9yaXR5LmF1dGhvcml6YXRpb25FbmRwb2ludCwgcXVlcnlTdHJpbmcpO1xyXG59XHJcbi8qKlxyXG4gKiBIYW5kbGVzIHRoZSBoYXNoIGZyYWdtZW50IHJlc3BvbnNlIGZyb20gcHVibGljIGNsaWVudCBjb2RlIHJlcXVlc3QuIFJldHVybnMgYSBjb2RlIHJlc3BvbnNlIHVzZWQgYnlcclxuICogdGhlIGNsaWVudCB0byBleGNoYW5nZSBmb3IgYSB0b2tlbiBpbiBhY3F1aXJlVG9rZW4uXHJcbiAqIEBwYXJhbSBzZXJ2ZXJQYXJhbXNcclxuICogQHBhcmFtIGNhY2hlZFN0YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBdXRob3JpemF0aW9uQ29kZVBheWxvYWQoc2VydmVyUGFyYW1zLCBjYWNoZWRTdGF0ZSkge1xyXG4gICAgLy8gR2V0IGNvZGUgcmVzcG9uc2VcclxuICAgIHZhbGlkYXRlQXV0aG9yaXphdGlvblJlc3BvbnNlKHNlcnZlclBhcmFtcywgY2FjaGVkU3RhdGUpO1xyXG4gICAgLy8gdGhyb3cgd2hlbiB0aGVyZSBpcyBubyBhdXRoIGNvZGUgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICBpZiAoIXNlcnZlclBhcmFtcy5jb2RlKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKGF1dGhvcml6YXRpb25Db2RlTWlzc2luZ0Zyb21TZXJ2ZXJSZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VydmVyUGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB3aGljaCB2YWxpZGF0ZXMgc2VydmVyIGF1dGhvcml6YXRpb24gY29kZSByZXNwb25zZS5cclxuICogQHBhcmFtIHNlcnZlclJlc3BvbnNlSGFzaFxyXG4gKiBAcGFyYW0gcmVxdWVzdFN0YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUF1dGhvcml6YXRpb25SZXNwb25zZShzZXJ2ZXJSZXNwb25zZSwgcmVxdWVzdFN0YXRlKSB7XHJcbiAgICBpZiAoIXNlcnZlclJlc3BvbnNlLnN0YXRlIHx8ICFyZXF1ZXN0U3RhdGUpIHtcclxuICAgICAgICB0aHJvdyBzZXJ2ZXJSZXNwb25zZS5zdGF0ZVxyXG4gICAgICAgICAgICA/IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihzdGF0ZU5vdEZvdW5kLCBcIkNhY2hlZCBTdGF0ZVwiKVxyXG4gICAgICAgICAgICA6IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihzdGF0ZU5vdEZvdW5kLCBcIlNlcnZlciBTdGF0ZVwiKTtcclxuICAgIH1cclxuICAgIGxldCBkZWNvZGVkU2VydmVyUmVzcG9uc2VTdGF0ZTtcclxuICAgIGxldCBkZWNvZGVkUmVxdWVzdFN0YXRlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBkZWNvZGVkU2VydmVyUmVzcG9uc2VTdGF0ZSA9IGRlY29kZVVSSUNvbXBvbmVudChzZXJ2ZXJSZXNwb25zZS5zdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihpbnZhbGlkU3RhdGUsIHNlcnZlclJlc3BvbnNlLnN0YXRlKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgZGVjb2RlZFJlcXVlc3RTdGF0ZSA9IGRlY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0U3RhdGUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoaW52YWxpZFN0YXRlLCBzZXJ2ZXJSZXNwb25zZS5zdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGVjb2RlZFNlcnZlclJlc3BvbnNlU3RhdGUgIT09IGRlY29kZWRSZXF1ZXN0U3RhdGUpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3Ioc3RhdGVNaXNtYXRjaCk7XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayBmb3IgZXJyb3JcclxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5lcnJvciB8fFxyXG4gICAgICAgIHNlcnZlclJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uIHx8XHJcbiAgICAgICAgc2VydmVyUmVzcG9uc2Uuc3ViZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBzZXJ2ZXJFcnJvck5vID0gcGFyc2VTZXJ2ZXJFcnJvck5vKHNlcnZlclJlc3BvbnNlKTtcclxuICAgICAgICBpZiAoaXNJbnRlcmFjdGlvblJlcXVpcmVkRXJyb3Ioc2VydmVyUmVzcG9uc2UuZXJyb3IsIHNlcnZlclJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uLCBzZXJ2ZXJSZXNwb25zZS5zdWJlcnJvcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3Ioc2VydmVyUmVzcG9uc2UuZXJyb3IgfHwgXCJcIiwgc2VydmVyUmVzcG9uc2UuZXJyb3JfZGVzY3JpcHRpb24sIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yLCBzZXJ2ZXJSZXNwb25zZS50aW1lc3RhbXAgfHwgXCJcIiwgc2VydmVyUmVzcG9uc2UudHJhY2VfaWQgfHwgXCJcIiwgc2VydmVyUmVzcG9uc2UuY29ycmVsYXRpb25faWQgfHwgXCJcIiwgc2VydmVyUmVzcG9uc2UuY2xhaW1zIHx8IFwiXCIsIHNlcnZlckVycm9yTm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3Ioc2VydmVyUmVzcG9uc2UuZXJyb3IgfHwgXCJcIiwgc2VydmVyUmVzcG9uc2UuZXJyb3JfZGVzY3JpcHRpb24sIHNlcnZlclJlc3BvbnNlLnN1YmVycm9yLCBzZXJ2ZXJFcnJvck5vKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2V0IHNlcnZlciBlcnJvciBObyBmcm9tIHRoZSBlcnJvcl91cmlcclxuICogQHBhcmFtIHNlcnZlclJlc3BvbnNlXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVNlcnZlckVycm9yTm8oc2VydmVyUmVzcG9uc2UpIHtcclxuICAgIGNvbnN0IGVycm9yQ29kZVByZWZpeCA9IFwiY29kZT1cIjtcclxuICAgIGNvbnN0IGVycm9yQ29kZVByZWZpeEluZGV4ID0gc2VydmVyUmVzcG9uc2UuZXJyb3JfdXJpPy5sYXN0SW5kZXhPZihlcnJvckNvZGVQcmVmaXgpO1xyXG4gICAgcmV0dXJuIGVycm9yQ29kZVByZWZpeEluZGV4ICYmIGVycm9yQ29kZVByZWZpeEluZGV4ID49IDBcclxuICAgICAgICA/IHNlcnZlclJlc3BvbnNlLmVycm9yX3VyaT8uc3Vic3RyaW5nKGVycm9yQ29kZVByZWZpeEluZGV4ICsgZXJyb3JDb2RlUHJlZml4Lmxlbmd0aClcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBzaWQgZnJvbSBhY2NvdW50LiBSZXR1cm5zIG51bGwgaWYgaWRUb2tlbkNsYWltcyBhcmUgbm90IHByZXNlbnQgb3Igc2lkIGlzIG5vdCBwcmVzZW50LlxyXG4gKiBAcGFyYW0gYWNjb3VudFxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEFjY291bnRTaWQoYWNjb3VudCkge1xyXG4gICAgcmV0dXJuIGFjY291bnQuaWRUb2tlbkNsYWltcz8uc2lkIHx8IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdExvZ2luSGludChhY2NvdW50KSB7XHJcbiAgICByZXR1cm4gYWNjb3VudC5pZFRva2VuQ2xhaW1zPy5sb2dpbl9oaW50IHx8IG51bGw7XHJcbn1cblxuZXhwb3J0IHsgZ2V0QXV0aG9yaXphdGlvbkNvZGVQYXlsb2FkLCBnZXRBdXRob3JpemVVcmwsIGdldFN0YW5kYXJkQXV0aG9yaXplUmVxdWVzdFBhcmFtZXRlcnMsIHZhbGlkYXRlQXV0aG9yaXphdGlvblJlc3BvbnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRob3JpemUubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEF1dGhvcml6ZVByb3RvY29sLCBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlciwgUHJvdG9jb2xNb2RlLCBPQXV0aFJlc3BvbnNlVHlwZSB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbi9ub2RlJztcbmltcG9ydCB7IENvbnN0YW50cyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2VNZXRhZGF0YS5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgdGhlIGZ1bGwgL2F1dGhvcml6ZSBVUkwgd2l0aCByZXF1ZXN0IHBhcmFtZXRlcnNcclxuICogQHBhcmFtIGNvbmZpZ1xyXG4gKiBAcGFyYW0gYXV0aG9yaXR5XHJcbiAqIEBwYXJhbSByZXF1ZXN0XHJcbiAqIEBwYXJhbSBsb2dnZXJcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGdldEF1dGhDb2RlUmVxdWVzdFVybChjb25maWcsIGF1dGhvcml0eSwgcmVxdWVzdCwgbG9nZ2VyKSB7XHJcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gQXV0aG9yaXplUHJvdG9jb2wuZ2V0U3RhbmRhcmRBdXRob3JpemVSZXF1ZXN0UGFyYW1ldGVycyh7XHJcbiAgICAgICAgLi4uY29uZmlnLmF1dGgsXHJcbiAgICAgICAgYXV0aG9yaXR5OiBhdXRob3JpdHksXHJcbiAgICAgICAgcmVkaXJlY3RVcmk6IHJlcXVlc3QucmVkaXJlY3RVcmkgfHwgXCJcIixcclxuICAgIH0sIHJlcXVlc3QsIGxvZ2dlcik7XHJcbiAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMaWJyYXJ5SW5mbyhwYXJhbWV0ZXJzLCB7XHJcbiAgICAgICAgc2t1OiBDb25zdGFudHMuTVNBTF9TS1UsXHJcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcclxuICAgICAgICBjcHU6IHByb2Nlc3MuYXJjaCB8fCBcIlwiLFxyXG4gICAgICAgIG9zOiBwcm9jZXNzLnBsYXRmb3JtIHx8IFwiXCIsXHJcbiAgICB9KTtcclxuICAgIGlmIChjb25maWcuYXV0aC5wcm90b2NvbE1vZGUgIT09IFByb3RvY29sTW9kZS5PSURDKSB7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQXBwbGljYXRpb25UZWxlbWV0cnkocGFyYW1ldGVycywgY29uZmlnLnRlbGVtZXRyeS5hcHBsaWNhdGlvbik7XHJcbiAgICB9XHJcbiAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRSZXNwb25zZVR5cGUocGFyYW1ldGVycywgT0F1dGhSZXNwb25zZVR5cGUuQ09ERSk7XHJcbiAgICBpZiAocmVxdWVzdC5jb2RlQ2hhbGxlbmdlICYmIHJlcXVlc3QuY29kZUNoYWxsZW5nZU1ldGhvZCkge1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENvZGVDaGFsbGVuZ2VQYXJhbXMocGFyYW1ldGVycywgcmVxdWVzdC5jb2RlQ2hhbGxlbmdlLCByZXF1ZXN0LmNvZGVDaGFsbGVuZ2VNZXRob2QpO1xyXG4gICAgfVxyXG4gICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkRXh0cmFRdWVyeVBhcmFtZXRlcnMocGFyYW1ldGVycywgcmVxdWVzdC5leHRyYVF1ZXJ5UGFyYW1ldGVycyB8fCB7fSk7XHJcbiAgICByZXR1cm4gQXV0aG9yaXplUHJvdG9jb2wuZ2V0QXV0aG9yaXplVXJsKGF1dGhvcml0eSwgcGFyYW1ldGVycywgY29uZmlnLmF1dGguZW5jb2RlRXh0cmFRdWVyeVBhcmFtcywgcmVxdWVzdC5leHRyYVF1ZXJ5UGFyYW1ldGVycyk7XHJcbn1cblxuZXhwb3J0IHsgZ2V0QXV0aENvZGVSZXF1ZXN0VXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRob3JpemUubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IExvZ2dlciwgYnVpbGRTdGF0aWNBdXRob3JpdHlPcHRpb25zLCBSZXNwb25zZU1vZGUsIEF1dGhlbnRpY2F0aW9uU2NoZW1lLCBBdXRob3JpemF0aW9uQ29kZUNsaWVudCwgQXV0aEVycm9yLCBSZWZyZXNoVG9rZW5DbGllbnQsIFNpbGVudEZsb3dDbGllbnQsIENsaWVudEF1dGhFcnJvciwgQ2xpZW50QXV0aEVycm9yQ29kZXMsIE9JRENfREVGQVVMVF9TQ09QRVMsIENhY2hlT3V0Y29tZSwgY3JlYXRlQ2xpZW50QXV0aEVycm9yLCBDb25zdGFudHMgYXMgQ29uc3RhbnRzJDEsIGdldENsaWVudEFzc2VydGlvbiwgU3RyaW5nVXRpbHMsIFNlcnZlclRlbGVtZXRyeU1hbmFnZXIsIEF1dGhvcml0eSwgQXV0aG9yaXR5RmFjdG9yeSB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbi9ub2RlJztcbmltcG9ydCB7IGJ1aWxkQXBwQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL2NvbmZpZy9Db25maWd1cmF0aW9uLm1qcyc7XG5pbXBvcnQgeyBDcnlwdG9Qcm92aWRlciB9IGZyb20gJy4uL2NyeXB0by9DcnlwdG9Qcm92aWRlci5tanMnO1xuaW1wb3J0IHsgTm9kZVN0b3JhZ2UgfSBmcm9tICcuLi9jYWNoZS9Ob2RlU3RvcmFnZS5tanMnO1xuaW1wb3J0IHsgQXBpSWQsIENvbnN0YW50cyB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgVG9rZW5DYWNoZSB9IGZyb20gJy4uL2NhY2hlL1Rva2VuQ2FjaGUubWpzJztcbmltcG9ydCB7IENsaWVudEFzc2VydGlvbiB9IGZyb20gJy4vQ2xpZW50QXNzZXJ0aW9uLm1qcyc7XG5pbXBvcnQgeyBuYW1lLCB2ZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZU1ldGFkYXRhLm1qcyc7XG5pbXBvcnQgeyBOb2RlQXV0aEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvTm9kZUF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgVXNlcm5hbWVQYXNzd29yZENsaWVudCB9IGZyb20gJy4vVXNlcm5hbWVQYXNzd29yZENsaWVudC5tanMnO1xuaW1wb3J0IHsgZ2V0QXV0aENvZGVSZXF1ZXN0VXJsIH0gZnJvbSAnLi4vcHJvdG9jb2wvQXV0aG9yaXplLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQmFzZSBhYnN0cmFjdCBjbGFzcyBmb3IgYWxsIENsaWVudEFwcGxpY2F0aW9ucyAtIHB1YmxpYyBhbmQgY29uZmlkZW50aWFsXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIENsaWVudEFwcGxpY2F0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBDbGllbnRBcHBsaWNhdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBidWlsZEFwcENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgdGhpcy5jcnlwdG9Qcm92aWRlciA9IG5ldyBDcnlwdG9Qcm92aWRlcigpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IExvZ2dlcih0aGlzLmNvbmZpZy5zeXN0ZW0ubG9nZ2VyT3B0aW9ucywgbmFtZSwgdmVyc2lvbik7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IE5vZGVTdG9yYWdlKHRoaXMubG9nZ2VyLCB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudElkLCB0aGlzLmNyeXB0b1Byb3ZpZGVyLCBidWlsZFN0YXRpY0F1dGhvcml0eU9wdGlvbnModGhpcy5jb25maWcuYXV0aCkpO1xyXG4gICAgICAgIHRoaXMudG9rZW5DYWNoZSA9IG5ldyBUb2tlbkNhY2hlKHRoaXMuc3RvcmFnZSwgdGhpcy5sb2dnZXIsIHRoaXMuY29uZmlnLmNhY2hlLmNhY2hlUGx1Z2luKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgVVJMIG9mIHRoZSBhdXRob3JpemF0aW9uIHJlcXVlc3QsIGxldHRpbmcgdGhlIHVzZXIgaW5wdXQgY3JlZGVudGlhbHMgYW5kIGNvbnNlbnQgdG8gdGhlXHJcbiAgICAgKiBhcHBsaWNhdGlvbi4gVGhlIFVSTCB0YXJnZXRzIHRoZSAvYXV0aG9yaXplIGVuZHBvaW50IG9mIHRoZSBhdXRob3JpdHkgY29uZmlndXJlZCBpbiB0aGVcclxuICAgICAqIGFwcGxpY2F0aW9uIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBPbmNlIHRoZSB1c2VyIGlucHV0cyB0aGVpciBjcmVkZW50aWFscyBhbmQgY29uc2VudHMsIHRoZSBhdXRob3JpdHkgd2lsbCBzZW5kIGEgcmVzcG9uc2UgdG8gdGhlIHJlZGlyZWN0IFVSSVxyXG4gICAgICogc2VudCBpbiB0aGUgcmVxdWVzdCBhbmQgc2hvdWxkIGNvbnRhaW4gYW4gYXV0aG9yaXphdGlvbiBjb2RlLCB3aGljaCBjYW4gdGhlbiBiZSB1c2VkIHRvIGFjcXVpcmUgdG9rZW5zIHZpYVxyXG4gICAgICogYGFjcXVpcmVUb2tlbkJ5Q29kZShBdXRob3JpemF0aW9uQ29kZVJlcXVlc3QpYC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QXV0aENvZGVVcmwocmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJnZXRBdXRoQ29kZVVybCBjYWxsZWRcIiwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBjb25zdCB2YWxpZFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXHJcbiAgICAgICAgICAgIC4uLihhd2FpdCB0aGlzLmluaXRpYWxpemVCYXNlUmVxdWVzdChyZXF1ZXN0KSksXHJcbiAgICAgICAgICAgIHJlc3BvbnNlTW9kZTogcmVxdWVzdC5yZXNwb25zZU1vZGUgfHwgUmVzcG9uc2VNb2RlLlFVRVJZLFxyXG4gICAgICAgICAgICBhdXRoZW50aWNhdGlvblNjaGVtZTogQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSLFxyXG4gICAgICAgICAgICBzdGF0ZTogcmVxdWVzdC5zdGF0ZSB8fCBcIlwiLFxyXG4gICAgICAgICAgICBub25jZTogcmVxdWVzdC5ub25jZSB8fCBcIlwiLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZGlzY292ZXJlZEF1dGhvcml0eSA9IGF3YWl0IHRoaXMuY3JlYXRlQXV0aG9yaXR5KHZhbGlkUmVxdWVzdC5hdXRob3JpdHksIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCB1bmRlZmluZWQsIHJlcXVlc3QuYXp1cmVDbG91ZE9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBnZXRBdXRoQ29kZVJlcXVlc3RVcmwodGhpcy5jb25maWcsIGRpc2NvdmVyZWRBdXRob3JpdHksIHZhbGlkUmVxdWVzdCwgdGhpcy5sb2dnZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3F1aXJlcyBhIHRva2VuIGJ5IGV4Y2hhbmdpbmcgdGhlIEF1dGhvcml6YXRpb24gQ29kZSByZWNlaXZlZCBmcm9tIHRoZSBmaXJzdCBzdGVwIG9mIE9BdXRoMi4wXHJcbiAgICAgKiBBdXRob3JpemF0aW9uIENvZGUgZmxvdy5cclxuICAgICAqXHJcbiAgICAgKiBgZ2V0QXV0aENvZGVVcmwoQXV0aG9yaXphdGlvbkNvZGVVcmxSZXF1ZXN0KWAgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBVUkwgZm9yIHRoZSBmaXJzdCBzdGVwIG9mIE9BdXRoMi4wXHJcbiAgICAgKiBBdXRob3JpemF0aW9uIENvZGUgZmxvdy4gRW5zdXJlIHRoYXQgdmFsdWVzIGZvciByZWRpcmVjdFVyaSBhbmQgc2NvcGVzIGluIEF1dGhvcml6YXRpb25Db2RlVXJsUmVxdWVzdCBhbmRcclxuICAgICAqIEF1dGhvcml6YXRpb25Db2RlUmVxdWVzdCBhcmUgdGhlIHNhbWUuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGFjcXVpcmVUb2tlbkJ5Q29kZShyZXF1ZXN0LCBhdXRoQ29kZVBheUxvYWQpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiYWNxdWlyZVRva2VuQnlDb2RlIGNhbGxlZFwiKTtcclxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0ZSAmJiBhdXRoQ29kZVBheUxvYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImFjcXVpcmVUb2tlbkJ5Q29kZSAtIHZhbGlkYXRpbmcgc3RhdGVcIik7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTdGF0ZShyZXF1ZXN0LnN0YXRlLCBhdXRoQ29kZVBheUxvYWQuc3RhdGUgfHwgXCJcIik7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgICAgICBhdXRoQ29kZVBheUxvYWQgPSB7IC4uLmF1dGhDb2RlUGF5TG9hZCwgc3RhdGU6IFwiXCIgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxyXG4gICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5pbml0aWFsaXplQmFzZVJlcXVlc3QocmVxdWVzdCkpLFxyXG4gICAgICAgICAgICBhdXRoZW50aWNhdGlvblNjaGVtZTogQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2VydmVyVGVsZW1ldHJ5TWFuYWdlciA9IHRoaXMuaW5pdGlhbGl6ZVNlcnZlclRlbGVtZXRyeU1hbmFnZXIoQXBpSWQuYWNxdWlyZVRva2VuQnlDb2RlLCB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZGlzY292ZXJlZEF1dGhvcml0eSA9IGF3YWl0IHRoaXMuY3JlYXRlQXV0aG9yaXR5KHZhbGlkUmVxdWVzdC5hdXRob3JpdHksIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCB1bmRlZmluZWQsIHJlcXVlc3QuYXp1cmVDbG91ZE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBhdXRoQ2xpZW50Q29uZmlnID0gYXdhaXQgdGhpcy5idWlsZE9hdXRoQ2xpZW50Q29uZmlndXJhdGlvbihkaXNjb3ZlcmVkQXV0aG9yaXR5LCB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCwgdmFsaWRSZXF1ZXN0LnJlZGlyZWN0VXJpLCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKTtcclxuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbkNvZGVDbGllbnQgPSBuZXcgQXV0aG9yaXphdGlvbkNvZGVDbGllbnQoYXV0aENsaWVudENvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJBdXRoIGNvZGUgY2xpZW50IGNyZWF0ZWRcIiwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXV0aG9yaXphdGlvbkNvZGVDbGllbnQuYWNxdWlyZVRva2VuKHZhbGlkUmVxdWVzdCwgYXV0aENvZGVQYXlMb2FkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBdXRoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGUuc2V0Q29ycmVsYXRpb25JZCh2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5jYWNoZUZhaWxlZFJlcXVlc3QoZSk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3F1aXJlcyBhIHRva2VuIGJ5IGV4Y2hhbmdpbmcgdGhlIHJlZnJlc2ggdG9rZW4gcHJvdmlkZWQgZm9yIGEgbmV3IHNldCBvZiB0b2tlbnMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBBUEkgaXMgcHJvdmlkZWQgb25seSBmb3Igc2NlbmFyaW9zIHdoZXJlIHlvdSB3b3VsZCBsaWtlIHRvIG1pZ3JhdGUgZnJvbSBBREFMIHRvIE1TQUwuIE90aGVyd2lzZSwgaXQgaXNcclxuICAgICAqIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBgYWNxdWlyZVRva2VuU2lsZW50KClgIGZvciBzaWxlbnQgc2NlbmFyaW9zLiBXaGVuIHVzaW5nIGBhY3F1aXJlVG9rZW5TaWxlbnQoKWAsIE1TQUwgd2lsbFxyXG4gICAgICogaGFuZGxlIHRoZSBjYWNoaW5nIGFuZCByZWZyZXNoaW5nIG9mIHRva2VucyBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICovXHJcbiAgICBhc3luYyBhY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbihyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuIGNhbGxlZFwiLCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgLi4ucmVxdWVzdCxcclxuICAgICAgICAgICAgLi4uKGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUJhc2VSZXF1ZXN0KHJlcXVlc3QpKSxcclxuICAgICAgICAgICAgYXV0aGVudGljYXRpb25TY2hlbWU6IEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNlcnZlclRlbGVtZXRyeU1hbmFnZXIgPSB0aGlzLmluaXRpYWxpemVTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKEFwaUlkLmFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuLCB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZGlzY292ZXJlZEF1dGhvcml0eSA9IGF3YWl0IHRoaXMuY3JlYXRlQXV0aG9yaXR5KHZhbGlkUmVxdWVzdC5hdXRob3JpdHksIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCB1bmRlZmluZWQsIHJlcXVlc3QuYXp1cmVDbG91ZE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCByZWZyZXNoVG9rZW5DbGllbnRDb25maWcgPSBhd2FpdCB0aGlzLmJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uKGRpc2NvdmVyZWRBdXRob3JpdHksIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCB2YWxpZFJlcXVlc3QucmVkaXJlY3RVcmkgfHwgXCJcIiwgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbkNsaWVudCA9IG5ldyBSZWZyZXNoVG9rZW5DbGllbnQocmVmcmVzaFRva2VuQ2xpZW50Q29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlJlZnJlc2ggdG9rZW4gY2xpZW50IGNyZWF0ZWRcIiwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVmcmVzaFRva2VuQ2xpZW50LmFjcXVpcmVUb2tlbih2YWxpZFJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZS5zZXRDb3JyZWxhdGlvbklkKHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmNhY2hlRmFpbGVkUmVxdWVzdChlKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjcXVpcmVzIGEgdG9rZW4gc2lsZW50bHkgd2hlbiBhIHVzZXIgc3BlY2lmaWVzIHRoZSBhY2NvdW50IHRoZSB0b2tlbiBpcyByZXF1ZXN0ZWQgZm9yLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgQVBJIGV4cGVjdHMgdGhlIHVzZXIgdG8gcHJvdmlkZSBhbiBhY2NvdW50IG9iamVjdCBhbmQgbG9va3MgaW50byB0aGUgY2FjaGUgdG8gcmV0cmlldmUgdGhlIHRva2VuIGlmIHByZXNlbnQuXHJcbiAgICAgKiBUaGVyZSBpcyBhbHNvIGFuIG9wdGlvbmFsIFwiZm9yY2VSZWZyZXNoXCIgYm9vbGVhbiB0aGUgdXNlciBjYW4gc2VuZCB0byBieXBhc3MgdGhlIGNhY2hlIGZvciBhY2Nlc3NfdG9rZW4gYW5kIGlkX3Rva2VuLlxyXG4gICAgICogSW4gY2FzZSB0aGUgcmVmcmVzaF90b2tlbiBpcyBleHBpcmVkIG9yIG5vdCBmb3VuZCwgYW4gZXJyb3IgaXMgdGhyb3duXHJcbiAgICAgKiBhbmQgdGhlIGd1aWRhbmNlIGlzIGZvciB0aGUgdXNlciB0byBjYWxsIGFueSBpbnRlcmFjdGl2ZSB0b2tlbiBhY3F1aXNpdGlvbiBBUEkgKGVnOiBgYWNxdWlyZVRva2VuQnlDb2RlKClgKS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuU2lsZW50KHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCB2YWxpZFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXHJcbiAgICAgICAgICAgIC4uLihhd2FpdCB0aGlzLmluaXRpYWxpemVCYXNlUmVxdWVzdChyZXF1ZXN0KSksXHJcbiAgICAgICAgICAgIGZvcmNlUmVmcmVzaDogcmVxdWVzdC5mb3JjZVJlZnJlc2ggfHwgZmFsc2UsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyID0gdGhpcy5pbml0aWFsaXplU2VydmVyVGVsZW1ldHJ5TWFuYWdlcihBcGlJZC5hY3F1aXJlVG9rZW5TaWxlbnQsIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCB2YWxpZFJlcXVlc3QuZm9yY2VSZWZyZXNoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNjb3ZlcmVkQXV0aG9yaXR5ID0gYXdhaXQgdGhpcy5jcmVhdGVBdXRob3JpdHkodmFsaWRSZXF1ZXN0LmF1dGhvcml0eSwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsIHVuZGVmaW5lZCwgcmVxdWVzdC5henVyZUNsb3VkT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudENvbmZpZ3VyYXRpb24gPSBhd2FpdCB0aGlzLmJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uKGRpc2NvdmVyZWRBdXRob3JpdHksIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCB2YWxpZFJlcXVlc3QucmVkaXJlY3RVcmkgfHwgXCJcIiwgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpbGVudEZsb3dDbGllbnQgPSBuZXcgU2lsZW50Rmxvd0NsaWVudChjbGllbnRDb25maWd1cmF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIlNpbGVudCBmbG93IGNsaWVudCBjcmVhdGVkXCIsIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBvdmVyd3JpdGUgdGhlIGluLW1lbW9yeSBjYWNoZSB3aXRoIHRoZSBwZXJzaXN0ZW5jZSBjYWNoZSAoaWYgaXQgZXhpc3RzKSBiZWZvcmUgYSBjYWNoZSBsb29rdXBcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5DYWNoZS5vdmVyd3JpdGVDYWNoZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWNxdWlyZUNhY2hlZFRva2VuU2lsZW50KHZhbGlkUmVxdWVzdCwgc2lsZW50Rmxvd0NsaWVudCwgY2xpZW50Q29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDbGllbnRBdXRoRXJyb3IgJiZcclxuICAgICAgICAgICAgICAgICAgICBlcnJvci5lcnJvckNvZGUgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWVudEF1dGhFcnJvckNvZGVzLnRva2VuUmVmcmVzaFJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuQ2xpZW50ID0gbmV3IFJlZnJlc2hUb2tlbkNsaWVudChjbGllbnRDb25maWd1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmcmVzaFRva2VuQ2xpZW50LmFjcXVpcmVUb2tlbkJ5UmVmcmVzaFRva2VuKHZhbGlkUmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXV0aEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvci5zZXRDb3JyZWxhdGlvbklkKHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmNhY2hlRmFpbGVkUmVxdWVzdChlcnJvcik7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIGFjcXVpcmVDYWNoZWRUb2tlblNpbGVudCh2YWxpZFJlcXVlc3QsIHNpbGVudEZsb3dDbGllbnQsIGNsaWVudENvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICBjb25zdCBbYXV0aFJlc3BvbnNlLCBjYWNoZU91dGNvbWVdID0gYXdhaXQgc2lsZW50Rmxvd0NsaWVudC5hY3F1aXJlQ2FjaGVkVG9rZW4oe1xyXG4gICAgICAgICAgICAuLi52YWxpZFJlcXVlc3QsXHJcbiAgICAgICAgICAgIHNjb3BlczogdmFsaWRSZXF1ZXN0LnNjb3Blcz8ubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA/IHZhbGlkUmVxdWVzdC5zY29wZXNcclxuICAgICAgICAgICAgICAgIDogWy4uLk9JRENfREVGQVVMVF9TQ09QRVNdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjYWNoZU91dGNvbWUgPT09IENhY2hlT3V0Y29tZS5QUk9BQ1RJVkVMWV9SRUZSRVNIRUQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIkNsaWVudEFwcGxpY2F0aW9uOmFjcXVpcmVDYWNoZWRUb2tlblNpbGVudCAtIENhY2hlZCBhY2Nlc3MgdG9rZW4ncyByZWZyZXNoT24gcHJvcGVydHkgaGFzIGJlZW4gZXhjZWVkZWQnLiBJdCdzIG5vdCBleHBpcmVkLCBidXQgbXVzdCBiZSByZWZyZXNoZWQuXCIpO1xyXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSBhY2Nlc3MgdG9rZW4gaW4gdGhlIGJhY2tncm91bmRcclxuICAgICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuQ2xpZW50ID0gbmV3IFJlZnJlc2hUb2tlbkNsaWVudChjbGllbnRDb25maWd1cmF0aW9uKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlZnJlc2hUb2tlbkNsaWVudC5hY3F1aXJlVG9rZW5CeVJlZnJlc2hUb2tlbih2YWxpZFJlcXVlc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcsIHRoaXMgaXMgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCBhbmQgbm8gYWN0aW9uIGlzIHRvIGJlIHRha2VuIHVwb24gc3VjY2VzcyBvciBmYWlsdXJlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBjYWNoZWQgdG9rZW5cclxuICAgICAgICByZXR1cm4gYXV0aFJlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3F1aXJlcyB0b2tlbnMgd2l0aCBwYXNzd29yZCBncmFudCBieSBleGNoYW5naW5nIGNsaWVudCBhcHBsaWNhdGlvbnMgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGZvciBjcmVkZW50aWFsc1xyXG4gICAgICpcclxuICAgICAqIFRoZSBsYXRlc3QgT0F1dGggMi4wIFNlY3VyaXR5IEJlc3QgQ3VycmVudCBQcmFjdGljZSBkaXNhbGxvd3MgdGhlIHBhc3N3b3JkIGdyYW50IGVudGlyZWx5LlxyXG4gICAgICogTW9yZSBkZXRhaWxzIG9uIHRoaXMgcmVjb21tZW5kYXRpb24gYXQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtb2F1dGgtc2VjdXJpdHktdG9waWNzLTEzI3NlY3Rpb24tMy40XHJcbiAgICAgKiBNaWNyb3NvZnQncyBkb2N1bWVudGF0aW9uIGFuZCByZWNvbW1lbmRhdGlvbnMgYXJlIGF0OlxyXG4gICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvYWN0aXZlLWRpcmVjdG9yeS9kZXZlbG9wL21zYWwtYXV0aGVudGljYXRpb24tZmxvd3MjdXNlcm5hbWVwYXNzd29yZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gVXNlbmFtZVBhc3N3b3JkUmVxdWVzdFxyXG4gICAgICogQGRlcHJlY2F0ZWQgLSBVc2UgYSBtb3JlIHNlY3VyZSBmbG93IGluc3RlYWRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuQnlVc2VybmFtZVBhc3N3b3JkKHJlcXVlc3QpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiYWNxdWlyZVRva2VuQnlVc2VybmFtZVBhc3N3b3JkIGNhbGxlZFwiLCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgLi4ucmVxdWVzdCxcclxuICAgICAgICAgICAgLi4uKGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUJhc2VSZXF1ZXN0KHJlcXVlc3QpKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNlcnZlclRlbGVtZXRyeU1hbmFnZXIgPSB0aGlzLmluaXRpYWxpemVTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKEFwaUlkLmFjcXVpcmVUb2tlbkJ5VXNlcm5hbWVQYXNzd29yZCwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyZWRBdXRob3JpdHkgPSBhd2FpdCB0aGlzLmNyZWF0ZUF1dGhvcml0eSh2YWxpZFJlcXVlc3QuYXV0aG9yaXR5LCB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCwgdW5kZWZpbmVkLCByZXF1ZXN0LmF6dXJlQ2xvdWRPcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgdXNlcm5hbWVQYXNzd29yZENsaWVudENvbmZpZyA9IGF3YWl0IHRoaXMuYnVpbGRPYXV0aENsaWVudENvbmZpZ3VyYXRpb24oZGlzY292ZXJlZEF1dGhvcml0eSwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsIFwiXCIsIHNlcnZlclRlbGVtZXRyeU1hbmFnZXIpO1xyXG4gICAgICAgICAgICBjb25zdCB1c2VybmFtZVBhc3N3b3JkQ2xpZW50ID0gbmV3IFVzZXJuYW1lUGFzc3dvcmRDbGllbnQodXNlcm5hbWVQYXNzd29yZENsaWVudENvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJVc2VybmFtZSBwYXNzd29yZCBjbGllbnQgY3JlYXRlZFwiLCB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB1c2VybmFtZVBhc3N3b3JkQ2xpZW50LmFjcXVpcmVUb2tlbih2YWxpZFJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZS5zZXRDb3JyZWxhdGlvbklkKHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmNhY2hlRmFpbGVkUmVxdWVzdChlKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHRva2VuIGNhY2hlIGZvciB0aGUgYXBwbGljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldFRva2VuQ2FjaGUoKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImdldFRva2VuQ2FjaGUgY2FsbGVkXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuQ2FjaGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyBPSURDIHN0YXRlIGJ5IGNvbXBhcmluZyB0aGUgdXNlciBjYWNoZWQgc3RhdGUgd2l0aCB0aGUgc3RhdGUgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgQVBJIGlzIHByb3ZpZGVkIGZvciBzY2VuYXJpb3Mgd2hlcmUgeW91IHdvdWxkIHVzZSBPQXV0aDIuMCBzdGF0ZSBwYXJhbWV0ZXIgdG8gbWl0aWdhdGUgYWdhaW5zdFxyXG4gICAgICogQ1NSRiBhdHRhY2tzLlxyXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgc3RhdGUsIHZpc2l0IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjgxOSNzZWN0aW9uLTMuNi5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIFVuaXF1ZSBHVUlEIGdlbmVyYXRlZCBieSB0aGUgdXNlciB0aGF0IGlzIGNhY2hlZCBieSB0aGUgdXNlciBhbmQgc2VudCB0byB0aGUgc2VydmVyIGR1cmluZyB0aGUgZmlyc3QgbGVnIG9mIHRoZSBmbG93XHJcbiAgICAgKiBAcGFyYW0gY2FjaGVkU3RhdGUgLSBUaGlzIHN0cmluZyBpcyBzZW50IGJhY2sgYnkgdGhlIHNlcnZlciB3aXRoIHRoZSBhdXRob3JpemF0aW9uIGNvZGVcclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVTdGF0ZShzdGF0ZSwgY2FjaGVkU3RhdGUpIHtcclxuICAgICAgICBpZiAoIXN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRocm93IE5vZGVBdXRoRXJyb3IuY3JlYXRlU3RhdGVOb3RGb3VuZEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gY2FjaGVkU3RhdGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLnN0YXRlTWlzbWF0Y2gpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbG9nZ2VyIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGdldExvZ2dlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2dnZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIHRoZSBkZWZhdWx0IGxvZ2dlciBzZXQgaW4gY29uZmlndXJhdGlvbnMgd2l0aCBuZXcgTG9nZ2VyIHdpdGggbmV3IGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgKiBAcGFyYW0gbG9nZ2VyIC0gTG9nZ2VyIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHNldExvZ2dlcihsb2dnZXIpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIHRoZSBjb21tb24gY29uZmlndXJhdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIGNvbW1vbiBjb21wb25lbnQgYmFzZWQgb24gdGhlIHBsYXRmb3JtIGNvbmZpZ3VyYXJpb25cclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHkgLSB1c2VyIHBhc3NlZCBhdXRob3JpdHkgaW4gY29uZmlndXJhdGlvblxyXG4gICAgICogQHBhcmFtIHNlcnZlclRlbGVtZXRyeU1hbmFnZXIgLSBpbml0aWFsaXplcyBzZXJ2ZXJ0ZWxlbWV0cnkgaWYgcGFzc2VkXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uKGRpc2NvdmVyZWRBdXRob3JpdHksIHJlcXVlc3RDb3JyZWxhdGlvbklkLCByZWRpcmVjdFVyaSwgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJidWlsZE9hdXRoQ2xpZW50Q29uZmlndXJhdGlvbiBjYWxsZWRcIiwgcmVxdWVzdENvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEJ1aWxkaW5nIG9hdXRoIGNsaWVudCBjb25maWd1cmF0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBhdXRob3JpdHk6ICR7ZGlzY292ZXJlZEF1dGhvcml0eS50b2tlbkVuZHBvaW50fS5gLCByZXF1ZXN0Q29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcj8udXBkYXRlUmVnaW9uRGlzY292ZXJ5TWV0YWRhdGEoZGlzY292ZXJlZEF1dGhvcml0eS5yZWdpb25EaXNjb3ZlcnlNZXRhZGF0YSk7XHJcbiAgICAgICAgY29uc3QgY2xpZW50Q29uZmlndXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgYXV0aE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudElkLFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5OiBkaXNjb3ZlcmVkQXV0aG9yaXR5LFxyXG4gICAgICAgICAgICAgICAgY2xpZW50Q2FwYWJpbGl0aWVzOiB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENhcGFiaWxpdGllcyxcclxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsb2dnZXJPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBsb2dMZXZlbDogdGhpcy5jb25maWcuc3lzdGVtLmxvZ2dlck9wdGlvbnMubG9nTGV2ZWwsXHJcbiAgICAgICAgICAgICAgICBsb2dnZXJDYWxsYmFjazogdGhpcy5jb25maWcuc3lzdGVtLmxvZ2dlck9wdGlvbnMubG9nZ2VyQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBwaWlMb2dnaW5nRW5hYmxlZDogdGhpcy5jb25maWcuc3lzdGVtLmxvZ2dlck9wdGlvbnMucGlpTG9nZ2luZ0VuYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkOiByZXF1ZXN0Q29ycmVsYXRpb25JZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FjaGVPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBjbGFpbXNCYXNlZENhY2hpbmdFbmFibGVkOiB0aGlzLmNvbmZpZy5jYWNoZS5jbGFpbXNCYXNlZENhY2hpbmdFbmFibGVkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjcnlwdG9JbnRlcmZhY2U6IHRoaXMuY3J5cHRvUHJvdmlkZXIsXHJcbiAgICAgICAgICAgIG5ldHdvcmtJbnRlcmZhY2U6IHRoaXMuY29uZmlnLnN5c3RlbS5uZXR3b3JrQ2xpZW50LFxyXG4gICAgICAgICAgICBzdG9yYWdlSW50ZXJmYWNlOiB0aGlzLnN0b3JhZ2UsXHJcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI6IHNlcnZlclRlbGVtZXRyeU1hbmFnZXIsXHJcbiAgICAgICAgICAgIGNsaWVudENyZWRlbnRpYWxzOiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRTZWNyZXQ6IHRoaXMuY2xpZW50U2VjcmV0LFxyXG4gICAgICAgICAgICAgICAgY2xpZW50QXNzZXJ0aW9uOiBhd2FpdCB0aGlzLmdldENsaWVudEFzc2VydGlvbihkaXNjb3ZlcmVkQXV0aG9yaXR5KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGlicmFyeUluZm86IHtcclxuICAgICAgICAgICAgICAgIHNrdTogQ29uc3RhbnRzLk1TQUxfU0tVLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcclxuICAgICAgICAgICAgICAgIGNwdTogcHJvY2Vzcy5hcmNoIHx8IENvbnN0YW50cyQxLkVNUFRZX1NUUklORyxcclxuICAgICAgICAgICAgICAgIG9zOiBwcm9jZXNzLnBsYXRmb3JtIHx8IENvbnN0YW50cyQxLkVNUFRZX1NUUklORyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGVsZW1ldHJ5OiB0aGlzLmNvbmZpZy50ZWxlbWV0cnksXHJcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlUGx1Z2luOiB0aGlzLmNvbmZpZy5jYWNoZS5jYWNoZVBsdWdpbixcclxuICAgICAgICAgICAgc2VyaWFsaXphYmxlQ2FjaGU6IHRoaXMudG9rZW5DYWNoZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGllbnRDb25maWd1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0Q2xpZW50QXNzZXJ0aW9uKGF1dGhvcml0eSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRldmVsb3BlclByb3ZpZGVkQ2xpZW50QXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50QXNzZXJ0aW9uID0gQ2xpZW50QXNzZXJ0aW9uLmZyb21Bc3NlcnRpb24oYXdhaXQgZ2V0Q2xpZW50QXNzZXJ0aW9uKHRoaXMuZGV2ZWxvcGVyUHJvdmlkZWRDbGllbnRBc3NlcnRpb24sIHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWQsIGF1dGhvcml0eS50b2tlbkVuZHBvaW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5jbGllbnRBc3NlcnRpb24gJiYge1xyXG4gICAgICAgICAgICBhc3NlcnRpb246IHRoaXMuY2xpZW50QXNzZXJ0aW9uLmdldEp3dCh0aGlzLmNyeXB0b1Byb3ZpZGVyLCB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudElkLCBhdXRob3JpdHkudG9rZW5FbmRwb2ludCksXHJcbiAgICAgICAgICAgIGFzc2VydGlvblR5cGU6IENvbnN0YW50cy5KV1RfQkVBUkVSX0FTU0VSVElPTl9UWVBFLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSByZXF1ZXN0IHdpdGggdGhlIGRlZmF1bHQgc2NvcGVzICYgZ2VuZXJhdGVzIGEgY29ycmVsYXRpb25JZC5cclxuICAgICAqIEBwYXJhbSBhdXRoUmVxdWVzdCAtIEJhc2VBdXRoUmVxdWVzdCBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgICAqL1xyXG4gICAgYXN5bmMgaW5pdGlhbGl6ZUJhc2VSZXF1ZXN0KGF1dGhSZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcImluaXRpYWxpemVSZXF1ZXN0U2NvcGVzIGNhbGxlZFwiLCBhdXRoUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAvLyBEZWZhdWx0IGF1dGhlbnRpY2F0aW9uU2NoZW1lIHRvIEJlYXJlciwgbG9nIHRoYXQgUE9QIGlzbid0IHN1cHBvcnRlZCB5ZXRcclxuICAgICAgICBpZiAoYXV0aFJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgJiZcclxuICAgICAgICAgICAgYXV0aFJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgPT09IEF1dGhlbnRpY2F0aW9uU2NoZW1lLlBPUCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiQXV0aGVudGljYXRpb24gU2NoZW1lICdwb3AnIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LCBzZXR0aW5nIEF1dGhlbnRpY2F0aW9uIFNjaGVtZSB0byAnQmVhcmVyJyBmb3IgcmVxdWVzdFwiLCBhdXRoUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXV0aFJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgPSBBdXRoZW50aWNhdGlvblNjaGVtZS5CRUFSRVI7XHJcbiAgICAgICAgLy8gU2V0IHJlcXVlc3RlZCBjbGFpbXMgaGFzaCBpZiBjbGFpbXMtYmFzZWQgY2FjaGluZyBpcyBlbmFibGVkIGFuZCBjbGFpbXMgd2VyZSByZXF1ZXN0ZWRcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2FjaGUuY2xhaW1zQmFzZWRDYWNoaW5nRW5hYmxlZCAmJlxyXG4gICAgICAgICAgICBhdXRoUmVxdWVzdC5jbGFpbXMgJiZcclxuICAgICAgICAgICAgLy8gQ2hlY2tzIGZvciBlbXB0eSBzdHJpbmdpZmllZCBvYmplY3QgXCJ7fVwiIHdoaWNoIGRvZXNuJ3QgcXVhbGlmeSBhcyByZXF1ZXN0ZWQgY2xhaW1zXHJcbiAgICAgICAgICAgICFTdHJpbmdVdGlscy5pc0VtcHR5T2JqKGF1dGhSZXF1ZXN0LmNsYWltcykpIHtcclxuICAgICAgICAgICAgYXV0aFJlcXVlc3QucmVxdWVzdGVkQ2xhaW1zSGFzaCA9XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyeXB0b1Byb3ZpZGVyLmhhc2hTdHJpbmcoYXV0aFJlcXVlc3QuY2xhaW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uYXV0aFJlcXVlc3QsXHJcbiAgICAgICAgICAgIHNjb3BlczogW1xyXG4gICAgICAgICAgICAgICAgLi4uKChhdXRoUmVxdWVzdCAmJiBhdXRoUmVxdWVzdC5zY29wZXMpIHx8IFtdKSxcclxuICAgICAgICAgICAgICAgIC4uLk9JRENfREVGQVVMVF9TQ09QRVMsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IChhdXRoUmVxdWVzdCAmJiBhdXRoUmVxdWVzdC5jb3JyZWxhdGlvbklkKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcnlwdG9Qcm92aWRlci5jcmVhdGVOZXdHdWlkKCksXHJcbiAgICAgICAgICAgIGF1dGhvcml0eTogYXV0aFJlcXVlc3QuYXV0aG9yaXR5IHx8IHRoaXMuY29uZmlnLmF1dGguYXV0aG9yaXR5LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzZXJ2ZXIgdGVsZW1ldHJ5IHBheWxvYWRcclxuICAgICAqIEBwYXJhbSBhcGlJZCAtIElkIGZvciBhIHNwZWNpZmljIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkIC0gR1VJRFxyXG4gICAgICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIGJvb2xlYW4gdG8gaW5kaWNhdGUgbmV0d29yayBjYWxsXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxpemVTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKGFwaUlkLCBjb3JyZWxhdGlvbklkLCBmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBjb25zdCB0ZWxlbWV0cnlQYXlsb2FkID0ge1xyXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aC5jbGllbnRJZCxcclxuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogY29ycmVsYXRpb25JZCxcclxuICAgICAgICAgICAgYXBpSWQ6IGFwaUlkLFxyXG4gICAgICAgICAgICBmb3JjZVJlZnJlc2g6IGZvcmNlUmVmcmVzaCB8fCBmYWxzZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyVGVsZW1ldHJ5TWFuYWdlcih0ZWxlbWV0cnlQYXlsb2FkLCB0aGlzLnN0b3JhZ2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYXV0aG9yaXR5IGluc3RhbmNlLiBJZiBhdXRob3JpdHkgbm90IHBhc3NlZCBpbiByZXF1ZXN0LCBkZWZhdWx0IHRvIGF1dGhvcml0eSBzZXQgb24gdGhlIGFwcGxpY2F0aW9uXHJcbiAgICAgKiBvYmplY3QuIElmIG5vIGF1dGhvcml0eSBzZXQgaW4gYXBwbGljYXRpb24gb2JqZWN0LCB0aGVuIGRlZmF1bHQgdG8gY29tbW9uIGF1dGhvcml0eS5cclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHlTdHJpbmcgLSBhdXRob3JpdHkgZnJvbSB1c2VyIGNvbmZpZ3VyYXRpb25cclxuICAgICAqL1xyXG4gICAgYXN5bmMgY3JlYXRlQXV0aG9yaXR5KGF1dGhvcml0eVN0cmluZywgcmVxdWVzdENvcnJlbGF0aW9uSWQsIGF6dXJlUmVnaW9uQ29uZmlndXJhdGlvbiwgYXp1cmVDbG91ZE9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiY3JlYXRlQXV0aG9yaXR5IGNhbGxlZFwiLCByZXF1ZXN0Q29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgLy8gYnVpbGQgYXV0aG9yaXR5IHN0cmluZyBiYXNlZCBvbiBhdXRoIHBhcmFtcyAtIGF6dXJlQ2xvdWRJbnN0YW5jZSBpcyBwcmlvcml0aXplZCBpZiBwcm92aWRlZFxyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eVVybCA9IEF1dGhvcml0eS5nZW5lcmF0ZUF1dGhvcml0eShhdXRob3JpdHlTdHJpbmcsIGF6dXJlQ2xvdWRPcHRpb25zIHx8IHRoaXMuY29uZmlnLmF1dGguYXp1cmVDbG91ZE9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHByb3RvY29sTW9kZTogdGhpcy5jb25maWcuYXV0aC5wcm90b2NvbE1vZGUsXHJcbiAgICAgICAgICAgIGtub3duQXV0aG9yaXRpZXM6IHRoaXMuY29uZmlnLmF1dGgua25vd25BdXRob3JpdGllcyxcclxuICAgICAgICAgICAgY2xvdWREaXNjb3ZlcnlNZXRhZGF0YTogdGhpcy5jb25maWcuYXV0aC5jbG91ZERpc2NvdmVyeU1ldGFkYXRhLFxyXG4gICAgICAgICAgICBhdXRob3JpdHlNZXRhZGF0YTogdGhpcy5jb25maWcuYXV0aC5hdXRob3JpdHlNZXRhZGF0YSxcclxuICAgICAgICAgICAgYXp1cmVSZWdpb25Db25maWd1cmF0aW9uLFxyXG4gICAgICAgICAgICBza2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZTogdGhpcy5jb25maWcuYXV0aC5za2lwQXV0aG9yaXR5TWV0YWRhdGFDYWNoZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBBdXRob3JpdHlGYWN0b3J5LmNyZWF0ZURpc2NvdmVyZWRJbnN0YW5jZShhdXRob3JpdHlVcmwsIHRoaXMuY29uZmlnLnN5c3RlbS5uZXR3b3JrQ2xpZW50LCB0aGlzLnN0b3JhZ2UsIGF1dGhvcml0eU9wdGlvbnMsIHRoaXMubG9nZ2VyLCByZXF1ZXN0Q29ycmVsYXRpb25JZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIHRoZSBjYWNoZVxyXG4gICAgICovXHJcbiAgICBjbGVhckNhY2hlKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENsaWVudEFwcGxpY2F0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGllbnRBcHBsaWNhdGlvbi5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBVcmxVdGlscywgSHR0cFN0YXR1cyB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbi9ub2RlJztcbmltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IHsgTm9kZUF1dGhFcnJvciB9IGZyb20gJy4uL2Vycm9yL05vZGVBdXRoRXJyb3IubWpzJztcbmltcG9ydCB7IENvbnN0YW50cyBhcyBDb25zdGFudHMkMSB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTG9vcGJhY2tDbGllbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGlucyB1cCBhIGxvb3BiYWNrIHNlcnZlciB3aGljaCByZXR1cm5zIHRoZSBzZXJ2ZXIgcmVzcG9uc2Ugd2hlbiB0aGUgbG9jYWxob3N0IHJlZGlyZWN0VXJpIGlzIGhpdFxyXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NUZW1wbGF0ZVxyXG4gICAgICogQHBhcmFtIGVycm9yVGVtcGxhdGVcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGxpc3RlbkZvckF1dGhDb2RlKHN1Y2Nlc3NUZW1wbGF0ZSwgZXJyb3JUZW1wbGF0ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBOb2RlQXV0aEVycm9yLmNyZWF0ZUxvb3BiYWNrU2VydmVyQWxyZWFkeUV4aXN0c0Vycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSByZXEudXJsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKGVycm9yVGVtcGxhdGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJFcnJvciBvY2N1cnJlZCBsb2FkaW5nIHJlZGlyZWN0VXJsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChOb2RlQXV0aEVycm9yLmNyZWF0ZVVuYWJsZVRvTG9hZFJlZGlyZWN0VXJsRXJyb3IoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXJsID09PSBDb25zdGFudHMuRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoc3VjY2Vzc1RlbXBsYXRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQXV0aCBjb2RlIHdhcyBzdWNjZXNzZnVsbHkgYWNxdWlyZWQuIFlvdSBjYW4gY2xvc2UgdGhpcyB3aW5kb3cgbm93LlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFVyaSA9IHRoaXMuZ2V0UmVkaXJlY3RVcmkoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsLCByZWRpcmVjdFVyaSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoQ29kZVJlc3BvbnNlID0gVXJsVXRpbHMuZ2V0RGVzZXJpYWxpemVkUmVzcG9uc2UocGFyc2VkVXJsLnNlYXJjaCkgfHxcclxuICAgICAgICAgICAgICAgICAgICB7fTtcclxuICAgICAgICAgICAgICAgIGlmIChhdXRoQ29kZVJlc3BvbnNlLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKEh0dHBTdGF0dXMuUkVESVJFQ1QsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHJlZGlyZWN0VXJpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pOyAvLyBQcmV2ZW50IGF1dGggY29kZSBmcm9tIGJlaW5nIHNhdmVkIGluIHRoZSBicm93c2VyIGhpc3RvcnlcclxuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXV0aENvZGVSZXNwb25zZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoZXJyb3JUZW1wbGF0ZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBgRXJyb3Igb2NjdXJyZWQ6ICR7YXV0aENvZGVSZXNwb25zZS5lcnJvcn1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoYXV0aENvZGVSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZlci5saXN0ZW4oMCwgXCIxMjcuMC4wLjFcIik7IC8vIExpc3RlbiBvbiBhbnkgYXZhaWxhYmxlIHBvcnRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBwb3J0IHRoYXQgdGhlIGxvb3BiYWNrIHNlcnZlciBpcyBydW5uaW5nIG9uXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBnZXRSZWRpcmVjdFVyaSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2VydmVyIHx8ICF0aGlzLnNlcnZlci5saXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgTm9kZUF1dGhFcnJvci5jcmVhdGVOb0xvb3BiYWNrU2VydmVyRXhpc3RzRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuc2VydmVyLmFkZHJlc3MoKTtcclxuICAgICAgICBpZiAoIWFkZHJlc3MgfHwgdHlwZW9mIGFkZHJlc3MgPT09IFwic3RyaW5nXCIgfHwgIWFkZHJlc3MucG9ydCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlU2VydmVyKCk7XHJcbiAgICAgICAgICAgIHRocm93IE5vZGVBdXRoRXJyb3IuY3JlYXRlSW52YWxpZExvb3BiYWNrQWRkcmVzc1R5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwb3J0ID0gYWRkcmVzcyAmJiBhZGRyZXNzLnBvcnQ7XHJcbiAgICAgICAgcmV0dXJuIGAke0NvbnN0YW50cyQxLkhUVFBfUFJPVE9DT0x9JHtDb25zdGFudHMkMS5MT0NBTEhPU1R9OiR7cG9ydH1gO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZSB0aGUgbG9vcGJhY2sgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIGNsb3NlU2VydmVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlcnZlcikge1xyXG4gICAgICAgICAgICAvLyBPbmx5IHN0b3BzIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMsIHNlcnZlciB3aWxsIGNsb3NlIG9uY2Ugb3Blbi9pZGxlIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQuXHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXJ2ZXIuY2xvc2VBbGxDb25uZWN0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogQ2xvc2Ugb3Blbi9pZGxlIGNvbm5lY3Rpb25zLiBUaGlzIEFQSSBpcyBhdmFpbGFibGUgaW4gTm9kZSB2ZXJzaW9ucyAxOC4yIGFuZCBoaWdoZXJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuY2xvc2VBbGxDb25uZWN0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLnVucmVmKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBMb29wYmFja0NsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9vcGJhY2tDbGllbnQubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEJhc2VDbGllbnQsIFRpbWVVdGlscywgUmVzcG9uc2VIYW5kbGVyLCBVcmxTdHJpbmcsIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLCBVcmxVdGlscywgY3JlYXRlQ2xpZW50QXV0aEVycm9yLCBDbGllbnRBdXRoRXJyb3JDb2RlcywgQ29uc3RhbnRzLCBjcmVhdGVBdXRoRXJyb3IsIEF1dGhFcnJvckNvZGVzLCBHcmFudFR5cGUsIFN0cmluZ1V0aWxzIH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE9BdXRoMi4wIERldmljZSBjb2RlIGNsaWVudFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBEZXZpY2VDb2RlQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgZGV2aWNlIGNvZGUgZnJvbSBkZXZpY2UgY29kZSBlbmRwb2ludCwgY2FsbHMgYmFjayB0byB3aXRoIGRldmljZSBjb2RlIHJlc3BvbnNlLCBhbmRcclxuICAgICAqIHBvbGxzIHRva2VuIGVuZHBvaW50IHRvIGV4Y2hhbmdlIGRldmljZSBjb2RlIGZvciB0b2tlbnNcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gZGV2ZWxvcGVyIHByb3ZpZGVkIENvbW1vbkRldmljZUNvZGVSZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGFjcXVpcmVUb2tlbihyZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgZGV2aWNlQ29kZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXREZXZpY2VDb2RlKHJlcXVlc3QpO1xyXG4gICAgICAgIHJlcXVlc3QuZGV2aWNlQ29kZUNhbGxiYWNrKGRldmljZUNvZGVSZXNwb25zZSk7XHJcbiAgICAgICAgY29uc3QgcmVxVGltZXN0YW1wID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNxdWlyZVRva2VuV2l0aERldmljZUNvZGUocmVxdWVzdCwgZGV2aWNlQ29kZVJlc3BvbnNlKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSBuZXcgUmVzcG9uc2VIYW5kbGVyKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCB0aGlzLmNhY2hlTWFuYWdlciwgdGhpcy5jcnlwdG9VdGlscywgdGhpcy5sb2dnZXIsIHRoaXMuY29uZmlnLnNlcmlhbGl6YWJsZUNhY2hlLCB0aGlzLmNvbmZpZy5wZXJzaXN0ZW5jZVBsdWdpbik7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVzcG9uc2UuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIGEgc2VydmVyIGVycm9yIGlmIGFuIGVycm9yIGlzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnZhbGlkYXRlVG9rZW5SZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlSGFuZGxlci5oYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlKHJlc3BvbnNlLCB0aGlzLmF1dGhvcml0eSwgcmVxVGltZXN0YW1wLCByZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBkZXZpY2UgY29kZSByZXF1ZXN0IGFuZCBleGVjdXRlcyBodHRwIEdFVFxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uRGV2aWNlQ29kZVJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0RGV2aWNlQ29kZShyZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5jcmVhdGVFeHRyYVF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBlbmRwb2ludCA9IFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyh0aGlzLmF1dGhvcml0eS5kZXZpY2VDb2RlRW5kcG9pbnQsIHF1ZXJ5UGFyYW1ldGVyc1N0cmluZyk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSB0aGlzLmNyZWF0ZVF1ZXJ5U3RyaW5nKHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdEhlYWRlcnMoKTtcclxuICAgICAgICBjb25zdCB0aHVtYnByaW50ID0ge1xyXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXHJcbiAgICAgICAgICAgIGF1dGhvcml0eTogcmVxdWVzdC5hdXRob3JpdHksXHJcbiAgICAgICAgICAgIHNjb3BlczogcmVxdWVzdC5zY29wZXMsXHJcbiAgICAgICAgICAgIGNsYWltczogcmVxdWVzdC5jbGFpbXMsXHJcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uU2NoZW1lOiByZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lLFxyXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RNZXRob2Q6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0TWV0aG9kLFxyXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RVcmk6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpLFxyXG4gICAgICAgICAgICBzaHJDbGFpbXM6IHJlcXVlc3Quc2hyQ2xhaW1zLFxyXG4gICAgICAgICAgICBzc2hLaWQ6IHJlcXVlc3Quc3NoS2lkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVBvc3RSZXF1ZXN0VG9EZXZpY2VDb2RlRW5kcG9pbnQoZW5kcG9pbnQsIHF1ZXJ5U3RyaW5nLCBoZWFkZXJzLCB0aHVtYnByaW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHF1ZXJ5IHN0cmluZyBmb3IgdGhlIGRldmljZSBjb2RlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gZGV2ZWxvcGVyIHByb3ZpZGVkIENvbW1vbkRldmljZUNvZGVSZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUV4dHJhUXVlcnlQYXJhbWV0ZXJzKHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHJlcXVlc3QuZXh0cmFRdWVyeVBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVXJsVXRpbHMubWFwVG9RdWVyeVN0cmluZyhwYXJhbWV0ZXJzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgUE9TVCByZXF1ZXN0IHRvIGRldmljZSBjb2RlIGVuZHBvaW50XHJcbiAgICAgKiBAcGFyYW0gZGV2aWNlQ29kZUVuZHBvaW50IC0gdG9rZW4gZW5kcG9pbnRcclxuICAgICAqIEBwYXJhbSBxdWVyeVN0cmluZyAtIHN0cmluZyB0byBiZSB1c2VkIGluIHRoZSBib2R5IG9mIHRoZSByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gaGVhZGVycyAtIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gdGh1bWJwcmludCAtIHVuaXF1ZSByZXF1ZXN0IHRodW1icHJpbnRcclxuICAgICAqIEBwYXJhbSBjb3JyZWxhdGlvbklkIC0gY29ycmVsYXRpb24gaWQgdG8gYmUgdXNlZCBpbiB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBleGVjdXRlUG9zdFJlcXVlc3RUb0RldmljZUNvZGVFbmRwb2ludChkZXZpY2VDb2RlRW5kcG9pbnQsIHF1ZXJ5U3RyaW5nLCBoZWFkZXJzLCB0aHVtYnByaW50LCBjb3JyZWxhdGlvbklkKSB7XHJcbiAgICAgICAgY29uc3QgeyBib2R5OiB7IHVzZXJfY29kZTogdXNlckNvZGUsIGRldmljZV9jb2RlOiBkZXZpY2VDb2RlLCB2ZXJpZmljYXRpb25fdXJpOiB2ZXJpZmljYXRpb25VcmksIGV4cGlyZXNfaW46IGV4cGlyZXNJbiwgaW50ZXJ2YWwsIG1lc3NhZ2UsIH0sIH0gPSBhd2FpdCB0aGlzLnNlbmRQb3N0UmVxdWVzdCh0aHVtYnByaW50LCBkZXZpY2VDb2RlRW5kcG9pbnQsIHtcclxuICAgICAgICAgICAgYm9keTogcXVlcnlTdHJpbmcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXHJcbiAgICAgICAgfSwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlckNvZGUsXHJcbiAgICAgICAgICAgIGRldmljZUNvZGUsXHJcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvblVyaSxcclxuICAgICAgICAgICAgZXhwaXJlc0luLFxyXG4gICAgICAgICAgICBpbnRlcnZhbCxcclxuICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgZGV2aWNlIGNvZGUgZW5kcG9pbnQgcXVlcnkgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBzdHJpbmdcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gZGV2ZWxvcGVyIHByb3ZpZGVkIENvbW1vbkRldmljZUNvZGVSZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVF1ZXJ5U3RyaW5nKHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNjb3BlcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LnNjb3Blcyk7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SWQocGFyYW1ldGVycywgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0LmV4dHJhUXVlcnlQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEV4dHJhUXVlcnlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHJlcXVlc3QuZXh0cmFRdWVyeVBhcmFtZXRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVxdWVzdC5jbGFpbXMgfHxcclxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsYWltcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LmNsYWltcywgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVybFV0aWxzLm1hcFRvUXVlcnlTdHJpbmcocGFyYW1ldGVycyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJyZWFrcyB0aGUgcG9sbGluZyB3aXRoIHNwZWNpZmljIGNvbmRpdGlvbnNcclxuICAgICAqIEBwYXJhbSBkZXZpY2VDb2RlRXhwaXJhdGlvblRpbWUgLSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSBkZXZpY2UgY29kZSByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gdXNlclNwZWNpZmllZFRpbWVvdXQgLSBkZXZlbG9wZXIgcHJvdmlkZWQgdGltZW91dCwgdG8gYmUgY29tcGFyZWQgYWdhaW5zdCBkZXZpY2VDb2RlRXhwaXJhdGlvblRpbWVcclxuICAgICAqIEBwYXJhbSB1c2VyU3BlY2lmaWVkQ2FuY2VsRmxhZyAtIGJvb2xlYW4gaW5kaWNhdGluZyB0aGUgZGV2ZWxvcGVyIHdvdWxkIGxpa2UgdG8gY2FuY2VsIHRoZSByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIGNvbnRpbnVlUG9sbGluZyhkZXZpY2VDb2RlRXhwaXJhdGlvblRpbWUsIHVzZXJTcGVjaWZpZWRUaW1lb3V0LCB1c2VyU3BlY2lmaWVkQ2FuY2VsRmxhZykge1xyXG4gICAgICAgIGlmICh1c2VyU3BlY2lmaWVkQ2FuY2VsRmxhZykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlRva2VuIHJlcXVlc3QgY2FuY2VsbGVkIGJ5IHNldHRpbmcgRGV2aWNlQ29kZVJlcXVlc3QuY2FuY2VsID0gdHJ1ZVwiKTtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLmRldmljZUNvZGVQb2xsaW5nQ2FuY2VsbGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodXNlclNwZWNpZmllZFRpbWVvdXQgJiZcclxuICAgICAgICAgICAgdXNlclNwZWNpZmllZFRpbWVvdXQgPCBkZXZpY2VDb2RlRXhwaXJhdGlvblRpbWUgJiZcclxuICAgICAgICAgICAgVGltZVV0aWxzLm5vd1NlY29uZHMoKSA+IHVzZXJTcGVjaWZpZWRUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBVc2VyIGRlZmluZWQgdGltZW91dCBmb3IgZGV2aWNlIGNvZGUgcG9sbGluZyByZWFjaGVkLiBUaGUgdGltZW91dCB3YXMgc2V0IGZvciAke3VzZXJTcGVjaWZpZWRUaW1lb3V0fWApO1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMudXNlclRpbWVvdXRSZWFjaGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoVGltZVV0aWxzLm5vd1NlY29uZHMoKSA+IGRldmljZUNvZGVFeHBpcmF0aW9uVGltZSkge1xyXG4gICAgICAgICAgICBpZiAodXNlclNwZWNpZmllZFRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoYFVzZXIgc3BlY2lmaWVkIHRpbWVvdXQgaWdub3JlZCBhcyB0aGUgZGV2aWNlIGNvZGUgaGFzIGV4cGlyZWQgYmVmb3JlIHRoZSB0aW1lb3V0IGVsYXBzZWQuIFRoZSB1c2VyIHNwZWNpZmllZCB0aW1lb3V0IHdhcyBzZXQgZm9yICR7dXNlclNwZWNpZmllZFRpbWVvdXR9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYERldmljZSBjb2RlIGV4cGlyZWQuIEV4cGlyYXRpb24gdGltZSBvZiBkZXZpY2UgY29kZSB3YXMgJHtkZXZpY2VDb2RlRXhwaXJhdGlvblRpbWV9YCk7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5kZXZpY2VDb2RlRXhwaXJlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRva2VuIHJlcXVlc3Qgd2l0aCBkZXZpY2UgY29kZSByZXNwb25zZSBhbmQgcG9sbHMgdG9rZW4gZW5kcG9pbnQgYXQgaW50ZXJ2YWwgc2V0IGJ5IHRoZSBkZXZpY2UgY29kZSByZXNwb25zZVxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uRGV2aWNlQ29kZVJlcXVlc3RcclxuICAgICAqIEBwYXJhbSBkZXZpY2VDb2RlUmVzcG9uc2UgLSBEZXZpY2VDb2RlUmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIHNlY3VyaXR5IHRva2VuIHNlcnZpY2UgZGV2aWNlIGNvZGUgZW5kcG9pbnRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuV2l0aERldmljZUNvZGUocmVxdWVzdCwgZGV2aWNlQ29kZVJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5jcmVhdGVUb2tlblF1ZXJ5UGFyYW1ldGVycyhyZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBlbmRwb2ludCA9IFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyh0aGlzLmF1dGhvcml0eS50b2tlbkVuZHBvaW50LCBxdWVyeVBhcmFtZXRlcnNTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gdGhpcy5jcmVhdGVUb2tlblJlcXVlc3RCb2R5KHJlcXVlc3QsIGRldmljZUNvZGVSZXNwb25zZSk7XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0SGVhZGVycygpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJTcGVjaWZpZWRUaW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0XHJcbiAgICAgICAgICAgID8gVGltZVV0aWxzLm5vd1NlY29uZHMoKSArIHJlcXVlc3QudGltZW91dFxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBkZXZpY2VDb2RlRXhwaXJhdGlvblRpbWUgPSBUaW1lVXRpbHMubm93U2Vjb25kcygpICsgZGV2aWNlQ29kZVJlc3BvbnNlLmV4cGlyZXNJbjtcclxuICAgICAgICBjb25zdCBwb2xsaW5nSW50ZXJ2YWxNaWxsaSA9IGRldmljZUNvZGVSZXNwb25zZS5pbnRlcnZhbCAqIDEwMDA7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBQb2xsIHRva2VuIGVuZHBvaW50IHdoaWxlIChkZXZpY2UgY29kZSBpcyBub3QgZXhwaXJlZCBBTkQgb3BlcmF0aW9uIGhhcyBub3QgYmVlbiBjYW5jZWxsZWQgYnlcclxuICAgICAgICAgKiBzZXR0aW5nIENhbmNlbGxhdGlvblRva2VuLmNhbmNlbCA9IHRydWUpLiBQT1NUIHJlcXVlc3QgaXMgc2VudCBhdCBpbnRlcnZhbCBzZXQgYnkgcG9sbGluZ0ludGVydmFsTWlsbGlcclxuICAgICAgICAgKi9cclxuICAgICAgICB3aGlsZSAodGhpcy5jb250aW51ZVBvbGxpbmcoZGV2aWNlQ29kZUV4cGlyYXRpb25UaW1lLCB1c2VyU3BlY2lmaWVkVGltZW91dCwgcmVxdWVzdC5jYW5jZWwpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRodW1icHJpbnQgPSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHJlcXVlc3QuYXV0aG9yaXR5LFxyXG4gICAgICAgICAgICAgICAgc2NvcGVzOiByZXF1ZXN0LnNjb3BlcyxcclxuICAgICAgICAgICAgICAgIGNsYWltczogcmVxdWVzdC5jbGFpbXMsXHJcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvblNjaGVtZTogcmVxdWVzdC5hdXRoZW50aWNhdGlvblNjaGVtZSxcclxuICAgICAgICAgICAgICAgIHJlc291cmNlUmVxdWVzdE1ldGhvZDogcmVxdWVzdC5yZXNvdXJjZVJlcXVlc3RNZXRob2QsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RVcmk6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpLFxyXG4gICAgICAgICAgICAgICAgc2hyQ2xhaW1zOiByZXF1ZXN0LnNockNsYWltcyxcclxuICAgICAgICAgICAgICAgIHNzaEtpZDogcmVxdWVzdC5zc2hLaWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUG9zdFRvVG9rZW5FbmRwb2ludChlbmRwb2ludCwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHRodW1icHJpbnQsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5ib2R5ICYmIHJlc3BvbnNlLmJvZHkuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHVzZXIgYXV0aG9yaXphdGlvbiBpcyBwZW5kaW5nLiBTbGVlcCBmb3IgcG9sbGluZyBpbnRlcnZhbCBhbmQgdHJ5IGFnYWluXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuYm9keS5lcnJvciA9PT0gQ29uc3RhbnRzLkFVVEhPUklaQVRJT05fUEVORElORykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJBdXRob3JpemF0aW9uIHBlbmRpbmcuIENvbnRpbnVlIHBvbGxpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IFRpbWVVdGlscy5kZWxheShwb2xsaW5nSW50ZXJ2YWxNaWxsaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYW55IG90aGVyIGVycm9yLCB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJVbmV4cGVjdGVkIGVycm9yIGluIHBvbGxpbmcgZnJvbSB0aGUgc2VydmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUF1dGhFcnJvcihBdXRoRXJyb3JDb2Rlcy5wb3N0UmVxdWVzdEZhaWxlZCwgcmVzcG9uc2UuYm9keS5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiQXV0aG9yaXphdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBQb2xsaW5nIHN0b3BwZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgYWJvdmUgY29kZSBzaG91bGQndmUgdGhyb3duIGJ5IHRoaXMgcG9pbnQsIGJ1dCB0byBzYXRpc2Z5IFR5cGVTY3JpcHQsXHJcbiAgICAgICAgICogYW5kIGluIHRoZSByYXJlIGNhc2UgdGhlIGNvbmRpdGlvbmFscyBpbiBjb250aW51ZVBvbGxpbmcoKSBtYXkgbm90IGNhdGNoIGV2ZXJ5dGhpbmcuLi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlBvbGxpbmcgc3RvcHBlZCBmb3IgdW5rbm93biByZWFzb25zLlwiKTtcclxuICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMuZGV2aWNlQ29kZVVua25vd25FcnJvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgcXVlcnkgcGFyYW1ldGVycyBhbmQgY29udmVydHMgdG8gc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uRGV2aWNlQ29kZVJlcXVlc3RcclxuICAgICAqIEBwYXJhbSBkZXZpY2VDb2RlUmVzcG9uc2UgLSBEZXZpY2VDb2RlUmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIHNlY3VyaXR5IHRva2VuIHNlcnZpY2UgZGV2aWNlIGNvZGUgZW5kcG9pbnRcclxuICAgICAqL1xyXG4gICAgY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShyZXF1ZXN0LCBkZXZpY2VDb2RlUmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNjb3BlcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LnNjb3Blcyk7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SWQocGFyYW1ldGVycywgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEdyYW50VHlwZShwYXJhbWV0ZXJzLCBHcmFudFR5cGUuREVWSUNFX0NPREVfR1JBTlQpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZERldmljZUNvZGUocGFyYW1ldGVycywgZGV2aWNlQ29kZVJlc3BvbnNlLmRldmljZUNvZGUpO1xyXG4gICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSByZXF1ZXN0LmNvcnJlbGF0aW9uSWQgfHxcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuY3J5cHRvSW50ZXJmYWNlLmNyZWF0ZU5ld0d1aWQoKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDb3JyZWxhdGlvbklkKHBhcmFtZXRlcnMsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEluZm8ocGFyYW1ldGVycyk7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkTGlicmFyeUluZm8ocGFyYW1ldGVycywgdGhpcy5jb25maWcubGlicmFyeUluZm8pO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEFwcGxpY2F0aW9uVGVsZW1ldHJ5KHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLnRlbGVtZXRyeS5hcHBsaWNhdGlvbik7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyhwYXJhbWV0ZXJzKTtcclxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNlcnZlclRlbGVtZXRyeShwYXJhbWV0ZXJzLCB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIVN0cmluZ1V0aWxzLmlzRW1wdHlPYmoocmVxdWVzdC5jbGFpbXMpIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGFpbXMocGFyYW1ldGVycywgcmVxdWVzdC5jbGFpbXMsIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBVcmxVdGlscy5tYXBUb1F1ZXJ5U3RyaW5nKHBhcmFtZXRlcnMpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IERldmljZUNvZGVDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURldmljZUNvZGVDbGllbnQubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IENvbnN0YW50cywgQXBpSWQsIExPT1BCQUNLX1NFUlZFUl9DT05TVEFOVFMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IFNlcnZlclRlbGVtZXRyeU1hbmFnZXIsIEF1dGhFcnJvciwgT0lEQ19ERUZBVUxUX1NDT1BFUywgUmVzcG9uc2VNb2RlLCBDb2RlQ2hhbGxlbmdlTWV0aG9kVmFsdWVzLCBTZXJ2ZXJFcnJvciwgQ29uc3RhbnRzIGFzIENvbnN0YW50cyQxLCBBQURTZXJ2ZXJQYXJhbUtleXMgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBDbGllbnRBcHBsaWNhdGlvbiB9IGZyb20gJy4vQ2xpZW50QXBwbGljYXRpb24ubWpzJztcbmltcG9ydCB7IE5vZGVBdXRoRXJyb3IsIE5vZGVBdXRoRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vZXJyb3IvTm9kZUF1dGhFcnJvci5tanMnO1xuaW1wb3J0IHsgTG9vcGJhY2tDbGllbnQgfSBmcm9tICcuLi9uZXR3b3JrL0xvb3BiYWNrQ2xpZW50Lm1qcyc7XG5pbXBvcnQgeyBEZXZpY2VDb2RlQ2xpZW50IH0gZnJvbSAnLi9EZXZpY2VDb2RlQ2xpZW50Lm1qcyc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZU1ldGFkYXRhLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyB0byBiZSB1c2VkIHRvIGFjcXVpcmUgdG9rZW5zIGZvciBwdWJsaWMgY2xpZW50IGFwcGxpY2F0aW9ucyAoZGVza3RvcCwgbW9iaWxlKS4gUHVibGljIGNsaWVudCBhcHBsaWNhdGlvbnNcclxuICogYXJlIG5vdCB0cnVzdGVkIHRvIHNhZmVseSBzdG9yZSBhcHBsaWNhdGlvbiBzZWNyZXRzLCBhbmQgdGhlcmVmb3JlIGNhbiBvbmx5IHJlcXVlc3QgdG9rZW5zIGluIHRoZSBuYW1lIG9mIGFuIHVzZXIuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIFB1YmxpY0NsaWVudEFwcGxpY2F0aW9uIGV4dGVuZHMgQ2xpZW50QXBwbGljYXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBvcnRhbnQgYXR0cmlidXRlcyBpbiB0aGUgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGF1dGggYXJlOlxyXG4gICAgICogLSBjbGllbnRJRDogdGhlIGFwcGxpY2F0aW9uIElEIG9mIHlvdXIgYXBwbGljYXRpb24uIFlvdSBjYW4gb2J0YWluIG9uZSBieSByZWdpc3RlcmluZyB5b3VyIGFwcGxpY2F0aW9uIHdpdGggb3VyIEFwcGxpY2F0aW9uIHJlZ2lzdHJhdGlvbiBwb3J0YWwuXHJcbiAgICAgKiAtIGF1dGhvcml0eTogdGhlIGF1dGhvcml0eSBVUkwgZm9yIHlvdXIgYXBwbGljYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQUFEIGF1dGhvcml0aWVzIGFyZSBvZiB0aGUgZm9ybSBodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20vXFx7RW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcXH0uXHJcbiAgICAgKiAtIElmIHlvdXIgYXBwbGljYXRpb24gc3VwcG9ydHMgQWNjb3VudHMgaW4gb25lIG9yZ2FuaXphdGlvbmFsIGRpcmVjdG9yeSwgcmVwbGFjZSBcIkVudGVyX3RoZV9UZW5hbnRfSW5mb19IZXJlXCIgdmFsdWUgd2l0aCB0aGUgVGVuYW50IElkIG9yIFRlbmFudCBuYW1lIChmb3IgZXhhbXBsZSwgY29udG9zby5taWNyb3NvZnQuY29tKS5cclxuICAgICAqIC0gSWYgeW91ciBhcHBsaWNhdGlvbiBzdXBwb3J0cyBBY2NvdW50cyBpbiBhbnkgb3JnYW5pemF0aW9uYWwgZGlyZWN0b3J5LCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIG9yZ2FuaXphdGlvbnMuXHJcbiAgICAgKiAtIElmIHlvdXIgYXBwbGljYXRpb24gc3VwcG9ydHMgQWNjb3VudHMgaW4gYW55IG9yZ2FuaXphdGlvbmFsIGRpcmVjdG9yeSBhbmQgcGVyc29uYWwgTWljcm9zb2Z0IGFjY291bnRzLCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIGNvbW1vbi5cclxuICAgICAqIC0gVG8gcmVzdHJpY3Qgc3VwcG9ydCB0byBQZXJzb25hbCBNaWNyb3NvZnQgYWNjb3VudHMgb25seSwgcmVwbGFjZSBcIkVudGVyX3RoZV9UZW5hbnRfSW5mb19IZXJlXCIgdmFsdWUgd2l0aCBjb25zdW1lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQXp1cmUgQjJDIGF1dGhvcml0aWVzIGFyZSBvZiB0aGUgZm9ybSBodHRwczovL1xce2luc3RhbmNlXFx9L1xce3RlbmFudFxcfS9cXHtwb2xpY3lcXH0uIEVhY2ggcG9saWN5IGlzIGNvbnNpZGVyZWRcclxuICAgICAqIGl0cyBvd24gYXV0aG9yaXR5LiBZb3Ugd2lsbCBoYXZlIHRvIHNldCB0aGUgYWxsIG9mIHRoZSBrbm93bkF1dGhvcml0aWVzIGF0IHRoZSB0aW1lIG9mIHRoZSBjbGllbnQgYXBwbGljYXRpb25cclxuICAgICAqIGNvbnN0cnVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBBREZTIGF1dGhvcml0aWVzIGFyZSBvZiB0aGUgZm9ybSBodHRwczovL1xce2luc3RhbmNlXFx9L2FkZnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uKTtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuYnJva2VyLm5hdGl2ZUJyb2tlclBsdWdpbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuYnJva2VyLm5hdGl2ZUJyb2tlclBsdWdpbi5pc0Jyb2tlckF2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVCcm9rZXJQbHVnaW4gPSB0aGlzLmNvbmZpZy5icm9rZXIubmF0aXZlQnJva2VyUGx1Z2luO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVCcm9rZXJQbHVnaW4uc2V0TG9nZ2VyKHRoaXMuY29uZmlnLnN5c3RlbS5sb2dnZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm5pbmcoXCJOYXRpdmVCcm9rZXIgaW1wbGVtZW50YXRpb24gd2FzIHByb3ZpZGVkIGJ1dCB0aGUgYnJva2VyIGlzIHVuYXZhaWxhYmxlLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNrdXMgPSBTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLm1ha2VFeHRyYVNrdVN0cmluZyh7XHJcbiAgICAgICAgICAgIGxpYnJhcnlOYW1lOiBDb25zdGFudHMuTVNBTF9TS1UsXHJcbiAgICAgICAgICAgIGxpYnJhcnlWZXJzaW9uOiB2ZXJzaW9uLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3F1aXJlcyBhIHRva2VuIGZyb20gdGhlIGF1dGhvcml0eSB1c2luZyBPQXV0aDIuMCBkZXZpY2UgY29kZSBmbG93LlxyXG4gICAgICogVGhpcyBmbG93IGlzIGRlc2lnbmVkIGZvciBkZXZpY2VzIHRoYXQgZG8gbm90IGhhdmUgYWNjZXNzIHRvIGEgYnJvd3NlciBvciBoYXZlIGlucHV0IGNvbnN0cmFpbnRzLlxyXG4gICAgICogVGhlIGF1dGhvcml6YXRpb24gc2VydmVyIGlzc3VlcyBhIERldmljZUNvZGUgb2JqZWN0IHdpdGggYSB2ZXJpZmljYXRpb24gY29kZSwgYW4gZW5kLXVzZXIgY29kZSxcclxuICAgICAqIGFuZCB0aGUgZW5kLXVzZXIgdmVyaWZpY2F0aW9uIFVSSS4gVGhlIERldmljZUNvZGUgb2JqZWN0IGlzIHByb3ZpZGVkIHRocm91Z2ggYSBjYWxsYmFjaywgYW5kIHRoZSBlbmQtdXNlciBzaG91bGQgYmVcclxuICAgICAqIGluc3RydWN0ZWQgdG8gdXNlIGFub3RoZXIgZGV2aWNlIHRvIG5hdmlnYXRlIHRvIHRoZSB2ZXJpZmljYXRpb24gVVJJIHRvIGlucHV0IGNyZWRlbnRpYWxzLlxyXG4gICAgICogU2luY2UgdGhlIGNsaWVudCBjYW5ub3QgcmVjZWl2ZSBpbmNvbWluZyByZXF1ZXN0cywgaXQgcG9sbHMgdGhlIGF1dGhvcml6YXRpb24gc2VydmVyIHJlcGVhdGVkbHlcclxuICAgICAqIHVudGlsIHRoZSBlbmQtdXNlciBjb21wbGV0ZXMgaW5wdXQgb2YgY3JlZGVudGlhbHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGFjcXVpcmVUb2tlbkJ5RGV2aWNlQ29kZShyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImFjcXVpcmVUb2tlbkJ5RGV2aWNlQ29kZSBjYWxsZWRcIiwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBjb25zdCB2YWxpZFJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHJlcXVlc3QsIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUJhc2VSZXF1ZXN0KHJlcXVlc3QpKTtcclxuICAgICAgICBjb25zdCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyID0gdGhpcy5pbml0aWFsaXplU2VydmVyVGVsZW1ldHJ5TWFuYWdlcihBcGlJZC5hY3F1aXJlVG9rZW5CeURldmljZUNvZGUsIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNjb3ZlcmVkQXV0aG9yaXR5ID0gYXdhaXQgdGhpcy5jcmVhdGVBdXRob3JpdHkodmFsaWRSZXF1ZXN0LmF1dGhvcml0eSwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsIHVuZGVmaW5lZCwgcmVxdWVzdC5henVyZUNsb3VkT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRldmljZUNvZGVDb25maWcgPSBhd2FpdCB0aGlzLmJ1aWxkT2F1dGhDbGllbnRDb25maWd1cmF0aW9uKGRpc2NvdmVyZWRBdXRob3JpdHksIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCBcIlwiLCBzZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKTtcclxuICAgICAgICAgICAgY29uc3QgZGV2aWNlQ29kZUNsaWVudCA9IG5ldyBEZXZpY2VDb2RlQ2xpZW50KGRldmljZUNvZGVDb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci52ZXJib3NlKFwiRGV2aWNlIGNvZGUgY2xpZW50IGNyZWF0ZWRcIiwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZGV2aWNlQ29kZUNsaWVudC5hY3F1aXJlVG9rZW4odmFsaWRSZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBdXRoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGUuc2V0Q29ycmVsYXRpb25JZCh2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlci5jYWNoZUZhaWxlZFJlcXVlc3QoZSk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3F1aXJlcyBhIHRva2VuIGludGVyYWN0aXZlbHkgdmlhIHRoZSBicm93c2VyIGJ5IHJlcXVlc3RpbmcgYW4gYXV0aG9yaXphdGlvbiBjb2RlIHRoZW4gZXhjaGFuZ2luZyBpdCBmb3IgYSB0b2tlbi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuSW50ZXJhY3RpdmUocmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSByZXF1ZXN0LmNvcnJlbGF0aW9uSWQgfHwgdGhpcy5jcnlwdG9Qcm92aWRlci5jcmVhdGVOZXdHdWlkKCk7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJhY3F1aXJlVG9rZW5JbnRlcmFjdGl2ZSBjYWxsZWRcIiwgY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgY29uc3QgeyBvcGVuQnJvd3Nlciwgc3VjY2Vzc1RlbXBsYXRlLCBlcnJvclRlbXBsYXRlLCB3aW5kb3dIYW5kbGUsIGxvb3BiYWNrQ2xpZW50OiBjdXN0b21Mb29wYmFja0NsaWVudCwgLi4ucmVtYWluaW5nUHJvcGVydGllcyB9ID0gcmVxdWVzdDtcclxuICAgICAgICBpZiAodGhpcy5uYXRpdmVCcm9rZXJQbHVnaW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYnJva2VyUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnJlbWFpbmluZ1Byb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aC5jbGllbnRJZCxcclxuICAgICAgICAgICAgICAgIHNjb3BlczogcmVxdWVzdC5zY29wZXMgfHwgT0lEQ19ERUZBVUxUX1NDT1BFUyxcclxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiBgJHtDb25zdGFudHMuSFRUUF9QUk9UT0NPTH0ke0NvbnN0YW50cy5MT0NBTEhPU1R9YCxcclxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogcmVxdWVzdC5hdXRob3JpdHkgfHwgdGhpcy5jb25maWcuYXV0aC5hdXRob3JpdHksXHJcbiAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVtYWluaW5nUHJvcGVydGllcy5leHRyYVF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5yZW1haW5pbmdQcm9wZXJ0aWVzLnRva2VuUXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIFtBQURTZXJ2ZXJQYXJhbUtleXMuWF9DTElFTlRfRVhUUkFfU0tVXTogdGhpcy5za3VzLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFjY291bnRJZDogcmVtYWluaW5nUHJvcGVydGllcy5hY2NvdW50Py5uYXRpdmVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZUJyb2tlclBsdWdpbi5hY3F1aXJlVG9rZW5JbnRlcmFjdGl2ZShicm9rZXJSZXF1ZXN0LCB3aW5kb3dIYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHZlcmlmaWVyLCBjaGFsbGVuZ2UgfSA9IGF3YWl0IHRoaXMuY3J5cHRvUHJvdmlkZXIuZ2VuZXJhdGVQa2NlQ29kZXMoKTtcclxuICAgICAgICBjb25zdCBsb29wYmFja0NsaWVudCA9IGN1c3RvbUxvb3BiYWNrQ2xpZW50IHx8IG5ldyBMb29wYmFja0NsaWVudCgpO1xyXG4gICAgICAgIGxldCBhdXRoQ29kZVJlc3BvbnNlID0ge307XHJcbiAgICAgICAgbGV0IGF1dGhDb2RlTGlzdGVuZXJFcnJvciA9IG51bGw7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYXV0aENvZGVMaXN0ZW5lciA9IGxvb3BiYWNrQ2xpZW50XHJcbiAgICAgICAgICAgICAgICAubGlzdGVuRm9yQXV0aENvZGUoc3VjY2Vzc1RlbXBsYXRlLCBlcnJvclRlbXBsYXRlKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhdXRoQ29kZVJlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBwcm9taXNlIGluc3RlYWQgb2YgdGhyb3dpbmcgc28gd2UgY2FuIGNvbnRyb2wgd2hlbiBpdHMgdGhyb3duXHJcbiAgICAgICAgICAgICAgICBhdXRoQ29kZUxpc3RlbmVyRXJyb3IgPSBlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gV2FpdCBmb3Igc2VydmVyIHRvIGJlIGxpc3RlbmluZ1xyXG4gICAgICAgICAgICBjb25zdCByZWRpcmVjdFVyaSA9IGF3YWl0IHRoaXMud2FpdEZvclJlZGlyZWN0VXJpKGxvb3BiYWNrQ2xpZW50KTtcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgLi4ucmVtYWluaW5nUHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQsXHJcbiAgICAgICAgICAgICAgICBzY29wZXM6IHJlcXVlc3Quc2NvcGVzIHx8IE9JRENfREVGQVVMVF9TQ09QRVMsXHJcbiAgICAgICAgICAgICAgICByZWRpcmVjdFVyaTogcmVkaXJlY3RVcmksXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZU1vZGU6IFJlc3BvbnNlTW9kZS5RVUVSWSxcclxuICAgICAgICAgICAgICAgIGNvZGVDaGFsbGVuZ2U6IGNoYWxsZW5nZSxcclxuICAgICAgICAgICAgICAgIGNvZGVDaGFsbGVuZ2VNZXRob2Q6IENvZGVDaGFsbGVuZ2VNZXRob2RWYWx1ZXMuUzI1NixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgYXV0aENvZGVVcmwgPSBhd2FpdCB0aGlzLmdldEF1dGhDb2RlVXJsKHZhbGlkUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIGF3YWl0IG9wZW5Ccm93c2VyKGF1dGhDb2RlVXJsKTtcclxuICAgICAgICAgICAgYXdhaXQgYXV0aENvZGVMaXN0ZW5lcjtcclxuICAgICAgICAgICAgaWYgKGF1dGhDb2RlTGlzdGVuZXJFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXV0aENvZGVMaXN0ZW5lckVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhdXRoQ29kZVJlc3BvbnNlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3IoYXV0aENvZGVSZXNwb25zZS5lcnJvciwgYXV0aENvZGVSZXNwb25zZS5lcnJvcl9kZXNjcmlwdGlvbiwgYXV0aENvZGVSZXNwb25zZS5zdWJlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWF1dGhDb2RlUmVzcG9uc2UuY29kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgTm9kZUF1dGhFcnJvci5jcmVhdGVOb0F1dGhDb2RlSW5SZXNwb25zZUVycm9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2xpZW50SW5mbyA9IGF1dGhDb2RlUmVzcG9uc2UuY2xpZW50X2luZm87XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGF1dGhDb2RlUmVzcG9uc2UuY29kZSxcclxuICAgICAgICAgICAgICAgIGNvZGVWZXJpZmllcjogdmVyaWZpZXIsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRJbmZvOiBjbGllbnRJbmZvIHx8IENvbnN0YW50cyQxLkVNUFRZX1NUUklORyxcclxuICAgICAgICAgICAgICAgIC4uLnZhbGlkUmVxdWVzdCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWNxdWlyZVRva2VuQnlDb2RlKHRva2VuUmVxdWVzdCk7IC8vIEF3YWl0IHRoaXMgc28gdGhlIHNlcnZlciBkb2Vzbid0IGNsb3NlIHByZW1hdHVyZWx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBsb29wYmFja0NsaWVudC5jbG9zZVNlcnZlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHRva2VuIHJldHJpZXZlZCBlaXRoZXIgZnJvbSB0aGUgY2FjaGUgb3IgYnkgZXhjaGFuZ2luZyB0aGUgcmVmcmVzaCB0b2tlbiBmb3IgYSBmcmVzaCBhY2Nlc3MgdG9rZW4uIElmIGJyb2tlcmluZyBpcyBlbmFibGVkIHRoZSB0b2tlbiByZXF1ZXN0IHdpbGwgYmUgc2VydmljZWQgYnkgdGhlIGJyb2tlci5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gZGV2ZWxvcGVyIHByb3ZpZGVkIFNpbGVudEZsb3dSZXF1ZXN0XHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBhc3luYyBhY3F1aXJlVG9rZW5TaWxlbnQocmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSByZXF1ZXN0LmNvcnJlbGF0aW9uSWQgfHwgdGhpcy5jcnlwdG9Qcm92aWRlci5jcmVhdGVOZXdHdWlkKCk7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJhY3F1aXJlVG9rZW5TaWxlbnQgY2FsbGVkXCIsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGlmICh0aGlzLm5hdGl2ZUJyb2tlclBsdWdpbikge1xyXG4gICAgICAgICAgICBjb25zdCBicm9rZXJSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgLi4ucmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudElkLFxyXG4gICAgICAgICAgICAgICAgc2NvcGVzOiByZXF1ZXN0LnNjb3BlcyB8fCBPSURDX0RFRkFVTFRfU0NPUEVTLFxyXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RVcmk6IGAke0NvbnN0YW50cy5IVFRQX1BST1RPQ09MfSR7Q29uc3RhbnRzLkxPQ0FMSE9TVH1gLFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5OiByZXF1ZXN0LmF1dGhvcml0eSB8fCB0aGlzLmNvbmZpZy5hdXRoLmF1dGhvcml0eSxcclxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQsXHJcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5yZXF1ZXN0LnRva2VuUXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIFtBQURTZXJ2ZXJQYXJhbUtleXMuWF9DTElFTlRfRVhUUkFfU0tVXTogdGhpcy5za3VzLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFjY291bnRJZDogcmVxdWVzdC5hY2NvdW50Lm5hdGl2ZUFjY291bnRJZCxcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVmcmVzaDogcmVxdWVzdC5mb3JjZVJlZnJlc2ggfHwgZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZUJyb2tlclBsdWdpbi5hY3F1aXJlVG9rZW5TaWxlbnQoYnJva2VyUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5hY3F1aXJlVG9rZW5TaWxlbnQocmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgY2FjaGUgYXJ0aWZhY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gYWNjb3VudFxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgU2lnbk91dFJlcXVlc3RcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHNpZ25PdXQocmVxdWVzdCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5hdGl2ZUJyb2tlclBsdWdpbiAmJiByZXF1ZXN0LmFjY291bnQubmF0aXZlQWNjb3VudElkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25vdXRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWQsXHJcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQ6IHJlcXVlc3QuYWNjb3VudC5uYXRpdmVBY2NvdW50SWQsXHJcbiAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbklkOiByZXF1ZXN0LmNvcnJlbGF0aW9uSWQgfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyeXB0b1Byb3ZpZGVyLmNyZWF0ZU5ld0d1aWQoKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXRpdmVCcm9rZXJQbHVnaW4uc2lnbk91dChzaWdub3V0UmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0VG9rZW5DYWNoZSgpLnJlbW92ZUFjY291bnQocmVxdWVzdC5hY2NvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgY2FjaGVkIGFjY291bnRzIGZvciB0aGlzIGFwcGxpY2F0aW9uLiBJZiBicm9rZXJpbmcgaXMgZW5hYmxlZCB0aGlzIHJlcXVlc3Qgd2lsbCBiZSBzZXJ2aWNlZCBieSB0aGUgYnJva2VyLlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QWxsQWNjb3VudHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmF0aXZlQnJva2VyUGx1Z2luKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSB0aGlzLmNyeXB0b1Byb3ZpZGVyLmNyZWF0ZU5ld0d1aWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlQnJva2VyUGx1Z2luLmdldEFsbEFjY291bnRzKHRoaXMuY29uZmlnLmF1dGguY2xpZW50SWQsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkNhY2hlKCkuZ2V0QWxsQWNjb3VudHMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gcmV0cmlldmUgdGhlIHJlZGlyZWN0VXJpIGZyb20gdGhlIGxvb3BiYWNrIHNlcnZlci4gSWYgdGhlIGxvb3BiYWNrIHNlcnZlciBkb2VzIG5vdCBzdGFydCBsaXN0ZW5pbmcgZm9yIHJlcXVlc3RzIHdpdGhpbiB0aGUgdGltZW91dCB0aGlzIHdpbGwgdGhyb3cuXHJcbiAgICAgKiBAcGFyYW0gbG9vcGJhY2tDbGllbnQgLSBkZXZlbG9wZXIgcHJvdmlkZWQgY3VzdG9tIGxvb3BiYWNrIHNlcnZlciBpbXBsZW1lbnRhdGlvblxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgd2FpdEZvclJlZGlyZWN0VXJpKGxvb3BiYWNrQ2xpZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRpY2tzID0gMDtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTE9PUEJBQ0tfU0VSVkVSX0NPTlNUQU5UUy5USU1FT1VUX01TIC9cclxuICAgICAgICAgICAgICAgICAgICBMT09QQkFDS19TRVJWRVJfQ09OU1RBTlRTLklOVEVSVkFMX01TIDxcclxuICAgICAgICAgICAgICAgICAgICB0aWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChOb2RlQXV0aEVycm9yLmNyZWF0ZUxvb3BiYWNrU2VydmVyVGltZW91dEVycm9yKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IGxvb3BiYWNrQ2xpZW50LmdldFJlZGlyZWN0VXJpKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQXV0aEVycm9yICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZXJyb3JDb2RlID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9kZUF1dGhFcnJvck1lc3NhZ2Uubm9Mb29wYmFja1NlcnZlckV4aXN0cy5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb3BiYWNrIHNlcnZlciBpcyBub3QgbGlzdGVuaW5nIHlldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrcysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIExPT1BCQUNLX1NFUlZFUl9DT05TVEFOVFMuSU5URVJWQUxfTVMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IFB1YmxpY0NsaWVudEFwcGxpY2F0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QdWJsaWNDbGllbnRBcHBsaWNhdGlvbi5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQmFzZUNsaWVudCwgQ2FjaGVPdXRjb21lLCBUb2tlbkNhY2hlQ29udGV4dCwgU2NvcGVTZXQsIFRpbWVVdGlscywgREVGQVVMVF9UT0tFTl9SRU5FV0FMX09GRlNFVF9TRUMsIFJlc3BvbnNlSGFuZGxlciwgQ29uc3RhbnRzLCBDcmVkZW50aWFsVHlwZSwgY3JlYXRlQ2xpZW50QXV0aEVycm9yLCBDbGllbnRBdXRoRXJyb3JDb2RlcywgVXJsU3RyaW5nLCBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlciwgR3JhbnRUeXBlLCBnZXRDbGllbnRBc3NlcnRpb24sIFN0cmluZ1V0aWxzLCBVcmxVdGlscywgQXV0aGVudGljYXRpb25TY2hlbWUgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogT0F1dGgyLjAgY2xpZW50IGNyZWRlbnRpYWwgZ3JhbnRcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQ2xpZW50Q3JlZGVudGlhbENsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgYXBwVG9rZW5Qcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgIHRoaXMuYXBwVG9rZW5Qcm92aWRlciA9IGFwcFRva2VuUHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFB1YmxpYyBBUEkgdG8gYWNxdWlyZSBhIHRva2VuIHdpdGggQ2xpZW50Q3JlZGVudGlhbCBGbG93IGZvciBDb25maWRlbnRpYWwgY2xpZW50c1xyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBDb21tb25DbGllbnRDcmVkZW50aWFsUmVxdWVzdCBwcm92aWRlZCBieSB0aGUgZGV2ZWxvcGVyXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGFjcXVpcmVUb2tlbihyZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKHJlcXVlc3Quc2tpcENhY2hlIHx8IHJlcXVlc3QuY2xhaW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVUb2tlblJlcXVlc3QocmVxdWVzdCwgdGhpcy5hdXRob3JpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBbY2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQsIGxhc3RDYWNoZU91dGNvbWVdID0gYXdhaXQgdGhpcy5nZXRDYWNoZWRBdXRoZW50aWNhdGlvblJlc3VsdChyZXF1ZXN0LCB0aGlzLmNvbmZpZywgdGhpcy5jcnlwdG9VdGlscywgdGhpcy5hdXRob3JpdHksIHRoaXMuY2FjaGVNYW5hZ2VyLCB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIpO1xyXG4gICAgICAgIGlmIChjYWNoZWRBdXRoZW50aWNhdGlvblJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgYnV0IG11c3QgYmUgcmVmcmVzaGVkOyBnZXQgYSBuZXcgb25lIGluIHRoZSBiYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgIGlmIChsYXN0Q2FjaGVPdXRjb21lID09PSBDYWNoZU91dGNvbWUuUFJPQUNUSVZFTFlfUkVGUkVTSEVEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiQ2xpZW50Q3JlZGVudGlhbENsaWVudDpnZXRDYWNoZWRBdXRoZW50aWNhdGlvblJlc3VsdCAtIENhY2hlZCBhY2Nlc3MgdG9rZW4ncyByZWZyZXNoT24gcHJvcGVydHkgaGFzIGJlZW4gZXhjZWVkZWQnLiBJdCdzIG5vdCBleHBpcmVkLCBidXQgbXVzdCBiZSByZWZyZXNoZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuIGluIHRoZSBiYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoQWNjZXNzVG9rZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlVG9rZW5SZXF1ZXN0KHJlcXVlc3QsIHRoaXMuYXV0aG9yaXR5LCByZWZyZXNoQWNjZXNzVG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgY2FjaGVkIHRva2VuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRBdXRoZW50aWNhdGlvblJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVUb2tlblJlcXVlc3QocmVxdWVzdCwgdGhpcy5hdXRob3JpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogbG9va3MgdXAgY2FjaGUgaWYgdGhlIHRva2VucyBhcmUgY2FjaGVkIGFscmVhZHlcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQocmVxdWVzdCwgY29uZmlnLCBjcnlwdG9VdGlscywgYXV0aG9yaXR5LCBjYWNoZU1hbmFnZXIsIHNlcnZlclRlbGVtZXRyeU1hbmFnZXIpIHtcclxuICAgICAgICBjb25zdCBjbGllbnRDb25maWd1cmF0aW9uID0gY29uZmlnO1xyXG4gICAgICAgIGNvbnN0IG1hbmFnZWRJZGVudGl0eUNvbmZpZ3VyYXRpb24gPSBjb25maWc7XHJcbiAgICAgICAgbGV0IGxhc3RDYWNoZU91dGNvbWUgPSBDYWNoZU91dGNvbWUuTk9UX0FQUExJQ0FCTEU7XHJcbiAgICAgICAgLy8gcmVhZCB0aGUgdXNlci1zdXBwbGllZCBjYWNoZSBpbnRvIG1lbW9yeSwgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgIGxldCBjYWNoZUNvbnRleHQ7XHJcbiAgICAgICAgaWYgKGNsaWVudENvbmZpZ3VyYXRpb24uc2VyaWFsaXphYmxlQ2FjaGUgJiZcclxuICAgICAgICAgICAgY2xpZW50Q29uZmlndXJhdGlvbi5wZXJzaXN0ZW5jZVBsdWdpbikge1xyXG4gICAgICAgICAgICBjYWNoZUNvbnRleHQgPSBuZXcgVG9rZW5DYWNoZUNvbnRleHQoY2xpZW50Q29uZmlndXJhdGlvbi5zZXJpYWxpemFibGVDYWNoZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBhd2FpdCBjbGllbnRDb25maWd1cmF0aW9uLnBlcnNpc3RlbmNlUGx1Z2luLmJlZm9yZUNhY2hlQWNjZXNzKGNhY2hlQ29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhY2hlZEFjY2Vzc1Rva2VuID0gdGhpcy5yZWFkQWNjZXNzVG9rZW5Gcm9tQ2FjaGUoYXV0aG9yaXR5LCBtYW5hZ2VkSWRlbnRpdHlDb25maWd1cmF0aW9uLm1hbmFnZWRJZGVudGl0eUlkPy5pZCB8fFxyXG4gICAgICAgICAgICBjbGllbnRDb25maWd1cmF0aW9uLmF1dGhPcHRpb25zLmNsaWVudElkLCBuZXcgU2NvcGVTZXQocmVxdWVzdC5zY29wZXMgfHwgW10pLCBjYWNoZU1hbmFnZXIpO1xyXG4gICAgICAgIGlmIChjbGllbnRDb25maWd1cmF0aW9uLnNlcmlhbGl6YWJsZUNhY2hlICYmXHJcbiAgICAgICAgICAgIGNsaWVudENvbmZpZ3VyYXRpb24ucGVyc2lzdGVuY2VQbHVnaW4gJiZcclxuICAgICAgICAgICAgY2FjaGVDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudENvbmZpZ3VyYXRpb24ucGVyc2lzdGVuY2VQbHVnaW4uYWZ0ZXJDYWNoZUFjY2VzcyhjYWNoZUNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtdXN0IHJlZnJlc2ggZHVlIHRvIG5vbi1leGlzdGVudCBhY2Nlc3NfdG9rZW5cclxuICAgICAgICBpZiAoIWNhY2hlZEFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShDYWNoZU91dGNvbWUuTk9fQ0FDSEVEX0FDQ0VTU19UT0tFTik7XHJcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgQ2FjaGVPdXRjb21lLk5PX0NBQ0hFRF9BQ0NFU1NfVE9LRU5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtdXN0IHJlZnJlc2ggZHVlIHRvIHRoZSBleHBpcmVzX2luIHZhbHVlXHJcbiAgICAgICAgaWYgKFRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZChjYWNoZWRBY2Nlc3NUb2tlbi5leHBpcmVzT24sIGNsaWVudENvbmZpZ3VyYXRpb24uc3lzdGVtT3B0aW9ucz8udG9rZW5SZW5ld2FsT2Zmc2V0U2Vjb25kcyB8fFxyXG4gICAgICAgICAgICBERUZBVUxUX1RPS0VOX1JFTkVXQUxfT0ZGU0VUX1NFQykpIHtcclxuICAgICAgICAgICAgc2VydmVyVGVsZW1ldHJ5TWFuYWdlcj8uc2V0Q2FjaGVPdXRjb21lKENhY2hlT3V0Y29tZS5DQUNIRURfQUNDRVNTX1RPS0VOX0VYUElSRUQpO1xyXG4gICAgICAgICAgICByZXR1cm4gW251bGwsIENhY2hlT3V0Y29tZS5DQUNIRURfQUNDRVNTX1RPS0VOX0VYUElSRURdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtdXN0IHJlZnJlc2ggKGluIHRoZSBiYWNrZ3JvdW5kKSBkdWUgdG8gdGhlIHJlZnJlc2hfaW4gdmFsdWVcclxuICAgICAgICBpZiAoY2FjaGVkQWNjZXNzVG9rZW4ucmVmcmVzaE9uICYmXHJcbiAgICAgICAgICAgIFRpbWVVdGlscy5pc1Rva2VuRXhwaXJlZChjYWNoZWRBY2Nlc3NUb2tlbi5yZWZyZXNoT24udG9TdHJpbmcoKSwgMCkpIHtcclxuICAgICAgICAgICAgbGFzdENhY2hlT3V0Y29tZSA9IENhY2hlT3V0Y29tZS5QUk9BQ1RJVkVMWV9SRUZSRVNIRUQ7XHJcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShDYWNoZU91dGNvbWUuUFJPQUNUSVZFTFlfUkVGUkVTSEVEKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgYXdhaXQgUmVzcG9uc2VIYW5kbGVyLmdlbmVyYXRlQXV0aGVudGljYXRpb25SZXN1bHQoY3J5cHRvVXRpbHMsIGF1dGhvcml0eSwge1xyXG4gICAgICAgICAgICAgICAgYWNjb3VudDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGlkVG9rZW46IG51bGwsXHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogY2FjaGVkQWNjZXNzVG9rZW4sXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW46IG51bGwsXHJcbiAgICAgICAgICAgICAgICBhcHBNZXRhZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgfSwgdHJ1ZSwgcmVxdWVzdCksXHJcbiAgICAgICAgICAgIGxhc3RDYWNoZU91dGNvbWUsXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYWNjZXNzIHRva2VuIGZyb20gdGhlIGNhY2hlXHJcbiAgICAgKi9cclxuICAgIHJlYWRBY2Nlc3NUb2tlbkZyb21DYWNoZShhdXRob3JpdHksIGlkLCBzY29wZVNldCwgY2FjaGVNYW5hZ2VyKSB7XHJcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5GaWx0ZXIgPSB7XHJcbiAgICAgICAgICAgIGhvbWVBY2NvdW50SWQ6IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBhdXRob3JpdHkuY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cy5Ib3N0TmFtZUFuZFBvcnQsXHJcbiAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOiBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU4sXHJcbiAgICAgICAgICAgIGNsaWVudElkOiBpZCxcclxuICAgICAgICAgICAgcmVhbG06IGF1dGhvcml0eS50ZW5hbnQsXHJcbiAgICAgICAgICAgIHRhcmdldDogU2NvcGVTZXQuY3JlYXRlU2VhcmNoU2NvcGVzKHNjb3BlU2V0LmFzQXJyYXkoKSksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbnMgPSBjYWNoZU1hbmFnZXIuZ2V0QWNjZXNzVG9rZW5zQnlGaWx0ZXIoYWNjZXNzVG9rZW5GaWx0ZXIpO1xyXG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbnMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWNjZXNzVG9rZW5zLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLm11bHRpcGxlTWF0Y2hpbmdUb2tlbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW5zWzBdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBhIG5ldHdvcmsgY2FsbCB0byByZXF1ZXN0IHRoZSB0b2tlbiBmcm9tIHRoZSBzZXJ2aWNlXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIENvbW1vbkNsaWVudENyZWRlbnRpYWxSZXF1ZXN0IHByb3ZpZGVkIGJ5IHRoZSBkZXZlbG9wZXJcclxuICAgICAqIEBwYXJhbSBhdXRob3JpdHkgLSBhdXRob3JpdHkgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGV4ZWN1dGVUb2tlblJlcXVlc3QocmVxdWVzdCwgYXV0aG9yaXR5LCByZWZyZXNoQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICBsZXQgc2VydmVyVG9rZW5SZXNwb25zZTtcclxuICAgICAgICBsZXQgcmVxVGltZXN0YW1wO1xyXG4gICAgICAgIGlmICh0aGlzLmFwcFRva2VuUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIlVzaW5nIGFwcFRva2VuUHJvdmlkZXIgZXh0ZW5zaWJpbGl0eS5cIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcFRva2VuUHJvcHZpZGVyUGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IHJlcXVlc3QuY29ycmVsYXRpb25JZCxcclxuICAgICAgICAgICAgICAgIHRlbmFudElkOiB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5hdXRob3JpdHkudGVuYW50LFxyXG4gICAgICAgICAgICAgICAgc2NvcGVzOiByZXF1ZXN0LnNjb3BlcyxcclxuICAgICAgICAgICAgICAgIGNsYWltczogcmVxdWVzdC5jbGFpbXMsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlcVRpbWVzdGFtcCA9IFRpbWVVdGlscy5ub3dTZWNvbmRzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcFRva2VuUHJvdmlkZXJSZXN1bHQgPSBhd2FpdCB0aGlzLmFwcFRva2VuUHJvdmlkZXIoYXBwVG9rZW5Qcm9wdmlkZXJQYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZSA9IHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogYXBwVG9rZW5Qcm92aWRlclJlc3VsdC5hY2Nlc3NUb2tlbixcclxuICAgICAgICAgICAgICAgIGV4cGlyZXNfaW46IGFwcFRva2VuUHJvdmlkZXJSZXN1bHQuZXhwaXJlc0luU2Vjb25kcyxcclxuICAgICAgICAgICAgICAgIHJlZnJlc2hfaW46IGFwcFRva2VuUHJvdmlkZXJSZXN1bHQucmVmcmVzaEluU2Vjb25kcyxcclxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6IEF1dGhlbnRpY2F0aW9uU2NoZW1lLkJFQVJFUixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVyc1N0cmluZyA9IHRoaXMuY3JlYXRlVG9rZW5RdWVyeVBhcmFtZXRlcnMocmVxdWVzdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gVXJsU3RyaW5nLmFwcGVuZFF1ZXJ5U3RyaW5nKGF1dGhvcml0eS50b2tlbkVuZHBvaW50LCBxdWVyeVBhcmFtZXRlcnNTdHJpbmcpO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IGF3YWl0IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0Qm9keShyZXF1ZXN0KTtcclxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0SGVhZGVycygpO1xyXG4gICAgICAgICAgICBjb25zdCB0aHVtYnByaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxyXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5OiByZXF1ZXN0LmF1dGhvcml0eSxcclxuICAgICAgICAgICAgICAgIHNjb3BlczogcmVxdWVzdC5zY29wZXMsXHJcbiAgICAgICAgICAgICAgICBjbGFpbXM6IHJlcXVlc3QuY2xhaW1zLFxyXG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb25TY2hlbWU6IHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RNZXRob2Q6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0TWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VSZXF1ZXN0VXJpOiByZXF1ZXN0LnJlc291cmNlUmVxdWVzdFVyaSxcclxuICAgICAgICAgICAgICAgIHNockNsYWltczogcmVxdWVzdC5zaHJDbGFpbXMsXHJcbiAgICAgICAgICAgICAgICBzc2hLaWQ6IHJlcXVlc3Quc3NoS2lkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiU2VuZGluZyB0b2tlbiByZXF1ZXN0IHRvIGVuZHBvaW50OiBcIiArIGF1dGhvcml0eS50b2tlbkVuZHBvaW50KTtcclxuICAgICAgICAgICAgcmVxVGltZXN0YW1wID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVQb3N0VG9Ub2tlbkVuZHBvaW50KGVuZHBvaW50LCByZXF1ZXN0Qm9keSwgaGVhZGVycywgdGh1bWJwcmludCwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgc2VydmVyVG9rZW5SZXNwb25zZSA9IHJlc3BvbnNlLmJvZHk7XHJcbiAgICAgICAgICAgIHNlcnZlclRva2VuUmVzcG9uc2Uuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSBuZXcgUmVzcG9uc2VIYW5kbGVyKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCB0aGlzLmNhY2hlTWFuYWdlciwgdGhpcy5jcnlwdG9VdGlscywgdGhpcy5sb2dnZXIsIHRoaXMuY29uZmlnLnNlcmlhbGl6YWJsZUNhY2hlLCB0aGlzLmNvbmZpZy5wZXJzaXN0ZW5jZVBsdWdpbik7XHJcbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnZhbGlkYXRlVG9rZW5SZXNwb25zZShzZXJ2ZXJUb2tlblJlc3BvbnNlLCByZWZyZXNoQWNjZXNzVG9rZW4pO1xyXG4gICAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZUhhbmRsZXIuaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZShzZXJ2ZXJUb2tlblJlc3BvbnNlLCB0aGlzLmF1dGhvcml0eSwgcmVxVGltZXN0YW1wLCByZXF1ZXN0KTtcclxuICAgICAgICByZXR1cm4gdG9rZW5SZXNwb25zZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZ2VuZXJhdGUgdGhlIHJlcXVlc3QgdG8gdGhlIHNlcnZlciBpbiB0aGUgYWNjZXB0YWJsZSBmb3JtYXRcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gQ29tbW9uQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3QgcHJvdmlkZWQgYnkgdGhlIGRldmVsb3BlclxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGVUb2tlblJlcXVlc3RCb2R5KHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudElkKHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTY29wZXMocGFyYW1ldGVycywgcmVxdWVzdC5zY29wZXMsIGZhbHNlKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRHcmFudFR5cGUocGFyYW1ldGVycywgR3JhbnRUeXBlLkNMSUVOVF9DUkVERU5USUFMU19HUkFOVCk7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkTGlicmFyeUluZm8ocGFyYW1ldGVycywgdGhpcy5jb25maWcubGlicmFyeUluZm8pO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEFwcGxpY2F0aW9uVGVsZW1ldHJ5KHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLnRlbGVtZXRyeS5hcHBsaWNhdGlvbik7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkVGhyb3R0bGluZyhwYXJhbWV0ZXJzKTtcclxuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFNlcnZlclRlbGVtZXRyeShwYXJhbWV0ZXJzLCB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gcmVxdWVzdC5jb3JyZWxhdGlvbklkIHx8XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNyeXB0b0ludGVyZmFjZS5jcmVhdGVOZXdHdWlkKCk7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ29ycmVsYXRpb25JZChwYXJhbWV0ZXJzLCBjb3JyZWxhdGlvbklkKTtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2xpZW50Q3JlZGVudGlhbHMuY2xpZW50U2VjcmV0KSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudFNlY3JldChwYXJhbWV0ZXJzLCB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVc2UgY2xpZW50QXNzZXJ0aW9uIGZyb20gcmVxdWVzdCwgZmFsbGJhY2sgdG8gY2xpZW50IGFzc2VydGlvbiBpbiBiYXNlIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICBjb25zdCBjbGllbnRBc3NlcnRpb24gPSByZXF1ZXN0LmNsaWVudEFzc2VydGlvbiB8fFxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRBc3NlcnRpb247XHJcbiAgICAgICAgaWYgKGNsaWVudEFzc2VydGlvbikge1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb24ocGFyYW1ldGVycywgYXdhaXQgZ2V0Q2xpZW50QXNzZXJ0aW9uKGNsaWVudEFzc2VydGlvbi5hc3NlcnRpb24sIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLCByZXF1ZXN0LnJlc291cmNlUmVxdWVzdFVyaSkpO1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDbGllbnRBc3NlcnRpb25UeXBlKHBhcmFtZXRlcnMsIGNsaWVudEFzc2VydGlvbi5hc3NlcnRpb25UeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFTdHJpbmdVdGlscy5pc0VtcHR5T2JqKHJlcXVlc3QuY2xhaW1zKSB8fFxyXG4gICAgICAgICAgICAodGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xhaW1zKHBhcmFtZXRlcnMsIHJlcXVlc3QuY2xhaW1zLCB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5jbGllbnRDYXBhYmlsaXRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVXJsVXRpbHMubWFwVG9RdWVyeVN0cmluZyhwYXJhbWV0ZXJzKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBDbGllbnRDcmVkZW50aWFsQ2xpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGllbnRDcmVkZW50aWFsQ2xpZW50Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBCYXNlQ2xpZW50LCBTY29wZVNldCwgQ2FjaGVPdXRjb21lLCBjcmVhdGVDbGllbnRBdXRoRXJyb3IsIENsaWVudEF1dGhFcnJvckNvZGVzLCBUaW1lVXRpbHMsIEF1dGhUb2tlbiwgUmVzcG9uc2VIYW5kbGVyLCBBdXRoZW50aWNhdGlvblNjaGVtZSwgQ3JlZGVudGlhbFR5cGUsIFVybFN0cmluZywgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIsIEdyYW50VHlwZSwgQUFEU2VydmVyUGFyYW1LZXlzLCBnZXRDbGllbnRBc3NlcnRpb24sIFVybFV0aWxzLCBDb25zdGFudHMgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBFbmNvZGluZ1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMvRW5jb2RpbmdVdGlscy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIE9uLUJlaGFsZi1PZiBjbGllbnRcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgT25CZWhhbGZPZkNsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQdWJsaWMgQVBJIHRvIGFjcXVpcmUgdG9rZW5zIHdpdGggb24gYmVoYWxmIG9mIGZsb3dcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gZGV2ZWxvcGVyIHByb3ZpZGVkIENvbW1vbk9uQmVoYWxmT2ZSZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGFjcXVpcmVUb2tlbihyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5zY29wZVNldCA9IG5ldyBTY29wZVNldChyZXF1ZXN0LnNjb3BlcyB8fCBbXSk7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIHVzZXJfYXNzZXJ0aW9uX2hhc2ggZm9yIE9CT0Fzc2VydGlvblxyXG4gICAgICAgIHRoaXMudXNlckFzc2VydGlvbkhhc2ggPSBhd2FpdCB0aGlzLmNyeXB0b1V0aWxzLmhhc2hTdHJpbmcocmVxdWVzdC5vYm9Bc3NlcnRpb24pO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0LnNraXBDYWNoZSB8fCByZXF1ZXN0LmNsYWltcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlVG9rZW5SZXF1ZXN0KHJlcXVlc3QsIHRoaXMuYXV0aG9yaXR5LCB0aGlzLnVzZXJBc3NlcnRpb25IYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQocmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIEFueSBmYWlsdXJlIGZhbGxzIGJhY2sgdG8gaW50ZXJhY3RpdmUgcmVxdWVzdCwgb25jZSB3ZSBpbXBsZW1lbnQgZGlzdHJpYnV0ZWQgY2FjaGUsIHdlIHBsYW4gdG8gaGFuZGxlIGBjcmVhdGVSZWZyZXNoUmVxdWlyZWRFcnJvcmAgdG8gcmVmcmVzaCB1c2luZyB0aGUgUlRcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVRva2VuUmVxdWVzdChyZXF1ZXN0LCB0aGlzLmF1dGhvcml0eSwgdGhpcy51c2VyQXNzZXJ0aW9uSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBsb29rIHVwIGNhY2hlIGZvciB0b2tlbnNcclxuICAgICAqIEZpbmQgaWR0b2tlbiBpbiB0aGUgY2FjaGVcclxuICAgICAqIEZpbmQgYWNjZXNzVG9rZW4gYmFzZWQgb24gdXNlciBhc3NlcnRpb24gYW5kIGFjY291bnQgaW5mbyBpbiB0aGUgY2FjaGVcclxuICAgICAqIFBsZWFzZSBub3RlIHdlIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBPQk8gdG9rZW5zIHJlZnJlc2hlZCB3aXRoIGxvbmcgbGl2ZWQgUlQuIFVzZXIgd2lsbCBoYXZlIHRvIHNlbmQgYSBuZXcgYXNzZXJ0aW9uIGlmIHRoZSBjdXJyZW50IGFjY2VzcyB0b2tlbiBleHBpcmVzXHJcbiAgICAgKiBUaGlzIGlzIHRvIHByZXZlbnQgc2VjdXJpdHkgaXNzdWVzIHdoZW4gdGhlIGFzc2VydGlvbiBjaGFuZ2VzIG92ZXIgdGltZSwgaG93ZXZlciwgbG9uZ2xpdmVkIFJUIGhlbHBzIHJldGFpbmluZyB0aGUgc2Vzc2lvblxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uT25CZWhhbGZPZlJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQocmVxdWVzdCkge1xyXG4gICAgICAgIC8vIGxvb2sgaW4gdGhlIGNhY2hlIGZvciB0aGUgYWNjZXNzX3Rva2VuIHdoaWNoIG1hdGNoZXMgdGhlIGluY29taW5nX2Fzc2VydGlvblxyXG4gICAgICAgIGNvbnN0IGNhY2hlZEFjY2Vzc1Rva2VuID0gdGhpcy5yZWFkQWNjZXNzVG9rZW5Gcm9tQ2FjaGVGb3JPQk8odGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsIHJlcXVlc3QpO1xyXG4gICAgICAgIGlmICghY2FjaGVkQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgLy8gTXVzdCByZWZyZXNoIGR1ZSB0byBub24tZXhpc3RlbnQgYWNjZXNzX3Rva2VuLlxyXG4gICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShDYWNoZU91dGNvbWUuTk9fQ0FDSEVEX0FDQ0VTU19UT0tFTik7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJTaWxlbnRGbG93Q2xpZW50OmFjcXVpcmVDYWNoZWRUb2tlbiAtIE5vIGFjY2VzcyB0b2tlbiBmb3VuZCBpbiBjYWNoZSBmb3IgdGhlIGdpdmVuIHByb3BlcnRpZXMuXCIpO1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5SZWZyZXNoUmVxdWlyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChUaW1lVXRpbHMuaXNUb2tlbkV4cGlyZWQoY2FjaGVkQWNjZXNzVG9rZW4uZXhwaXJlc09uLCB0aGlzLmNvbmZpZy5zeXN0ZW1PcHRpb25zLnRva2VuUmVuZXdhbE9mZnNldFNlY29uZHMpKSB7XHJcbiAgICAgICAgICAgIC8vIEFjY2VzcyB0b2tlbiBleHBpcmVkLCB3aWxsIG5lZWQgdG8gcmVuZXdlZFxyXG4gICAgICAgICAgICB0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXI/LnNldENhY2hlT3V0Y29tZShDYWNoZU91dGNvbWUuQ0FDSEVEX0FDQ0VTU19UT0tFTl9FWFBJUkVEKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgT25iZWhhbGZvZkZsb3c6Z2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQgLSBDYWNoZWQgYWNjZXNzIHRva2VuIGlzIGV4cGlyZWQgb3Igd2lsbCBleHBpcmUgd2l0aGluICR7dGhpcy5jb25maWcuc3lzdGVtT3B0aW9ucy50b2tlblJlbmV3YWxPZmZzZXRTZWNvbmRzfSBzZWNvbmRzLmApO1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMudG9rZW5SZWZyZXNoUmVxdWlyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmZXRjaCB0aGUgaWRUb2tlbiBmcm9tIGNhY2hlXHJcbiAgICAgICAgY29uc3QgY2FjaGVkSWRUb2tlbiA9IHRoaXMucmVhZElkVG9rZW5Gcm9tQ2FjaGVGb3JPQk8oY2FjaGVkQWNjZXNzVG9rZW4uaG9tZUFjY291bnRJZCk7XHJcbiAgICAgICAgbGV0IGlkVG9rZW5DbGFpbXM7XHJcbiAgICAgICAgbGV0IGNhY2hlZEFjY291bnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChjYWNoZWRJZFRva2VuKSB7XHJcbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMgPSBBdXRoVG9rZW4uZXh0cmFjdFRva2VuQ2xhaW1zKGNhY2hlZElkVG9rZW4uc2VjcmV0LCBFbmNvZGluZ1V0aWxzLmJhc2U2NERlY29kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQWNjb3VudElkID0gaWRUb2tlbkNsYWltcy5vaWQgfHwgaWRUb2tlbkNsYWltcy5zdWI7XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgaG9tZUFjY291bnRJZDogY2FjaGVkSWRUb2tlbi5ob21lQWNjb3VudElkLFxyXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGNhY2hlZElkVG9rZW4uZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICAgICAgICB0ZW5hbnRJZDogY2FjaGVkSWRUb2tlbi5yZWFsbSxcclxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBDb25zdGFudHMuRU1QVFlfU1RSSU5HLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxBY2NvdW50SWQ6IGxvY2FsQWNjb3VudElkIHx8IENvbnN0YW50cy5FTVBUWV9TVFJJTkcsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhY2hlZEFjY291bnQgPSB0aGlzLmNhY2hlTWFuYWdlci5yZWFkQWNjb3VudEZyb21DYWNoZShhY2NvdW50SW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluY3JlbWVudCB0ZWxlbWV0cnkgY2FjaGUgaGl0IGNvdW50ZXJcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyLmluY3JlbWVudENhY2hlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVzcG9uc2VIYW5kbGVyLmdlbmVyYXRlQXV0aGVudGljYXRpb25SZXN1bHQodGhpcy5jcnlwdG9VdGlscywgdGhpcy5hdXRob3JpdHksIHtcclxuICAgICAgICAgICAgYWNjb3VudDogY2FjaGVkQWNjb3VudCxcclxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IGNhY2hlZEFjY2Vzc1Rva2VuLFxyXG4gICAgICAgICAgICBpZFRva2VuOiBjYWNoZWRJZFRva2VuLFxyXG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IG51bGwsXHJcbiAgICAgICAgICAgIGFwcE1ldGFkYXRhOiBudWxsLFxyXG4gICAgICAgIH0sIHRydWUsIHJlcXVlc3QsIGlkVG9rZW5DbGFpbXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiByZWFkIGlkdG9rZW4gZnJvbSBjYWNoZSwgdGhpcyBpcyBhIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGZvciBPQk8gYXMgdGhlIHJlcXVpcmVtZW50cyBkaWZmZXIgZnJvbSBhIGdlbmVyaWMgbG9va3VwIGluIHRoZSBjYWNoZU1hbmFnZXJcclxuICAgICAqIENlcnRhaW4gdXNlIGNhc2VzIG9mIE9CTyBmbG93IGRvIG5vdCBleHBlY3QgYW4gaWRUb2tlbiBpbiB0aGUgY2FjaGUvb3IgZnJvbSB0aGUgc2VydmljZVxyXG4gICAgICogQHBhcmFtIGF0SG9tZUFjY291bnRJZCAtIGFjY291bnQgaWRcclxuICAgICAqL1xyXG4gICAgcmVhZElkVG9rZW5Gcm9tQ2FjaGVGb3JPQk8oYXRIb21lQWNjb3VudElkKSB7XHJcbiAgICAgICAgY29uc3QgaWRUb2tlbkZpbHRlciA9IHtcclxuICAgICAgICAgICAgaG9tZUFjY291bnRJZDogYXRIb21lQWNjb3VudElkLFxyXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogdGhpcy5hdXRob3JpdHkuY2Fub25pY2FsQXV0aG9yaXR5VXJsQ29tcG9uZW50cy5Ib3N0TmFtZUFuZFBvcnQsXHJcbiAgICAgICAgICAgIGNyZWRlbnRpYWxUeXBlOiBDcmVkZW50aWFsVHlwZS5JRF9UT0tFTixcclxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkLFxyXG4gICAgICAgICAgICByZWFsbTogdGhpcy5hdXRob3JpdHkudGVuYW50LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgaWRUb2tlbk1hcCA9IHRoaXMuY2FjaGVNYW5hZ2VyLmdldElkVG9rZW5zQnlGaWx0ZXIoaWRUb2tlbkZpbHRlcik7XHJcbiAgICAgICAgLy8gV2hlbiBhY3F1aXJpbmcgYSB0b2tlbiBvbiBiZWhhbGYgb2YgYW4gYXBwbGljYXRpb24sIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBpZCB0b2tlbiBpbiB0aGUgY2FjaGVcclxuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhpZFRva2VuTWFwKS5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpZFRva2VuTWFwKVswXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbiBiYXNlZCBvbiBpbmNvbWluZyBhc3NlcnRpb25cclxuICAgICAqIEBwYXJhbSBjbGllbnRJZCAtIGNsaWVudCBpZFxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBkZXZlbG9wZXIgcHJvdmlkZWQgQ29tbW9uT25CZWhhbGZPZlJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgcmVhZEFjY2Vzc1Rva2VuRnJvbUNhY2hlRm9yT0JPKGNsaWVudElkLCByZXF1ZXN0KSB7XHJcbiAgICAgICAgY29uc3QgYXV0aFNjaGVtZSA9IHJlcXVlc3QuYXV0aGVudGljYXRpb25TY2hlbWUgfHwgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRGlzdGluZ3Vpc2ggYmV0d2VlbiBCZWFyZXIgYW5kIFBvUC9TU0ggdG9rZW4gY2FjaGUgdHlwZXNcclxuICAgICAgICAgKiBDYXN0IHRvIGxvd2VyY2FzZSB0byBoYW5kbGUgXCJiZWFyZXJcIiBmcm9tIEFERlNcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBjcmVkZW50aWFsVHlwZSA9IGF1dGhTY2hlbWUgJiZcclxuICAgICAgICAgICAgYXV0aFNjaGVtZS50b0xvd2VyQ2FzZSgpICE9PVxyXG4gICAgICAgICAgICAgICAgQXV0aGVudGljYXRpb25TY2hlbWUuQkVBUkVSLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgPyBDcmVkZW50aWFsVHlwZS5BQ0NFU1NfVE9LRU5fV0lUSF9BVVRIX1NDSEVNRVxyXG4gICAgICAgICAgICA6IENyZWRlbnRpYWxUeXBlLkFDQ0VTU19UT0tFTjtcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbkZpbHRlciA9IHtcclxuICAgICAgICAgICAgY3JlZGVudGlhbFR5cGU6IGNyZWRlbnRpYWxUeXBlLFxyXG4gICAgICAgICAgICBjbGllbnRJZCxcclxuICAgICAgICAgICAgdGFyZ2V0OiBTY29wZVNldC5jcmVhdGVTZWFyY2hTY29wZXModGhpcy5zY29wZVNldC5hc0FycmF5KCkpLFxyXG4gICAgICAgICAgICB0b2tlblR5cGU6IGF1dGhTY2hlbWUsXHJcbiAgICAgICAgICAgIGtleUlkOiByZXF1ZXN0LnNzaEtpZCxcclxuICAgICAgICAgICAgcmVxdWVzdGVkQ2xhaW1zSGFzaDogcmVxdWVzdC5yZXF1ZXN0ZWRDbGFpbXNIYXNoLFxyXG4gICAgICAgICAgICB1c2VyQXNzZXJ0aW9uSGFzaDogdGhpcy51c2VyQXNzZXJ0aW9uSGFzaCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VucyA9IHRoaXMuY2FjaGVNYW5hZ2VyLmdldEFjY2Vzc1Rva2Vuc0J5RmlsdGVyKGFjY2Vzc1Rva2VuRmlsdGVyKTtcclxuICAgICAgICBjb25zdCBudW1BY2Nlc3NUb2tlbnMgPSBhY2Nlc3NUb2tlbnMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChudW1BY2Nlc3NUb2tlbnMgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChudW1BY2Nlc3NUb2tlbnMgPiAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5tdWx0aXBsZU1hdGNoaW5nVG9rZW5zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2Vuc1swXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFrZSBhIG5ldHdvcmsgY2FsbCB0byB0aGUgc2VydmVyIHJlcXVlc3RpbmcgY3JlZGVudGlhbHNcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gZGV2ZWxvcGVyIHByb3ZpZGVkIENvbW1vbk9uQmVoYWxmT2ZSZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gYXV0aG9yaXR5IC0gYXV0aG9yaXR5IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBleGVjdXRlVG9rZW5SZXF1ZXN0KHJlcXVlc3QsIGF1dGhvcml0eSwgdXNlckFzc2VydGlvbkhhc2gpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnNTdHJpbmcgPSB0aGlzLmNyZWF0ZVRva2VuUXVlcnlQYXJhbWV0ZXJzKHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gVXJsU3RyaW5nLmFwcGVuZFF1ZXJ5U3RyaW5nKGF1dGhvcml0eS50b2tlbkVuZHBvaW50LCBxdWVyeVBhcmFtZXRlcnNTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gYXdhaXQgdGhpcy5jcmVhdGVUb2tlblJlcXVlc3RCb2R5KHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmNyZWF0ZVRva2VuUmVxdWVzdEhlYWRlcnMoKTtcclxuICAgICAgICBjb25zdCB0aHVtYnByaW50ID0ge1xyXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsXHJcbiAgICAgICAgICAgIGF1dGhvcml0eTogcmVxdWVzdC5hdXRob3JpdHksXHJcbiAgICAgICAgICAgIHNjb3BlczogcmVxdWVzdC5zY29wZXMsXHJcbiAgICAgICAgICAgIGNsYWltczogcmVxdWVzdC5jbGFpbXMsXHJcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uU2NoZW1lOiByZXF1ZXN0LmF1dGhlbnRpY2F0aW9uU2NoZW1lLFxyXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RNZXRob2Q6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0TWV0aG9kLFxyXG4gICAgICAgICAgICByZXNvdXJjZVJlcXVlc3RVcmk6IHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpLFxyXG4gICAgICAgICAgICBzaHJDbGFpbXM6IHJlcXVlc3Quc2hyQ2xhaW1zLFxyXG4gICAgICAgICAgICBzc2hLaWQ6IHJlcXVlc3Quc3NoS2lkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVxVGltZXN0YW1wID0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVBvc3RUb1Rva2VuRW5kcG9pbnQoZW5kcG9pbnQsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB0aHVtYnByaW50LCByZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IG5ldyBSZXNwb25zZUhhbmRsZXIodGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsIHRoaXMuY2FjaGVNYW5hZ2VyLCB0aGlzLmNyeXB0b1V0aWxzLCB0aGlzLmxvZ2dlciwgdGhpcy5jb25maWcuc2VyaWFsaXphYmxlQ2FjaGUsIHRoaXMuY29uZmlnLnBlcnNpc3RlbmNlUGx1Z2luKTtcclxuICAgICAgICByZXNwb25zZUhhbmRsZXIudmFsaWRhdGVUb2tlblJlc3BvbnNlKHJlc3BvbnNlLmJvZHkpO1xyXG4gICAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZUhhbmRsZXIuaGFuZGxlU2VydmVyVG9rZW5SZXNwb25zZShyZXNwb25zZS5ib2R5LCB0aGlzLmF1dGhvcml0eSwgcmVxVGltZXN0YW1wLCByZXF1ZXN0LCB1bmRlZmluZWQsIHVzZXJBc3NlcnRpb25IYXNoKTtcclxuICAgICAgICByZXR1cm4gdG9rZW5SZXNwb25zZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogZ2VuZXJhdGUgYSBzZXJ2ZXIgcmVxdWVzdCBpbiBhY2NlcGFibGUgZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIGRldmVsb3BlciBwcm92aWRlZCBDb21tb25PbkJlaGFsZk9mUmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGVUb2tlblJlcXVlc3RCb2R5KHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudElkKHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudElkKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRTY29wZXMocGFyYW1ldGVycywgcmVxdWVzdC5zY29wZXMpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZEdyYW50VHlwZShwYXJhbWV0ZXJzLCBHcmFudFR5cGUuSldUX0JFQVJFUik7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50SW5mbyhwYXJhbWV0ZXJzKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRMaWJyYXJ5SW5mbyhwYXJhbWV0ZXJzLCB0aGlzLmNvbmZpZy5saWJyYXJ5SW5mbyk7XHJcbiAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQXBwbGljYXRpb25UZWxlbWV0cnkocGFyYW1ldGVycywgdGhpcy5jb25maWcudGVsZW1ldHJ5LmFwcGxpY2F0aW9uKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRUaHJvdHRsaW5nKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlcnZlclRlbGVtZXRyeU1hbmFnZXIpIHtcclxuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkU2VydmVyVGVsZW1ldHJ5KHBhcmFtZXRlcnMsIHRoaXMuc2VydmVyVGVsZW1ldHJ5TWFuYWdlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSByZXF1ZXN0LmNvcnJlbGF0aW9uSWQgfHxcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuY3J5cHRvSW50ZXJmYWNlLmNyZWF0ZU5ld0d1aWQoKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRDb3JyZWxhdGlvbklkKHBhcmFtZXRlcnMsIGNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZFJlcXVlc3RUb2tlblVzZShwYXJhbWV0ZXJzLCBBQURTZXJ2ZXJQYXJhbUtleXMuT05fQkVIQUxGX09GKTtcclxuICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRPYm9Bc3NlcnRpb24ocGFyYW1ldGVycywgcmVxdWVzdC5vYm9Bc3NlcnRpb24pO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jbGllbnRDcmVkZW50aWFscy5jbGllbnRTZWNyZXQpIHtcclxuICAgICAgICAgICAgUmVxdWVzdFBhcmFtZXRlckJ1aWxkZXIuYWRkQ2xpZW50U2VjcmV0KHBhcmFtZXRlcnMsIHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudFNlY3JldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNsaWVudEFzc2VydGlvbiA9IHRoaXMuY29uZmlnLmNsaWVudENyZWRlbnRpYWxzLmNsaWVudEFzc2VydGlvbjtcclxuICAgICAgICBpZiAoY2xpZW50QXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEFzc2VydGlvbihwYXJhbWV0ZXJzLCBhd2FpdCBnZXRDbGllbnRBc3NlcnRpb24oY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvbiwgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50SWQsIHJlcXVlc3QucmVzb3VyY2VSZXF1ZXN0VXJpKSk7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsaWVudEFzc2VydGlvblR5cGUocGFyYW1ldGVycywgY2xpZW50QXNzZXJ0aW9uLmFzc2VydGlvblR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVxdWVzdC5jbGFpbXMgfHxcclxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLmNsaWVudENhcGFiaWxpdGllcyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgICAgIFJlcXVlc3RQYXJhbWV0ZXJCdWlsZGVyLmFkZENsYWltcyhwYXJhbWV0ZXJzLCByZXF1ZXN0LmNsYWltcywgdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVybFV0aWxzLm1hcFRvUXVlcnlTdHJpbmcocGFyYW1ldGVycyk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgT25CZWhhbGZPZkNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T25CZWhhbGZPZkNsaWVudC5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgQ2xpZW50QXBwbGljYXRpb24gfSBmcm9tICcuL0NsaWVudEFwcGxpY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBDbGllbnRBc3NlcnRpb24gfSBmcm9tICcuL0NsaWVudEFzc2VydGlvbi5tanMnO1xuaW1wb3J0IHsgQ29uc3RhbnRzLCBNU0FMX0ZPUkNFX1JFR0lPTiwgUkVHSU9OX0VOVklST05NRU5UX1ZBUklBQkxFLCBBcGlJZCB9IGZyb20gJy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50QXV0aEVycm9yLCBDbGllbnRBdXRoRXJyb3JDb2RlcywgZ2V0Q2xpZW50QXNzZXJ0aW9uLCBPSURDX0RFRkFVTFRfU0NPUEVTLCBVcmxTdHJpbmcsIEFBREF1dGhvcml0eUNvbnN0YW50cywgQXV0aEVycm9yIH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuaW1wb3J0IHsgQ2xpZW50Q3JlZGVudGlhbENsaWVudCB9IGZyb20gJy4vQ2xpZW50Q3JlZGVudGlhbENsaWVudC5tanMnO1xuaW1wb3J0IHsgT25CZWhhbGZPZkNsaWVudCB9IGZyb20gJy4vT25CZWhhbGZPZkNsaWVudC5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQUFEQXV0aG9yaXR5Q29uc3RhbnRzXHJcbi8qKlxyXG4gKiAgVGhpcyBjbGFzcyBpcyB0byBiZSB1c2VkIHRvIGFjcXVpcmUgdG9rZW5zIGZvciBjb25maWRlbnRpYWwgY2xpZW50IGFwcGxpY2F0aW9ucyAod2ViQXBwLCB3ZWJBUEkpLiBDb25maWRlbnRpYWwgY2xpZW50IGFwcGxpY2F0aW9uc1xyXG4gKiAgd2lsbCBjb25maWd1cmUgYXBwbGljYXRpb24gc2VjcmV0cywgY2xpZW50IGNlcnRpZmljYXRlcy9hc3NlcnRpb25zIGFzIGFwcGxpY2FibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQ29uZmlkZW50aWFsQ2xpZW50QXBwbGljYXRpb24gZXh0ZW5kcyBDbGllbnRBcHBsaWNhdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgQ29uZmlkZW50aWFsQ2xpZW50QXBwbGljYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBSZXF1aXJlZCBhdHRyaWJ1dGVzIGluIHRoZSBDb25maWd1cmF0aW9uIG9iamVjdCBhcmU6XHJcbiAgICAgKiAtIGNsaWVudElEOiB0aGUgYXBwbGljYXRpb24gSUQgb2YgeW91ciBhcHBsaWNhdGlvbi4gWW91IGNhbiBvYnRhaW4gb25lIGJ5IHJlZ2lzdGVyaW5nIHlvdXIgYXBwbGljYXRpb24gd2l0aCBvdXIgYXBwbGljYXRpb24gcmVnaXN0cmF0aW9uIHBvcnRhbFxyXG4gICAgICogLSBhdXRob3JpdHk6IHRoZSBhdXRob3JpdHkgVVJMIGZvciB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAgICogLSBjbGllbnQgY3JlZGVudGlhbDogTXVzdCBzZXQgZWl0aGVyIGNsaWVudCBzZWNyZXQsIGNlcnRpZmljYXRlLCBvciBhc3NlcnRpb24gZm9yIGNvbmZpZGVudGlhbCBjbGllbnRzLiBZb3UgY2FuIG9idGFpbiBhIGNsaWVudCBzZWNyZXQgZnJvbSB0aGUgYXBwbGljYXRpb24gcmVnaXN0cmF0aW9uIHBvcnRhbC5cclxuICAgICAqXHJcbiAgICAgKiBJbiBBenVyZSBBRCwgYXV0aG9yaXR5IGlzIGEgVVJMIGluZGljYXRpbmcgb2YgdGhlIGZvcm0gaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL1xce0VudGVyX3RoZV9UZW5hbnRfSW5mb19IZXJlXFx9LlxyXG4gICAgICogSWYgeW91ciBhcHBsaWNhdGlvbiBzdXBwb3J0cyBBY2NvdW50cyBpbiBvbmUgb3JnYW5pemF0aW9uYWwgZGlyZWN0b3J5LCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIHRoZSBUZW5hbnQgSWQgb3IgVGVuYW50IG5hbWUgKGZvciBleGFtcGxlLCBjb250b3NvLm1pY3Jvc29mdC5jb20pLlxyXG4gICAgICogSWYgeW91ciBhcHBsaWNhdGlvbiBzdXBwb3J0cyBBY2NvdW50cyBpbiBhbnkgb3JnYW5pemF0aW9uYWwgZGlyZWN0b3J5LCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIG9yZ2FuaXphdGlvbnMuXHJcbiAgICAgKiBJZiB5b3VyIGFwcGxpY2F0aW9uIHN1cHBvcnRzIEFjY291bnRzIGluIGFueSBvcmdhbml6YXRpb25hbCBkaXJlY3RvcnkgYW5kIHBlcnNvbmFsIE1pY3Jvc29mdCBhY2NvdW50cywgcmVwbGFjZSBcIkVudGVyX3RoZV9UZW5hbnRfSW5mb19IZXJlXCIgdmFsdWUgd2l0aCBjb21tb24uXHJcbiAgICAgKiBUbyByZXN0cmljdCBzdXBwb3J0IHRvIFBlcnNvbmFsIE1pY3Jvc29mdCBhY2NvdW50cyBvbmx5LCByZXBsYWNlIFwiRW50ZXJfdGhlX1RlbmFudF9JbmZvX0hlcmVcIiB2YWx1ZSB3aXRoIGNvbnN1bWVycy5cclxuICAgICAqXHJcbiAgICAgKiBJbiBBenVyZSBCMkMsIGF1dGhvcml0eSBpcyBvZiB0aGUgZm9ybSBodHRwczovL1xce2luc3RhbmNlXFx9L3RmcC9cXHt0ZW5hbnRcXH0vXFx7cG9saWN5TmFtZVxcfS9cclxuICAgICAqIEZ1bGwgQjJDIGZ1bmN0aW9uYWxpdHkgd2lsbCBiZSBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5IGluIGZ1dHVyZSB2ZXJzaW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gQ29uZmlndXJhdGlvbiAtIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgTVNBTCBDb25maWRlbnRpYWxDbGllbnRBcHBsaWNhdGlvbiBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgY29uc3QgY2xpZW50U2VjcmV0Tm90RW1wdHkgPSAhIXRoaXMuY29uZmlnLmF1dGguY2xpZW50U2VjcmV0O1xyXG4gICAgICAgIGNvbnN0IGNsaWVudEFzc2VydGlvbk5vdEVtcHR5ID0gISF0aGlzLmNvbmZpZy5hdXRoLmNsaWVudEFzc2VydGlvbjtcclxuICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZU5vdEVtcHR5ID0gKCEhdGhpcy5jb25maWcuYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZT8udGh1bWJwcmludCB8fFxyXG4gICAgICAgICAgICAhIXRoaXMuY29uZmlnLmF1dGguY2xpZW50Q2VydGlmaWNhdGU/LnRodW1icHJpbnRTaGEyNTYpICYmXHJcbiAgICAgICAgICAgICEhdGhpcy5jb25maWcuYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZT8ucHJpdmF0ZUtleTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIElmIGFwcCBkZXZlbG9wZXIgY29uZmlndXJlcyB0aGlzIGNhbGxiYWNrLCB0aGV5IGRvbid0IG5lZWQgYSBjcmVkZW50aWFsXHJcbiAgICAgICAgICogaS5lLiBBenVyZVNESyBjYW4gZ2V0IHRva2VuIGZyb20gTWFuYWdlZCBJZGVudGl0eSB3aXRob3V0IGEgY2VydCAvIHNlY3JldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLmFwcFRva2VuUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayB0aGF0IGF0IG1vc3Qgb25lIGNyZWRlbnRpYWwgaXMgc2V0IG9uIHRoZSBhcHBsaWNhdGlvblxyXG4gICAgICAgIGlmICgoY2xpZW50U2VjcmV0Tm90RW1wdHkgJiYgY2xpZW50QXNzZXJ0aW9uTm90RW1wdHkpIHx8XHJcbiAgICAgICAgICAgIChjbGllbnRBc3NlcnRpb25Ob3RFbXB0eSAmJiBjZXJ0aWZpY2F0ZU5vdEVtcHR5KSB8fFxyXG4gICAgICAgICAgICAoY2xpZW50U2VjcmV0Tm90RW1wdHkgJiYgY2VydGlmaWNhdGVOb3RFbXB0eSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50QXV0aEVycm9yKENsaWVudEF1dGhFcnJvckNvZGVzLmludmFsaWRDbGllbnRDcmVkZW50aWFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGguY2xpZW50U2VjcmV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50U2VjcmV0ID0gdGhpcy5jb25maWcuYXV0aC5jbGllbnRTZWNyZXQ7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGguY2xpZW50QXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGV2ZWxvcGVyUHJvdmlkZWRDbGllbnRBc3NlcnRpb24gPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuYXV0aC5jbGllbnRBc3NlcnRpb247XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjZXJ0aWZpY2F0ZU5vdEVtcHR5KSB7XHJcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5pbnZhbGlkQ2xpZW50Q3JlZGVudGlhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudEFzc2VydGlvbiA9ICEhdGhpcy5jb25maWcuYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZVxyXG4gICAgICAgICAgICAgICAgLnRodW1icHJpbnRTaGEyNTZcclxuICAgICAgICAgICAgICAgID8gQ2xpZW50QXNzZXJ0aW9uLmZyb21DZXJ0aWZpY2F0ZVdpdGhTaGEyNTZUaHVtYnByaW50KHRoaXMuY29uZmlnLmF1dGguY2xpZW50Q2VydGlmaWNhdGUudGh1bWJwcmludFNoYTI1NiwgdGhpcy5jb25maWcuYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZS5wcml2YXRlS2V5LCB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlLng1YylcclxuICAgICAgICAgICAgICAgIDogQ2xpZW50QXNzZXJ0aW9uLmZyb21DZXJ0aWZpY2F0ZShcclxuICAgICAgICAgICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgYSBzdHJpbmcsIGR1ZSB0byBwcmlvciBlcnJvciBjaGVja2luZyBpbiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRoLmNsaWVudENlcnRpZmljYXRlLnRodW1icHJpbnQsIHRoaXMuY29uZmlnLmF1dGguY2xpZW50Q2VydGlmaWNhdGUucHJpdmF0ZUtleSwgdGhpcy5jb25maWcuYXV0aC5jbGllbnRDZXJ0aWZpY2F0ZS54NWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFwcFRva2VuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXh0ZW5zaWJpbGl0eSBwb2ludCBvbmx5IHdvcmtzIGZvciB0aGUgY2xpZW50X2NyZWRlbnRpYWwgZmxvdywgaS5lLiBhY3F1aXJlVG9rZW5CeUNsaWVudENyZWRlbnRpYWwgYW5kXHJcbiAgICAgKiBpcyBtZWFudCBmb3IgQXp1cmUgU0RLIHRvIGVuaGFuY2UgTWFuYWdlZCBJZGVudGl0eSBzdXBwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBJQXBwVG9rZW5Qcm92aWRlciAgLSBFeHRlbnNpYmlsaXR5IGludGVyZmFjZSwgd2hpY2ggYWxsb3dzIHRoZSBhcHAgZGV2ZWxvcGVyIHRvIHJldHVybiBhIHRva2VuIGZyb20gYSBjdXN0b20gc291cmNlLlxyXG4gICAgICovXHJcbiAgICBTZXRBcHBUb2tlblByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5hcHBUb2tlblByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjcXVpcmVzIHRva2VucyBmcm9tIHRoZSBhdXRob3JpdHkgZm9yIHRoZSBhcHBsaWNhdGlvbiAobm90IGZvciBhbiBlbmQgdXNlcikuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGFjcXVpcmVUb2tlbkJ5Q2xpZW50Q3JlZGVudGlhbChyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImFjcXVpcmVUb2tlbkJ5Q2xpZW50Q3JlZGVudGlhbCBjYWxsZWRcIiwgcmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGNsaWVudCBhc3NlcnRpb24gcHJlc2VudCBpbiB0aGUgcmVxdWVzdCwgaXQgb3ZlcnJpZGVzIHRoZSBvbmUgcHJlc2VudCBpbiB0aGUgY2xpZW50IGNvbmZpZ3VyYXRpb25cclxuICAgICAgICBsZXQgY2xpZW50QXNzZXJ0aW9uO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0LmNsaWVudEFzc2VydGlvbikge1xyXG4gICAgICAgICAgICBjbGllbnRBc3NlcnRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnRpb246IGF3YWl0IGdldENsaWVudEFzc2VydGlvbihyZXF1ZXN0LmNsaWVudEFzc2VydGlvbiwgdGhpcy5jb25maWcuYXV0aC5jbGllbnRJZFxyXG4gICAgICAgICAgICAgICAgLy8gdG9rZW5FbmRwb2ludCB3aWxsIGJlIHVuZGVmaW5lZC4gcmVzb3VyY2VSZXF1ZXN0VXJpIGlzIG9taXR0ZWQgaW4gQ2xpZW50Q3JlZGVudGlhbFJlcXVlc3RcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBhc3NlcnRpb25UeXBlOiBDb25zdGFudHMuSldUX0JFQVJFUl9BU1NFUlRJT05fVFlQRSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmFzZVJlcXVlc3QgPSBhd2FpdCB0aGlzLmluaXRpYWxpemVCYXNlUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgICAgICAvLyB2YWxpZCBiYXNlIHJlcXVlc3Qgc2hvdWxkIG5vdCBjb250YWluIG9pZGMgc2NvcGVzIGluIHRoaXMgZ3JhbnQgdHlwZVxyXG4gICAgICAgIGNvbnN0IHZhbGlkQmFzZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIC4uLmJhc2VSZXF1ZXN0LFxyXG4gICAgICAgICAgICBzY29wZXM6IGJhc2VSZXF1ZXN0LnNjb3Blcy5maWx0ZXIoKHNjb3BlKSA9PiAhT0lEQ19ERUZBVUxUX1NDT1BFUy5pbmNsdWRlcyhzY29wZSkpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxyXG4gICAgICAgICAgICAuLi52YWxpZEJhc2VSZXF1ZXN0LFxyXG4gICAgICAgICAgICBjbGllbnRBc3NlcnRpb24sXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIHZhbGlkIHJlcXVlc3Qgc2hvdWxkIG5vdCBoYXZlIFwiY29tbW9uXCIgb3IgXCJvcmdhbml6YXRpb25zXCIgaW4gbGlldSBvZiB0aGUgdGVuYW50X2lkIGluIHRoZSBhdXRob3JpdHkgaW4gdGhlIGF1dGggY29uZmlndXJhdGlvblxyXG4gICAgICAgICAqIGV4YW1wbGUgYXV0aG9yaXR5OiBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9UZW5hbnRJZFwiLFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGF1dGhvcml0eSA9IG5ldyBVcmxTdHJpbmcodmFsaWRSZXF1ZXN0LmF1dGhvcml0eSk7XHJcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhdXRob3JpdHkuZ2V0VXJsQ29tcG9uZW50cygpLlBhdGhTZWdtZW50c1swXTtcclxuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhBQURBdXRob3JpdHlDb25zdGFudHMpLmluY2x1ZGVzKHRlbmFudElkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubWlzc2luZ1RlbmFudElkRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIGlmIHRoaXMgZW52IHZhcmlhYmxlIGlzIHNldCwgYW5kIHRoZSBkZXZlbG9wZXIgcHJvdmlkZWQgcmVnaW9uIGlzbid0IGRlZmluZWQgYW5kIGlzbid0IFwiRGlzYWJsZU1zYWxGb3JjZVJlZ2lvblwiLFxyXG4gICAgICAgICAqIE1TQUwgc2hhbGwgb3B0LWluIHRvIEVTVFMtUiB3aXRoIHRoZSB2YWx1ZSBvZiB0aGlzIHZhcmlhYmxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgRU5WX01TQUxfRk9SQ0VfUkVHSU9OID0gcHJvY2Vzcy5lbnZbTVNBTF9GT1JDRV9SRUdJT05dO1xyXG4gICAgICAgIGxldCByZWdpb247XHJcbiAgICAgICAgaWYgKHZhbGlkUmVxdWVzdC5henVyZVJlZ2lvbiAhPT0gXCJEaXNhYmxlTXNhbEZvcmNlUmVnaW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZFJlcXVlc3QuYXp1cmVSZWdpb24gJiYgRU5WX01TQUxfRk9SQ0VfUkVHSU9OKSB7XHJcbiAgICAgICAgICAgICAgICByZWdpb24gPSBFTlZfTVNBTF9GT1JDRV9SRUdJT047XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWdpb24gPSB2YWxpZFJlcXVlc3QuYXp1cmVSZWdpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXp1cmVSZWdpb25Db25maWd1cmF0aW9uID0ge1xyXG4gICAgICAgICAgICBhenVyZVJlZ2lvbjogcmVnaW9uLFxyXG4gICAgICAgICAgICBlbnZpcm9ubWVudFJlZ2lvbjogcHJvY2Vzcy5lbnZbUkVHSU9OX0VOVklST05NRU5UX1ZBUklBQkxFXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNlcnZlclRlbGVtZXRyeU1hbmFnZXIgPSB0aGlzLmluaXRpYWxpemVTZXJ2ZXJUZWxlbWV0cnlNYW5hZ2VyKEFwaUlkLmFjcXVpcmVUb2tlbkJ5Q2xpZW50Q3JlZGVudGlhbCwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsIHZhbGlkUmVxdWVzdC5za2lwQ2FjaGUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyZWRBdXRob3JpdHkgPSBhd2FpdCB0aGlzLmNyZWF0ZUF1dGhvcml0eSh2YWxpZFJlcXVlc3QuYXV0aG9yaXR5LCB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCwgYXp1cmVSZWdpb25Db25maWd1cmF0aW9uLCByZXF1ZXN0LmF6dXJlQ2xvdWRPcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50Q3JlZGVudGlhbENvbmZpZyA9IGF3YWl0IHRoaXMuYnVpbGRPYXV0aENsaWVudENvbmZpZ3VyYXRpb24oZGlzY292ZXJlZEF1dGhvcml0eSwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQsIFwiXCIsIHNlcnZlclRlbGVtZXRyeU1hbmFnZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBjbGllbnRDcmVkZW50aWFsQ2xpZW50ID0gbmV3IENsaWVudENyZWRlbnRpYWxDbGllbnQoY2xpZW50Q3JlZGVudGlhbENvbmZpZywgdGhpcy5hcHBUb2tlblByb3ZpZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIudmVyYm9zZShcIkNsaWVudCBjcmVkZW50aWFsIGNsaWVudCBjcmVhdGVkXCIsIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNsaWVudENyZWRlbnRpYWxDbGllbnQuYWNxdWlyZVRva2VuKHZhbGlkUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQXV0aEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlLnNldENvcnJlbGF0aW9uSWQodmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlcnZlclRlbGVtZXRyeU1hbmFnZXIuY2FjaGVGYWlsZWRSZXF1ZXN0KGUpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWNxdWlyZXMgdG9rZW5zIGZyb20gdGhlIGF1dGhvcml0eSBmb3IgdGhlIGFwcGxpY2F0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFVzZWQgaW4gc2NlbmFyaW9zIHdoZXJlIHRoZSBjdXJyZW50IGFwcCBpcyBhIG1pZGRsZS10aWVyIHNlcnZpY2Ugd2hpY2ggd2FzIGNhbGxlZCB3aXRoIGEgdG9rZW5cclxuICAgICAqIHJlcHJlc2VudGluZyBhbiBlbmQgdXNlci4gVGhlIGN1cnJlbnQgYXBwIGNhbiB1c2UgdGhlIHRva2VuIChvYm9Bc3NlcnRpb24pIHRvIHJlcXVlc3QgYW5vdGhlclxyXG4gICAgICogdG9rZW4gdG8gYWNjZXNzIGRvd25zdHJlYW0gd2ViIEFQSSwgb24gYmVoYWxmIG9mIHRoYXQgdXNlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgY3VycmVudCBtaWRkbGUtdGllciBhcHAgaGFzIG5vIHVzZXIgaW50ZXJhY3Rpb24gdG8gb2J0YWluIGNvbnNlbnQuXHJcbiAgICAgKiBTZWUgaG93IHRvIGdhaW4gY29uc2VudCB1cGZyb250IGZvciB5b3VyIG1pZGRsZS10aWVyIGFwcCBmcm9tIHRoaXMgYXJ0aWNsZS5cclxuICAgICAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2F6dXJlL2FjdGl2ZS1kaXJlY3RvcnkvZGV2ZWxvcC92Mi1vYXV0aDItb24tYmVoYWxmLW9mLWZsb3cjZ2FpbmluZy1jb25zZW50LWZvci10aGUtbWlkZGxlLXRpZXItYXBwbGljYXRpb25cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuT25CZWhhbGZPZihyZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcImFjcXVpcmVUb2tlbk9uQmVoYWxmT2YgY2FsbGVkXCIsIHJlcXVlc3QuY29ycmVsYXRpb25JZCk7XHJcbiAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxyXG4gICAgICAgICAgICAuLi4oYXdhaXQgdGhpcy5pbml0aWFsaXplQmFzZVJlcXVlc3QocmVxdWVzdCkpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZGlzY292ZXJlZEF1dGhvcml0eSA9IGF3YWl0IHRoaXMuY3JlYXRlQXV0aG9yaXR5KHZhbGlkUmVxdWVzdC5hdXRob3JpdHksIHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkLCB1bmRlZmluZWQsIHJlcXVlc3QuYXp1cmVDbG91ZE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkJlaGFsZk9mQ29uZmlnID0gYXdhaXQgdGhpcy5idWlsZE9hdXRoQ2xpZW50Q29uZmlndXJhdGlvbihkaXNjb3ZlcmVkQXV0aG9yaXR5LCB2YWxpZFJlcXVlc3QuY29ycmVsYXRpb25JZCwgXCJcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgY29uc3Qgb2JvQ2xpZW50ID0gbmV3IE9uQmVoYWxmT2ZDbGllbnQob25CZWhhbGZPZkNvbmZpZyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnZlcmJvc2UoXCJPbiBiZWhhbGYgb2YgY2xpZW50IGNyZWF0ZWRcIiwgdmFsaWRSZXF1ZXN0LmNvcnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgb2JvQ2xpZW50LmFjcXVpcmVUb2tlbih2YWxpZFJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEF1dGhFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZS5zZXRDb3JyZWxhdGlvbklkKHZhbGlkUmVxdWVzdC5jb3JyZWxhdGlvbklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBDb25maWRlbnRpYWxDbGllbnRBcHBsaWNhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uZmlkZW50aWFsQ2xpZW50QXBwbGljYXRpb24ubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0Jztcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGRhdGUgc3RyaW5nIGlzIGluIElTTyA4NjAxIGZvcm1hdC5cclxuICpcclxuICogQHBhcmFtIGRhdGVTdHJpbmcgLSBUaGUgZGF0ZSBzdHJpbmcgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMgYm9vbGVhbiAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF0ZSBzdHJpbmcgaXMgaW4gSVNPIDg2MDEgZm9ybWF0LCBvdGhlcndpc2UgZmFsc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0lzbzg2MDEoZGF0ZVN0cmluZykge1xyXG4gICAgaWYgKHR5cGVvZiBkYXRlU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xyXG4gICAgcmV0dXJuICFpc05hTihkYXRlLmdldFRpbWUoKSkgJiYgZGF0ZS50b0lTT1N0cmluZygpID09PSBkYXRlU3RyaW5nO1xyXG59XG5cbmV4cG9ydCB7IGlzSXNvODYwMSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZVV0aWxzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBIZWFkZXJOYW1lcyB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbi9ub2RlJztcbmltcG9ydCB7IEh0dHBNZXRob2QgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEh0dHBDbGllbnRXaXRoUmV0cmllcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihodHRwQ2xpZW50Tm9SZXRyaWVzLCByZXRyeVBvbGljeSwgbG9nZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50Tm9SZXRyaWVzID0gaHR0cENsaWVudE5vUmV0cmllcztcclxuICAgICAgICB0aGlzLnJldHJ5UG9saWN5ID0gcmV0cnlQb2xpY3k7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kTmV0d29ya1JlcXVlc3RBc3luY0hlbHBlcihodHRwTWV0aG9kLCB1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoaHR0cE1ldGhvZCA9PT0gSHR0cE1ldGhvZC5HRVQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudE5vUmV0cmllcy5zZW5kR2V0UmVxdWVzdEFzeW5jKHVybCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50Tm9SZXRyaWVzLnNlbmRQb3N0UmVxdWVzdEFzeW5jKHVybCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZE5ldHdvcmtSZXF1ZXN0QXN5bmMoaHR0cE1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgbmV0d29yayBtb2R1bGUgKGN1c3RvbSBvciBIdHRwQ2xpZW50KSB3aWxsIG1ha2UgdGhlIGNhbGxcclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmROZXR3b3JrUmVxdWVzdEFzeW5jSGVscGVyKGh0dHBNZXRob2QsIHVybCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKFwiaXNOZXdSZXF1ZXN0XCIgaW4gdGhpcy5yZXRyeVBvbGljeSkge1xyXG4gICAgICAgICAgICB0aGlzLnJldHJ5UG9saWN5LmlzTmV3UmVxdWVzdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjdXJyZW50UmV0cnkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChhd2FpdCB0aGlzLnJldHJ5UG9saWN5LnBhdXNlRm9yUmV0cnkocmVzcG9uc2Uuc3RhdHVzLCBjdXJyZW50UmV0cnksIHRoaXMubG9nZ2VyLCByZXNwb25zZS5oZWFkZXJzW0hlYWRlck5hbWVzLlJFVFJZX0FGVEVSXSkpIHtcclxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmROZXR3b3JrUmVxdWVzdEFzeW5jSGVscGVyKGh0dHBNZXRob2QsIHVybCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRSZXRyeSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kR2V0UmVxdWVzdEFzeW5jKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmROZXR3b3JrUmVxdWVzdEFzeW5jKEh0dHBNZXRob2QuR0VULCB1cmwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZFBvc3RSZXF1ZXN0QXN5bmModXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE5ldHdvcmtSZXF1ZXN0QXN5bmMoSHR0cE1ldGhvZC5QT1NULCB1cmwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IEh0dHBDbGllbnRXaXRoUmV0cmllcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SHR0cENsaWVudFdpdGhSZXRyaWVzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBUaW1lVXRpbHMsIEhlYWRlck5hbWVzLCBDb25zdGFudHMsIEF1dGhFcnJvciwgY3JlYXRlQ2xpZW50QXV0aEVycm9yLCBDbGllbnRBdXRoRXJyb3JDb2RlcywgUmVzcG9uc2VIYW5kbGVyLCBVcmxTdHJpbmcgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMsIEh0dHBNZXRob2QsIE1hbmFnZWRJZGVudGl0eUlkVHlwZSB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvci9NYW5hZ2VkSWRlbnRpdHlFcnJvci5tanMnO1xuaW1wb3J0IHsgaXNJc284NjAxIH0gZnJvbSAnLi4vLi4vdXRpbHMvVGltZVV0aWxzLm1qcyc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50V2l0aFJldHJpZXMgfSBmcm9tICcuLi8uLi9uZXR3b3JrL0h0dHBDbGllbnRXaXRoUmV0cmllcy5tanMnO1xuaW1wb3J0IHsgaW52YWxpZE1hbmFnZWRJZGVudGl0eUlkVHlwZSwgTXNpRW52aXJvbm1lbnRWYXJpYWJsZVVybE1hbGZvcm1lZEVycm9yQ29kZXMgfSBmcm9tICcuLi8uLi9lcnJvci9NYW5hZ2VkSWRlbnRpdHlFcnJvckNvZGVzLm1qcyc7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTWFuYWdlZCBJZGVudGl0eSBVc2VyIEFzc2lnbmVkIElkIFF1ZXJ5IFBhcmFtZXRlciBOYW1lc1xyXG4gKi9cclxuY29uc3QgTWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlck5hbWVzID0ge1xyXG4gICAgTUFOQUdFRF9JREVOVElUWV9DTElFTlRfSURfMjAxNzogXCJjbGllbnRpZFwiLFxyXG4gICAgTUFOQUdFRF9JREVOVElUWV9DTElFTlRfSUQ6IFwiY2xpZW50X2lkXCIsXHJcbiAgICBNQU5BR0VEX0lERU5USVRZX09CSkVDVF9JRDogXCJvYmplY3RfaWRcIixcclxuICAgIE1BTkFHRURfSURFTlRJVFlfUkVTT1VSQ0VfSURfSU1EUzogXCJtc2lfcmVzX2lkXCIsXHJcbiAgICBNQU5BR0VEX0lERU5USVRZX1JFU09VUkNFX0lEX05PTl9JTURTOiBcIm1pX3Jlc19pZFwiLFxyXG59O1xyXG5jbGFzcyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICAgICAgdGhpcy5ub2RlU3RvcmFnZSA9IG5vZGVTdG9yYWdlO1xyXG4gICAgICAgIHRoaXMubmV0d29ya0NsaWVudCA9IG5ldHdvcmtDbGllbnQ7XHJcbiAgICAgICAgdGhpcy5jcnlwdG9Qcm92aWRlciA9IGNyeXB0b1Byb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZUludGVybmFsUmV0cmllcyA9IGRpc2FibGVJbnRlcm5hbFJldHJpZXM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRTZXJ2ZXJUb2tlblJlc3BvbnNlQXN5bmMocmVzcG9uc2UsIFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgX25ldHdvcmtDbGllbnQsIFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgX25ldHdvcmtSZXF1ZXN0LCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgIF9uZXR3b3JrUmVxdWVzdE9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2ZXJUb2tlblJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIGdldFNlcnZlclRva2VuUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgICAgICBsZXQgcmVmcmVzaEluLCBleHBpcmVzSW47XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmJvZHkuZXhwaXJlc19vbikge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgZXhwaXJlc19vbiBmaWVsZCBpbiB0aGUgcmVzcG9uc2UgYm9keSBpcyBhIHN0cmluZyBhbmQgaW4gSVNPIDg2MDEgZm9ybWF0LCBjb252ZXJ0IGl0IHRvIGEgVW5peCB0aW1lc3RhbXAgKHNlY29uZHMgc2luY2UgZXBvY2gpXHJcbiAgICAgICAgICAgIGlmIChpc0lzbzg2MDEocmVzcG9uc2UuYm9keS5leHBpcmVzX29uKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keS5leHBpcmVzX29uID1cclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShyZXNwb25zZS5ib2R5LmV4cGlyZXNfb24pLmdldFRpbWUoKSAvIDEwMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhwaXJlc0luID0gcmVzcG9uc2UuYm9keS5leHBpcmVzX29uIC0gVGltZVV0aWxzLm5vd1NlY29uZHMoKTtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSByZWZyZXNoX2luIGFzIDEvMiBvZiBleHBpcmVzX2luLCBidXQgb25seSBpZiBleHBpcmVzX2luID4gMmhcclxuICAgICAgICAgICAgaWYgKGV4cGlyZXNJbiA+IDIgKiAzNjAwKSB7XHJcbiAgICAgICAgICAgICAgICByZWZyZXNoSW4gPSBleHBpcmVzSW4gLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcnZlclRva2VuUmVzcG9uc2UgPSB7XHJcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgICAgICAvLyBzdWNjZXNzXHJcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogcmVzcG9uc2UuYm9keS5hY2Nlc3NfdG9rZW4sXHJcbiAgICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNJbixcclxuICAgICAgICAgICAgc2NvcGU6IHJlc3BvbnNlLmJvZHkucmVzb3VyY2UsXHJcbiAgICAgICAgICAgIHRva2VuX3R5cGU6IHJlc3BvbnNlLmJvZHkudG9rZW5fdHlwZSxcclxuICAgICAgICAgICAgcmVmcmVzaF9pbjogcmVmcmVzaEluLFxyXG4gICAgICAgICAgICAvLyBlcnJvclxyXG4gICAgICAgICAgICBjb3JyZWxhdGlvbl9pZDogcmVzcG9uc2UuYm9keS5jb3JyZWxhdGlvbl9pZCB8fCByZXNwb25zZS5ib2R5LmNvcnJlbGF0aW9uSWQsXHJcbiAgICAgICAgICAgIGVycm9yOiB0eXBlb2YgcmVzcG9uc2UuYm9keS5lcnJvciA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICAgICAgPyByZXNwb25zZS5ib2R5LmVycm9yXHJcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLmJvZHkuZXJyb3I/LmNvZGUsXHJcbiAgICAgICAgICAgIGVycm9yX2Rlc2NyaXB0aW9uOiByZXNwb25zZS5ib2R5Lm1lc3NhZ2UgfHxcclxuICAgICAgICAgICAgICAgICh0eXBlb2YgcmVzcG9uc2UuYm9keS5lcnJvciA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuYm9keS5lcnJvcl9kZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIDogcmVzcG9uc2UuYm9keS5lcnJvcj8ubWVzc2FnZSksXHJcbiAgICAgICAgICAgIGVycm9yX2NvZGVzOiByZXNwb25zZS5ib2R5LmVycm9yX2NvZGVzLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHJlc3BvbnNlLmJvZHkudGltZXN0YW1wLFxyXG4gICAgICAgICAgICB0cmFjZV9pZDogcmVzcG9uc2UuYm9keS50cmFjZV9pZCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBzZXJ2ZXJUb2tlblJlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuV2l0aE1hbmFnZWRJZGVudGl0eShtYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0LCBtYW5hZ2VkSWRlbnRpdHlJZCwgZmFrZUF1dGhvcml0eSwgcmVmcmVzaEFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29ya1JlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QobWFuYWdlZElkZW50aXR5UmVxdWVzdC5yZXNvdXJjZSwgbWFuYWdlZElkZW50aXR5SWQpO1xyXG4gICAgICAgIGlmIChtYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0LnJldm9rZWRUb2tlblNoYTI1Nkhhc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldIFRoZSBmb2xsb3dpbmcgY2xhaW1zIGFyZSBwcmVzZW50IGluIHRoZSByZXF1ZXN0OiAke21hbmFnZWRJZGVudGl0eVJlcXVlc3QuY2xhaW1zfWApO1xyXG4gICAgICAgICAgICBuZXR3b3JrUmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbTWFuYWdlZElkZW50aXR5UXVlcnlQYXJhbWV0ZXJzLlNIQTI1Nl9UT0tFTl9UT19SRUZSRVNIXSA9IG1hbmFnZWRJZGVudGl0eVJlcXVlc3QucmV2b2tlZFRva2VuU2hhMjU2SGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hbmFnZWRJZGVudGl0eVJlcXVlc3QuY2xpZW50Q2FwYWJpbGl0aWVzPy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50Q2FwYWJpbGl0aWVzID0gbWFuYWdlZElkZW50aXR5UmVxdWVzdC5jbGllbnRDYXBhYmlsaXRpZXMudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldIFRoZSBmb2xsb3dpbmcgY2xpZW50IGNhcGFiaWxpdGllcyBhcmUgcHJlc2VudCBpbiB0aGUgcmVxdWVzdDogJHtjbGllbnRDYXBhYmlsaXRpZXN9YCk7XHJcbiAgICAgICAgICAgIG5ldHdvcmtSZXF1ZXN0LnF1ZXJ5UGFyYW1ldGVyc1tNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMuWE1TX0NDXSA9IGNsaWVudENhcGFiaWxpdGllcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldHdvcmtSZXF1ZXN0LmhlYWRlcnM7XHJcbiAgICAgICAgaGVhZGVyc1tIZWFkZXJOYW1lcy5DT05URU5UX1RZUEVdID0gQ29uc3RhbnRzLlVSTF9GT1JNX0NPTlRFTlRfVFlQRTtcclxuICAgICAgICBjb25zdCBuZXR3b3JrUmVxdWVzdE9wdGlvbnMgPSB7IGhlYWRlcnMgfTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV0d29ya1JlcXVlc3QuYm9keVBhcmFtZXRlcnMpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBuZXR3b3JrUmVxdWVzdE9wdGlvbnMuYm9keSA9XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrUmVxdWVzdC5jb21wdXRlUGFyYW1ldGVyc0JvZHlTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIG5ldHdvcmsgY2xpZW50IGhlbHBlciBiYXNlZCBvbiB0aGUgcmV0cnkgcG9saWN5IGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgICogSWYgaW50ZXJuYWwgcmV0cmllcyBhcmUgZGlzYWJsZWQsIGl0IHVzZXMgdGhlIHByb3ZpZGVkIG5ldHdvcmsgY2xpZW50IGRpcmVjdGx5LlxyXG4gICAgICAgICAqIE90aGVyd2lzZSwgaXQgd3JhcHMgdGhlIG5ldHdvcmsgY2xpZW50IHdpdGggYW4gSFRUUCBjbGllbnQgdGhhdCBzdXBwb3J0cyByZXRyaWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IG5ldHdvcmtDbGllbnRIZWxwZXIgPSB0aGlzLmRpc2FibGVJbnRlcm5hbFJldHJpZXNcclxuICAgICAgICAgICAgPyB0aGlzLm5ldHdvcmtDbGllbnRcclxuICAgICAgICAgICAgOiBuZXcgSHR0cENsaWVudFdpdGhSZXRyaWVzKHRoaXMubmV0d29ya0NsaWVudCwgbmV0d29ya1JlcXVlc3QucmV0cnlQb2xpY3ksIHRoaXMubG9nZ2VyKTtcclxuICAgICAgICBjb25zdCByZXFUaW1lc3RhbXAgPSBUaW1lVXRpbHMubm93U2Vjb25kcygpO1xyXG4gICAgICAgIGxldCByZXNwb25zZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBTb3VyY2VzIHRoYXQgc2VuZCBQT1NUIHJlcXVlc3RzOiBDbG91ZCBTaGVsbFxyXG4gICAgICAgICAgICBpZiAobmV0d29ya1JlcXVlc3QuaHR0cE1ldGhvZCA9PT0gSHR0cE1ldGhvZC5QT1NUKSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV0d29ya0NsaWVudEhlbHBlci5zZW5kUG9zdFJlcXVlc3RBc3luYyhuZXR3b3JrUmVxdWVzdC5jb21wdXRlVXJpKCksIG5ldHdvcmtSZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAvLyBTb3VyY2VzIHRoYXQgc2VuZCBHRVQgcmVxdWVzdHM6IEFwcCBTZXJ2aWNlLCBBenVyZSBBcmMsIElNRFMsIFNlcnZpY2UgRmFicmljXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV0d29ya0NsaWVudEhlbHBlci5zZW5kR2V0UmVxdWVzdEFzeW5jKG5ldHdvcmtSZXF1ZXN0LmNvbXB1dGVVcmkoKSwgbmV0d29ya1JlcXVlc3RPcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXV0aEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUNsaWVudEF1dGhFcnJvcihDbGllbnRBdXRoRXJyb3JDb2Rlcy5uZXR3b3JrRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IG5ldyBSZXNwb25zZUhhbmRsZXIobWFuYWdlZElkZW50aXR5SWQuaWQsIHRoaXMubm9kZVN0b3JhZ2UsIHRoaXMuY3J5cHRvUHJvdmlkZXIsIHRoaXMubG9nZ2VyLCBudWxsLCBudWxsKTtcclxuICAgICAgICBjb25zdCBzZXJ2ZXJUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRTZXJ2ZXJUb2tlblJlc3BvbnNlQXN5bmMocmVzcG9uc2UsIG5ldHdvcmtDbGllbnRIZWxwZXIsIG5ldHdvcmtSZXF1ZXN0LCBuZXR3b3JrUmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgIHJlc3BvbnNlSGFuZGxlci52YWxpZGF0ZVRva2VuUmVzcG9uc2Uoc2VydmVyVG9rZW5SZXNwb25zZSwgcmVmcmVzaEFjY2Vzc1Rva2VuKTtcclxuICAgICAgICAvLyBjYWNoZXMgdGhlIHRva2VuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlSGFuZGxlci5oYW5kbGVTZXJ2ZXJUb2tlblJlc3BvbnNlKHNlcnZlclRva2VuUmVzcG9uc2UsIGZha2VBdXRob3JpdHksIHJlcVRpbWVzdGFtcCwgbWFuYWdlZElkZW50aXR5UmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICBnZXRNYW5hZ2VkSWRlbnRpdHlVc2VyQXNzaWduZWRJZFF1ZXJ5UGFyYW1ldGVyS2V5KG1hbmFnZWRJZGVudGl0eUlkVHlwZSwgaXNJbWRzLCB1c2VzQXBpMjAxNykge1xyXG4gICAgICAgIHN3aXRjaCAobWFuYWdlZElkZW50aXR5SWRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTWFuYWdlZElkZW50aXR5SWRUeXBlLlVTRVJfQVNTSUdORURfQ0xJRU5UX0lEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldIFtBUEkgdmVyc2lvbiAke3VzZXNBcGkyMDE3ID8gXCIyMDE3K1wiIDogXCIyMDE5K1wifV0gQWRkaW5nIHVzZXIgYXNzaWduZWQgY2xpZW50IGlkIHRvIHRoZSByZXF1ZXN0LmApO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIE1hY2hpbmUgTGVhcm5pbmcgc291cmNlIHVzZXMgdGhlIDIwMTctMDktMDEgQVBJIHZlcnNpb24sIHdoaWNoIHVzZXMgXCJjbGllbnRpZFwiIGluc3RlYWQgb2YgXCJjbGllbnRfaWRcIlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXNBcGkyMDE3XHJcbiAgICAgICAgICAgICAgICAgICAgPyBNYW5hZ2VkSWRlbnRpdHlVc2VyQXNzaWduZWRJZFF1ZXJ5UGFyYW1ldGVyTmFtZXMuTUFOQUdFRF9JREVOVElUWV9DTElFTlRfSURfMjAxN1xyXG4gICAgICAgICAgICAgICAgICAgIDogTWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlck5hbWVzLk1BTkFHRURfSURFTlRJVFlfQ0xJRU5UX0lEO1xyXG4gICAgICAgICAgICBjYXNlIE1hbmFnZWRJZGVudGl0eUlkVHlwZS5VU0VSX0FTU0lHTkVEX1JFU09VUkNFX0lEOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIltNYW5hZ2VkIElkZW50aXR5XSBBZGRpbmcgdXNlciBhc3NpZ25lZCByZXNvdXJjZSBpZCB0byB0aGUgcmVxdWVzdC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNJbWRzXHJcbiAgICAgICAgICAgICAgICAgICAgPyBNYW5hZ2VkSWRlbnRpdHlVc2VyQXNzaWduZWRJZFF1ZXJ5UGFyYW1ldGVyTmFtZXMuTUFOQUdFRF9JREVOVElUWV9SRVNPVVJDRV9JRF9JTURTXHJcbiAgICAgICAgICAgICAgICAgICAgOiBNYW5hZ2VkSWRlbnRpdHlVc2VyQXNzaWduZWRJZFF1ZXJ5UGFyYW1ldGVyTmFtZXMuTUFOQUdFRF9JREVOVElUWV9SRVNPVVJDRV9JRF9OT05fSU1EUztcclxuICAgICAgICAgICAgY2FzZSBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUuVVNFUl9BU1NJR05FRF9PQkpFQ1RfSUQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiW01hbmFnZWQgSWRlbnRpdHldIEFkZGluZyB1c2VyIGFzc2lnbmVkIG9iamVjdCBpZCB0byB0aGUgcmVxdWVzdC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlck5hbWVzLk1BTkFHRURfSURFTlRJVFlfT0JKRUNUX0lEO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IoaW52YWxpZE1hbmFnZWRJZGVudGl0eUlkVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkJhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2UuZ2V0VmFsaWRhdGVkRW52VmFyaWFibGVVcmxTdHJpbmcgPSAoZW52VmFyaWFibGVTdHJpbmdOYW1lLCBlbnZWYXJpYWJsZSwgc291cmNlTmFtZSwgbG9nZ2VyKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVXJsU3RyaW5nKGVudlZhcmlhYmxlKS51cmxTdHJpbmc7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldICR7c291cmNlTmFtZX0gbWFuYWdlZCBpZGVudGl0eSBpcyB1bmF2YWlsYWJsZSBiZWNhdXNlIHRoZSAnJHtlbnZWYXJpYWJsZVN0cmluZ05hbWV9JyBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtYWxmb3JtZWQuYCk7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IoTXNpRW52aXJvbm1lbnRWYXJpYWJsZVVybE1hbGZvcm1lZEVycm9yQ29kZXNbZW52VmFyaWFibGVTdHJpbmdOYW1lXSk7XHJcbiAgICB9XHJcbn07XG5cbmV4cG9ydCB7IEJhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2UsIE1hbmFnZWRJZGVudGl0eVVzZXJBc3NpZ25lZElkUXVlcnlQYXJhbWV0ZXJOYW1lcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZS5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIExpbmVhclJldHJ5U3RyYXRlZ3kge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHNsZWVwIGJhc2VkIG9uIHRoZSBgcmV0cnktYWZ0ZXJgIEhUVFAgaGVhZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXRyeUhlYWRlciAtIFRoZSB2YWx1ZSBvZiB0aGUgYHJldHJ5LWFmdGVyYCBIVFRQIGhlYWRlci4gVGhpcyBjYW4gYmUgZWl0aGVyIGEgbnVtYmVyIG9mIHNlY29uZHNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9yIGFuIEhUVFAgZGF0ZSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBzbGVlcCBiZWZvcmUgcmV0cnlpbmcgdGhlIHJlcXVlc3QuIElmIHRoZSBgcmV0cnktYWZ0ZXJgIGhlYWRlciBpcyBub3RcclxuICAgICAqICAgICAgICAgIHByZXNlbnQgb3IgY2Fubm90IGJlIHBhcnNlZCwgcmV0dXJucyAwLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVEZWxheShyZXRyeUhlYWRlciwgbWluaW11bURlbGF5KSB7XHJcbiAgICAgICAgaWYgKCFyZXRyeUhlYWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWluaW11bURlbGF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXRyeS1hZnRlciBoZWFkZXIgaXMgaW4gc2Vjb25kc1xyXG4gICAgICAgIGxldCBtaWxsaXNUb1NsZWVwID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHJldHJ5SGVhZGVyKSAqIDEwMDApO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogcmV0cnktYWZ0ZXIgaGVhZGVyIGlzIGluIEhUVFAgRGF0ZSBmb3JtYXRcclxuICAgICAgICAgKiA8ZGF5LW5hbWU+LCA8ZGF5PiA8bW9udGg+IDx5ZWFyPiA8aG91cj46PG1pbnV0ZT46PHNlY29uZD4gR01UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGlzTmFOKG1pbGxpc1RvU2xlZXApKSB7XHJcbiAgICAgICAgICAgIC8vIC52YWx1ZU9mKCkgaXMgbmVlZGVkIHRvIHN1YnRyYWN0IGRhdGVzIGluIFR5cGVTY3JpcHRcclxuICAgICAgICAgICAgbWlsbGlzVG9TbGVlcCA9XHJcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShyZXRyeUhlYWRlcikudmFsdWVPZigpIC0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW5pbXVtRGVsYXksIG1pbGxpc1RvU2xlZXApO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IExpbmVhclJldHJ5U3RyYXRlZ3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVhclJldHJ5U3RyYXRlZ3kubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEh0dHBTdGF0dXMgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24nO1xuaW1wb3J0IHsgTGluZWFyUmV0cnlTdHJhdGVneSB9IGZyb20gJy4vTGluZWFyUmV0cnlTdHJhdGVneS5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX01BWF9SRVRSSUVTID0gMzsgLy8gcmVmZXJlbmNlZCBpbiB1bml0IHRlc3RcclxuY29uc3QgREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX1JFVFJZX0RFTEFZX01TID0gMTAwMDtcclxuY29uc3QgREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX0hUVFBfU1RBVFVTX0NPREVTX1RPX1JFVFJZX09OID0gW1xyXG4gICAgSHR0cFN0YXR1cy5OT1RfRk9VTkQsXHJcbiAgICBIdHRwU3RhdHVzLlJFUVVFU1RfVElNRU9VVCxcclxuICAgIEh0dHBTdGF0dXMuVE9PX01BTllfUkVRVUVTVFMsXHJcbiAgICBIdHRwU3RhdHVzLlNFUlZFUl9FUlJPUixcclxuICAgIEh0dHBTdGF0dXMuU0VSVklDRV9VTkFWQUlMQUJMRSxcclxuICAgIEh0dHBTdGF0dXMuR0FURVdBWV9USU1FT1VULFxyXG5dO1xyXG5jbGFzcyBEZWZhdWx0TWFuYWdlZElkZW50aXR5UmV0cnlQb2xpY3kge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5saW5lYXJSZXRyeVN0cmF0ZWd5ID0gbmV3IExpbmVhclJldHJ5U3RyYXRlZ3koKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgKiB0aGlzIGlzIGRlZmluZWQgaGVyZSBhcyBhIHN0YXRpYyB2YXJpYWJsZSBkZXNwaXRlIGJlaW5nIGRlZmluZWQgYXMgYSBjb25zdGFudCBvdXRzaWRlIG9mIHRoZVxyXG4gICAgICogY2xhc3MgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBvdmVycmlkZGVuIGluIHRoZSB1bml0IHRlc3RzIHNvIHRoYXQgdGhlIHVuaXQgdGVzdHMgcnVuIGZhc3RlclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERFRkFVTFRfTUFOQUdFRF9JREVOVElUWV9SRVRSWV9ERUxBWV9NUygpIHtcclxuICAgICAgICByZXR1cm4gREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX1JFVFJZX0RFTEFZX01TO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcGF1c2VGb3JSZXRyeShodHRwU3RhdHVzQ29kZSwgY3VycmVudFJldHJ5LCBsb2dnZXIsIHJldHJ5QWZ0ZXJIZWFkZXIpIHtcclxuICAgICAgICBpZiAoREVGQVVMVF9NQU5BR0VEX0lERU5USVRZX0hUVFBfU1RBVFVTX0NPREVTX1RPX1JFVFJZX09OLmluY2x1ZGVzKGh0dHBTdGF0dXNDb2RlKSAmJlxyXG4gICAgICAgICAgICBjdXJyZW50UmV0cnkgPCBERUZBVUxUX01BTkFHRURfSURFTlRJVFlfTUFYX1JFVFJJRVMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlckRlbGF5ID0gdGhpcy5saW5lYXJSZXRyeVN0cmF0ZWd5LmNhbGN1bGF0ZURlbGF5KHJldHJ5QWZ0ZXJIZWFkZXIsIERlZmF1bHRNYW5hZ2VkSWRlbnRpdHlSZXRyeVBvbGljeS5ERUZBVUxUX01BTkFHRURfSURFTlRJVFlfUkVUUllfREVMQVlfTVMpO1xyXG4gICAgICAgICAgICBsb2dnZXIudmVyYm9zZShgUmV0cnlpbmcgcmVxdWVzdCBpbiAke3JldHJ5QWZ0ZXJEZWxheX1tcyAocmV0cnkgYXR0ZW1wdDogJHtjdXJyZW50UmV0cnkgKyAxfSlgKTtcclxuICAgICAgICAgICAgLy8gcGF1c2UgZXhlY3V0aW9uIGZvciB0aGUgY2FsY3VsYXRlZCBkZWxheVxyXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnlBZnRlckhlYWRlciB2YWx1ZSBvZiAwIGV2YWx1YXRlcyB0byBmYWxzZSwgYW5kIERFRkFVTFRfTUFOQUdFRF9JREVOVElUWV9SRVRSWV9ERUxBWV9NUyB3aWxsIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5QWZ0ZXJEZWxheSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHN0YXR1cyBjb2RlIGlzIG5vdCByZXRyaWFibGUgb3IgbWF4IHJldHJpZXMgaGF2ZSBiZWVuIHJlYWNoZWQsIGRvIG5vdCByZXRyeVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBERUZBVUxUX01BTkFHRURfSURFTlRJVFlfTUFYX1JFVFJJRVMsIERlZmF1bHRNYW5hZ2VkSWRlbnRpdHlSZXRyeVBvbGljeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmYXVsdE1hbmFnZWRJZGVudGl0eVJldHJ5UG9saWN5Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlciwgVXJsVXRpbHMsIFVybFN0cmluZyB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbi9ub2RlJztcbmltcG9ydCB7IERlZmF1bHRNYW5hZ2VkSWRlbnRpdHlSZXRyeVBvbGljeSB9IGZyb20gJy4uL3JldHJ5L0RlZmF1bHRNYW5hZ2VkSWRlbnRpdHlSZXRyeVBvbGljeS5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMge1xyXG4gICAgY29uc3RydWN0b3IoaHR0cE1ldGhvZCwgZW5kcG9pbnQsIHJldHJ5UG9saWN5KSB7XHJcbiAgICAgICAgdGhpcy5odHRwTWV0aG9kID0gaHR0cE1ldGhvZDtcclxuICAgICAgICB0aGlzLl9iYXNlRW5kcG9pbnQgPSBlbmRwb2ludDtcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLmJvZHlQYXJhbWV0ZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5xdWVyeVBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLnJldHJ5UG9saWN5ID1cclxuICAgICAgICAgICAgcmV0cnlQb2xpY3kgfHwgbmV3IERlZmF1bHRNYW5hZ2VkSWRlbnRpdHlSZXRyeVBvbGljeSgpO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZVVyaSgpIHtcclxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRFeHRyYVF1ZXJ5UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCB0aGlzLnF1ZXJ5UGFyYW1ldGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVyc1N0cmluZyA9IFVybFV0aWxzLm1hcFRvUXVlcnlTdHJpbmcocGFyYW1ldGVycyk7XHJcbiAgICAgICAgcmV0dXJuIFVybFN0cmluZy5hcHBlbmRRdWVyeVN0cmluZyh0aGlzLl9iYXNlRW5kcG9pbnQsIHF1ZXJ5UGFyYW1ldGVyc1N0cmluZyk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlUGFyYW1ldGVyc0JvZHlTdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBpZiAodGhpcy5ib2R5UGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBSZXF1ZXN0UGFyYW1ldGVyQnVpbGRlci5hZGRFeHRyYVF1ZXJ5UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCB0aGlzLmJvZHlQYXJhbWV0ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVybFV0aWxzLm1hcFRvUXVlcnlTdHJpbmcocGFyYW1ldGVycyk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIH0gZnJvbSAnLi9CYXNlTWFuYWdlZElkZW50aXR5U291cmNlLm1qcyc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMsIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLCBNYW5hZ2VkSWRlbnRpdHlIZWFkZXJzLCBNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMsIE1hbmFnZWRJZGVudGl0eUlkVHlwZSwgSHR0cE1ldGhvZCB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9jb25maWcvTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8vIE1TSSBDb25zdGFudHMuIERvY3MgZm9yIE1TSSBhcmUgYXZhaWxhYmxlIGhlcmUgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vYXp1cmUvYXBwLXNlcnZpY2Uvb3ZlcnZpZXctbWFuYWdlZC1pZGVudGl0eVxyXG5jb25zdCBBUFBfU0VSVklDRV9NU0lfQVBJX1ZFUlNJT04gPSBcIjIwMTktMDgtMDFcIjtcclxuLyoqXHJcbiAqIE9yaWdpbmFsIHNvdXJjZSBvZiBjb2RlOiBodHRwczovL2dpdGh1Yi5jb20vQXp1cmUvYXp1cmUtc2RrLWZvci1uZXQvYmxvYi9tYWluL3Nkay9pZGVudGl0eS9BenVyZS5JZGVudGl0eS9zcmMvQXBwU2VydmljZU1hbmFnZWRJZGVudGl0eVNvdXJjZS5jc1xyXG4gKi9cclxuY2xhc3MgQXBwU2VydmljZSBleHRlbmRzIEJhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIGlkZW50aXR5RW5kcG9pbnQsIGlkZW50aXR5SGVhZGVyKSB7XHJcbiAgICAgICAgc3VwZXIobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMpO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpdHlFbmRwb2ludCA9IGlkZW50aXR5RW5kcG9pbnQ7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eUhlYWRlciA9IGlkZW50aXR5SGVhZGVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEVudmlyb25tZW50VmFyaWFibGVzKCkge1xyXG4gICAgICAgIGNvbnN0IGlkZW50aXR5RW5kcG9pbnQgPSBwcm9jZXNzLmVudltNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfRU5EUE9JTlRdO1xyXG4gICAgICAgIGNvbnN0IGlkZW50aXR5SGVhZGVyID0gcHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklERU5USVRZX0hFQURFUl07XHJcbiAgICAgICAgcmV0dXJuIFtpZGVudGl0eUVuZHBvaW50LCBpZGVudGl0eUhlYWRlcl07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdHJ5Q3JlYXRlKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzKSB7XHJcbiAgICAgICAgY29uc3QgW2lkZW50aXR5RW5kcG9pbnQsIGlkZW50aXR5SGVhZGVyXSA9IEFwcFNlcnZpY2UuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKTtcclxuICAgICAgICAvLyBpZiBlaXRoZXIgb2YgdGhlIGlkZW50aXR5IGVuZHBvaW50IG9yIGlkZW50aXR5IGhlYWRlciB2YXJpYWJsZXMgYXJlIHVuZGVmaW5lZCwgdGhpcyBNU0kgcHJvdmlkZXIgaXMgdW5hdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKCFpZGVudGl0eUVuZHBvaW50IHx8ICFpZGVudGl0eUhlYWRlcikge1xyXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVBQX1NFUlZJQ0V9IG1hbmFnZWQgaWRlbnRpdHkgaXMgdW5hdmFpbGFibGUgYmVjYXVzZSBvbmUgb3IgYm90aCBvZiB0aGUgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklERU5USVRZX0hFQURFUn0nIGFuZCAnJHtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfRU5EUE9JTlR9JyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIG5vdCBkZWZpbmVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludCA9IEFwcFNlcnZpY2UuZ2V0VmFsaWRhdGVkRW52VmFyaWFibGVVcmxTdHJpbmcoTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklERU5USVRZX0VORFBPSU5ULCBpZGVudGl0eUVuZHBvaW50LCBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5BUFBfU0VSVklDRSwgbG9nZ2VyKTtcclxuICAgICAgICBsb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldIEVudmlyb25tZW50IHZhcmlhYmxlcyB2YWxpZGF0aW9uIHBhc3NlZCBmb3IgJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5BUFBfU0VSVklDRX0gbWFuYWdlZCBpZGVudGl0eS4gRW5kcG9pbnQgVVJJOiAke3ZhbGlkYXRlZElkZW50aXR5RW5kcG9pbnR9LiBDcmVhdGluZyAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFQUF9TRVJWSUNFfSBtYW5hZ2VkIGlkZW50aXR5LmApO1xyXG4gICAgICAgIHJldHVybiBuZXcgQXBwU2VydmljZShsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcywgaWRlbnRpdHlFbmRwb2ludCwgaWRlbnRpdHlIZWFkZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUmVxdWVzdChyZXNvdXJjZSwgbWFuYWdlZElkZW50aXR5SWQpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzKEh0dHBNZXRob2QuR0VULCB0aGlzLmlkZW50aXR5RW5kcG9pbnQpO1xyXG4gICAgICAgIHJlcXVlc3QuaGVhZGVyc1tNYW5hZ2VkSWRlbnRpdHlIZWFkZXJzLkFQUF9TRVJWSUNFX1NFQ1JFVF9IRUFERVJfTkFNRV0gPVxyXG4gICAgICAgICAgICB0aGlzLmlkZW50aXR5SGVhZGVyO1xyXG4gICAgICAgIHJlcXVlc3QucXVlcnlQYXJhbWV0ZXJzW01hbmFnZWRJZGVudGl0eVF1ZXJ5UGFyYW1ldGVycy5BUElfVkVSU0lPTl0gPVxyXG4gICAgICAgICAgICBBUFBfU0VSVklDRV9NU0lfQVBJX1ZFUlNJT047XHJcbiAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbTWFuYWdlZElkZW50aXR5UXVlcnlQYXJhbWV0ZXJzLlJFU09VUkNFXSA9XHJcbiAgICAgICAgICAgIHJlc291cmNlO1xyXG4gICAgICAgIGlmIChtYW5hZ2VkSWRlbnRpdHlJZC5pZFR5cGUgIT09IE1hbmFnZWRJZGVudGl0eUlkVHlwZS5TWVNURU1fQVNTSUdORUQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbdGhpcy5nZXRNYW5hZ2VkSWRlbnRpdHlVc2VyQXNzaWduZWRJZFF1ZXJ5UGFyYW1ldGVyS2V5KG1hbmFnZWRJZGVudGl0eUlkLmlkVHlwZSldID0gbWFuYWdlZElkZW50aXR5SWQuaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvZHlQYXJhbWV0ZXJzIGNhbGN1bGF0ZWQgaW4gQmFzZU1hbmFnZWRJZGVudGl0eS5hY3F1aXJlVG9rZW5XaXRoTWFuYWdlZElkZW50aXR5XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQXBwU2VydmljZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwU2VydmljZS5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgSHR0cFN0YXR1cywgRW5jb2RpbmdUeXBlcywgQXV0aEVycm9yLCBjcmVhdGVDbGllbnRBdXRoRXJyb3IsIENsaWVudEF1dGhFcnJvckNvZGVzIH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9jb25maWcvTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMubWpzJztcbmltcG9ydCB7IEJhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2UgfSBmcm9tICcuL0Jhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2UubWpzJztcbmltcG9ydCB7IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3IvTWFuYWdlZElkZW50aXR5RXJyb3IubWpzJztcbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcywgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMsIE1hbmFnZWRJZGVudGl0eUlkVHlwZSwgSHR0cE1ldGhvZCwgTWFuYWdlZElkZW50aXR5SGVhZGVycywgTWFuYWdlZElkZW50aXR5UXVlcnlQYXJhbWV0ZXJzLCBBWlVSRV9BUkNfU0VDUkVUX0ZJTEVfTUFYX1NJWkVfQllURVMgfSBmcm9tICcuLi8uLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IGFjY2Vzc1N5bmMsIGNvbnN0YW50cywgc3RhdFN5bmMsIHJlYWRGaWxlU3luYyB9IGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgdW5hYmxlVG9DcmVhdGVBenVyZUFyYywgd3d3QXV0aGVudGljYXRlSGVhZGVyTWlzc2luZywgd3d3QXV0aGVudGljYXRlSGVhZGVyVW5zdXBwb3J0ZWRGb3JtYXQsIHBsYXRmb3JtTm90U3VwcG9ydGVkLCBpbnZhbGlkRmlsZUV4dGVuc2lvbiwgaW52YWxpZEZpbGVQYXRoLCB1bmFibGVUb1JlYWRTZWNyZXRGaWxlLCBpbnZhbGlkU2VjcmV0IH0gZnJvbSAnLi4vLi4vZXJyb3IvTWFuYWdlZElkZW50aXR5RXJyb3JDb2Rlcy5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgQVJDX0FQSV9WRVJTSU9OID0gXCIyMDE5LTExLTAxXCI7XHJcbmNvbnN0IERFRkFVTFRfQVpVUkVfQVJDX0lERU5USVRZX0VORFBPSU5UID0gXCJodHRwOi8vMTI3LjAuMC4xOjQwMzQyL21ldGFkYXRhL2lkZW50aXR5L29hdXRoMi90b2tlblwiO1xyXG5jb25zdCBISU1EU19FWEVDVVRBQkxFX0hFTFBFUl9TVFJJTkcgPSBcIk4vQTogaGltZHMgZXhlY3V0YWJsZSBleGlzdHNcIjtcclxuY29uc3QgU1VQUE9SVEVEX0FaVVJFX0FSQ19QTEFURk9STVMgPSB7XHJcbiAgICB3aW4zMjogYCR7cHJvY2Vzcy5lbnZbXCJQcm9ncmFtRGF0YVwiXX1cXFxcQXp1cmVDb25uZWN0ZWRNYWNoaW5lQWdlbnRcXFxcVG9rZW5zXFxcXGAsXHJcbiAgICBsaW51eDogXCIvdmFyL29wdC9hemNtYWdlbnQvdG9rZW5zL1wiLFxyXG59O1xyXG5jb25zdCBBWlVSRV9BUkNfRklMRV9ERVRFQ1RJT04gPSB7XHJcbiAgICB3aW4zMjogYCR7cHJvY2Vzcy5lbnZbXCJQcm9ncmFtRmlsZXNcIl19XFxcXEF6dXJlQ29ubmVjdGVkTWFjaGluZUFnZW50XFxcXGhpbWRzLmV4ZWAsXHJcbiAgICBsaW51eDogXCIvb3B0L2F6Y21hZ2VudC9iaW4vaGltZHNcIixcclxufTtcclxuLyoqXHJcbiAqIE9yaWdpbmFsIHNvdXJjZSBvZiBjb2RlOiBodHRwczovL2dpdGh1Yi5jb20vQXp1cmUvYXp1cmUtc2RrLWZvci1uZXQvYmxvYi9tYWluL3Nkay9pZGVudGl0eS9BenVyZS5JZGVudGl0eS9zcmMvQXp1cmVBcmNNYW5hZ2VkSWRlbnRpdHlTb3VyY2UuY3NcclxuICovXHJcbmNsYXNzIEF6dXJlQXJjIGV4dGVuZHMgQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcywgaWRlbnRpdHlFbmRwb2ludCkge1xyXG4gICAgICAgIHN1cGVyKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzKTtcclxuICAgICAgICB0aGlzLmlkZW50aXR5RW5kcG9pbnQgPSBpZGVudGl0eUVuZHBvaW50O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEVudmlyb25tZW50VmFyaWFibGVzKCkge1xyXG4gICAgICAgIGxldCBpZGVudGl0eUVuZHBvaW50ID0gcHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklERU5USVRZX0VORFBPSU5UXTtcclxuICAgICAgICBsZXQgaW1kc0VuZHBvaW50ID0gcHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklNRFNfRU5EUE9JTlRdO1xyXG4gICAgICAgIC8vIGlmIGVpdGhlciBvZiB0aGUgaWRlbnRpdHkgb3IgaW1kcyBlbmRwb2ludHMgYXJlIHVuZGVmaW5lZCwgY2hlY2sgaWYgdGhlIGhpbWRzIGV4ZWN1dGFibGUgZXhpc3RzXHJcbiAgICAgICAgaWYgKCFpZGVudGl0eUVuZHBvaW50IHx8ICFpbWRzRW5kcG9pbnQpIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBleHBlY3RlZCBXaW5kb3dzIG9yIExpbnV4IGZpbGUgcGF0aCBvZiB0aGUgaGltZHMgZXhlY3V0YWJsZVxyXG4gICAgICAgICAgICBjb25zdCBmaWxlRGV0ZWN0aW9uUGF0aCA9IEFaVVJFX0FSQ19GSUxFX0RFVEVDVElPTltwcm9jZXNzLnBsYXRmb3JtXTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBjaGVjayBpZiB0aGUgaGltZHMgZXhlY3V0YWJsZSBleGlzdHMgYW5kIGl0cyBwZXJtaXNzaW9ucyBhbGxvdyBpdCB0byBiZSByZWFkXHJcbiAgICAgICAgICAgICAgICAgKiByZXR1cm5zIHVuZGVmaW5lZCBpZiB0cnVlLCB0aHJvd3MgYW4gZXJyb3Igb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGFjY2Vzc1N5bmMoZmlsZURldGVjdGlvblBhdGgsIGNvbnN0YW50cy5GX09LIHwgY29uc3RhbnRzLlJfT0spO1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlFbmRwb2ludCA9IERFRkFVTFRfQVpVUkVfQVJDX0lERU5USVRZX0VORFBPSU5UO1xyXG4gICAgICAgICAgICAgICAgaW1kc0VuZHBvaW50ID0gSElNRFNfRVhFQ1VUQUJMRV9IRUxQRVJfU1RSSU5HO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICAgKiBhY2Nlc3NTeW5jIHJldHVybnMgdW5kZWZpbmVkIG9uIHN1Y2Nlc3MsIGFuZCB0aHJvd3MgYW4gZXJyb3Igb24gZmFpbHVyZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtpZGVudGl0eUVuZHBvaW50LCBpbWRzRW5kcG9pbnRdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRyeUNyZWF0ZShsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcywgbWFuYWdlZElkZW50aXR5SWQpIHtcclxuICAgICAgICBjb25zdCBbaWRlbnRpdHlFbmRwb2ludCwgaW1kc0VuZHBvaW50XSA9IEF6dXJlQXJjLmdldEVudmlyb25tZW50VmFyaWFibGVzKCk7XHJcbiAgICAgICAgLy8gaWYgZWl0aGVyIG9mIHRoZSBpZGVudGl0eSBvciBpbWRzIGVuZHBvaW50cyBhcmUgdW5kZWZpbmVkIChldmVuIGFmdGVyIGhpbWRzIGZpbGUgZGV0ZWN0aW9uKVxyXG4gICAgICAgIGlmICghaWRlbnRpdHlFbmRwb2ludCB8fCAhaW1kc0VuZHBvaW50KSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBbTWFuYWdlZCBJZGVudGl0eV0gJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5BWlVSRV9BUkN9IG1hbmFnZWQgaWRlbnRpdHkgaXMgdW5hdmFpbGFibGUgdGhyb3VnaCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYmVjYXVzZSBvbmUgb3IgYm90aCBvZiAnJHtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfRU5EUE9JTlR9JyBhbmQgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklNRFNfRU5EUE9JTlR9JyBhcmUgbm90IGRlZmluZWQuICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDfSBtYW5hZ2VkIGlkZW50aXR5IGlzIGFsc28gdW5hdmFpbGFibGUgdGhyb3VnaCBmaWxlIGRldGVjdGlvbi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbWRzIGVuZHBvaW50IGlzIHNldCB0byB0aGUgZGVmYXVsdCBmb3IgZmlsZSBkZXRlY3Rpb25cclxuICAgICAgICBpZiAoaW1kc0VuZHBvaW50ID09PSBISU1EU19FWEVDVVRBQkxFX0hFTFBFUl9TVFJJTkcpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYFtNYW5hZ2VkIElkZW50aXR5XSAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQ30gbWFuYWdlZCBpZGVudGl0eSBpcyBhdmFpbGFibGUgdGhyb3VnaCBmaWxlIGRldGVjdGlvbi4gRGVmYXVsdGluZyB0byBrbm93biAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQ30gZW5kcG9pbnQ6ICR7REVGQVVMVF9BWlVSRV9BUkNfSURFTlRJVFlfRU5EUE9JTlR9LiBDcmVhdGluZyAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFaVVJFX0FSQ30gbWFuYWdlZCBpZGVudGl0eS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgYm90aCB0aGUgaWRlbnRpdHkgYW5kIGltZHMgZW5kcG9pbnRzIGFyZSBkZWZpbmVkIHdpdGhvdXQgZmlsZSBkZXRlY3Rpb247IHZhbGlkYXRlIHRoZW1cclxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludCA9IEF6dXJlQXJjLmdldFZhbGlkYXRlZEVudlZhcmlhYmxlVXJsU3RyaW5nKE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JREVOVElUWV9FTkRQT0lOVCwgaWRlbnRpdHlFbmRwb2ludCwgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDLCBsb2dnZXIpO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcclxuICAgICAgICAgICAgdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludC5lbmRzV2l0aChcIi9cIilcclxuICAgICAgICAgICAgICAgID8gdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludC5zbGljZSgwLCAtMSlcclxuICAgICAgICAgICAgICAgIDogdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludDtcclxuICAgICAgICAgICAgQXp1cmVBcmMuZ2V0VmFsaWRhdGVkRW52VmFyaWFibGVVcmxTdHJpbmcoTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklNRFNfRU5EUE9JTlQsIGltZHNFbmRwb2ludCwgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDLCBsb2dnZXIpO1xyXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldIEVudmlyb25tZW50IHZhcmlhYmxlcyB2YWxpZGF0aW9uIHBhc3NlZCBmb3IgJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5BWlVSRV9BUkN9IG1hbmFnZWQgaWRlbnRpdHkuIEVuZHBvaW50IFVSSTogJHt2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50fS4gQ3JlYXRpbmcgJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5BWlVSRV9BUkN9IG1hbmFnZWQgaWRlbnRpdHkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYW5hZ2VkSWRlbnRpdHlJZC5pZFR5cGUgIT09IE1hbmFnZWRJZGVudGl0eUlkVHlwZS5TWVNURU1fQVNTSUdORUQpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IodW5hYmxlVG9DcmVhdGVBenVyZUFyYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQXp1cmVBcmMobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIGlkZW50aXR5RW5kcG9pbnQpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUmVxdWVzdChyZXNvdXJjZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMoSHR0cE1ldGhvZC5HRVQsIHRoaXMuaWRlbnRpdHlFbmRwb2ludC5yZXBsYWNlKFwibG9jYWxob3N0XCIsIFwiMTI3LjAuMC4xXCIpKTtcclxuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbTWFuYWdlZElkZW50aXR5SGVhZGVycy5NRVRBREFUQV9IRUFERVJfTkFNRV0gPSBcInRydWVcIjtcclxuICAgICAgICByZXF1ZXN0LnF1ZXJ5UGFyYW1ldGVyc1tNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMuQVBJX1ZFUlNJT05dID1cclxuICAgICAgICAgICAgQVJDX0FQSV9WRVJTSU9OO1xyXG4gICAgICAgIHJlcXVlc3QucXVlcnlQYXJhbWV0ZXJzW01hbmFnZWRJZGVudGl0eVF1ZXJ5UGFyYW1ldGVycy5SRVNPVVJDRV0gPVxyXG4gICAgICAgICAgICByZXNvdXJjZTtcclxuICAgICAgICAvLyBib2R5UGFyYW1ldGVycyBjYWxjdWxhdGVkIGluIEJhc2VNYW5hZ2VkSWRlbnRpdHkuYWNxdWlyZVRva2VuV2l0aE1hbmFnZWRJZGVudGl0eVxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0U2VydmVyVG9rZW5SZXNwb25zZUFzeW5jKG9yaWdpbmFsUmVzcG9uc2UsIG5ldHdvcmtDbGllbnQsIG5ldHdvcmtSZXF1ZXN0LCBuZXR3b3JrUmVxdWVzdE9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgcmV0cnlSZXNwb25zZTtcclxuICAgICAgICBpZiAob3JpZ2luYWxSZXNwb25zZS5zdGF0dXMgPT09IEh0dHBTdGF0dXMuVU5BVVRIT1JJWkVEKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHd3d0F1dGhIZWFkZXIgPSBvcmlnaW5hbFJlc3BvbnNlLmhlYWRlcnNbXCJ3d3ctYXV0aGVudGljYXRlXCJdO1xyXG4gICAgICAgICAgICBpZiAoIXd3d0F1dGhIZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKHd3d0F1dGhlbnRpY2F0ZUhlYWRlck1pc3NpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghd3d3QXV0aEhlYWRlci5pbmNsdWRlcyhcIkJhc2ljIHJlYWxtPVwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3Iod3d3QXV0aGVudGljYXRlSGVhZGVyVW5zdXBwb3J0ZWRGb3JtYXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY3JldEZpbGVQYXRoID0gd3d3QXV0aEhlYWRlci5zcGxpdChcIkJhc2ljIHJlYWxtPVwiKVsxXTtcclxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG1hbmFnZWQgaWRlbnRpdHkgYXBwbGljYXRpb24gaXMgbm90IGJlaW5nIHJ1biBvbiBXaW5kb3dzIG9yIExpbnV4XHJcbiAgICAgICAgICAgIGlmICghU1VQUE9SVEVEX0FaVVJFX0FSQ19QTEFURk9STVMuaGFzT3duUHJvcGVydHkocHJvY2Vzcy5wbGF0Zm9ybSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKHBsYXRmb3JtTm90U3VwcG9ydGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGV4cGVjdGVkIFdpbmRvd3Mgb3IgTGludXggZmlsZSBwYXRoXHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkU2VjcmV0RmlsZVBhdGggPSBTVVBQT1JURURfQVpVUkVfQVJDX1BMQVRGT1JNU1twcm9jZXNzLnBsYXRmb3JtXTtcclxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgaW4gdGhlIGZpbGUgcGF0aCBpcyBub3QgYSAua2V5IGZpbGVcclxuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHNlY3JldEZpbGVQYXRoKTtcclxuICAgICAgICAgICAgaWYgKCFmaWxlTmFtZS5lbmRzV2l0aChcIi5rZXlcIikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKGludmFsaWRGaWxlRXh0ZW5zaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBwYXRoIGZyb20gdGhlIHd3dy1hdXRoZW50aWNhdGUgaGVhZGVyIGRvZXMgbm90IG1hdGNoIHRoZVxyXG4gICAgICAgICAgICAgKiBleHBlY3RlZCBmaWxlIHBhdGggZm9yIHRoZSBwbGF0Zm9ybSAoV2luZG93cyBvciBMaW51eCkgdGhlIG1hbmFnZWQgaWRlbnRpdHkgYXBwbGljYXRpb25cclxuICAgICAgICAgICAgICogaXMgcnVubmluZyBvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkU2VjcmV0RmlsZVBhdGggKyBmaWxlTmFtZSAhPT0gc2VjcmV0RmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKGludmFsaWRGaWxlUGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNlY3JldEZpbGVTaXplO1xyXG4gICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGdldCB0aGUgc2VjcmV0IGZpbGUncyBzaXplLCBpbiBieXRlc1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc2VjcmV0RmlsZVNpemUgPSBhd2FpdCBzdGF0U3luYyhzZWNyZXRGaWxlUGF0aCkuc2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IodW5hYmxlVG9SZWFkU2VjcmV0RmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNlY3JldCBmaWxlJ3Mgc2l6ZSBpcyBncmVhdGVyIHRoYW4gNDA5NiBieXRlc1xyXG4gICAgICAgICAgICBpZiAoc2VjcmV0RmlsZVNpemUgPiBBWlVSRV9BUkNfU0VDUkVUX0ZJTEVfTUFYX1NJWkVfQllURVMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKGludmFsaWRTZWNyZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCB0aGUgY29udGVudHMgb2YgdGhlIHNlY3JldCBmaWxlXHJcbiAgICAgICAgICAgIGxldCBzZWNyZXQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzZWNyZXQgPSByZWFkRmlsZVN5bmMoc2VjcmV0RmlsZVBhdGgsIEVuY29kaW5nVHlwZXMuVVRGOCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yKHVuYWJsZVRvUmVhZFNlY3JldEZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dGhIZWFkZXJWYWx1ZSA9IGBCYXNpYyAke3NlY3JldH1gO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbTWFuYWdlZCBJZGVudGl0eV0gQWRkaW5nIGF1dGhvcml6YXRpb24gaGVhZGVyIHRvIHRoZSByZXF1ZXN0LmApO1xyXG4gICAgICAgICAgICBuZXR3b3JrUmVxdWVzdC5oZWFkZXJzW01hbmFnZWRJZGVudGl0eUhlYWRlcnMuQVVUSE9SSVpBVElPTl9IRUFERVJfTkFNRV0gPSBhdXRoSGVhZGVyVmFsdWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXRyeVJlc3BvbnNlID1cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXR3b3JrQ2xpZW50LnNlbmRHZXRSZXF1ZXN0QXN5bmMobmV0d29ya1JlcXVlc3QuY29tcHV0ZVVyaSgpLCBuZXR3b3JrUmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXV0aEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVDbGllbnRBdXRoRXJyb3IoQ2xpZW50QXV0aEVycm9yQ29kZXMubmV0d29ya0Vycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2ZXJUb2tlblJlc3BvbnNlKHJldHJ5UmVzcG9uc2UgfHwgb3JpZ2luYWxSZXNwb25zZSk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQVJDX0FQSV9WRVJTSU9OLCBBWlVSRV9BUkNfRklMRV9ERVRFQ1RJT04sIEF6dXJlQXJjLCBERUZBVUxUX0FaVVJFX0FSQ19JREVOVElUWV9FTkRQT0lOVCwgU1VQUE9SVEVEX0FaVVJFX0FSQ19QTEFURk9STVMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF6dXJlQXJjLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyB9IGZyb20gJy4uLy4uL2NvbmZpZy9NYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycy5tanMnO1xuaW1wb3J0IHsgQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZSB9IGZyb20gJy4vQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLCBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcywgTWFuYWdlZElkZW50aXR5SWRUeXBlLCBNYW5hZ2VkSWRlbnRpdHlIZWFkZXJzLCBNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMsIEh0dHBNZXRob2QgfSBmcm9tICcuLi8uLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3IvTWFuYWdlZElkZW50aXR5RXJyb3IubWpzJztcbmltcG9ydCB7IHVuYWJsZVRvQ3JlYXRlQ2xvdWRTaGVsbCB9IGZyb20gJy4uLy4uL2Vycm9yL01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBPcmlnaW5hbCBzb3VyY2Ugb2YgY29kZTogaHR0cHM6Ly9naXRodWIuY29tL0F6dXJlL2F6dXJlLXNkay1mb3ItbmV0L2Jsb2IvbWFpbi9zZGsvaWRlbnRpdHkvQXp1cmUuSWRlbnRpdHkvc3JjL0Nsb3VkU2hlbGxNYW5hZ2VkSWRlbnRpdHlTb3VyY2UuY3NcclxuICovXHJcbmNsYXNzIENsb3VkU2hlbGwgZXh0ZW5kcyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzLCBtc2lFbmRwb2ludCkge1xyXG4gICAgICAgIHN1cGVyKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzKTtcclxuICAgICAgICB0aGlzLm1zaUVuZHBvaW50ID0gbXNpRW5kcG9pbnQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB7XHJcbiAgICAgICAgY29uc3QgbXNpRW5kcG9pbnQgPSBwcm9jZXNzLmVudltNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuTVNJX0VORFBPSU5UXTtcclxuICAgICAgICByZXR1cm4gW21zaUVuZHBvaW50XTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0cnlDcmVhdGUobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1hbmFnZWRJZGVudGl0eUlkKSB7XHJcbiAgICAgICAgY29uc3QgW21zaUVuZHBvaW50XSA9IENsb3VkU2hlbGwuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKTtcclxuICAgICAgICAvLyBpZiB0aGUgbXNpIGVuZHBvaW50IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhpcyBNU0kgcHJvdmlkZXIgaXMgdW5hdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKCFtc2lFbmRwb2ludCkge1xyXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQ0xPVURfU0hFTEx9IG1hbmFnZWQgaWRlbnRpdHkgaXMgdW5hdmFpbGFibGUgYmVjYXVzZSB0aGUgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLk1TSV9FTkRQT0lOVH0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGRlZmluZWQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRNc2lFbmRwb2ludCA9IENsb3VkU2hlbGwuZ2V0VmFsaWRhdGVkRW52VmFyaWFibGVVcmxTdHJpbmcoTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLk1TSV9FTkRQT0lOVCwgbXNpRW5kcG9pbnQsIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkNMT1VEX1NIRUxMLCBsb2dnZXIpO1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKGBbTWFuYWdlZCBJZGVudGl0eV0gRW52aXJvbm1lbnQgdmFyaWFibGUgdmFsaWRhdGlvbiBwYXNzZWQgZm9yICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQ0xPVURfU0hFTEx9IG1hbmFnZWQgaWRlbnRpdHkuIEVuZHBvaW50IFVSSTogJHt2YWxpZGF0ZWRNc2lFbmRwb2ludH0uIENyZWF0aW5nICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQ0xPVURfU0hFTEx9IG1hbmFnZWQgaWRlbnRpdHkuYCk7XHJcbiAgICAgICAgaWYgKG1hbmFnZWRJZGVudGl0eUlkLmlkVHlwZSAhPT0gTWFuYWdlZElkZW50aXR5SWRUeXBlLlNZU1RFTV9BU1NJR05FRCkge1xyXG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVNYW5hZ2VkSWRlbnRpdHlFcnJvcih1bmFibGVUb0NyZWF0ZUNsb3VkU2hlbGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENsb3VkU2hlbGwobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1zaUVuZHBvaW50KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVJlcXVlc3QocmVzb3VyY2UpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzKEh0dHBNZXRob2QuUE9TVCwgdGhpcy5tc2lFbmRwb2ludCk7XHJcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzW01hbmFnZWRJZGVudGl0eUhlYWRlcnMuTUVUQURBVEFfSEVBREVSX05BTUVdID0gXCJ0cnVlXCI7XHJcbiAgICAgICAgcmVxdWVzdC5ib2R5UGFyYW1ldGVyc1tNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMuUkVTT1VSQ0VdID1cclxuICAgICAgICAgICAgcmVzb3VyY2U7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQ2xvdWRTaGVsbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2xvdWRTaGVsbC5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEV4cG9uZW50aWFsUmV0cnlTdHJhdGVneSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW5FeHBvbmVudGlhbEJhY2tvZmYsIG1heEV4cG9uZW50aWFsQmFja29mZiwgZXhwb25lbnRpYWxEZWx0YUJhY2tvZmYpIHtcclxuICAgICAgICB0aGlzLm1pbkV4cG9uZW50aWFsQmFja29mZiA9IG1pbkV4cG9uZW50aWFsQmFja29mZjtcclxuICAgICAgICB0aGlzLm1heEV4cG9uZW50aWFsQmFja29mZiA9IG1heEV4cG9uZW50aWFsQmFja29mZjtcclxuICAgICAgICB0aGlzLmV4cG9uZW50aWFsRGVsdGFCYWNrb2ZmID0gZXhwb25lbnRpYWxEZWx0YUJhY2tvZmY7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGV4cG9uZW50aWFsIGRlbGF5IGJhc2VkIG9uIHRoZSBjdXJyZW50IHJldHJ5IGF0dGVtcHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRSZXRyeSAtIFRoZSBjdXJyZW50IHJldHJ5IGF0dGVtcHQgbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2FsY3VsYXRlZCBleHBvbmVudGlhbCBkZWxheSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlbGF5IGlzIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIGZvcm11bGE6XHJcbiAgICAgKiAtIElmIGBjdXJyZW50UmV0cnlgIGlzIDAsIGl0IHJldHVybnMgdGhlIG1pbmltdW0gYmFja29mZiB0aW1lLlxyXG4gICAgICogLSBPdGhlcndpc2UsIGl0IGNhbGN1bGF0ZXMgdGhlIGRlbGF5IGFzIHRoZSBtaW5pbXVtIG9mOlxyXG4gICAgICogICAtIGAoMl4oY3VycmVudFJldHJ5IC0gMSkpICogZGVsdGFCYWNrb2ZmYFxyXG4gICAgICogICAtIGBtYXhCYWNrb2ZmYFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBkZWxheSBpbmNyZWFzZXMgZXhwb25lbnRpYWxseSB3aXRoIGVhY2ggcmV0cnkgYXR0ZW1wdCxcclxuICAgICAqIGJ1dCBkb2VzIG5vdCBleGNlZWQgdGhlIG1heGltdW0gYmFja29mZiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVEZWxheShjdXJyZW50UmV0cnkpIHtcclxuICAgICAgICAvLyBBdHRlbXB0IDFcclxuICAgICAgICBpZiAoY3VycmVudFJldHJ5ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbkV4cG9uZW50aWFsQmFja29mZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXR0ZW1wdCAyK1xyXG4gICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCBjdXJyZW50UmV0cnkgLSAxKSAqIHRoaXMuZXhwb25lbnRpYWxEZWx0YUJhY2tvZmYsIHRoaXMubWF4RXhwb25lbnRpYWxCYWNrb2ZmKTtcclxuICAgICAgICByZXR1cm4gZXhwb25lbnRpYWxEZWxheTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBFeHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4cG9uZW50aWFsUmV0cnlTdHJhdGVneS5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgSHR0cFN0YXR1cyB9IGZyb20gJ0BhenVyZS9tc2FsLWNvbW1vbic7XG5pbXBvcnQgeyBFeHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kgfSBmcm9tICcuL0V4cG9uZW50aWFsUmV0cnlTdHJhdGVneS5tanMnO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgSFRUUF9TVEFUVVNfNDAwX0NPREVTX0ZPUl9FWFBPTkVOVElBTF9TVFJBVEVHWSA9IFtcclxuICAgIEh0dHBTdGF0dXMuTk9UX0ZPVU5ELFxyXG4gICAgSHR0cFN0YXR1cy5SRVFVRVNUX1RJTUVPVVQsXHJcbiAgICBIdHRwU3RhdHVzLkdPTkUsXHJcbiAgICBIdHRwU3RhdHVzLlRPT19NQU5ZX1JFUVVFU1RTLFxyXG5dO1xyXG5jb25zdCBFWFBPTkVOVElBTF9TVFJBVEVHWV9OVU1fUkVUUklFUyA9IDM7XHJcbmNvbnN0IExJTkVBUl9TVFJBVEVHWV9OVU1fUkVUUklFUyA9IDc7XHJcbmNvbnN0IE1JTl9FWFBPTkVOVElBTF9CQUNLT0ZGX01TID0gMTAwMDtcclxuY29uc3QgTUFYX0VYUE9ORU5USUFMX0JBQ0tPRkZfTVMgPSA0MDAwO1xyXG5jb25zdCBFWFBPTkVOVElBTF9ERUxUQV9CQUNLT0ZGX01TID0gMjAwMDtcclxuY29uc3QgSFRUUF9TVEFUVVNfR09ORV9SRVRSWV9BRlRFUl9NUyA9IDEwICogMTAwMDsgLy8gMTAgc2Vjb25kc1xyXG5jbGFzcyBJbWRzUmV0cnlQb2xpY3kge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5leHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kgPSBuZXcgRXhwb25lbnRpYWxSZXRyeVN0cmF0ZWd5KEltZHNSZXRyeVBvbGljeS5NSU5fRVhQT05FTlRJQUxfQkFDS09GRl9NUywgSW1kc1JldHJ5UG9saWN5Lk1BWF9FWFBPTkVOVElBTF9CQUNLT0ZGX01TLCBJbWRzUmV0cnlQb2xpY3kuRVhQT05FTlRJQUxfREVMVEFfQkFDS09GRl9NUyk7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICogdGhlc2UgYXJlIGRlZmluZWQgaGVyZSBhcyBzdGF0aWMgdmFyaWFibGVzIGRlc3BpdGUgYmVpbmcgZGVmaW5lZCBhcyBjb25zdGFudHMgb3V0c2lkZSBvZiB0aGVcclxuICAgICAqIGNsYXNzIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIG92ZXJyaWRkZW4gaW4gdGhlIHVuaXQgdGVzdHMgc28gdGhhdCB0aGUgdW5pdCB0ZXN0cyBydW4gZmFzdGVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgTUlOX0VYUE9ORU5USUFMX0JBQ0tPRkZfTVMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1JTl9FWFBPTkVOVElBTF9CQUNLT0ZGX01TO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBNQVhfRVhQT05FTlRJQUxfQkFDS09GRl9NUygpIHtcclxuICAgICAgICByZXR1cm4gTUFYX0VYUE9ORU5USUFMX0JBQ0tPRkZfTVM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IEVYUE9ORU5USUFMX0RFTFRBX0JBQ0tPRkZfTVMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEVYUE9ORU5USUFMX0RFTFRBX0JBQ0tPRkZfTVM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IEhUVFBfU1RBVFVTX0dPTkVfUkVUUllfQUZURVJfTVMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEhUVFBfU1RBVFVTX0dPTkVfUkVUUllfQUZURVJfTVM7XHJcbiAgICB9XHJcbiAgICBzZXQgaXNOZXdSZXF1ZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5faXNOZXdSZXF1ZXN0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhdXNlcyBleGVjdXRpb24gZm9yIGEgY2FsY3VsYXRlZCBkZWxheSBiZWZvcmUgcmV0cnlpbmcgYSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBodHRwU3RhdHVzQ29kZSAtIFRoZSBIVFRQIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZS5cclxuICAgICAqIEBwYXJhbSBjdXJyZW50UmV0cnkgLSBUaGUgY3VycmVudCByZXRyeSBhdHRlbXB0IG51bWJlci5cclxuICAgICAqIEBwYXJhbSByZXRyeUFmdGVySGVhZGVyIC0gVGhlIHZhbHVlIG9mIHRoZSBcInJldHJ5LWFmdGVyXCIgaGVhZGVyIGZyb20gdGhlIHJlc3BvbnNlLlxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIHJldHJ5IHNob3VsZCBiZSBhdHRlbXB0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHBhdXNlRm9yUmV0cnkoaHR0cFN0YXR1c0NvZGUsIGN1cnJlbnRSZXRyeSwgbG9nZ2VyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzTmV3UmVxdWVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc05ld1JlcXVlc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtYXhSZXRyaWVzIGJhc2VkIG9uIHRoZSBzdGF0dXMgY29kZSwgb25jZSBwZXIgcmVxdWVzdFxyXG4gICAgICAgICAgICB0aGlzLm1heFJldHJpZXMgPVxyXG4gICAgICAgICAgICAgICAgaHR0cFN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXMuR09ORVxyXG4gICAgICAgICAgICAgICAgICAgID8gTElORUFSX1NUUkFURUdZX05VTV9SRVRSSUVTXHJcbiAgICAgICAgICAgICAgICAgICAgOiBFWFBPTkVOVElBTF9TVFJBVEVHWV9OVU1fUkVUUklFUztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogKHN0YXR1cyBjb2RlIGlzIG9uZSBvZiB0aGUgcmV0cmlhYmxlIDQwMCBzdGF0dXMgY29kZVxyXG4gICAgICAgICAqIG9yXHJcbiAgICAgICAgICogc3RhdHVzIGNvZGUgaXMgPj0gNTAwIGFuZCA8PSA1OTkpXHJcbiAgICAgICAgICogYW5kXHJcbiAgICAgICAgICogY3VycmVudCBjb3VudCBvZiByZXRyaWVzIGlzIGxlc3MgdGhhbiB0aGUgbWF4IG51bWJlciBvZiByZXRyaWVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKChIVFRQX1NUQVRVU180MDBfQ09ERVNfRk9SX0VYUE9ORU5USUFMX1NUUkFURUdZLmluY2x1ZGVzKGh0dHBTdGF0dXNDb2RlKSB8fFxyXG4gICAgICAgICAgICAoaHR0cFN0YXR1c0NvZGUgPj0gSHR0cFN0YXR1cy5TRVJWRVJfRVJST1JfUkFOR0VfU1RBUlQgJiZcclxuICAgICAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlIDw9IEh0dHBTdGF0dXMuU0VSVkVSX0VSUk9SX1JBTkdFX0VORCAmJlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFJldHJ5IDwgdGhpcy5tYXhSZXRyaWVzKSkgJiZcclxuICAgICAgICAgICAgY3VycmVudFJldHJ5IDwgdGhpcy5tYXhSZXRyaWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJEZWxheSA9IGh0dHBTdGF0dXNDb2RlID09PSBIdHRwU3RhdHVzLkdPTkVcclxuICAgICAgICAgICAgICAgID8gSW1kc1JldHJ5UG9saWN5LkhUVFBfU1RBVFVTX0dPTkVfUkVUUllfQUZURVJfTVNcclxuICAgICAgICAgICAgICAgIDogdGhpcy5leHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kuY2FsY3VsYXRlRGVsYXkoY3VycmVudFJldHJ5KTtcclxuICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoYFJldHJ5aW5nIHJlcXVlc3QgaW4gJHtyZXRyeUFmdGVyRGVsYXl9bXMgKHJldHJ5IGF0dGVtcHQ6ICR7Y3VycmVudFJldHJ5ICsgMX0pYCk7XHJcbiAgICAgICAgICAgIC8vIHBhdXNlIGV4ZWN1dGlvbiBmb3IgdGhlIGNhbGN1bGF0ZWQgZGVsYXlcclxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5QWZ0ZXJEZWxheSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHN0YXR1cyBjb2RlIGlzIG5vdCByZXRyaWFibGUgb3IgbWF4IHJldHJpZXMgaGF2ZSBiZWVuIHJlYWNoZWQsIGRvIG5vdCByZXRyeVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBJbWRzUmV0cnlQb2xpY3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltZHNSZXRyeVBvbGljeS5tanMubWFwXG4iLCIvKiEgQGF6dXJlL21zYWwtbm9kZSB2My42LjAgMjAyNS0wNS0zMCAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9jb25maWcvTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMubWpzJztcbmltcG9ydCB7IEJhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2UgfSBmcm9tICcuL0Jhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2UubWpzJztcbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcywgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMsIE1hbmFnZWRJZGVudGl0eUhlYWRlcnMsIE1hbmFnZWRJZGVudGl0eVF1ZXJ5UGFyYW1ldGVycywgTWFuYWdlZElkZW50aXR5SWRUeXBlLCBIdHRwTWV0aG9kIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyBJbWRzUmV0cnlQb2xpY3kgfSBmcm9tICcuLi8uLi9yZXRyeS9JbWRzUmV0cnlQb2xpY3kubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8vIERvY3VtZW50YXRpb24gZm9yIElNRFMgaXMgYXZhaWxhYmxlIGF0IGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2F6dXJlL2FjdGl2ZS1kaXJlY3RvcnkvbWFuYWdlZC1pZGVudGl0aWVzLWF6dXJlLXJlc291cmNlcy9ob3ctdG8tdXNlLXZtLXRva2VuI2dldC1hLXRva2VuLXVzaW5nLWh0dHBcclxuY29uc3QgSU1EU19UT0tFTl9QQVRIID0gXCIvbWV0YWRhdGEvaWRlbnRpdHkvb2F1dGgyL3Rva2VuXCI7XHJcbmNvbnN0IERFRkFVTFRfSU1EU19FTkRQT0lOVCA9IGBodHRwOi8vMTY5LjI1NC4xNjkuMjU0JHtJTURTX1RPS0VOX1BBVEh9YDtcclxuY29uc3QgSU1EU19BUElfVkVSU0lPTiA9IFwiMjAxOC0wMi0wMVwiO1xyXG4vKipcclxuICogT3JpZ2luYWwgc291cmNlIG9mIGNvZGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BenVyZS9henVyZS1zZGstZm9yLW5ldC9ibG9iL21haW4vc2RrL2lkZW50aXR5L0F6dXJlLklkZW50aXR5L3NyYy9JbWRzTWFuYWdlZElkZW50aXR5U291cmNlLmNzXHJcbiAqL1xyXG5jbGFzcyBJbWRzIGV4dGVuZHMgQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYW4gSW1kcyBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBsb2dnZXIgLSBMb2dnZXIgaW5zdGFuY2UgZm9yIGxvZ2dpbmcuXHJcbiAgICAgKiBAcGFyYW0gbm9kZVN0b3JhZ2UgLSBOb2RlU3RvcmFnZSBpbnN0YW5jZSBmb3IgY2FjaGluZy5cclxuICAgICAqIEBwYXJhbSBuZXR3b3JrQ2xpZW50IC0gTmV0d29yayBjbGllbnQgZm9yIEhUVFAgcmVxdWVzdHMuXHJcbiAgICAgKiBAcGFyYW0gY3J5cHRvUHJvdmlkZXIgLSBDcnlwdG9Qcm92aWRlciBmb3IgY3J5cHRvZ3JhcGhpYyBvcGVyYXRpb25zLlxyXG4gICAgICogQHBhcmFtIGRpc2FibGVJbnRlcm5hbFJldHJpZXMgLSBXaGV0aGVyIHRvIGRpc2FibGUgaW50ZXJuYWwgcmV0cnkgbG9naWMuXHJcbiAgICAgKiBAcGFyYW0gaWRlbnRpdHlFbmRwb2ludCAtIFRoZSBJTURTIGVuZHBvaW50IHRvIHVzZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIGlkZW50aXR5RW5kcG9pbnQpIHtcclxuICAgICAgICBzdXBlcihsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcyk7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eUVuZHBvaW50ID0gaWRlbnRpdHlFbmRwb2ludDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gY3JlYXRlIGFuIEltZHMgaW5zdGFuY2UgYnkgZGV0ZXJtaW5pbmcgdGhlIGNvcnJlY3QgZW5kcG9pbnQuXHJcbiAgICAgKiBJZiB0aGUgQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NUIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHNldCwgaXQgdXNlcyB0aGF0IGFzIHRoZSBlbmRwb2ludC5cclxuICAgICAqIE90aGVyd2lzZSwgaXQgZmFsbHMgYmFjayB0byB0aGUgZGVmYXVsdCBJTURTIGVuZHBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2dnZXIgLSBMb2dnZXIgaW5zdGFuY2UgZm9yIGxvZ2dpbmcuXHJcbiAgICAgKiBAcGFyYW0gbm9kZVN0b3JhZ2UgLSBOb2RlU3RvcmFnZSBpbnN0YW5jZSBmb3IgY2FjaGluZy5cclxuICAgICAqIEBwYXJhbSBuZXR3b3JrQ2xpZW50IC0gTmV0d29yayBjbGllbnQgZm9yIEhUVFAgcmVxdWVzdHMuXHJcbiAgICAgKiBAcGFyYW0gY3J5cHRvUHJvdmlkZXIgLSBDcnlwdG9Qcm92aWRlciBmb3IgY3J5cHRvZ3JhcGhpYyBvcGVyYXRpb25zLlxyXG4gICAgICogQHBhcmFtIGRpc2FibGVJbnRlcm5hbFJldHJpZXMgLSBXaGV0aGVyIHRvIGRpc2FibGUgaW50ZXJuYWwgcmV0cnkgbG9naWMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBJbWRzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgZW5kcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cnlDcmVhdGUobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMpIHtcclxuICAgICAgICBsZXQgdmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludDtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzXHJcbiAgICAgICAgICAgIC5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RdKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBbTWFuYWdlZCBJZGVudGl0eV0gRW52aXJvbm1lbnQgdmFyaWFibGUgJHtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NUfSBmb3IgJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5JTURTfSByZXR1cm5lZCBlbmRwb2ludDogJHtwcm9jZXNzLmVudltNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXNcclxuICAgICAgICAgICAgICAgIC5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RdfWApO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50ID0gSW1kcy5nZXRWYWxpZGF0ZWRFbnZWYXJpYWJsZVVybFN0cmluZyhNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuQVpVUkVfUE9EX0lERU5USVRZX0FVVEhPUklUWV9IT1NULCBgJHtwcm9jZXNzLmVudltNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXNcclxuICAgICAgICAgICAgICAgIC5BWlVSRV9QT0RfSURFTlRJVFlfQVVUSE9SSVRZX0hPU1RdfSR7SU1EU19UT0tFTl9QQVRIfWAsIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLklNRFMsIGxvZ2dlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldIFVuYWJsZSB0byBmaW5kICR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLkFaVVJFX1BPRF9JREVOVElUWV9BVVRIT1JJVFlfSE9TVH0gZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuSU1EU30sIHVzaW5nIHRoZSBkZWZhdWx0IGVuZHBvaW50LmApO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50ID0gREVGQVVMVF9JTURTX0VORFBPSU5UO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEltZHMobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIHZhbGlkYXRlZElkZW50aXR5RW5kcG9pbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgb2JqZWN0IGZvciBhY3F1aXJpbmcgYSB0b2tlbiBmcm9tIElNRFMuXHJcbiAgICAgKiBTZXRzIHRoZSByZXF1aXJlZCBoZWFkZXJzIGFuZCBxdWVyeSBwYXJhbWV0ZXJzIGZvciB0aGUgSU1EUyB0b2tlbiByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXNvdXJjZSAtIFRoZSByZXNvdXJjZSBVUkkgZm9yIHdoaWNoIHRoZSB0b2tlbiBpcyByZXF1ZXN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gbWFuYWdlZElkZW50aXR5SWQgLSBUaGUgbWFuYWdlZCBpZGVudGl0eSBJRCAoc3lzdGVtLWFzc2lnbmVkIG9yIHVzZXItYXNzaWduZWQpLlxyXG4gICAgICogQHJldHVybnMgQSBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyBvYmplY3QgY29uZmlndXJlZCBmb3IgSU1EUy5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlUmVxdWVzdChyZXNvdXJjZSwgbWFuYWdlZElkZW50aXR5SWQpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbWV0ZXJzKEh0dHBNZXRob2QuR0VULCB0aGlzLmlkZW50aXR5RW5kcG9pbnQpO1xyXG4gICAgICAgIHJlcXVlc3QuaGVhZGVyc1tNYW5hZ2VkSWRlbnRpdHlIZWFkZXJzLk1FVEFEQVRBX0hFQURFUl9OQU1FXSA9IFwidHJ1ZVwiO1xyXG4gICAgICAgIHJlcXVlc3QucXVlcnlQYXJhbWV0ZXJzW01hbmFnZWRJZGVudGl0eVF1ZXJ5UGFyYW1ldGVycy5BUElfVkVSU0lPTl0gPVxyXG4gICAgICAgICAgICBJTURTX0FQSV9WRVJTSU9OO1xyXG4gICAgICAgIHJlcXVlc3QucXVlcnlQYXJhbWV0ZXJzW01hbmFnZWRJZGVudGl0eVF1ZXJ5UGFyYW1ldGVycy5SRVNPVVJDRV0gPVxyXG4gICAgICAgICAgICByZXNvdXJjZTtcclxuICAgICAgICBpZiAobWFuYWdlZElkZW50aXR5SWQuaWRUeXBlICE9PSBNYW5hZ2VkSWRlbnRpdHlJZFR5cGUuU1lTVEVNX0FTU0lHTkVEKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucXVlcnlQYXJhbWV0ZXJzW3RoaXMuZ2V0TWFuYWdlZElkZW50aXR5VXNlckFzc2lnbmVkSWRRdWVyeVBhcmFtZXRlcktleShtYW5hZ2VkSWRlbnRpdHlJZC5pZFR5cGUsIHRydWUgLy8gaW5kaWNhdGVzIHNvdXJjZSBpcyBJTURTXHJcbiAgICAgICAgICAgICldID0gbWFuYWdlZElkZW50aXR5SWQuaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBib2R5UGFyYW1ldGVycyBhcmUgY2FsY3VsYXRlZCBpbiBCYXNlTWFuYWdlZElkZW50aXR5LmFjcXVpcmVUb2tlbldpdGhNYW5hZ2VkSWRlbnRpdHkuXHJcbiAgICAgICAgcmVxdWVzdC5yZXRyeVBvbGljeSA9IG5ldyBJbWRzUmV0cnlQb2xpY3koKTtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBJbWRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWRzLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyB9IGZyb20gJy4uLy4uL2NvbmZpZy9NYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycy5tanMnO1xuaW1wb3J0IHsgQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZSB9IGZyb20gJy4vQmFzZU1hbmFnZWRJZGVudGl0eVNvdXJjZS5tanMnO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLCBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcywgTWFuYWdlZElkZW50aXR5SWRUeXBlLCBNYW5hZ2VkSWRlbnRpdHlIZWFkZXJzLCBNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMsIEh0dHBNZXRob2QgfSBmcm9tICcuLi8uLi91dGlscy9Db25zdGFudHMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFNFUlZJQ0VfRkFCUklDX01TSV9BUElfVkVSU0lPTiA9IFwiMjAxOS0wNy0wMS1wcmV2aWV3XCI7XHJcbi8qKlxyXG4gKiBPcmlnaW5hbCBzb3VyY2Ugb2YgY29kZTogaHR0cHM6Ly9naXRodWIuY29tL0F6dXJlL2F6dXJlLXNkay1mb3ItbmV0L2Jsb2IvbWFpbi9zZGsvaWRlbnRpdHkvQXp1cmUuSWRlbnRpdHkvc3JjL1NlcnZpY2VGYWJyaWNNYW5hZ2VkSWRlbnRpdHlTb3VyY2UuY3NcclxuICovXHJcbmNsYXNzIFNlcnZpY2VGYWJyaWMgZXh0ZW5kcyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBTZXJ2aWNlRmFicmljIG1hbmFnZWQgaWRlbnRpdHkgc291cmNlLlxyXG4gICAgICogQHBhcmFtIGxvZ2dlciBMb2dnZXIgaW5zdGFuY2UgZm9yIGxvZ2dpbmdcclxuICAgICAqIEBwYXJhbSBub2RlU3RvcmFnZSBOb2RlU3RvcmFnZSBpbnN0YW5jZSBmb3IgY2FjaGluZ1xyXG4gICAgICogQHBhcmFtIG5ldHdvcmtDbGllbnQgTmV0d29yayBjbGllbnQgZm9yIEhUVFAgcmVxdWVzdHNcclxuICAgICAqIEBwYXJhbSBjcnlwdG9Qcm92aWRlciBDcnlwdG8gcHJvdmlkZXIgZm9yIGNyeXB0b2dyYXBoaWMgb3BlcmF0aW9uc1xyXG4gICAgICogQHBhcmFtIGRpc2FibGVJbnRlcm5hbFJldHJpZXMgV2hldGhlciB0byBkaXNhYmxlIGludGVybmFsIHJldHJ5IGxvZ2ljXHJcbiAgICAgKiBAcGFyYW0gaWRlbnRpdHlFbmRwb2ludCBUaGUgU2VydmljZSBGYWJyaWMgbWFuYWdlZCBpZGVudGl0eSBlbmRwb2ludFxyXG4gICAgICogQHBhcmFtIGlkZW50aXR5SGVhZGVyIFRoZSBTZXJ2aWNlIEZhYnJpYyBtYW5hZ2VkIGlkZW50aXR5IHNlY3JldCBoZWFkZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIGlkZW50aXR5RW5kcG9pbnQsIGlkZW50aXR5SGVhZGVyKSB7XHJcbiAgICAgICAgc3VwZXIobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMpO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpdHlFbmRwb2ludCA9IGlkZW50aXR5RW5kcG9pbnQ7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eUhlYWRlciA9IGlkZW50aXR5SGVhZGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyByZXF1aXJlZCBmb3IgU2VydmljZSBGYWJyaWMgbWFuYWdlZCBpZGVudGl0eS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGlkZW50aXR5IGVuZHBvaW50LCBpZGVudGl0eSBoZWFkZXIsIGFuZCBpZGVudGl0eSBzZXJ2ZXIgdGh1bWJwcmludC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEVudmlyb25tZW50VmFyaWFibGVzKCkge1xyXG4gICAgICAgIGNvbnN0IGlkZW50aXR5RW5kcG9pbnQgPSBwcm9jZXNzLmVudltNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfRU5EUE9JTlRdO1xyXG4gICAgICAgIGNvbnN0IGlkZW50aXR5SGVhZGVyID0gcHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLklERU5USVRZX0hFQURFUl07XHJcbiAgICAgICAgY29uc3QgaWRlbnRpdHlTZXJ2ZXJUaHVtYnByaW50ID0gcHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzXHJcbiAgICAgICAgICAgIC5JREVOVElUWV9TRVJWRVJfVEhVTUJQUklOVF07XHJcbiAgICAgICAgcmV0dXJuIFtpZGVudGl0eUVuZHBvaW50LCBpZGVudGl0eUhlYWRlciwgaWRlbnRpdHlTZXJ2ZXJUaHVtYnByaW50XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gY3JlYXRlIGEgU2VydmljZUZhYnJpYyBtYW5hZ2VkIGlkZW50aXR5IHNvdXJjZSBpZiBhbGwgcmVxdWlyZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSBwcmVzZW50LlxyXG4gICAgICogQHBhcmFtIGxvZ2dlciBMb2dnZXIgaW5zdGFuY2UgZm9yIGxvZ2dpbmdcclxuICAgICAqIEBwYXJhbSBub2RlU3RvcmFnZSBOb2RlU3RvcmFnZSBpbnN0YW5jZSBmb3IgY2FjaGluZ1xyXG4gICAgICogQHBhcmFtIG5ldHdvcmtDbGllbnQgTmV0d29yayBjbGllbnQgZm9yIEhUVFAgcmVxdWVzdHNcclxuICAgICAqIEBwYXJhbSBjcnlwdG9Qcm92aWRlciBDcnlwdG8gcHJvdmlkZXIgZm9yIGNyeXB0b2dyYXBoaWMgb3BlcmF0aW9uc1xyXG4gICAgICogQHBhcmFtIGRpc2FibGVJbnRlcm5hbFJldHJpZXMgV2hldGhlciB0byBkaXNhYmxlIGludGVybmFsIHJldHJ5IGxvZ2ljXHJcbiAgICAgKiBAcGFyYW0gbWFuYWdlZElkZW50aXR5SWQgTWFuYWdlZCBpZGVudGl0eSBpZGVudGlmaWVyXHJcbiAgICAgKiBAcmV0dXJucyBBIFNlcnZpY2VGYWJyaWMgaW5zdGFuY2UgaWYgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSBzZXQsIG90aGVyd2lzZSBudWxsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cnlDcmVhdGUobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1hbmFnZWRJZGVudGl0eUlkKSB7XHJcbiAgICAgICAgY29uc3QgW2lkZW50aXR5RW5kcG9pbnQsIGlkZW50aXR5SGVhZGVyLCBpZGVudGl0eVNlcnZlclRodW1icHJpbnRdID0gU2VydmljZUZhYnJpYy5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpO1xyXG4gICAgICAgIGlmICghaWRlbnRpdHlFbmRwb2ludCB8fCAhaWRlbnRpdHlIZWFkZXIgfHwgIWlkZW50aXR5U2VydmVyVGh1bWJwcmludCkge1xyXG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgW01hbmFnZWQgSWRlbnRpdHldICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuU0VSVklDRV9GQUJSSUN9IG1hbmFnZWQgaWRlbnRpdHkgaXMgdW5hdmFpbGFibGUgYmVjYXVzZSBvbmUgb3IgYWxsIG9mIHRoZSAnJHtNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfSEVBREVSfScsICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JREVOVElUWV9FTkRQT0lOVH0nIG9yICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5JREVOVElUWV9TRVJWRVJfVEhVTUJQUklOVH0nIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgbm90IGRlZmluZWQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRJZGVudGl0eUVuZHBvaW50ID0gU2VydmljZUZhYnJpYy5nZXRWYWxpZGF0ZWRFbnZWYXJpYWJsZVVybFN0cmluZyhNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMuSURFTlRJVFlfRU5EUE9JTlQsIGlkZW50aXR5RW5kcG9pbnQsIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLlNFUlZJQ0VfRkFCUklDLCBsb2dnZXIpO1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKGBbTWFuYWdlZCBJZGVudGl0eV0gRW52aXJvbm1lbnQgdmFyaWFibGVzIHZhbGlkYXRpb24gcGFzc2VkIGZvciAke01hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLlNFUlZJQ0VfRkFCUklDfSBtYW5hZ2VkIGlkZW50aXR5LiBFbmRwb2ludCBVUkk6ICR7dmFsaWRhdGVkSWRlbnRpdHlFbmRwb2ludH0uIENyZWF0aW5nICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuU0VSVklDRV9GQUJSSUN9IG1hbmFnZWQgaWRlbnRpdHkuYCk7XHJcbiAgICAgICAgaWYgKG1hbmFnZWRJZGVudGl0eUlkLmlkVHlwZSAhPT0gTWFuYWdlZElkZW50aXR5SWRUeXBlLlNZU1RFTV9BU1NJR05FRCkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybmluZyhgW01hbmFnZWQgSWRlbnRpdHldICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuU0VSVklDRV9GQUJSSUN9IHVzZXIgYXNzaWduZWQgbWFuYWdlZCBpZGVudGl0eSBpcyBjb25maWd1cmVkIGluIHRoZSBjbHVzdGVyLCBub3QgZHVyaW5nIHJ1bnRpbWUuIFNlZSBhbHNvOiBodHRwczovL2xlYXJuLm1pY3Jvc29mdC5jb20vZW4tdXMvYXp1cmUvc2VydmljZS1mYWJyaWMvY29uZmlndXJlLWV4aXN0aW5nLWNsdXN0ZXItZW5hYmxlLW1hbmFnZWQtaWRlbnRpdHktdG9rZW4tc2VydmljZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2aWNlRmFicmljKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzLCBpZGVudGl0eUVuZHBvaW50LCBpZGVudGl0eUhlYWRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHJlcXVlc3QgcGFyYW1ldGVycyBmb3IgYWNxdWlyaW5nIGEgdG9rZW4gZnJvbSB0aGUgU2VydmljZSBGYWJyaWMgY2x1c3Rlci5cclxuICAgICAqIEBwYXJhbSByZXNvdXJjZSAtIFRoZSByZXNvdXJjZSBVUkkgZm9yIHdoaWNoIHRoZSB0b2tlbiBpcyByZXF1ZXN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gbWFuYWdlZElkZW50aXR5SWQgLSBUaGUgbWFuYWdlZCBpZGVudGl0eSBJRCAoc3lzdGVtLWFzc2lnbmVkIG9yIHVzZXItYXNzaWduZWQpLlxyXG4gICAgICogQHJldHVybnMgQSBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyBvYmplY3QgY29uZmlndXJlZCBmb3IgU2VydmljZSBGYWJyaWMuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVJlcXVlc3QocmVzb3VyY2UsIG1hbmFnZWRJZGVudGl0eUlkKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyhIdHRwTWV0aG9kLkdFVCwgdGhpcy5pZGVudGl0eUVuZHBvaW50KTtcclxuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbTWFuYWdlZElkZW50aXR5SGVhZGVycy5NTF9BTkRfU0ZfU0VDUkVUX0hFQURFUl9OQU1FXSA9XHJcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpdHlIZWFkZXI7XHJcbiAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbTWFuYWdlZElkZW50aXR5UXVlcnlQYXJhbWV0ZXJzLkFQSV9WRVJTSU9OXSA9XHJcbiAgICAgICAgICAgIFNFUlZJQ0VfRkFCUklDX01TSV9BUElfVkVSU0lPTjtcclxuICAgICAgICByZXF1ZXN0LnF1ZXJ5UGFyYW1ldGVyc1tNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMuUkVTT1VSQ0VdID1cclxuICAgICAgICAgICAgcmVzb3VyY2U7XHJcbiAgICAgICAgaWYgKG1hbmFnZWRJZGVudGl0eUlkLmlkVHlwZSAhPT0gTWFuYWdlZElkZW50aXR5SWRUeXBlLlNZU1RFTV9BU1NJR05FRCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnF1ZXJ5UGFyYW1ldGVyc1t0aGlzLmdldE1hbmFnZWRJZGVudGl0eVVzZXJBc3NpZ25lZElkUXVlcnlQYXJhbWV0ZXJLZXkobWFuYWdlZElkZW50aXR5SWQuaWRUeXBlKV0gPSBtYW5hZ2VkSWRlbnRpdHlJZC5pZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm9keVBhcmFtZXRlcnMgY2FsY3VsYXRlZCBpbiBCYXNlTWFuYWdlZElkZW50aXR5LmFjcXVpcmVUb2tlbldpdGhNYW5hZ2VkSWRlbnRpdHlcclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBTZXJ2aWNlRmFicmljIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXJ2aWNlRmFicmljLm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBCYXNlTWFuYWdlZElkZW50aXR5U291cmNlIH0gZnJvbSAnLi9CYXNlTWFuYWdlZElkZW50aXR5U291cmNlLm1qcyc7XG5pbXBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlFbnZpcm9ubWVudFZhcmlhYmxlTmFtZXMsIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLCBNYW5hZ2VkSWRlbnRpdHlIZWFkZXJzLCBNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMsIE1hbmFnZWRJZGVudGl0eUlkVHlwZSwgSHR0cE1ldGhvZCB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbnN0YW50cy5tanMnO1xuaW1wb3J0IHsgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9jb25maWcvTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtZXRlcnMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IE1BQ0hJTkVfTEVBUk5JTkdfTVNJX0FQSV9WRVJTSU9OID0gXCIyMDE3LTA5LTAxXCI7XHJcbmNsYXNzIE1hY2hpbmVMZWFybmluZyBleHRlbmRzIEJhc2VNYW5hZ2VkSWRlbnRpdHlTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1zaUVuZHBvaW50LCBzZWNyZXQpIHtcclxuICAgICAgICBzdXBlcihsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcyk7XHJcbiAgICAgICAgdGhpcy5tc2lFbmRwb2ludCA9IG1zaUVuZHBvaW50O1xyXG4gICAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEVudmlyb25tZW50VmFyaWFibGVzKCkge1xyXG4gICAgICAgIGNvbnN0IG1zaUVuZHBvaW50ID0gcHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLk1TSV9FTkRQT0lOVF07XHJcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcHJvY2Vzcy5lbnZbTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLk1TSV9TRUNSRVRdO1xyXG4gICAgICAgIHJldHVybiBbbXNpRW5kcG9pbnQsIHNlY3JldF07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdHJ5Q3JlYXRlKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzKSB7XHJcbiAgICAgICAgY29uc3QgW21zaUVuZHBvaW50LCBzZWNyZXRdID0gTWFjaGluZUxlYXJuaW5nLmdldEVudmlyb25tZW50VmFyaWFibGVzKCk7XHJcbiAgICAgICAgLy8gaWYgZWl0aGVyIG9mIHRoZSBNU0kgZW5kcG9pbnQgb3IgTVNJIHNlY3JldCB2YXJpYWJsZXMgYXJlIHVuZGVmaW5lZCwgdGhpcyBNU0kgcHJvdmlkZXIgaXMgdW5hdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKCFtc2lFbmRwb2ludCB8fCAhc2VjcmV0KSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBbTWFuYWdlZCBJZGVudGl0eV0gJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5NQUNISU5FX0xFQVJOSU5HfSBtYW5hZ2VkIGlkZW50aXR5IGlzIHVuYXZhaWxhYmxlIGJlY2F1c2Ugb25lIG9yIGJvdGggb2YgdGhlICcke01hbmFnZWRJZGVudGl0eUVudmlyb25tZW50VmFyaWFibGVOYW1lcy5NU0lfRU5EUE9JTlR9JyBhbmQgJyR7TWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLk1TSV9TRUNSRVR9JyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIG5vdCBkZWZpbmVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkTXNpRW5kcG9pbnQgPSBNYWNoaW5lTGVhcm5pbmcuZ2V0VmFsaWRhdGVkRW52VmFyaWFibGVVcmxTdHJpbmcoTWFuYWdlZElkZW50aXR5RW52aXJvbm1lbnRWYXJpYWJsZU5hbWVzLk1TSV9FTkRQT0lOVCwgbXNpRW5kcG9pbnQsIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLk1BQ0hJTkVfTEVBUk5JTkcsIGxvZ2dlcik7XHJcbiAgICAgICAgbG9nZ2VyLmluZm8oYFtNYW5hZ2VkIElkZW50aXR5XSBFbnZpcm9ubWVudCB2YXJpYWJsZXMgdmFsaWRhdGlvbiBwYXNzZWQgZm9yICR7TWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuTUFDSElORV9MRUFSTklOR30gbWFuYWdlZCBpZGVudGl0eS4gRW5kcG9pbnQgVVJJOiAke3ZhbGlkYXRlZE1zaUVuZHBvaW50fS4gQ3JlYXRpbmcgJHtNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5NQUNISU5FX0xFQVJOSU5HfSBtYW5hZ2VkIGlkZW50aXR5LmApO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFjaGluZUxlYXJuaW5nKGxvZ2dlciwgbm9kZVN0b3JhZ2UsIG5ldHdvcmtDbGllbnQsIGNyeXB0b1Byb3ZpZGVyLCBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzLCBtc2lFbmRwb2ludCwgc2VjcmV0KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVJlcXVlc3QocmVzb3VyY2UsIG1hbmFnZWRJZGVudGl0eUlkKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBNYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1ldGVycyhIdHRwTWV0aG9kLkdFVCwgdGhpcy5tc2lFbmRwb2ludCk7XHJcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzW01hbmFnZWRJZGVudGl0eUhlYWRlcnMuTUVUQURBVEFfSEVBREVSX05BTUVdID0gXCJ0cnVlXCI7XHJcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzW01hbmFnZWRJZGVudGl0eUhlYWRlcnMuTUxfQU5EX1NGX1NFQ1JFVF9IRUFERVJfTkFNRV0gPVxyXG4gICAgICAgICAgICB0aGlzLnNlY3JldDtcclxuICAgICAgICByZXF1ZXN0LnF1ZXJ5UGFyYW1ldGVyc1tNYW5hZ2VkSWRlbnRpdHlRdWVyeVBhcmFtZXRlcnMuQVBJX1ZFUlNJT05dID1cclxuICAgICAgICAgICAgTUFDSElORV9MRUFSTklOR19NU0lfQVBJX1ZFUlNJT047XHJcbiAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbTWFuYWdlZElkZW50aXR5UXVlcnlQYXJhbWV0ZXJzLlJFU09VUkNFXSA9XHJcbiAgICAgICAgICAgIHJlc291cmNlO1xyXG4gICAgICAgIGlmIChtYW5hZ2VkSWRlbnRpdHlJZC5pZFR5cGUgIT09IE1hbmFnZWRJZGVudGl0eUlkVHlwZS5TWVNURU1fQVNTSUdORUQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5xdWVyeVBhcmFtZXRlcnNbdGhpcy5nZXRNYW5hZ2VkSWRlbnRpdHlVc2VyQXNzaWduZWRJZFF1ZXJ5UGFyYW1ldGVyS2V5KG1hbmFnZWRJZGVudGl0eUlkLmlkVHlwZSwgZmFsc2UsIC8vIGlzSU1EU1xyXG4gICAgICAgICAgICB0cnVlIC8vIHVzZXMyMDE3QVBJXHJcbiAgICAgICAgICAgICldID0gbWFuYWdlZElkZW50aXR5SWQuaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvZHlQYXJhbWV0ZXJzIGNhbGN1bGF0ZWQgaW4gQmFzZU1hbmFnZWRJZGVudGl0eS5hY3F1aXJlVG9rZW5XaXRoTWFuYWdlZElkZW50aXR5XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTWFjaGluZUxlYXJuaW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYWNoaW5lTGVhcm5pbmcubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IEFwcFNlcnZpY2UgfSBmcm9tICcuL01hbmFnZWRJZGVudGl0eVNvdXJjZXMvQXBwU2VydmljZS5tanMnO1xuaW1wb3J0IHsgQXp1cmVBcmMgfSBmcm9tICcuL01hbmFnZWRJZGVudGl0eVNvdXJjZXMvQXp1cmVBcmMubWpzJztcbmltcG9ydCB7IENsb3VkU2hlbGwgfSBmcm9tICcuL01hbmFnZWRJZGVudGl0eVNvdXJjZXMvQ2xvdWRTaGVsbC5tanMnO1xuaW1wb3J0IHsgSW1kcyB9IGZyb20gJy4vTWFuYWdlZElkZW50aXR5U291cmNlcy9JbWRzLm1qcyc7XG5pbXBvcnQgeyBTZXJ2aWNlRmFicmljIH0gZnJvbSAnLi9NYW5hZ2VkSWRlbnRpdHlTb3VyY2VzL1NlcnZpY2VGYWJyaWMubWpzJztcbmltcG9ydCB7IGNyZWF0ZU1hbmFnZWRJZGVudGl0eUVycm9yIH0gZnJvbSAnLi4vZXJyb3IvTWFuYWdlZElkZW50aXR5RXJyb3IubWpzJztcbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzIH0gZnJvbSAnLi4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgeyBNYWNoaW5lTGVhcm5pbmcgfSBmcm9tICcuL01hbmFnZWRJZGVudGl0eVNvdXJjZXMvTWFjaGluZUxlYXJuaW5nLm1qcyc7XG5pbXBvcnQgeyB1bmFibGVUb0NyZWF0ZVNvdXJjZSB9IGZyb20gJy4uL2Vycm9yL01hbmFnZWRJZGVudGl0eUVycm9yQ29kZXMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbi8qXHJcbiAqIENsYXNzIHRvIGluaXRpYWxpemUgYSBtYW5hZ2VkIGlkZW50aXR5IGFuZCBpZGVudGlmeSB0aGUgc2VydmljZS5cclxuICogT3JpZ2luYWwgc291cmNlIG9mIGNvZGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BenVyZS9henVyZS1zZGstZm9yLW5ldC9ibG9iL21haW4vc2RrL2lkZW50aXR5L0F6dXJlLklkZW50aXR5L3NyYy9NYW5hZ2VkSWRlbnRpdHlDbGllbnQuY3NcclxuICovXHJcbmNsYXNzIE1hbmFnZWRJZGVudGl0eUNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcykge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgICAgIHRoaXMubm9kZVN0b3JhZ2UgPSBub2RlU3RvcmFnZTtcclxuICAgICAgICB0aGlzLm5ldHdvcmtDbGllbnQgPSBuZXR3b3JrQ2xpZW50O1xyXG4gICAgICAgIHRoaXMuY3J5cHRvUHJvdmlkZXIgPSBjcnlwdG9Qcm92aWRlcjtcclxuICAgICAgICB0aGlzLmRpc2FibGVJbnRlcm5hbFJldHJpZXMgPSBkaXNhYmxlSW50ZXJuYWxSZXRyaWVzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZE1hbmFnZWRJZGVudGl0eVRva2VuUmVxdWVzdChtYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0LCBtYW5hZ2VkSWRlbnRpdHlJZCwgZmFrZUF1dGhvcml0eSwgcmVmcmVzaEFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgaWYgKCFNYW5hZ2VkSWRlbnRpdHlDbGllbnQuaWRlbnRpdHlTb3VyY2UpIHtcclxuICAgICAgICAgICAgTWFuYWdlZElkZW50aXR5Q2xpZW50LmlkZW50aXR5U291cmNlID1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0TWFuYWdlZElkZW50aXR5U291cmNlKHRoaXMubG9nZ2VyLCB0aGlzLm5vZGVTdG9yYWdlLCB0aGlzLm5ldHdvcmtDbGllbnQsIHRoaXMuY3J5cHRvUHJvdmlkZXIsIHRoaXMuZGlzYWJsZUludGVybmFsUmV0cmllcywgbWFuYWdlZElkZW50aXR5SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWFuYWdlZElkZW50aXR5Q2xpZW50LmlkZW50aXR5U291cmNlLmFjcXVpcmVUb2tlbldpdGhNYW5hZ2VkSWRlbnRpdHkobWFuYWdlZElkZW50aXR5UmVxdWVzdCwgbWFuYWdlZElkZW50aXR5SWQsIGZha2VBdXRob3JpdHksIHJlZnJlc2hBY2Nlc3NUb2tlbik7XHJcbiAgICB9XHJcbiAgICBhbGxFbnZpcm9ubWVudFZhcmlhYmxlc0FyZURlZmluZWQoZW52aXJvbm1lbnRWYXJpYWJsZXMpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhlbnZpcm9ubWVudFZhcmlhYmxlcykuZXZlcnkoKGVudmlyb25tZW50VmFyaWFibGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudmlyb25tZW50VmFyaWFibGUgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lIHRoZSBNYW5hZ2VkIElkZW50aXR5IFNvdXJjZSBiYXNlZCBvbiBhdmFpbGFibGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBUaGlzIEFQSSBpcyBjb25zdW1lZCBieSBNYW5hZ2VkSWRlbnRpdHlBcHBsaWNhdGlvbidzIGdldE1hbmFnZWRJZGVudGl0eVNvdXJjZS5cclxuICAgICAqIEByZXR1cm5zIE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzIC0gVGhlIE1hbmFnZWQgSWRlbnRpdHkgc291cmNlJ3MgbmFtZVxyXG4gICAgICovXHJcbiAgICBnZXRNYW5hZ2VkSWRlbnRpdHlTb3VyY2UoKSB7XHJcbiAgICAgICAgTWFuYWdlZElkZW50aXR5Q2xpZW50LnNvdXJjZU5hbWUgPVxyXG4gICAgICAgICAgICB0aGlzLmFsbEVudmlyb25tZW50VmFyaWFibGVzQXJlRGVmaW5lZChTZXJ2aWNlRmFicmljLmdldEVudmlyb25tZW50VmFyaWFibGVzKCkpXHJcbiAgICAgICAgICAgICAgICA/IE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLlNFUlZJQ0VfRkFCUklDXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMuYWxsRW52aXJvbm1lbnRWYXJpYWJsZXNBcmVEZWZpbmVkKEFwcFNlcnZpY2UuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSlcclxuICAgICAgICAgICAgICAgICAgICA/IE1hbmFnZWRJZGVudGl0eVNvdXJjZU5hbWVzLkFQUF9TRVJWSUNFXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmFsbEVudmlyb25tZW50VmFyaWFibGVzQXJlRGVmaW5lZChNYWNoaW5lTGVhcm5pbmcuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5NQUNISU5FX0xFQVJOSU5HXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5hbGxFbnZpcm9ubWVudFZhcmlhYmxlc0FyZURlZmluZWQoQ2xvdWRTaGVsbC5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5DTE9VRF9TSEVMTFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmFsbEVudmlyb25tZW50VmFyaWFibGVzQXJlRGVmaW5lZChBenVyZUFyYy5nZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuQVpVUkVfQVJDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcy5ERUZBVUxUX1RPX0lNRFM7XHJcbiAgICAgICAgcmV0dXJuIE1hbmFnZWRJZGVudGl0eUNsaWVudC5zb3VyY2VOYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmllcyB0byBjcmVhdGUgYSBtYW5hZ2VkIGlkZW50aXR5IHNvdXJjZSBmb3IgYWxsIHNvdXJjZXNcclxuICAgICAqIEByZXR1cm5zIHRoZSBtYW5hZ2VkIGlkZW50aXR5IFNvdXJjZVxyXG4gICAgICovXHJcbiAgICBzZWxlY3RNYW5hZ2VkSWRlbnRpdHlTb3VyY2UobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1hbmFnZWRJZGVudGl0eUlkKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gU2VydmljZUZhYnJpYy50cnlDcmVhdGUobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1hbmFnZWRJZGVudGl0eUlkKSB8fFxyXG4gICAgICAgICAgICBBcHBTZXJ2aWNlLnRyeUNyZWF0ZShsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcykgfHxcclxuICAgICAgICAgICAgTWFjaGluZUxlYXJuaW5nLnRyeUNyZWF0ZShsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcykgfHxcclxuICAgICAgICAgICAgQ2xvdWRTaGVsbC50cnlDcmVhdGUobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1hbmFnZWRJZGVudGl0eUlkKSB8fFxyXG4gICAgICAgICAgICBBenVyZUFyYy50cnlDcmVhdGUobG9nZ2VyLCBub2RlU3RvcmFnZSwgbmV0d29ya0NsaWVudCwgY3J5cHRvUHJvdmlkZXIsIGRpc2FibGVJbnRlcm5hbFJldHJpZXMsIG1hbmFnZWRJZGVudGl0eUlkKSB8fFxyXG4gICAgICAgICAgICBJbWRzLnRyeUNyZWF0ZShsb2dnZXIsIG5vZGVTdG9yYWdlLCBuZXR3b3JrQ2xpZW50LCBjcnlwdG9Qcm92aWRlciwgZGlzYWJsZUludGVybmFsUmV0cmllcyk7XHJcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlTWFuYWdlZElkZW50aXR5RXJyb3IodW5hYmxlVG9DcmVhdGVTb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IE1hbmFnZWRJZGVudGl0eUNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFuYWdlZElkZW50aXR5Q2xpZW50Lm1qcy5tYXBcbiIsIi8qISBAYXp1cmUvbXNhbC1ub2RlIHYzLjYuMCAyMDI1LTA1LTMwICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBMb2dnZXIsIERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OLCBBdXRob3JpdHksIGNyZWF0ZUNsaWVudENvbmZpZ3VyYXRpb25FcnJvciwgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMsIEVuY29kaW5nVHlwZXMsIENhY2hlT3V0Y29tZSwgQ29uc3RhbnRzLCBQcm90b2NvbE1vZGUgfSBmcm9tICdAYXp1cmUvbXNhbC1jb21tb24vbm9kZSc7XG5pbXBvcnQgeyBidWlsZE1hbmFnZWRJZGVudGl0eUNvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9jb25maWcvQ29uZmlndXJhdGlvbi5tanMnO1xuaW1wb3J0IHsgbmFtZSwgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2VNZXRhZGF0YS5tanMnO1xuaW1wb3J0IHsgQ3J5cHRvUHJvdmlkZXIgfSBmcm9tICcuLi9jcnlwdG8vQ3J5cHRvUHJvdmlkZXIubWpzJztcbmltcG9ydCB7IENsaWVudENyZWRlbnRpYWxDbGllbnQgfSBmcm9tICcuL0NsaWVudENyZWRlbnRpYWxDbGllbnQubWpzJztcbmltcG9ydCB7IE1hbmFnZWRJZGVudGl0eUNsaWVudCB9IGZyb20gJy4vTWFuYWdlZElkZW50aXR5Q2xpZW50Lm1qcyc7XG5pbXBvcnQgeyBOb2RlU3RvcmFnZSB9IGZyb20gJy4uL2NhY2hlL05vZGVTdG9yYWdlLm1qcyc7XG5pbXBvcnQgeyBERUZBVUxUX0FVVEhPUklUWV9GT1JfTUFOQUdFRF9JREVOVElUWSwgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMgfSBmcm9tICcuLi91dGlscy9Db25zdGFudHMubWpzJztcbmltcG9ydCB7IEhhc2hVdGlscyB9IGZyb20gJy4uL2NyeXB0by9IYXNoVXRpbHMubWpzJztcblxuLypcclxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFNPVVJDRVNfVEhBVF9TVVBQT1JUX1RPS0VOX1JFVk9DQVRJT04gPSBbTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMuU0VSVklDRV9GQUJSSUNdO1xyXG4vKipcclxuICogQ2xhc3MgdG8gaW5pdGlhbGl6ZSBhIG1hbmFnZWQgaWRlbnRpdHkgYW5kIGlkZW50aWZ5IHRoZSBzZXJ2aWNlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIE1hbmFnZWRJZGVudGl0eUFwcGxpY2F0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAvLyB1bmRlZmluZWQgY29uZmlnIG1lYW5zIHRoZSBtYW5hZ2VkIGlkZW50aXR5IGlzIHN5c3RlbS1hc3NpZ25lZFxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gYnVpbGRNYW5hZ2VkSWRlbnRpdHlDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24gfHwge30pO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IExvZ2dlcih0aGlzLmNvbmZpZy5zeXN0ZW0ubG9nZ2VyT3B0aW9ucywgbmFtZSwgdmVyc2lvbik7XHJcbiAgICAgICAgY29uc3QgZmFrZVN0YXR1c0F1dGhvcml0eU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNhbm9uaWNhbEF1dGhvcml0eTogQ29uc3RhbnRzLkRFRkFVTFRfQVVUSE9SSVRZLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFNYW5hZ2VkSWRlbnRpdHlBcHBsaWNhdGlvbi5ub2RlU3RvcmFnZSkge1xyXG4gICAgICAgICAgICBNYW5hZ2VkSWRlbnRpdHlBcHBsaWNhdGlvbi5ub2RlU3RvcmFnZSA9IG5ldyBOb2RlU3RvcmFnZSh0aGlzLmxvZ2dlciwgdGhpcy5jb25maWcubWFuYWdlZElkZW50aXR5SWQuaWQsIERFRkFVTFRfQ1JZUFRPX0lNUExFTUVOVEFUSU9OLCBmYWtlU3RhdHVzQXV0aG9yaXR5T3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmV0d29ya0NsaWVudCA9IHRoaXMuY29uZmlnLnN5c3RlbS5uZXR3b3JrQ2xpZW50O1xyXG4gICAgICAgIHRoaXMuY3J5cHRvUHJvdmlkZXIgPSBuZXcgQ3J5cHRvUHJvdmlkZXIoKTtcclxuICAgICAgICBjb25zdCBmYWtlQXV0aG9yaXR5T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgcHJvdG9jb2xNb2RlOiBQcm90b2NvbE1vZGUuQUFELFxyXG4gICAgICAgICAgICBrbm93bkF1dGhvcml0aWVzOiBbREVGQVVMVF9BVVRIT1JJVFlfRk9SX01BTkFHRURfSURFTlRJVFldLFxyXG4gICAgICAgICAgICBjbG91ZERpc2NvdmVyeU1ldGFkYXRhOiBcIlwiLFxyXG4gICAgICAgICAgICBhdXRob3JpdHlNZXRhZGF0YTogXCJcIixcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZmFrZUF1dGhvcml0eSA9IG5ldyBBdXRob3JpdHkoREVGQVVMVF9BVVRIT1JJVFlfRk9SX01BTkFHRURfSURFTlRJVFksIHRoaXMubmV0d29ya0NsaWVudCwgTWFuYWdlZElkZW50aXR5QXBwbGljYXRpb24ubm9kZVN0b3JhZ2UsIGZha2VBdXRob3JpdHlPcHRpb25zLCB0aGlzLmxvZ2dlciwgdGhpcy5jcnlwdG9Qcm92aWRlci5jcmVhdGVOZXdHdWlkKCksIC8vIGNvcnJlbGF0aW9uSURcclxuICAgICAgICB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZmFrZUNsaWVudENyZWRlbnRpYWxDbGllbnQgPSBuZXcgQ2xpZW50Q3JlZGVudGlhbENsaWVudCh7XHJcbiAgICAgICAgICAgIGF1dGhPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcubWFuYWdlZElkZW50aXR5SWQuaWQsXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHRoaXMuZmFrZUF1dGhvcml0eSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1hbmFnZWRJZGVudGl0eUNsaWVudCA9IG5ldyBNYW5hZ2VkSWRlbnRpdHlDbGllbnQodGhpcy5sb2dnZXIsIE1hbmFnZWRJZGVudGl0eUFwcGxpY2F0aW9uLm5vZGVTdG9yYWdlLCB0aGlzLm5ldHdvcmtDbGllbnQsIHRoaXMuY3J5cHRvUHJvdmlkZXIsIHRoaXMuY29uZmlnLmRpc2FibGVJbnRlcm5hbFJldHJpZXMpO1xyXG4gICAgICAgIHRoaXMuaGFzaFV0aWxzID0gbmV3IEhhc2hVdGlscygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3F1aXJlIGFuIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSBjYWNoZSBvciB0aGUgbWFuYWdlZCBpZGVudGl0eVxyXG4gICAgICogQHBhcmFtIG1hbmFnZWRJZGVudGl0eVJlcXVlc3QgLSB0aGUgTWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtcyBvYmplY3QgcGFzc2VkIGluIGJ5IHRoZSBkZXZlbG9wZXJcclxuICAgICAqIEByZXR1cm5zIHRoZSBhY2Nlc3MgdG9rZW5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWNxdWlyZVRva2VuKG1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbXMpIHtcclxuICAgICAgICBpZiAoIW1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbXMucmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yKENsaWVudENvbmZpZ3VyYXRpb25FcnJvckNvZGVzLnVybEVtcHR5RXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBmb3JjZVJlZnJlc2g6IG1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbXMuZm9yY2VSZWZyZXNoLFxyXG4gICAgICAgICAgICByZXNvdXJjZTogbWFuYWdlZElkZW50aXR5UmVxdWVzdFBhcmFtcy5yZXNvdXJjZS5yZXBsYWNlKFwiLy5kZWZhdWx0XCIsIFwiXCIpLFxyXG4gICAgICAgICAgICBzY29wZXM6IFtcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRJZGVudGl0eVJlcXVlc3RQYXJhbXMucmVzb3VyY2UucmVwbGFjZShcIi8uZGVmYXVsdFwiLCBcIlwiKSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgYXV0aG9yaXR5OiB0aGlzLmZha2VBdXRob3JpdHkuY2Fub25pY2FsQXV0aG9yaXR5LFxyXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiB0aGlzLmNyeXB0b1Byb3ZpZGVyLmNyZWF0ZU5ld0d1aWQoKSxcclxuICAgICAgICAgICAgY2xhaW1zOiBtYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0UGFyYW1zLmNsYWltcyxcclxuICAgICAgICAgICAgY2xpZW50Q2FwYWJpbGl0aWVzOiB0aGlzLmNvbmZpZy5jbGllbnRDYXBhYmlsaXRpZXMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobWFuYWdlZElkZW50aXR5UmVxdWVzdC5mb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNxdWlyZVRva2VuRnJvbU1hbmFnZWRJZGVudGl0eShtYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0LCB0aGlzLmNvbmZpZy5tYW5hZ2VkSWRlbnRpdHlJZCwgdGhpcy5mYWtlQXV0aG9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW2NhY2hlZEF1dGhlbnRpY2F0aW9uUmVzdWx0LCBsYXN0Q2FjaGVPdXRjb21lXSA9IGF3YWl0IHRoaXMuZmFrZUNsaWVudENyZWRlbnRpYWxDbGllbnQuZ2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQobWFuYWdlZElkZW50aXR5UmVxdWVzdCwgdGhpcy5jb25maWcsIHRoaXMuY3J5cHRvUHJvdmlkZXIsIHRoaXMuZmFrZUF1dGhvcml0eSwgTWFuYWdlZElkZW50aXR5QXBwbGljYXRpb24ubm9kZVN0b3JhZ2UpO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogQ2hlY2sgaWYgY2xhaW1zIGFyZSBwcmVzZW50IGluIHRoZSBtYW5hZ2VkIGlkZW50aXR5IHJlcXVlc3QuXHJcbiAgICAgICAgICogSWYgc28sIHRoZSBjYWNoZWQgdG9rZW4gd2lsbCBub3QgYmUgdXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAobWFuYWdlZElkZW50aXR5UmVxdWVzdC5jbGFpbXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHRoaXMubWFuYWdlZElkZW50aXR5Q2xpZW50LmdldE1hbmFnZWRJZGVudGl0eVNvdXJjZSgpO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBDaGVjayBpZiB0aGVyZSBpcyBhIGNhY2hlZCB0b2tlbiBhbmQgaWYgdGhlIE1hbmFnZWQgSWRlbnRpdHkgc291cmNlIHN1cHBvcnRzIHRva2VuIHJldm9jYXRpb24uXHJcbiAgICAgICAgICAgICAqIElmIHNvLCBoYXNoIHRoZSBjYWNoZWQgYWNjZXNzIHRva2VuIGFuZCBhZGQgaXQgdG8gdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQgJiZcclxuICAgICAgICAgICAgICAgIFNPVVJDRVNfVEhBVF9TVVBQT1JUX1RPS0VOX1JFVk9DQVRJT04uaW5jbHVkZXMoc291cmNlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldm9rZWRUb2tlblNoYTI1Nkhhc2ggPSB0aGlzLmhhc2hVdGlsc1xyXG4gICAgICAgICAgICAgICAgICAgIC5zaGEyNTYoY2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQuYWNjZXNzVG9rZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKEVuY29kaW5nVHlwZXMuSEVYKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRJZGVudGl0eVJlcXVlc3QucmV2b2tlZFRva2VuU2hhMjU2SGFzaCA9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV2b2tlZFRva2VuU2hhMjU2SGFzaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlVG9rZW5Gcm9tTWFuYWdlZElkZW50aXR5KG1hbmFnZWRJZGVudGl0eVJlcXVlc3QsIHRoaXMuY29uZmlnLm1hbmFnZWRJZGVudGl0eUlkLCB0aGlzLmZha2VBdXRob3JpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIGJ1dCBtdXN0IGJlIHJlZnJlc2hlZDsgZ2V0IGEgbmV3IG9uZSBpbiB0aGUgYmFja2dyb3VuZFxyXG4gICAgICAgICAgICBpZiAobGFzdENhY2hlT3V0Y29tZSA9PT0gQ2FjaGVPdXRjb21lLlBST0FDVElWRUxZX1JFRlJFU0hFRCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIkNsaWVudENyZWRlbnRpYWxDbGllbnQ6Z2V0Q2FjaGVkQXV0aGVudGljYXRpb25SZXN1bHQgLSBDYWNoZWQgYWNjZXNzIHRva2VuJ3MgcmVmcmVzaE9uIHByb3BlcnR5IGhhcyBiZWVuIGV4Y2VlZGVkJy4gSXQncyBub3QgZXhwaXJlZCwgYnV0IG11c3QgYmUgcmVmcmVzaGVkLlwiKTtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHJlZnJlc2g7IHdpbGwgcnVuIGluIHRoZSBiYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoQWNjZXNzVG9rZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hY3F1aXJlVG9rZW5Gcm9tTWFuYWdlZElkZW50aXR5KG1hbmFnZWRJZGVudGl0eVJlcXVlc3QsIHRoaXMuY29uZmlnLm1hbmFnZWRJZGVudGl0eUlkLCB0aGlzLmZha2VBdXRob3JpdHksIHJlZnJlc2hBY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEF1dGhlbnRpY2F0aW9uUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNxdWlyZVRva2VuRnJvbU1hbmFnZWRJZGVudGl0eShtYW5hZ2VkSWRlbnRpdHlSZXF1ZXN0LCB0aGlzLmNvbmZpZy5tYW5hZ2VkSWRlbnRpdHlJZCwgdGhpcy5mYWtlQXV0aG9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjcXVpcmVzIGEgdG9rZW4gZnJvbSBhIG1hbmFnZWQgaWRlbnRpdHkgZW5kcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hbmFnZWRJZGVudGl0eVJlcXVlc3QgLSBUaGUgcmVxdWVzdCBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIGZvciB0aGUgbWFuYWdlZCBpZGVudGl0eSB0b2tlbiByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIG1hbmFnZWRJZGVudGl0eUlkIC0gVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBtYW5hZ2VkIGlkZW50aXR5IChlLmcuLCBjbGllbnQgSUQgb3IgcmVzb3VyY2UgSUQpLlxyXG4gICAgICogQHBhcmFtIGZha2VBdXRob3JpdHkgLSBBIHBsYWNlaG9sZGVyIGF1dGhvcml0eSB1c2VkIGZvciB0aGUgdG9rZW4gcmVxdWVzdC5cclxuICAgICAqIEBwYXJhbSByZWZyZXNoQWNjZXNzVG9rZW4gLSBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0byBmb3JjZSBhIHJlZnJlc2ggb2YgdGhlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEF1dGhlbnRpY2F0aW9uUmVzdWx0IGNvbnRhaW5pbmcgdGhlIGFjcXVpcmVkIHRva2VuIGFuZCByZWxhdGVkIGluZm9ybWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBhY3F1aXJlVG9rZW5Gcm9tTWFuYWdlZElkZW50aXR5KG1hbmFnZWRJZGVudGl0eVJlcXVlc3QsIG1hbmFnZWRJZGVudGl0eUlkLCBmYWtlQXV0aG9yaXR5LCByZWZyZXNoQWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAvLyBtYWtlIGEgbmV0d29yayBjYWxsIHRvIHRoZSBtYW5hZ2VkIGlkZW50aXR5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlZElkZW50aXR5Q2xpZW50LnNlbmRNYW5hZ2VkSWRlbnRpdHlUb2tlblJlcXVlc3QobWFuYWdlZElkZW50aXR5UmVxdWVzdCwgbWFuYWdlZElkZW50aXR5SWQsIGZha2VBdXRob3JpdHksIHJlZnJlc2hBY2Nlc3NUb2tlbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB0aGUgTWFuYWdlZCBJZGVudGl0eSBTb3VyY2UgYmFzZWQgb24gYXZhaWxhYmxlIGVudmlyb25tZW50IHZhcmlhYmxlcy4gVGhpcyBBUEkgaXMgY29uc3VtZWQgYnkgQXp1cmUgSWRlbnRpdHkgU0RLLlxyXG4gICAgICogQHJldHVybnMgTWFuYWdlZElkZW50aXR5U291cmNlTmFtZXMgLSBUaGUgTWFuYWdlZCBJZGVudGl0eSBzb3VyY2UncyBuYW1lXHJcbiAgICAgKi9cclxuICAgIGdldE1hbmFnZWRJZGVudGl0eVNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gKE1hbmFnZWRJZGVudGl0eUNsaWVudC5zb3VyY2VOYW1lIHx8XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlZElkZW50aXR5Q2xpZW50LmdldE1hbmFnZWRJZGVudGl0eVNvdXJjZSgpKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlBcHBsaWNhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFuYWdlZElkZW50aXR5QXBwbGljYXRpb24ubWpzLm1hcFxuIiwiLyohIEBhenVyZS9tc2FsLW5vZGUgdjMuNi4wIDIwMjUtMDUtMzAgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCAqIGFzIGludGVybmFscyBmcm9tICcuL2ludGVybmFscy5tanMnO1xuZXhwb3J0IHsgaW50ZXJuYWxzIH07XG5leHBvcnQgeyBQdWJsaWNDbGllbnRBcHBsaWNhdGlvbiB9IGZyb20gJy4vY2xpZW50L1B1YmxpY0NsaWVudEFwcGxpY2F0aW9uLm1qcyc7XG5leHBvcnQgeyBDb25maWRlbnRpYWxDbGllbnRBcHBsaWNhdGlvbiB9IGZyb20gJy4vY2xpZW50L0NvbmZpZGVudGlhbENsaWVudEFwcGxpY2F0aW9uLm1qcyc7XG5leHBvcnQgeyBDbGllbnRBcHBsaWNhdGlvbiB9IGZyb20gJy4vY2xpZW50L0NsaWVudEFwcGxpY2F0aW9uLm1qcyc7XG5leHBvcnQgeyBDbGllbnRDcmVkZW50aWFsQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQvQ2xpZW50Q3JlZGVudGlhbENsaWVudC5tanMnO1xuZXhwb3J0IHsgRGV2aWNlQ29kZUNsaWVudCB9IGZyb20gJy4vY2xpZW50L0RldmljZUNvZGVDbGllbnQubWpzJztcbmV4cG9ydCB7IE9uQmVoYWxmT2ZDbGllbnQgfSBmcm9tICcuL2NsaWVudC9PbkJlaGFsZk9mQ2xpZW50Lm1qcyc7XG5leHBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlBcHBsaWNhdGlvbiB9IGZyb20gJy4vY2xpZW50L01hbmFnZWRJZGVudGl0eUFwcGxpY2F0aW9uLm1qcyc7XG5leHBvcnQgeyBVc2VybmFtZVBhc3N3b3JkQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQvVXNlcm5hbWVQYXNzd29yZENsaWVudC5tanMnO1xuZXhwb3J0IHsgQ2xpZW50QXNzZXJ0aW9uIH0gZnJvbSAnLi9jbGllbnQvQ2xpZW50QXNzZXJ0aW9uLm1qcyc7XG5leHBvcnQgeyBUb2tlbkNhY2hlIH0gZnJvbSAnLi9jYWNoZS9Ub2tlbkNhY2hlLm1qcyc7XG5leHBvcnQgeyBEaXN0cmlidXRlZENhY2hlUGx1Z2luIH0gZnJvbSAnLi9jYWNoZS9kaXN0cmlidXRlZC9EaXN0cmlidXRlZENhY2hlUGx1Z2luLm1qcyc7XG5leHBvcnQgeyBNYW5hZ2VkSWRlbnRpdHlTb3VyY2VOYW1lcyB9IGZyb20gJy4vdXRpbHMvQ29uc3RhbnRzLm1qcyc7XG5leHBvcnQgeyBDcnlwdG9Qcm92aWRlciB9IGZyb20gJy4vY3J5cHRvL0NyeXB0b1Byb3ZpZGVyLm1qcyc7XG5leHBvcnQgeyBBdXRoRXJyb3IsIEF1dGhFcnJvckNvZGVzLCBBdXRoRXJyb3JNZXNzYWdlLCBBenVyZUNsb3VkSW5zdGFuY2UsIENsaWVudEF1dGhFcnJvciwgQ2xpZW50QXV0aEVycm9yQ29kZXMsIENsaWVudEF1dGhFcnJvck1lc3NhZ2UsIENsaWVudENvbmZpZ3VyYXRpb25FcnJvciwgQ2xpZW50Q29uZmlndXJhdGlvbkVycm9yQ29kZXMsIENsaWVudENvbmZpZ3VyYXRpb25FcnJvck1lc3NhZ2UsIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3IsIEludGVyYWN0aW9uUmVxdWlyZWRBdXRoRXJyb3JDb2RlcywgSW50ZXJhY3Rpb25SZXF1aXJlZEF1dGhFcnJvck1lc3NhZ2UsIExvZ0xldmVsLCBMb2dnZXIsIFByb21wdFZhbHVlLCBQcm90b2NvbE1vZGUsIFJlc3BvbnNlTW9kZSwgU2VydmVyRXJyb3IsIFRva2VuQ2FjaGVDb250ZXh0IH0gZnJvbSAnQGF6dXJlL21zYWwtY29tbW9uL25vZGUnO1xuZXhwb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vcGFja2FnZU1ldGFkYXRhLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBBdXRoZW50aWNhdGlvbiBzZXJ2aWNlIHVzaW5nIE1TQUwgZm9yIEVsZWN0cm9uXG5pbXBvcnQgeyBQdWJsaWNDbGllbnRBcHBsaWNhdGlvbiwgTG9nTGV2ZWwgfSBmcm9tICdAYXp1cmUvbXNhbC1ub2RlJztcbmltcG9ydCB7IENsaWVudCB9IGZyb20gJ0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudCc7XG5leHBvcnQgY2xhc3MgQXV0aFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBVc2UgTWljcm9zb2Z0IEdyYXBoIFBvd2VyU2hlbGwgcHVibGljIGNsaWVudCBJRCBmb3IgaW50ZXJhY3RpdmUgbG9naW5cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXNlcnMgdG8gYXV0aGVudGljYXRlIHdpdGhvdXQgcmVxdWlyaW5nIHRoZWlyIG93biBBcHAgUmVnaXN0cmF0aW9uXG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gcHJvY2Vzcy5lbnYuTVNBTF9DTElFTlRfSUQgJiYgcHJvY2Vzcy5lbnYuTVNBTF9DTElFTlRfSUQudHJpbSgpICE9PSAnJ1xuICAgICAgICAgICAgPyBwcm9jZXNzLmVudi5NU0FMX0NMSUVOVF9JRFxuICAgICAgICAgICAgOiAnMTRkODJlZWMtMjA0Yi00YzJmLWI3ZTgtMjk2YTcwZGFiNjdlJzsgLy8gTWljcm9zb2Z0IEdyYXBoIFBvd2VyU2hlbGxcbiAgICAgICAgY29uc3QgYXV0aG9yaXR5ID0gcHJvY2Vzcy5lbnYuTVNBTF9URU5BTlRfSUQgJiYgcHJvY2Vzcy5lbnYuTVNBTF9URU5BTlRfSUQudHJpbSgpICE9PSAnJ1xuICAgICAgICAgICAgPyBgaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tLyR7cHJvY2Vzcy5lbnYuTVNBTF9URU5BTlRfSUR9YFxuICAgICAgICAgICAgOiAnaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbic7XG4gICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyBNU0FMIENsaWVudCBJRDogJHtjbGllbnRJZH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIEF1dGhvcml0eTogJHthdXRob3JpdHl9YCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgICAgIGNsaWVudElkLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzeXN0ZW06IHtcbiAgICAgICAgICAgICAgICBsb2dnZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlckNhbGxiYWNrOiAobGV2ZWwsIG1lc3NhZ2UsIGNvbnRhaW5zUGlpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNQaWkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtNU0FMICR7bGV2ZWx9XTogJHttZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwaWlMb2dnaW5nRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5JbmZvLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1zYWxDbGllbnQgPSBuZXcgUHVibGljQ2xpZW50QXBwbGljYXRpb24odGhpcy5jb25maWcpO1xuICAgIH1cbiAgICBhc3luYyBsb2dpbih1c2VSZWRpcmVjdEZsb3cgPSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBtaW5pbWFsIHBlcm1pc3Npb25zIHRoYXQgbW9zdCB1c2VycyBzaG91bGQgaGF2ZVxuICAgICAgICAgICAgY29uc3QgYXV0aFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICdVc2VyLlJlYWQnLCAvLyBSZWFkIGN1cnJlbnQgdXNlcidzIHByb2ZpbGUgLSBiYXNpYyBwZXJtaXNzaW9uXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBvcGVuQnJvd3NlcjogYXN5bmMgKHVybCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBFbGVjdHJvbiwgd2UgY2FuIHVzZSBzaGVsbC5vcGVuRXh0ZXJuYWwgdG8gb3BlbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNoZWxsIH0gPSBhd2FpdCBpbXBvcnQoJ2VsZWN0cm9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNoZWxsLm9wZW5FeHRlcm5hbCh1cmwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gVXNlIHN5c3RlbSBicm93c2VyIGZvciByZWRpcmVjdCBmbG93XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBtb3JlIGNvbXBhdGlibGUgd2l0aCBtb2JpbGUgYXV0aGVudGljYXRpb24gZmxvd3NcbiAgICAgICAgICAgICAgICByZWRpcmVjdFVyaTogdXNlUmVkaXJlY3RGbG93ID8gJ2h0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb21tb24vb2F1dGgyL25hdGl2ZWNsaWVudCcgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3VjY2Vzc1RlbXBsYXRlOiBgXHJcbiAgICAgICAgICA8aHRtbD5cclxuICAgICAgICAgICAgPGhlYWQ+PHRpdGxlPkF1dGhlbnRpY2F0aW9uIFN1Y2Nlc3NmdWw8L3RpdGxlPjwvaGVhZD5cclxuICAgICAgICAgICAgPGJvZHk+XHJcbiAgICAgICAgICAgICAgPGgxPkF1dGhlbnRpY2F0aW9uIFN1Y2Nlc3NmdWwhPC9oMT5cclxuICAgICAgICAgICAgICA8cD5Zb3UgY2FuIG5vdyBjbG9zZSB0aGlzIHdpbmRvdyBhbmQgcmV0dXJuIHRvIEVudHJhUHVsc2UgTGl0ZS48L3A+XHJcbiAgICAgICAgICAgICAgPHNjcmlwdD53aW5kb3cuY2xvc2UoKTs8L3NjcmlwdD5cclxuICAgICAgICAgICAgPC9ib2R5PlxyXG4gICAgICAgICAgPC9odG1sPlxyXG4gICAgICAgIGAsXG4gICAgICAgICAgICAgICAgZXJyb3JUZW1wbGF0ZTogYFxyXG4gICAgICAgICAgPGh0bWw+XHJcbiAgICAgICAgICAgIDxoZWFkPjx0aXRsZT5BdXRoZW50aWNhdGlvbiBGYWlsZWQ8L3RpdGxlPjwvaGVhZD5cclxuICAgICAgICAgICAgPGJvZHk+XHJcbiAgICAgICAgICAgICAgPGgxPkF1dGhlbnRpY2F0aW9uIEZhaWxlZDwvaDE+XHJcbiAgICAgICAgICAgICAgPHA+UGxlYXNlIHRyeSBhZ2Fpbi4gWW91IGNhbiBjbG9zZSB0aGlzIHdpbmRvdyBhbmQgcmV0dXJuIHRvIEVudHJhUHVsc2UgTGl0ZS48L3A+XHJcbiAgICAgICAgICAgICAgPHNjcmlwdD53aW5kb3cuY2xvc2UoKTs8L3NjcmlwdD5cclxuICAgICAgICAgICAgPC9ib2R5PlxyXG4gICAgICAgICAgPC9odG1sPlxyXG4gICAgICAgIGBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgYXV0aGVudGljYXRpb24gd2l0aCBtaW5pbWFsIHBlcm1pc3Npb25zLi4uJyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubXNhbENsaWVudC5hY3F1aXJlVG9rZW5JbnRlcmFjdGl2ZShhdXRoUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bCB3aXRoIGJhc2ljIHBlcm1pc3Npb25zIScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwVG9BdXRoVG9rZW4ocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQXV0aGVudGljYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RBZGRpdGlvbmFsUGVybWlzc2lvbnMocGVybWlzc2lvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5tc2FsQ2xpZW50LmdldFRva2VuQ2FjaGUoKS5nZXRBbGxBY2NvdW50cygpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXV0aGVudGljYXRlZCBhY2NvdW50IGZvdW5kLiBQbGVhc2UgbG9nIGluIGZpcnN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzOiBwZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50c1swXSxcbiAgICAgICAgICAgICAgICBmb3JjZVJlZnJlc2g6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXF1ZXN0aW5nIGFkZGl0aW9uYWwgcGVybWlzc2lvbnM6ICR7cGVybWlzc2lvbnMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIC8vIFRyeSBzaWxlbnQgcmVxdWVzdCBmaXJzdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubXNhbENsaWVudC5hY3F1aXJlVG9rZW5TaWxlbnQoYXV0aFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGRpdGlvbmFsIHBlcm1pc3Npb25zIGdyYW50ZWQgc2lsZW50bHknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0F1dGhUb2tlbihyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoc2lsZW50RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2lsZW50IHJlcXVlc3QgZmFpbGVkLCByZXF1aXJpbmcgaW50ZXJhY3RpdmUgY29uc2VudCcpO1xuICAgICAgICAgICAgICAgIC8vIElmIHNpbGVudCBmYWlscywgcmVxdWVzdCBpbnRlcmFjdGl2ZWx5XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJhY3RpdmVSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hdXRoUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgb3BlbkJyb3dzZXI6IGFzeW5jICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2hlbGwgfSA9IGF3YWl0IGltcG9ydCgnZWxlY3Ryb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNoZWxsLm9wZW5FeHRlcm5hbCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6ICdjb25zZW50JywgLy8gRm9yY2UgY29uc2VudCB0byBzaG93IHBlcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubXNhbENsaWVudC5hY3F1aXJlVG9rZW5JbnRlcmFjdGl2ZShpbnRlcmFjdGl2ZVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGRpdGlvbmFsIHBlcm1pc3Npb25zIGdyYW50ZWQgaW50ZXJhY3RpdmVseScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcFRvQXV0aFRva2VuKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZXF1ZXN0IGFkZGl0aW9uYWwgcGVybWlzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9rZW5XaXRoUGVybWlzc2lvbnMocGVybWlzc2lvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5tc2FsQ2xpZW50LmdldFRva2VuQ2FjaGUoKS5nZXRBbGxBY2NvdW50cygpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzOiBwZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50c1swXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubXNhbENsaWVudC5hY3F1aXJlVG9rZW5TaWxlbnQoYXV0aFJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwVG9BdXRoVG9rZW4ocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFRva2VuIHdpdGggcGVybWlzc2lvbnMgWyR7cGVybWlzc2lvbnMuam9pbignLCAnKX1dIG5vdCBhdmFpbGFibGUgc2lsZW50bHlgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxvZ291dCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5tc2FsQ2xpZW50LmdldFRva2VuQ2FjaGUoKS5nZXRBbGxBY2NvdW50cygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tc2FsQ2xpZW50LmdldFRva2VuQ2FjaGUoKS5yZW1vdmVBY2NvdW50KGFjY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTG9nb3V0IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ291dCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5tc2FsQ2xpZW50LmdldFRva2VuQ2FjaGUoKS5nZXRBbGxBY2NvdW50cygpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzOiBbJ1VzZXIuUmVhZCddLFxuICAgICAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnRzWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tc2FsQ2xpZW50LmFjcXVpcmVUb2tlblNpbGVudChhdXRoUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0F1dGhUb2tlbihyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiByZXRyaWV2YWwgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEN1cnJlbnRVc2VyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFRva2VuKCk7XG4gICAgICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IEdyYXBoIGNsaWVudCB0byBtYWtlIHRoZSBBUEkgY2FsbFxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gQ2xpZW50LmluaXQoe1xuICAgICAgICAgICAgICAgIGF1dGhQcm92aWRlcjogYXN5bmMgKGRvbmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShudWxsLCB0b2tlbi5hY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDYWxsIE1pY3Jvc29mdCBHcmFwaCBBUEkgdG8gZ2V0IHVzZXIgcHJvZmlsZVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuYXBpKCcvbWUnKS5nZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiByZXNwb25zZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICBtYWlsOiByZXNwb25zZS5tYWlsIHx8IHJlc3BvbnNlLnVzZXJQcmluY2lwYWxOYW1lLFxuICAgICAgICAgICAgICAgIHVzZXJQcmluY2lwYWxOYW1lOiByZXNwb25zZS51c2VyUHJpbmNpcGFsTmFtZSxcbiAgICAgICAgICAgICAgICBqb2JUaXRsZTogcmVzcG9uc2Uuam9iVGl0bGUsXG4gICAgICAgICAgICAgICAgZGVwYXJ0bWVudDogcmVzcG9uc2UuZGVwYXJ0bWVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgdXNlcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXBUb0F1dGhUb2tlbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHJlc3BvbnNlLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgaWRUb2tlbjogcmVzcG9uc2UuaWRUb2tlbiB8fCAnJyxcbiAgICAgICAgICAgIGV4cGlyZXNPbjogcmVzcG9uc2UuZXhwaXJlc09uIHx8IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBzY29wZXM6IHJlc3BvbnNlLnNjb3BlcyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCIvKipcbiAqIEltcHJvdmVkIG1ldGhvZCBmb3IgZmV0Y2hpbmcgdXNlciBwcm9maWxlIHBob3RvcyBmcm9tIE1pY3Jvc29mdCBHcmFwaCxcbiAqIHdpdGggbXVsdGlwbGUgZmFsbGJhY2sgbWVjaGFuaXNtcyBmb3IgYmV0dGVyIHJlbGlhYmlsaXR5XG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9maWxlUGhvdG9TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHVzZXIncyBwcm9maWxlIHBob3RvIHdpdGggbXVsdGlwbGUgZmFsbGJhY2sgbWVjaGFuaXNtc1xuICAgICAqIEBwYXJhbSB1c2VySWQgVXNlciBJRCBvciBlbWFpbCBhZGRyZXNzXG4gICAgICogQHJldHVybnMgQmFzZTY0LWVuY29kZWQgcGhvdG8gZGF0YSBVUkkgb3IgbnVsbCBpZiBubyBwaG90byBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VyUGhvdG8odXNlcklkID0gJ21lJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSW1wb3J0IHRoZSBSZXNwb25zZVR5cGUgZW51bSBmcm9tIHRoZSBNaWNyb3NvZnQgR3JhcGggY2xpZW50XG4gICAgICAgICAgICBjb25zdCB7IFJlc3BvbnNlVHlwZSB9ID0gcmVxdWlyZSgnQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50Jyk7XG4gICAgICAgICAgICAvLyBJZiB1c2VySWQgaXMgYW4gZW1haWwsIHdlIG5lZWQgdG8gZ2V0IHRoZSB1c2VyJ3MgSUQgZmlyc3RcbiAgICAgICAgICAgIGxldCB1c2VySWRUb1VzZSA9IHVzZXJJZDtcbiAgICAgICAgICAgIGxldCB1c2VyRW1haWwgPSB1c2VySWQ7IC8vIFN0b3JlIGVtYWlsIGZvciBPdXRsb29rIGZhbGxiYWNrXG4gICAgICAgICAgICBpZiAodXNlcklkICE9PSAnbWUnICYmIHVzZXJJZC5pbmNsdWRlcygnQCcpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEdldHRpbmcgdXNlciBJRCBmb3IgZW1haWw6ICR7dXNlcklkfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwaShgL3VzZXJzLyR7dXNlcklkfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUmVzcG9uc2UgJiYgdXNlclJlc3BvbnNlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWRUb1VzZSA9IHVzZXJSZXNwb25zZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJFbWFpbCA9IHVzZXJJZDsgLy8gS2VlcCB0aGUgZW1haWwgZm9yIGZhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlc29sdmVkIGVtYWlsICR7dXNlcklkfSB0byB1c2VyIElEOiAke3VzZXJJZFRvVXNlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIHJlc29sdmUgZW1haWwgdG8gSUQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIGVtYWlsIGFzIHRoZSB1c2VySWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdHRlbXB0IDE6IFRyeSBiZXRhIGVuZHBvaW50XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUcnlpbmcgdG8gZ2V0IHBob3RvIGZvciB1c2VyICR7dXNlcklkVG9Vc2V9IHVzaW5nIGJldGEgZW5kcG9pbnRgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwaG90b1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLmFwaShgL2JldGEvdXNlcnMvJHt1c2VySWRUb1VzZX0vcGhvdG8vJHZhbHVlYClcbiAgICAgICAgICAgICAgICAgICAgLnJlc3BvbnNlVHlwZShSZXNwb25zZVR5cGUuQVJSQVlCVUZGRVIpXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoKTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBhcnJheSBidWZmZXIgdG8gYSBiYXNlNjQgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ID0gQnVmZmVyLmZyb20ocGhvdG9SZXNwb25zZSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQaG90byBvYnRhaW5lZCB2aWEgYmV0YSBlbmRwb2ludCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwke2Jhc2U2NH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGJldGFFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBCZXRhIGVuZHBvaW50IHBob3RvIGZldGNoIGZhaWxlZDogJHtiZXRhRXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdHRlbXB0IDI6IFRyeSB2MS4wIGVuZHBvaW50XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgc3RhbmRhcmQgdjEuMCBlbmRwb2ludCBhcyBmYWxsYmFjaycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBob3RvUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudFxuICAgICAgICAgICAgICAgICAgICAuYXBpKGAvdXNlcnMvJHt1c2VySWRUb1VzZX0vcGhvdG8vJHZhbHVlYClcbiAgICAgICAgICAgICAgICAgICAgLnJlc3BvbnNlVHlwZShSZXNwb25zZVR5cGUuQVJSQVlCVUZGRVIpXG4gICAgICAgICAgICAgICAgICAgIC5nZXQoKTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBhcnJheSBidWZmZXIgdG8gYSBiYXNlNjQgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ID0gQnVmZmVyLmZyb20ocGhvdG9SZXNwb25zZSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQaG90byBvYnRhaW5lZCB2aWEgdjEuMCBlbmRwb2ludCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwke2Jhc2U2NH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHN0YW5kYXJkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3RhbmRhcmQgZW5kcG9pbnQgcGhvdG8gZmV0Y2ggZmFpbGVkOiAke3N0YW5kYXJkRXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdHRlbXB0IDM6IFRyeSBkaXJlY3QgcHJvZmlsZSBwaG90byBmcm9tIEV4Y2hhbmdlL091dGxvb2tcbiAgICAgICAgICAgIC8vIFRoaXMgb2Z0ZW4gd29ya3Mgd2hlbiBHcmFwaCBBUEkgZmFpbHNcbiAgICAgICAgICAgIGlmICh1c2VySWQuaW5jbHVkZXMoJ0AnKSB8fCB1c2VyRW1haWwuaW5jbHVkZXMoJ0AnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtYWlsVG9Vc2UgPSB1c2VySWQuaW5jbHVkZXMoJ0AnKSA/IHVzZXJJZCA6IHVzZXJFbWFpbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVHJ5aW5nIEV4Y2hhbmdlL091dGxvb2sgZW5kcG9pbnQgZm9yICR7ZW1haWxUb1VzZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGhvdG9SZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL291dGxvb2sub2ZmaWNlMzY1LmNvbS9vd2Evc2VydmljZS5zdmMvcy9HZXRQZXJzb25hUGhvdG8/ZW1haWw9JHtlbmNvZGVVUklDb21wb25lbnQoZW1haWxUb1VzZSl9JlVBPTAmc2l6ZT1IUjY0eDY0YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaG90b1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaG90b0Jsb2IgPSBhd2FpdCBwaG90b1Jlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcGhvdG9CbG9iLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjQgPSBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Bob3RvIG9idGFpbmVkIHZpYSBFeGNoYW5nZS9PdXRsb29rIGVuZHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGRhdGE6aW1hZ2UvanBlZztiYXNlNjQsJHtiYXNlNjR9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeGNoYW5nZSBlbmRwb2ludCByZXR1cm5lZCBzdGF0dXM6ICR7cGhvdG9SZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKG91dGxvb2tFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhjaGFuZ2UvT3V0bG9vayBlbmRwb2ludCBmYWlsZWQ6ICR7b3V0bG9va0Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsbCBhdHRlbXB0cyBmYWlsZWRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBwaG90byBhdmFpbGFibGUgZm9yIHVzZXIgJHt1c2VySWR9IGFmdGVyIHRyeWluZyBhbGwgbWV0aG9kc2ApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZ2V0IHVzZXIgcGhvdG86ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIE1pY3Jvc29mdCBHcmFwaCBBUEkgc2VydmljZSB3aXRoIHByb2dyZXNzaXZlIHBlcm1pc3Npb25zXG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tICdAbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQnO1xuaW1wb3J0IHsgUHJvZmlsZVBob3RvU2VydmljZSB9IGZyb20gJy4vUHJvZmlsZVBob3RvU2VydmljZSc7XG4vLyBEZWZpbmUgcGVybWlzc2lvbiB0aWVycyBmb3IgZGlmZmVyZW50IG9wZXJhdGlvbnNcbmV4cG9ydCBjb25zdCBQRVJNSVNTSU9OX1RJRVJTID0ge1xuICAgIEJBU0lDOiBbJ1VzZXIuUmVhZCddLFxuICAgIFVTRVJfTUFOQUdFTUVOVDogWydVc2VyLlJlYWQnLCAnVXNlci5SZWFkQmFzaWMuQWxsJ10sXG4gICAgRElSRUNUT1JZX1JFQUQ6IFsnVXNlci5SZWFkJywgJ1VzZXIuUmVhZEJhc2ljLkFsbCcsICdEaXJlY3RvcnkuUmVhZC5BbGwnXSxcbiAgICBHUk9VUF9NQU5BR0VNRU5UOiBbJ1VzZXIuUmVhZCcsICdVc2VyLlJlYWRCYXNpYy5BbGwnLCAnRGlyZWN0b3J5LlJlYWQuQWxsJywgJ0dyb3VwLlJlYWQuQWxsJ10sXG4gICAgQVBQTElDQVRJT05fUkVBRDogWydVc2VyLlJlYWQnLCAnVXNlci5SZWFkQmFzaWMuQWxsJywgJ0RpcmVjdG9yeS5SZWFkLkFsbCcsICdHcm91cC5SZWFkLkFsbCcsICdBcHBsaWNhdGlvbi5SZWFkLkFsbCddLFxufTtcbmV4cG9ydCBjbGFzcyBHcmFwaFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBlcm1pc3Npb25zID0gWydVc2VyLlJlYWQnXTsgLy8gU3RhcnQgd2l0aCBiYXNpYyBwZXJtaXNzaW9uc1xuICAgICAgICB0aGlzLmF1dGhTZXJ2aWNlID0gYXV0aFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gQ2xpZW50LmluaXQoe1xuICAgICAgICAgICAgYXV0aFByb3ZpZGVyOiBhc3luYyAoZG9uZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5hdXRoU2VydmljZS5nZXRUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgdG9rZW4uYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShuZXcgRXJyb3IoJ05vIHZhbGlkIHRva2VuIGF2YWlsYWJsZScpLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShlcnJvciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHByb2ZpbGUgcGhvdG8gc2VydmljZVxuICAgICAgICB0aGlzLnByb2ZpbGVQaG90b1NlcnZpY2UgPSBuZXcgUHJvZmlsZVBob3RvU2VydmljZSh0aGlzLmNsaWVudCk7XG4gICAgfVxuICAgIGFzeW5jIGVuc3VyZVBlcm1pc3Npb25zKHJlcXVpcmVkUGVybWlzc2lvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIGNvbnN0IGhhc0FsbFBlcm1pc3Npb25zID0gcmVxdWlyZWRQZXJtaXNzaW9ucy5ldmVyeShwZXJtaXNzaW9uID0+IHRoaXMuY3VycmVudFBlcm1pc3Npb25zLmluY2x1ZGVzKHBlcm1pc3Npb24pKTtcbiAgICAgICAgICAgIGlmIChoYXNBbGxQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCB0b2tlbiB3aXRoIHJlcXVpcmVkIHBlcm1pc3Npb25zIHNpbGVudGx5IGZpcnN0XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuYXV0aFNlcnZpY2UuZ2V0VG9rZW5XaXRoUGVybWlzc2lvbnMocmVxdWlyZWRQZXJtaXNzaW9ucyk7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJtaXNzaW9ucyA9IFsuLi5uZXcgU2V0KFsuLi50aGlzLmN1cnJlbnRQZXJtaXNzaW9ucywgLi4ucmVxdWlyZWRQZXJtaXNzaW9uc10pXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHNpbGVudCByZXF1ZXN0IGZhaWxzLCByZXF1ZXN0IHBlcm1pc3Npb25zIGludGVyYWN0aXZlbHlcbiAgICAgICAgICAgIGNvbnN0IG5ld1Rva2VuID0gYXdhaXQgdGhpcy5hdXRoU2VydmljZS5yZXF1ZXN0QWRkaXRpb25hbFBlcm1pc3Npb25zKHJlcXVpcmVkUGVybWlzc2lvbnMpO1xuICAgICAgICAgICAgaWYgKG5ld1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVybWlzc2lvbnMgPSBbLi4ubmV3IFNldChbLi4udGhpcy5jdXJyZW50UGVybWlzc2lvbnMsIC4uLnJlcXVpcmVkUGVybWlzc2lvbnNdKV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZW5zdXJlIHBlcm1pc3Npb25zOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBxdWVyeShlbmRwb2ludCwgbWV0aG9kID0gJ0dFVCcsIGRhdGEpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCBzdGF0dXMgPSAyMDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgcmVxdWlyZWQgcGVybWlzc2lvbnMgYmFzZWQgb24gZW5kcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkUGVybWlzc2lvbnMgPSB0aGlzLmdldFJlcXVpcmVkUGVybWlzc2lvbnMoZW5kcG9pbnQsIG1ldGhvZCk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbnNcbiAgICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb25zID0gYXdhaXQgdGhpcy5lbnN1cmVQZXJtaXNzaW9ucyhyZXF1aXJlZFBlcm1pc3Npb25zKTtcbiAgICAgICAgICAgIGlmICghaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBwZXJtaXNzaW9ucyBmb3IgJHtlbmRwb2ludH0uIFJlcXVpcmVkOiAke3JlcXVpcmVkUGVybWlzc2lvbnMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNsaWVudC5hcGkoZW5kcG9pbnQpO1xuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0dFVCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUE9TVCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5wb3N0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdQVVQnOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QucHV0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdQQVRDSCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5wYXRjaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEhUVFAgbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVyci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgICAgIHN0YXR1cyA9IGVyci5jb2RlIHx8IDUwMDtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEdyYXBoIEFQSSBjYWxsIGZhaWxlZDogJHtlbmRwb2ludH1gLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7IC8vIExvZyB0aGUgQVBJIGNhbGwgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBjb25zdCBhcGlDYWxsID0ge1xuICAgICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2dBcGlDYWxsKGFwaUNhbGwpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBnZXRSZXF1aXJlZFBlcm1pc3Npb25zKGVuZHBvaW50LCBtZXRob2QpIHtcbiAgICAgICAgLy8gTWFwIGVuZHBvaW50cyB0byByZXF1aXJlZCBwZXJtaXNzaW9uc1xuICAgICAgICBjb25zdCBlbmRwb2ludExvd2VyID0gZW5kcG9pbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gQmFzaWMgdXNlciBpbmZvIC0gbWluaW1hbCBwZXJtaXNzaW9uc1xuICAgICAgICBpZiAoZW5kcG9pbnRMb3dlci5pbmNsdWRlcygnL21lJykgJiYgbWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgcmV0dXJuIFBFUk1JU1NJT05fVElFUlMuQkFTSUM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlciBxdWVyaWVzIC0gbmVlZCB1c2VyIHJlYWQgcGVybWlzc2lvbnNcbiAgICAgICAgaWYgKGVuZHBvaW50TG93ZXIuaW5jbHVkZXMoJy91c2VycycpICYmIG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHJldHVybiBQRVJNSVNTSU9OX1RJRVJTLlVTRVJfTUFOQUdFTUVOVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHcm91cCBxdWVyaWVzIC0gbmVlZCBncm91cCByZWFkIHBlcm1pc3Npb25zXG4gICAgICAgIGlmIChlbmRwb2ludExvd2VyLmluY2x1ZGVzKCcvZ3JvdXBzJykgJiYgbWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgcmV0dXJuIFBFUk1JU1NJT05fVElFUlMuR1JPVVBfTUFOQUdFTUVOVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBsaWNhdGlvbiBxdWVyaWVzIC0gbmVlZCBhcHBsaWNhdGlvbiByZWFkIHBlcm1pc3Npb25zXG4gICAgICAgIGlmIChlbmRwb2ludExvd2VyLmluY2x1ZGVzKCcvYXBwbGljYXRpb25zJykgfHwgZW5kcG9pbnRMb3dlci5pbmNsdWRlcygnL3NlcnZpY2VQcmluY2lwYWxzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBQRVJNSVNTSU9OX1RJRVJTLkFQUExJQ0FUSU9OX1JFQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlyZWN0b3J5IHF1ZXJpZXMgLSBuZWVkIGRpcmVjdG9yeSByZWFkIHBlcm1pc3Npb25zXG4gICAgICAgIGlmIChlbmRwb2ludExvd2VyLmluY2x1ZGVzKCcvZGlyZWN0b3J5JykgfHwgZW5kcG9pbnRMb3dlci5pbmNsdWRlcygnL29yZ2FuaXphdGlvbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gUEVSTUlTU0lPTl9USUVSUy5ESVJFQ1RPUllfUkVBRDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IHRvIGJhc2ljIHBlcm1pc3Npb25zIGZvciB1bmtub3duIGVuZHBvaW50c1xuICAgICAgICByZXR1cm4gUEVSTUlTU0lPTl9USUVSUy5CQVNJQztcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KCcvbWUnKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VXNlclBob3RvKHVzZXJJZCA9ICdtZScpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBkZWRpY2F0ZWQgUHJvZmlsZVBob3RvU2VydmljZSBmb3IgYmV0dGVyIHBob3RvIHJldHJpZXZhbFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9maWxlUGhvdG9TZXJ2aWNlLmdldFVzZXJQaG90byh1c2VySWQpO1xuICAgIH1cbiAgICBhc3luYyBnZXRVc2VycyhmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBmaWx0ZXIgPyBgL3VzZXJzPyRmaWx0ZXI9JHtlbmNvZGVVUklDb21wb25lbnQoZmlsdGVyKX1gIDogJy91c2Vycyc7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KGVuZHBvaW50KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0R3JvdXBzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeSgnL2dyb3VwcycpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBcHBsaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KCcvYXBwbGljYXRpb25zJyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlcnZpY2VQcmluY2lwYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeSgnL3NlcnZpY2VQcmluY2lwYWxzJyk7XG4gICAgfVxuICAgIGxvZ0FwaUNhbGwoYXBpQ2FsbCkge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGVuaGFuY2VkIHRvIHNlbmQgdG8gYSBsb2dnaW5nIHNlcnZpY2Ugb3Igc3RvcmUgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAgICBjb25zb2xlLmxvZygnR3JhcGggQVBJIENhbGw6Jywge1xuICAgICAgICAgICAgZW5kcG9pbnQ6IGFwaUNhbGwuZW5kcG9pbnQsXG4gICAgICAgICAgICBtZXRob2Q6IGFwaUNhbGwubWV0aG9kLFxuICAgICAgICAgICAgZHVyYXRpb246IGAke2FwaUNhbGwuZHVyYXRpb259bXNgLFxuICAgICAgICAgICAgc3RhdHVzOiBhcGlDYWxsLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yOiBhcGlDYWxsLmVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRW1pdCBldmVudCBmb3IgVUkgdHJhY2luZ1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmVsZWN0cm9uQVBJKSB7XG4gICAgICAgICAgICAvLyBDb3VsZCBlbWl0IHRvIG1haW4gcHJvY2VzcyBmb3IgVUkgdXBkYXRlc1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgYmluZCBmcm9tICcuL2hlbHBlcnMvYmluZC5qcyc7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbmNvbnN0IHt0b1N0cmluZ30gPSBPYmplY3QucHJvdG90eXBlO1xuY29uc3Qge2dldFByb3RvdHlwZU9mfSA9IE9iamVjdDtcbmNvbnN0IHtpdGVyYXRvciwgdG9TdHJpbmdUYWd9ID0gU3ltYm9sO1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgISh0b1N0cmluZ1RhZyBpbiB2YWwpICYmICEoaXRlcmF0b3IgaW4gdmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRGF0ZSA9IGtpbmRPZlRlc3QoJ0RhdGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZSA9IGtpbmRPZlRlc3QoJ0ZpbGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQmxvYiA9IGtpbmRPZlRlc3QoJ0Jsb2InKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVMaXN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0ZpbGVMaXN0ID0ga2luZE9mVGVzdCgnRmlsZUxpc3QnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmVhbSA9ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRm9ybURhdGEgPSAodGhpbmcpID0+IHtcbiAgbGV0IGtpbmQ7XG4gIHJldHVybiB0aGluZyAmJiAoXG4gICAgKHR5cGVvZiBGb3JtRGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGluZyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB8fCAoXG4gICAgICBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgKFxuICAgICAgICAoa2luZCA9IGtpbmRPZih0aGluZykpID09PSAnZm9ybWRhdGEnIHx8XG4gICAgICAgIC8vIGRldGVjdCBmb3JtLWRhdGEgaW5zdGFuY2VcbiAgICAgICAgKGtpbmQgPT09ICdvYmplY3QnICYmIGlzRnVuY3Rpb24odGhpbmcudG9TdHJpbmcpICYmIHRoaW5nLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IEZvcm1EYXRhXScpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VSTFNlYXJjaFBhcmFtcyA9IGtpbmRPZlRlc3QoJ1VSTFNlYXJjaFBhcmFtcycpO1xuXG5jb25zdCBbaXNSZWFkYWJsZVN0cmVhbSwgaXNSZXF1ZXN0LCBpc1Jlc3BvbnNlLCBpc0hlYWRlcnNdID0gWydSZWFkYWJsZVN0cmVhbScsICdSZXF1ZXN0JywgJ1Jlc3BvbnNlJywgJ0hlYWRlcnMnXS5tYXAoa2luZE9mVGVzdCk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzXVxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5jb25zdCBleHRlbmQgPSAoYSwgYiwgdGhpc0FyZywge2FsbE93bktleXN9PSB7fSkgPT4ge1xuICBmb3JFYWNoKGIsICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuY29uc3Qgc3RyaXBCT00gPSAoY29udGVudCkgPT4ge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pID0+IHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbaXRlcmF0b3JdO1xuXG4gIGNvbnN0IF9pdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IF9pdGVyYXRvci5uZXh0KCkpICYmICFyZXN1bHQuZG9uZSkge1xuICAgIGNvbnN0IHBhaXIgPSByZXN1bHQudmFsdWU7XG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xuICB9XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnRXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxib29sZWFuPn1cbiAqL1xuY29uc3QgbWF0Y2hBbGwgPSAocmVnRXhwLCBzdHIpID0+IHtcbiAgbGV0IG1hdGNoZXM7XG4gIGNvbnN0IGFyciA9IFtdO1xuXG4gIHdoaWxlICgobWF0Y2hlcyA9IHJlZ0V4cC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgYXJyLnB1c2gobWF0Y2hlcyk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG4vKiBDaGVja2luZyBpZiB0aGUga2luZE9mVGVzdCBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiBwYXNzZWQgYW4gSFRNTEZvcm1FbGVtZW50LiAqL1xuY29uc3QgaXNIVE1MRm9ybSA9IGtpbmRPZlRlc3QoJ0hUTUxGb3JtRWxlbWVudCcpO1xuXG5jb25zdCB0b0NhbWVsQ2FzZSA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9cXHNdKFthLXpcXGRdKShcXHcqKS9nLFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG0sIHAxLCBwMikge1xuICAgICAgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCkgKyBwMjtcbiAgICB9XG4gICk7XG59O1xuXG4vKiBDcmVhdGluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9ICgoe2hhc093blByb3BlcnR5fSkgPT4gKG9iaiwgcHJvcCkgPT4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKShPYmplY3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUmVnRXhwID0ga2luZE9mVGVzdCgnUmVnRXhwJyk7XG5cbmNvbnN0IHJlZHVjZURlc2NyaXB0b3JzID0gKG9iaiwgcmVkdWNlcikgPT4ge1xuICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaik7XG4gIGNvbnN0IHJlZHVjZWREZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZvckVhY2goZGVzY3JpcHRvcnMsIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgbGV0IHJldDtcbiAgICBpZiAoKHJldCA9IHJlZHVjZXIoZGVzY3JpcHRvciwgbmFtZSwgb2JqKSkgIT09IGZhbHNlKSB7XG4gICAgICByZWR1Y2VkRGVzY3JpcHRvcnNbbmFtZV0gPSByZXQgfHwgZGVzY3JpcHRvcjtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcmVkdWNlZERlc2NyaXB0b3JzKTtcbn1cblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUgPSArdmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaW5nIC0gVGhlIHRoaW5nIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XG4gIHJldHVybiAhISh0aGluZyAmJiBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgdGhpbmdbdG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW2l0ZXJhdG9yXSk7XG59XG5cbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgQXJyYXkoMTApO1xuXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCEoJ3RvSlNPTicgaW4gc291cmNlKSkge1xuICAgICAgICBzdGFja1tpXSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXNBcnJheShzb3VyY2UpID8gW10gOiB7fTtcblxuICAgICAgICBmb3JFYWNoKHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VkVmFsdWUgPSB2aXNpdCh2YWx1ZSwgaSArIDEpO1xuICAgICAgICAgICFpc1VuZGVmaW5lZChyZWR1Y2VkVmFsdWUpICYmICh0YXJnZXRba2V5XSA9IHJlZHVjZWRWYWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0YWNrW2ldID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiB2aXNpdChvYmosIDApO1xufVxuXG5jb25zdCBpc0FzeW5jRm4gPSBraW5kT2ZUZXN0KCdBc3luY0Z1bmN0aW9uJyk7XG5cbmNvbnN0IGlzVGhlbmFibGUgPSAodGhpbmcpID0+XG4gIHRoaW5nICYmIChpc09iamVjdCh0aGluZykgfHwgaXNGdW5jdGlvbih0aGluZykpICYmIGlzRnVuY3Rpb24odGhpbmcudGhlbikgJiYgaXNGdW5jdGlvbih0aGluZy5jYXRjaCk7XG5cbi8vIG9yaWdpbmFsIGNvZGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EaWdpdGFsQnJhaW5KUy9BeGlvc1Byb21pc2UvYmxvYi8xNmRlYWIxMzcxMGVjMDk3Nzk5MjIxMzFmM2ZhNTk1NDMyMGY4M2FiL2xpYi91dGlscy5qcyNMMTEtTDM0XG5cbmNvbnN0IF9zZXRJbW1lZGlhdGUgPSAoKHNldEltbWVkaWF0ZVN1cHBvcnRlZCwgcG9zdE1lc3NhZ2VTdXBwb3J0ZWQpID0+IHtcbiAgaWYgKHNldEltbWVkaWF0ZVN1cHBvcnRlZCkge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGU7XG4gIH1cblxuICByZXR1cm4gcG9zdE1lc3NhZ2VTdXBwb3J0ZWQgPyAoKHRva2VuLCBjYWxsYmFja3MpID0+IHtcbiAgICBfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7c291cmNlLCBkYXRhfSkgPT4ge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gX2dsb2JhbCAmJiBkYXRhID09PSB0b2tlbikge1xuICAgICAgICBjYWxsYmFja3MubGVuZ3RoICYmIGNhbGxiYWNrcy5zaGlmdCgpKCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgX2dsb2JhbC5wb3N0TWVzc2FnZSh0b2tlbiwgXCIqXCIpO1xuICAgIH1cbiAgfSkoYGF4aW9zQCR7TWF0aC5yYW5kb20oKX1gLCBbXSkgOiAoY2IpID0+IHNldFRpbWVvdXQoY2IpO1xufSkoXG4gIHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicsXG4gIGlzRnVuY3Rpb24oX2dsb2JhbC5wb3N0TWVzc2FnZSlcbik7XG5cbmNvbnN0IGFzYXAgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgIT09ICd1bmRlZmluZWQnID9cbiAgcXVldWVNaWNyb3Rhc2suYmluZChfZ2xvYmFsKSA6ICggdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgX3NldEltbWVkaWF0ZSk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKlxuXG5cbmNvbnN0IGlzSXRlcmFibGUgPSAodGhpbmcpID0+IHRoaW5nICE9IG51bGwgJiYgaXNGdW5jdGlvbih0aGluZ1tpdGVyYXRvcl0pO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXIsXG4gIGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZyxcbiAgaXNOdW1iZXIsXG4gIGlzQm9vbGVhbixcbiAgaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVxdWVzdCxcbiAgaXNSZXNwb25zZSxcbiAgaXNIZWFkZXJzLFxuICBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlLFxuICBpc0ZpbGUsXG4gIGlzQmxvYixcbiAgaXNSZWdFeHAsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBpc1NwZWNDb21wbGlhbnRGb3JtLFxuICB0b0pTT05PYmplY3QsXG4gIGlzQXN5bmNGbixcbiAgaXNUaGVuYWJsZSxcbiAgc2V0SW1tZWRpYXRlOiBfc2V0SW1tZWRpYXRlLFxuICBhc2FwLFxuICBpc0l0ZXJhYmxlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQXhpb3NFcnJvcihtZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gIH1cblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLm5hbWUgPSAnQXhpb3NFcnJvcic7XG4gIGNvZGUgJiYgKHRoaXMuY29kZSA9IGNvZGUpO1xuICBjb25maWcgJiYgKHRoaXMuY29uZmlnID0gY29uZmlnKTtcbiAgcmVxdWVzdCAmJiAodGhpcy5yZXF1ZXN0ID0gcmVxdWVzdCk7XG4gIGlmIChyZXNwb25zZSkge1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cyA/IHJlc3BvbnNlLnN0YXR1cyA6IG51bGw7XG4gIH1cbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdXRpbHMudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXNcbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG5jb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJyxcbiAgJ0VSUl9OT1RfU1VQUE9SVCcsXG4gICdFUlJfSU5WQUxJRF9VUkwnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXS5mb3JFYWNoKGNvZGUgPT4ge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ2lzQXhpb3NFcnJvcicsIHt2YWx1ZTogdHJ1ZX0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuQXhpb3NFcnJvci5mcm9tID0gKGVycm9yLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlLCBjdXN0b21Qcm9wcykgPT4ge1xuICBjb25zdCBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuXG4gIHV0aWxzLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSwgcHJvcCA9PiB7XG4gICAgcmV0dXJuIHByb3AgIT09ICdpc0F4aW9zRXJyb3InO1xuICB9KTtcblxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgYXhpb3NFcnJvci5jYXVzZSA9IGVycm9yO1xuXG4gIGF4aW9zRXJyb3IubmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XG5cbiAgcmV0dXJuIGF4aW9zRXJyb3I7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0Vycm9yO1xuIiwiaW1wb3J0IEZvcm1EYXRhIGZyb20gJ2Zvcm0tZGF0YSc7XG5cbmV4cG9ydCBkZWZhdWx0IEZvcm1EYXRhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbi8vIHRlbXBvcmFyeSBob3RmaXggdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyB1bnRpbCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBpcyByZWZhY3RvcmVkXG5pbXBvcnQgUGxhdGZvcm1Gb3JtRGF0YSBmcm9tICcuLi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscy5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMudG9GbGF0T2JqZWN0KHV0aWxzLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChQbGF0Zm9ybUZvcm1EYXRhIHx8IEZvcm1EYXRhKSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscy5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZm9ybURhdGEpO1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMuaXNCbG9iKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUpO1xuICB9IDogZW5jb2RlO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5cbi8qKlxuICogSXQgcmVwbGFjZXMgYWxsIGluc3RhbmNlcyBvZiB0aGUgY2hhcmFjdGVycyBgOmAsIGAkYCwgYCxgLCBgK2AsIGBbYCwgYW5kIGBdYCB3aXRoIHRoZWlyXG4gKiBVUkkgZW5jb2RlZCBjb3VudGVycGFydHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIFRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHBhcmFtIHs/KG9iamVjdHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIFxuICBjb25zdCBfZW5jb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kZSB8fCBlbmNvZGU7XG5cbiAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgc2VyaWFsaXplOiBvcHRpb25zXG4gICAgfTtcbiAgfSBcblxuICBjb25zdCBzZXJpYWxpemVGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemU7XG5cbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XG5cbiAgaWYgKHNlcmlhbGl6ZUZuKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykgP1xuICAgICAgcGFyYW1zLnRvU3RyaW5nKCkgOlxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykudG9TdHJpbmcoX2VuY29kZSk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIGNvbnN0IGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG5cbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBJbnRlcmNlcHRvck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAgICovXG4gIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgIGZ1bGZpbGxlZCxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW50ZXJjZXB0b3Igd2FzIHJlbW92ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqL1xuICBlamVjdChpZCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgaW50ZXJjZXB0b3JzIGZyb20gdGhlIHN0YWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAgICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZm9yRWFjaChmbikge1xuICAgIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgICAgZm4oaCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxuICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmV4cG9ydCBkZWZhdWx0IHVybC5VUkxTZWFyY2hQYXJhbXM7XG4iLCJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4vY2xhc3Nlcy9VUkxTZWFyY2hQYXJhbXMuanMnXG5pbXBvcnQgRm9ybURhdGEgZnJvbSAnLi9jbGFzc2VzL0Zvcm1EYXRhLmpzJ1xuXG5jb25zdCBBTFBIQSA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcblxuY29uc3QgRElHSVQgPSAnMDEyMzQ1Njc4OSc7XG5cbmNvbnN0IEFMUEhBQkVUID0ge1xuICBESUdJVCxcbiAgQUxQSEEsXG4gIEFMUEhBX0RJR0lUOiBBTFBIQSArIEFMUEhBLnRvVXBwZXJDYXNlKCkgKyBESUdJVFxufVxuXG5jb25zdCBnZW5lcmF0ZVN0cmluZyA9IChzaXplID0gMTYsIGFscGhhYmV0ID0gQUxQSEFCRVQuQUxQSEFfRElHSVQpID0+IHtcbiAgbGV0IHN0ciA9ICcnO1xuICBjb25zdCB7bGVuZ3RofSA9IGFscGhhYmV0O1xuICBjb25zdCByYW5kb21WYWx1ZXMgPSBuZXcgVWludDMyQXJyYXkoc2l6ZSk7XG4gIGNyeXB0by5yYW5kb21GaWxsU3luYyhyYW5kb21WYWx1ZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHN0ciArPSBhbHBoYWJldFtyYW5kb21WYWx1ZXNbaV0gJSBsZW5ndGhdO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzTm9kZTogdHJ1ZSxcbiAgY2xhc3Nlczoge1xuICAgIFVSTFNlYXJjaFBhcmFtcyxcbiAgICBGb3JtRGF0YSxcbiAgICBCbG9iOiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYiB8fCBudWxsXG4gIH0sXG4gIEFMUEhBQkVULFxuICBnZW5lcmF0ZVN0cmluZyxcbiAgcHJvdG9jb2xzOiBbICdodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnZGF0YScgXVxufTtcbiIsImNvbnN0IGhhc0Jyb3dzZXJFbnYgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBfbmF2aWdhdG9yID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yIHx8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc1N0YW5kYXJkQnJvd3NlckVudiA9IGhhc0Jyb3dzZXJFbnYgJiZcbiAgKCFfbmF2aWdhdG9yIHx8IFsnUmVhY3ROYXRpdmUnLCAnTmF0aXZlU2NyaXB0JywgJ05TJ10uaW5kZXhPZihfbmF2aWdhdG9yLnByb2R1Y3QpIDwgMCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIHdlYldvcmtlciBlbnZpcm9ubWVudFxuICpcbiAqIEFsdGhvdWdoIHRoZSBgaXNTdGFuZGFyZEJyb3dzZXJFbnZgIG1ldGhvZCBpbmRpY2F0ZXMgdGhhdFxuICogYGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyYCwgdGhlIFdlYldvcmtlciB3aWxsIHN0aWxsIGJlXG4gKiBmaWx0ZXJlZCBvdXQgZHVlIHRvIGl0cyBqdWRnbWVudCBzdGFuZGFyZFxuICogYHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdgLlxuICogVGhpcyBsZWFkcyB0byBhIHByb2JsZW0gd2hlbiBheGlvcyBwb3N0IGBGb3JtRGF0YWAgaW4gd2ViV29ya2VyXG4gKi9cbmNvbnN0IGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudiA9ICgoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgIHR5cGVvZiBzZWxmLmltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbidcbiAgKTtcbn0pKCk7XG5cbmNvbnN0IG9yaWdpbiA9IGhhc0Jyb3dzZXJFbnYgJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJ2h0dHA6Ly9sb2NhbGhvc3QnO1xuXG5leHBvcnQge1xuICBoYXNCcm93c2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYsXG4gIGhhc1N0YW5kYXJkQnJvd3NlckVudixcbiAgX25hdmlnYXRvciBhcyBuYXZpZ2F0b3IsXG4gIG9yaWdpblxufVxuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vbm9kZS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2NvbW1vbi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLi4udXRpbHMsXG4gIC4uLnBsYXRmb3JtXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b0Zvcm1EYXRhKGRhdGEsIG5ldyBwbGF0Zm9ybS5jbGFzc2VzLlVSTFNlYXJjaFBhcmFtcygpLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aXNpdG9yOiBmdW5jdGlvbih2YWx1ZSwga2V5LCBwYXRoLCBoZWxwZXJzKSB7XG4gICAgICBpZiAocGxhdGZvcm0uaXNOb2RlICYmIHV0aWxzLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuZGVmYXVsdFZpc2l0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHN0cmluZyBsaWtlIGBmb29beF1beV1bel1gIGFuZCByZXR1cm5zIGFuIGFycmF5IGxpa2UgYFsnZm9vJywgJ3gnLCAneScsICd6J11cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9wUGF0aChuYW1lKSB7XG4gIC8vIGZvb1t4XVt5XVt6XVxuICAvLyBmb28ueC55LnpcbiAgLy8gZm9vLXgteS16XG4gIC8vIGZvbyB4IHkgelxuICByZXR1cm4gdXRpbHMubWF0Y2hBbGwoL1xcdyt8XFxbKFxcdyopXS9nLCBuYW1lKS5tYXAobWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNvbnZlcnQgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJyKTtcbiAgbGV0IGk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIG9ialtrZXldID0gYXJyW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIEZvcm1EYXRhIG9iamVjdCBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBhbnk+IHwgbnVsbH0gVGhlIGNvbnZlcnRlZCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGZvcm1EYXRhVG9KU09OKGZvcm1EYXRhKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0LCBpbmRleCkge1xuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBpc051bWVyaWNLZXkgPSBOdW1iZXIuaXNGaW5pdGUoK25hbWUpO1xuICAgIGNvbnN0IGlzTGFzdCA9IGluZGV4ID49IHBhdGgubGVuZ3RoO1xuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscy5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubGVuZ3RoIDogbmFtZTtcblxuICAgIGlmIChpc0xhc3QpIHtcbiAgICAgIGlmICh1dGlscy5oYXNPd25Qcm9wKHRhcmdldCwgbmFtZSkpIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gW3RhcmdldFtuYW1lXSwgdmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0W25hbWVdIHx8ICF1dGlscy5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldFtuYW1lXSwgaW5kZXgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc0FycmF5KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc0Zvcm1EYXRhKGZvcm1EYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGZvcm1EYXRhLmVudHJpZXMpKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgYnVpbGRQYXRoKHBhcnNlUHJvcFBhdGgobmFtZSksIHZhbHVlLCBvYmosIDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtRGF0YVRvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi90cmFuc2l0aW9uYWwuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi4vaGVscGVycy90b0Zvcm1EYXRhLmpzJztcbmltcG9ydCB0b1VSTEVuY29kZWRGb3JtIGZyb20gJy4uL2hlbHBlcnMvdG9VUkxFbmNvZGVkRm9ybS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZvcm1EYXRhVG9KU09OIGZyb20gJy4uL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJywgJ2ZldGNoJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBpc0ZpbGVMaXN0O1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpc0ZpbGVMaXN0ID0gdXRpbHMuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcbiAgICAgICAgY29uc3QgX0Zvcm1EYXRhID0gdGhpcy5lbnYgJiYgdGhpcy5lbnYuRm9ybURhdGE7XG5cbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXG4gICAgICAgICAgaXNGaWxlTGlzdCA/IHsnZmlsZXNbXSc6IGRhdGF9IDogZGF0YSxcbiAgICAgICAgICBfRm9ybURhdGEgJiYgbmV3IF9Gb3JtRGF0YSgpLFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGhhc0pTT05Db250ZW50VHlwZSApIHtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5U2FmZWx5KGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIGNvbnN0IEpTT05SZXF1ZXN0ZWQgPSB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHV0aWxzLmlzUmVzcG9uc2UoZGF0YSkgfHwgdXRpbHMuaXNSZWFkYWJsZVN0cmVhbShkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YSkgJiYgKChmb3JjZWRKU09OUGFyc2luZyAmJiAhdGhpcy5yZXNwb25zZVR5cGUpIHx8IEpTT05SZXF1ZXN0ZWQpKSB7XG4gICAgICBjb25zdCBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0cmljdEpTT05QYXJzaW5nKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgQXhpb3NFcnJvci5mcm9tKGUsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSwgdGhpcywgbnVsbCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIGVudjoge1xuICAgIEZvcm1EYXRhOiBwbGF0Zm9ybS5jbGFzc2VzLkZvcm1EYXRhLFxuICAgIEJsb2I6IHBsYXRmb3JtLmNsYXNzZXMuQmxvYlxuICB9LFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCddLCAobWV0aG9kKSA9PiB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi4vaGVscGVycy9wYXJzZUhlYWRlcnMuanMnO1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb2tlbnMoc3RyKSB7XG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHRva2Vuc1JFID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbnNSRS5leGVjKHN0cikpKSB7XG4gICAgdG9rZW5zW21hdGNoWzFdXSA9IG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuY29uc3QgaXNWYWxpZEhlYWRlck5hbWUgPSAoc3RyKSA9PiAvXlstX2EtekEtWjAtOV5gfH4sISMkJSYnKisuXSskLy50ZXN0KHN0ci50cmltKCkpO1xuXG5mdW5jdGlvbiBtYXRjaEhlYWRlclZhbHVlKGNvbnRleHQsIHZhbHVlLCBoZWFkZXIsIGZpbHRlciwgaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gICAgdmFsdWUgPSBoZWFkZXI7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscy5pc1N0cmluZyhmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsdGVyKSAhPT0gLTE7XG4gIH1cblxuICBpZiAodXRpbHMuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMudG9DYW1lbENhc2UoJyAnICsgaGVhZGVyKTtcblxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBtZXRob2ROYW1lICsgYWNjZXNzb3JOYW1lLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBBeGlvc0hlYWRlcnMge1xuICBjb25zdHJ1Y3RvcihoZWFkZXJzKSB7XG4gICAgaGVhZGVycyAmJiB0aGlzLnNldChoZWFkZXJzKTtcbiAgfVxuXG4gIHNldChoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFsSGVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGVhZGVyIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShzZWxmLCBsSGVhZGVyKTtcblxuICAgICAgaWYoIWtleSB8fCBzZWxmW2tleV0gPT09IHVuZGVmaW5lZCB8fCBfcmV3cml0ZSA9PT0gdHJ1ZSB8fCAoX3Jld3JpdGUgPT09IHVuZGVmaW5lZCAmJiBzZWxmW2tleV0gIT09IGZhbHNlKSkge1xuICAgICAgICBzZWxmW2tleSB8fCBfaGVhZGVyXSA9IG5vcm1hbGl6ZVZhbHVlKF92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0SGVhZGVycyA9IChoZWFkZXJzLCBfcmV3cml0ZSkgPT5cbiAgICAgIHV0aWxzLmZvckVhY2goaGVhZGVycywgKF92YWx1ZSwgX2hlYWRlcikgPT4gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpKTtcblxuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGhlYWRlcikgfHwgaGVhZGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgc2V0SGVhZGVycyhoZWFkZXIsIHZhbHVlT3JSZXdyaXRlKVxuICAgIH0gZWxzZSBpZih1dGlscy5pc1N0cmluZyhoZWFkZXIpICYmIChoZWFkZXIgPSBoZWFkZXIudHJpbSgpKSAmJiAhaXNWYWxpZEhlYWRlck5hbWUoaGVhZGVyKSkge1xuICAgICAgc2V0SGVhZGVycyhwYXJzZUhlYWRlcnMoaGVhZGVyKSwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QoaGVhZGVyKSAmJiB1dGlscy5pc0l0ZXJhYmxlKGhlYWRlcikpIHtcbiAgICAgIGxldCBvYmogPSB7fSwgZGVzdCwga2V5O1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBoZWFkZXIpIHtcbiAgICAgICAgaWYgKCF1dGlscy5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignT2JqZWN0IGl0ZXJhdG9yIG11c3QgcmV0dXJuIGEga2V5LXZhbHVlIHBhaXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ialtrZXkgPSBlbnRyeVswXV0gPSAoZGVzdCA9IG9ialtrZXldKSA/XG4gICAgICAgICAgKHV0aWxzLmlzQXJyYXkoZGVzdCkgPyBbLi4uZGVzdCwgZW50cnlbMV1dIDogW2Rlc3QsIGVudHJ5WzFdXSkgOiBlbnRyeVsxXTtcbiAgICAgIH1cblxuICAgICAgc2V0SGVhZGVycyhvYmosIHZhbHVlT3JSZXdyaXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgIT0gbnVsbCAmJiBzZXRIZWFkZXIodmFsdWVPclJld3JpdGUsIGhlYWRlciwgcmV3cml0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQoaGVhZGVyLCBwYXJzZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbnModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1JlZ0V4cChwYXJzZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5leGVjKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcnNlciBtdXN0IGJlIGJvb2xlYW58cmVnZXhwfGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFzKGhlYWRlciwgbWF0Y2hlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleSh0aGlzLCBoZWFkZXIpO1xuXG4gICAgICByZXR1cm4gISEoa2V5ICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlbGV0ZShoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlSGVhZGVyKF9oZWFkZXIpIHtcbiAgICAgIF9oZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmIChfaGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgX2hlYWRlcik7XG5cbiAgICAgICAgaWYgKGtleSAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZShzZWxmLCBzZWxmW2tleV0sIGtleSwgbWF0Y2hlcikpKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcblxuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgaGVhZGVyLmZvckVhY2goZGVsZXRlSGVhZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlSGVhZGVyKGhlYWRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBjbGVhcihtYXRjaGVyKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZighbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyLCB0cnVlKSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIG5vcm1hbGl6ZShmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KGhlYWRlcnMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc2VsZltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmb3JtYXQgPyBmb3JtYXRIZWFkZXIoaGVhZGVyKSA6IFN0cmluZyhoZWFkZXIpLnRyaW0oKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgfVxuXG4gICAgICBzZWxmW25vcm1hbGl6ZWRdID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uY2F0KC4uLnRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb25jYXQodGhpcywgLi4udGFyZ2V0cyk7XG4gIH1cblxuICB0b0pTT04oYXNTdHJpbmdzKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHV0aWxzLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcbiAgICAgIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIChvYmpbaGVhZGVyXSA9IGFzU3RyaW5ncyAmJiB1dGlscy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKS5tYXAoKFtoZWFkZXIsIHZhbHVlXSkgPT4gaGVhZGVyICsgJzogJyArIHZhbHVlKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGdldFNldENvb2tpZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZXQtY29va2llXCIpIHx8IFtdO1xuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnQXhpb3NIZWFkZXJzJztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tKHRoaW5nKSB7XG4gICAgcmV0dXJuIHRoaW5nIGluc3RhbmNlb2YgdGhpcyA/IHRoaW5nIDogbmV3IHRoaXModGhpbmcpO1xuICB9XG5cbiAgc3RhdGljIGNvbmNhdChmaXJzdCwgLi4udGFyZ2V0cykge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gbmV3IHRoaXMoZmlyc3QpO1xuXG4gICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IGNvbXB1dGVkLnNldCh0YXJnZXQpKTtcblxuICAgIHJldHVybiBjb21wdXRlZDtcbiAgfVxuXG4gIHN0YXRpYyBhY2Nlc3NvcihoZWFkZXIpIHtcbiAgICBjb25zdCBpbnRlcm5hbHMgPSB0aGlzWyRpbnRlcm5hbHNdID0gKHRoaXNbJGludGVybmFsc10gPSB7XG4gICAgICBhY2Nlc3NvcnM6IHt9XG4gICAgfSk7XG5cbiAgICBjb25zdCBhY2Nlc3NvcnMgPSBpbnRlcm5hbHMuYWNjZXNzb3JzO1xuICAgIGNvbnN0IHByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gZGVmaW5lQWNjZXNzb3IoX2hlYWRlcikge1xuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcblxuICAgICAgaWYgKCFhY2Nlc3NvcnNbbEhlYWRlcl0pIHtcbiAgICAgICAgYnVpbGRBY2Nlc3NvcnMocHJvdG90eXBlLCBfaGVhZGVyKTtcbiAgICAgICAgYWNjZXNzb3JzW2xIZWFkZXJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlscy5pc0FycmF5KGhlYWRlcikgPyBoZWFkZXIuZm9yRWFjaChkZWZpbmVBY2Nlc3NvcikgOiBkZWZpbmVBY2Nlc3NvcihoZWFkZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuQXhpb3NIZWFkZXJzLmFjY2Vzc29yKFsnQ29udGVudC1UeXBlJywgJ0NvbnRlbnQtTGVuZ3RoJywgJ0FjY2VwdCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnVXNlci1BZ2VudCcsICdBdXRob3JpemF0aW9uJ10pO1xuXG4vLyByZXNlcnZlZCBuYW1lcyBob3RmaXhcbnV0aWxzLnJlZHVjZURlc2NyaXB0b3JzKEF4aW9zSGVhZGVycy5wcm90b3R5cGUsICh7dmFsdWV9LCBrZXkpID0+IHtcbiAgbGV0IG1hcHBlZCA9IGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpOyAvLyBtYXAgYHNldGAgPT4gYFNldGBcbiAgcmV0dXJuIHtcbiAgICBnZXQ6ICgpID0+IHZhbHVlLFxuICAgIHNldChoZWFkZXJWYWx1ZSkge1xuICAgICAgdGhpc1ttYXBwZWRdID0gaGVhZGVyVmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudXRpbHMuZnJlZXplTWV0aG9kcyhBeGlvc0hlYWRlcnMpO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvc0hlYWRlcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZucywgcmVzcG9uc2UpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgY29uc3QgY29udGV4dCA9IHJlc3BvbnNlIHx8IGNvbmZpZztcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb25maWcsIGRhdGEsIGhlYWRlcnMubm9ybWFsaXplKCksIHJlc3BvbnNlID8gcmVzcG9uc2Uuc3RhdHVzIDogdW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaGVhZGVycy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxlZEVycm9yYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gcmVxdWVzdCBUaGUgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsZWRFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBBeGlvc0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSA9PSBudWxsID8gJ2NhbmNlbGVkJyA6IG1lc3NhZ2UsIEF4aW9zRXJyb3IuRVJSX0NBTkNFTEVELCBjb25maWcsIHJlcXVlc3QpO1xuICB0aGlzLm5hbWUgPSAnQ2FuY2VsZWRFcnJvcic7XG59XG5cbnV0aWxzLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbGVkRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vQXhpb3NFcnJvci5qcyc7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvP1xcLyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGlzQWJzb2x1dGVVUkwgZnJvbSAnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMLmpzJztcbmltcG9ydCBjb21iaW5lVVJMcyBmcm9tICcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMLCBhbGxvd0Fic29sdXRlVXJscykge1xuICBsZXQgaXNSZWxhdGl2ZVVybCA9ICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCk7XG4gIGlmIChiYXNlVVJMICYmIChpc1JlbGF0aXZlVXJsIHx8IGFsbG93QWJzb2x1dGVVcmxzID09IGZhbHNlKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59XG4iLCJjb25zdCBfX1dFQlBBQ0tfTkFNRVNQQUNFX09CSkVDVF9fID0gcmVxdWlyZShcInpsaWJcIik7IiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuOS4wXCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICBjb25zdCBtYXRjaCA9IC9eKFstK1xcd117MSwyNX0pKDo/XFwvXFwvfDopLy5leGVjKHVybCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCBwYXJzZVByb3RvY29sIGZyb20gJy4vcGFyc2VQcm90b2NvbC5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL14oPzooW147XSspOyk/KD86W147XSs7KT8oYmFzZTY0fCksKFtcXHNcXFNdKikkLztcblxuLyoqXG4gKiBQYXJzZSBkYXRhIHVyaSB0byBhIEJ1ZmZlciBvciBCbG9iXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQHBhcmFtIHs/Qm9vbGVhbn0gYXNCbG9iXG4gKiBAcGFyYW0gez9PYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBvcHRpb25zLkJsb2JcbiAqXG4gKiBAcmV0dXJucyB7QnVmZmVyfEJsb2J9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZyb21EYXRhVVJJKHVyaSwgYXNCbG9iLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucyAmJiBvcHRpb25zLkJsb2IgfHwgcGxhdGZvcm0uY2xhc3Nlcy5CbG9iO1xuICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2wodXJpKTtcblxuICBpZiAoYXNCbG9iID09PSB1bmRlZmluZWQgJiYgX0Jsb2IpIHtcbiAgICBhc0Jsb2IgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnZGF0YScpIHtcbiAgICB1cmkgPSBwcm90b2NvbC5sZW5ndGggPyB1cmkuc2xpY2UocHJvdG9jb2wubGVuZ3RoICsgMSkgOiB1cmk7XG5cbiAgICBjb25zdCBtYXRjaCA9IERBVEFfVVJMX1BBVFRFUk4uZXhlYyh1cmkpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0ludmFsaWQgVVJMJywgQXhpb3NFcnJvci5FUlJfSU5WQUxJRF9VUkwpO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbWUgPSBtYXRjaFsxXTtcbiAgICBjb25zdCBpc0Jhc2U2NCA9IG1hdGNoWzJdO1xuICAgIGNvbnN0IGJvZHkgPSBtYXRjaFszXTtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkZWNvZGVVUklDb21wb25lbnQoYm9keSksIGlzQmFzZTY0ID8gJ2Jhc2U2NCcgOiAndXRmOCcpO1xuXG4gICAgaWYgKGFzQmxvYikge1xuICAgICAgaWYgKCFfQmxvYikge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignQmxvYiBpcyBub3Qgc3VwcG9ydGVkJywgQXhpb3NFcnJvci5FUlJfTk9UX1NVUFBPUlQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IF9CbG9iKFtidWZmZXJdLCB7dHlwZTogbWltZX0pO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH1cblxuICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sLCBBeGlvc0Vycm9yLkVSUl9OT1RfU1VQUE9SVCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNvbnN0IGtJbnRlcm5hbHMgPSBTeW1ib2woJ2ludGVybmFscycpO1xuXG5jbGFzcyBBeGlvc1RyYW5zZm9ybVN0cmVhbSBleHRlbmRzIHN0cmVhbS5UcmFuc2Zvcm17XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgIG1heFJhdGU6IDAsXG4gICAgICBjaHVua1NpemU6IDY0ICogMTAyNCxcbiAgICAgIG1pbkNodW5rU2l6ZTogMTAwLFxuICAgICAgdGltZVdpbmRvdzogNTAwLFxuICAgICAgdGlja3NSYXRlOiAyLFxuICAgICAgc2FtcGxlc0NvdW50OiAxNVxuICAgIH0sIG51bGwsIChwcm9wLCBzb3VyY2UpID0+IHtcbiAgICAgIHJldHVybiAhdXRpbHMuaXNVbmRlZmluZWQoc291cmNlW3Byb3BdKTtcbiAgICB9KTtcblxuICAgIHN1cGVyKHtcbiAgICAgIHJlYWRhYmxlSGlnaFdhdGVyTWFyazogb3B0aW9ucy5jaHVua1NpemVcbiAgICB9KTtcblxuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNba0ludGVybmFsc10gPSB7XG4gICAgICB0aW1lV2luZG93OiBvcHRpb25zLnRpbWVXaW5kb3csXG4gICAgICBjaHVua1NpemU6IG9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgbWF4UmF0ZTogb3B0aW9ucy5tYXhSYXRlLFxuICAgICAgbWluQ2h1bmtTaXplOiBvcHRpb25zLm1pbkNodW5rU2l6ZSxcbiAgICAgIGJ5dGVzU2VlbjogMCxcbiAgICAgIGlzQ2FwdHVyZWQ6IGZhbHNlLFxuICAgICAgbm90aWZpZWRCeXRlc0xvYWRlZDogMCxcbiAgICAgIHRzOiBEYXRlLm5vdygpLFxuICAgICAgYnl0ZXM6IDAsXG4gICAgICBvblJlYWRDYWxsYmFjazogbnVsbFxuICAgIH07XG5cbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudCA9PT0gJ3Byb2dyZXNzJykge1xuICAgICAgICBpZiAoIWludGVybmFscy5pc0NhcHR1cmVkKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmlzQ2FwdHVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfcmVhZChzaXplKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1trSW50ZXJuYWxzXTtcblxuICAgIGlmIChpbnRlcm5hbHMub25SZWFkQ2FsbGJhY2spIHtcbiAgICAgIGludGVybmFscy5vblJlYWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5fcmVhZChzaXplKTtcbiAgfVxuXG4gIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNba0ludGVybmFsc107XG4gICAgY29uc3QgbWF4UmF0ZSA9IGludGVybmFscy5tYXhSYXRlO1xuXG4gICAgY29uc3QgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gdGhpcy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG5cbiAgICBjb25zdCB0aW1lV2luZG93ID0gaW50ZXJuYWxzLnRpbWVXaW5kb3c7XG5cbiAgICBjb25zdCBkaXZpZGVyID0gMTAwMCAvIHRpbWVXaW5kb3c7XG4gICAgY29uc3QgYnl0ZXNUaHJlc2hvbGQgPSAobWF4UmF0ZSAvIGRpdmlkZXIpO1xuICAgIGNvbnN0IG1pbkNodW5rU2l6ZSA9IGludGVybmFscy5taW5DaHVua1NpemUgIT09IGZhbHNlID8gTWF0aC5tYXgoaW50ZXJuYWxzLm1pbkNodW5rU2l6ZSwgYnl0ZXNUaHJlc2hvbGQgKiAwLjAxKSA6IDA7XG5cbiAgICBjb25zdCBwdXNoQ2h1bmsgPSAoX2NodW5rLCBfY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoX2NodW5rKTtcbiAgICAgIGludGVybmFscy5ieXRlc1NlZW4gKz0gYnl0ZXM7XG4gICAgICBpbnRlcm5hbHMuYnl0ZXMgKz0gYnl0ZXM7XG5cbiAgICAgIGludGVybmFscy5pc0NhcHR1cmVkICYmIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCBpbnRlcm5hbHMuYnl0ZXNTZWVuKTtcblxuICAgICAgaWYgKHRoaXMucHVzaChfY2h1bmspKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soX2NhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFscy5vblJlYWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICBpbnRlcm5hbHMub25SZWFkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soX2NhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1DaHVuayA9IChfY2h1bmssIF9jYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgoX2NodW5rKTtcbiAgICAgIGxldCBjaHVua1JlbWFpbmRlciA9IG51bGw7XG4gICAgICBsZXQgbWF4Q2h1bmtTaXplID0gcmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICAgICAgbGV0IGJ5dGVzTGVmdDtcbiAgICAgIGxldCBwYXNzZWQgPSAwO1xuXG4gICAgICBpZiAobWF4UmF0ZSkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmICghaW50ZXJuYWxzLnRzIHx8IChwYXNzZWQgPSAobm93IC0gaW50ZXJuYWxzLnRzKSkgPj0gdGltZVdpbmRvdykge1xuICAgICAgICAgIGludGVybmFscy50cyA9IG5vdztcbiAgICAgICAgICBieXRlc0xlZnQgPSBieXRlc1RocmVzaG9sZCAtIGludGVybmFscy5ieXRlcztcbiAgICAgICAgICBpbnRlcm5hbHMuYnl0ZXMgPSBieXRlc0xlZnQgPCAwID8gLWJ5dGVzTGVmdCA6IDA7XG4gICAgICAgICAgcGFzc2VkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzTGVmdCA9IGJ5dGVzVGhyZXNob2xkIC0gaW50ZXJuYWxzLmJ5dGVzO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4UmF0ZSkge1xuICAgICAgICBpZiAoYnl0ZXNMZWZ0IDw9IDApIHtcbiAgICAgICAgICAvLyBuZXh0IHRpbWUgd2luZG93XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgX2NhbGxiYWNrKG51bGwsIF9jaHVuayk7XG4gICAgICAgICAgfSwgdGltZVdpbmRvdyAtIHBhc3NlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnl0ZXNMZWZ0IDwgbWF4Q2h1bmtTaXplKSB7XG4gICAgICAgICAgbWF4Q2h1bmtTaXplID0gYnl0ZXNMZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhDaHVua1NpemUgJiYgY2h1bmtTaXplID4gbWF4Q2h1bmtTaXplICYmIChjaHVua1NpemUgLSBtYXhDaHVua1NpemUpID4gbWluQ2h1bmtTaXplKSB7XG4gICAgICAgIGNodW5rUmVtYWluZGVyID0gX2NodW5rLnN1YmFycmF5KG1heENodW5rU2l6ZSk7XG4gICAgICAgIF9jaHVuayA9IF9jaHVuay5zdWJhcnJheSgwLCBtYXhDaHVua1NpemUpO1xuICAgICAgfVxuXG4gICAgICBwdXNoQ2h1bmsoX2NodW5rLCBjaHVua1JlbWFpbmRlciA/ICgpID0+IHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhfY2FsbGJhY2ssIG51bGwsIGNodW5rUmVtYWluZGVyKTtcbiAgICAgIH0gOiBfY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1DaHVuayhjaHVuaywgZnVuY3Rpb24gdHJhbnNmb3JtTmV4dENodW5rKGVyciwgX2NodW5rKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2NodW5rKSB7XG4gICAgICAgIHRyYW5zZm9ybUNodW5rKF9jaHVuaywgdHJhbnNmb3JtTmV4dENodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zVHJhbnNmb3JtU3RyZWFtO1xuIiwiY29uc3QgX19XRUJQQUNLX05BTUVTUEFDRV9PQkpFQ1RfXyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwiY29uc3Qge2FzeW5jSXRlcmF0b3J9ID0gU3ltYm9sO1xuXG5jb25zdCByZWFkQmxvYiA9IGFzeW5jIGZ1bmN0aW9uKiAoYmxvYikge1xuICBpZiAoYmxvYi5zdHJlYW0pIHtcbiAgICB5aWVsZCogYmxvYi5zdHJlYW0oKVxuICB9IGVsc2UgaWYgKGJsb2IuYXJyYXlCdWZmZXIpIHtcbiAgICB5aWVsZCBhd2FpdCBibG9iLmFycmF5QnVmZmVyKClcbiAgfSBlbHNlIGlmIChibG9iW2FzeW5jSXRlcmF0b3JdKSB7XG4gICAgeWllbGQqIGJsb2JbYXN5bmNJdGVyYXRvcl0oKTtcbiAgfSBlbHNlIHtcbiAgICB5aWVsZCBibG9iO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlYWRCbG9iO1xuIiwiaW1wb3J0IHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQge1JlYWRhYmxlfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHJlYWRCbG9iIGZyb20gXCIuL3JlYWRCbG9iLmpzXCI7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5cbmNvbnN0IEJPVU5EQVJZX0FMUEhBQkVUID0gcGxhdGZvcm0uQUxQSEFCRVQuQUxQSEFfRElHSVQgKyAnLV8nO1xuXG5jb25zdCB0ZXh0RW5jb2RlciA9IHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RW5jb2RlcigpIDogbmV3IHV0aWwuVGV4dEVuY29kZXIoKTtcblxuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xuY29uc3QgQ1JMRl9CWVRFUyA9IHRleHRFbmNvZGVyLmVuY29kZShDUkxGKTtcbmNvbnN0IENSTEZfQllURVNfQ09VTlQgPSAyO1xuXG5jbGFzcyBGb3JtRGF0YVBhcnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IHtlc2NhcGVOYW1lfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgY29uc3QgaXNTdHJpbmdWYWx1ZSA9IHV0aWxzLmlzU3RyaW5nKHZhbHVlKTtcblxuICAgIGxldCBoZWFkZXJzID0gYENvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIiR7ZXNjYXBlTmFtZShuYW1lKX1cIiR7XG4gICAgICAhaXNTdHJpbmdWYWx1ZSAmJiB2YWx1ZS5uYW1lID8gYDsgZmlsZW5hbWU9XCIke2VzY2FwZU5hbWUodmFsdWUubmFtZSl9XCJgIDogJydcbiAgICB9JHtDUkxGfWA7XG5cbiAgICBpZiAoaXNTdHJpbmdWYWx1ZSkge1xuICAgICAgdmFsdWUgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9cXHI/XFxufFxcclxcbj8vZywgQ1JMRikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzICs9IGBDb250ZW50LVR5cGU6ICR7dmFsdWUudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSR7Q1JMRn1gXG4gICAgfVxuXG4gICAgdGhpcy5oZWFkZXJzID0gdGV4dEVuY29kZXIuZW5jb2RlKGhlYWRlcnMgKyBDUkxGKTtcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IGlzU3RyaW5nVmFsdWUgPyB2YWx1ZS5ieXRlTGVuZ3RoIDogdmFsdWUuc2l6ZTtcblxuICAgIHRoaXMuc2l6ZSA9IHRoaXMuaGVhZGVycy5ieXRlTGVuZ3RoICsgdGhpcy5jb250ZW50TGVuZ3RoICsgQ1JMRl9CWVRFU19DT1VOVDtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgYXN5bmMgKmVuY29kZSgpe1xuICAgIHlpZWxkIHRoaXMuaGVhZGVycztcblxuICAgIGNvbnN0IHt2YWx1ZX0gPSB0aGlzO1xuXG4gICAgaWYodXRpbHMuaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlpZWxkKiByZWFkQmxvYih2YWx1ZSk7XG4gICAgfVxuXG4gICAgeWllbGQgQ1JMRl9CWVRFUztcbiAgfVxuXG4gIHN0YXRpYyBlc2NhcGVOYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBTdHJpbmcobmFtZSkucmVwbGFjZSgvW1xcclxcblwiXS9nLCAobWF0Y2gpID0+ICh7XG4gICAgICAgICdcXHInIDogJyUwRCcsXG4gICAgICAgICdcXG4nIDogJyUwQScsXG4gICAgICAgICdcIicgOiAnJTIyJyxcbiAgICAgIH1bbWF0Y2hdKSk7XG4gIH1cbn1cblxuY29uc3QgZm9ybURhdGFUb1N0cmVhbSA9IChmb3JtLCBoZWFkZXJzSGFuZGxlciwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgdGFnID0gJ2Zvcm0tZGF0YS1ib3VuZGFyeScsXG4gICAgc2l6ZSA9IDI1LFxuICAgIGJvdW5kYXJ5ID0gdGFnICsgJy0nICsgcGxhdGZvcm0uZ2VuZXJhdGVTdHJpbmcoc2l6ZSwgQk9VTkRBUllfQUxQSEFCRVQpXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmKCF1dGlscy5pc0Zvcm1EYXRhKGZvcm0pKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdGb3JtRGF0YSBpbnN0YW5jZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5Lmxlbmd0aCA8IDEgfHwgYm91bmRhcnkubGVuZ3RoID4gNzApIHtcbiAgICB0aHJvdyBFcnJvcignYm91bmRhcnkgbXVzdCBiZSAxMC03MCBjaGFyYWN0ZXJzIGxvbmcnKVxuICB9XG5cbiAgY29uc3QgYm91bmRhcnlCeXRlcyA9IHRleHRFbmNvZGVyLmVuY29kZSgnLS0nICsgYm91bmRhcnkgKyBDUkxGKTtcbiAgY29uc3QgZm9vdGVyQnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoJy0tJyArIGJvdW5kYXJ5ICsgJy0tJyArIENSTEYpO1xuICBsZXQgY29udGVudExlbmd0aCA9IGZvb3RlckJ5dGVzLmJ5dGVMZW5ndGg7XG5cbiAgY29uc3QgcGFydHMgPSBBcnJheS5mcm9tKGZvcm0uZW50cmllcygpKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBwYXJ0ID0gbmV3IEZvcm1EYXRhUGFydChuYW1lLCB2YWx1ZSk7XG4gICAgY29udGVudExlbmd0aCArPSBwYXJ0LnNpemU7XG4gICAgcmV0dXJuIHBhcnQ7XG4gIH0pO1xuXG4gIGNvbnRlbnRMZW5ndGggKz0gYm91bmRhcnlCeXRlcy5ieXRlTGVuZ3RoICogcGFydHMubGVuZ3RoO1xuXG4gIGNvbnRlbnRMZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihjb250ZW50TGVuZ3RoKTtcblxuICBjb25zdCBjb21wdXRlZEhlYWRlcnMgPSB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWBcbiAgfVxuXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoY29udGVudExlbmd0aCkpIHtcbiAgICBjb21wdXRlZEhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBjb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgaGVhZGVyc0hhbmRsZXIgJiYgaGVhZGVyc0hhbmRsZXIoY29tcHV0ZWRIZWFkZXJzKTtcblxuICByZXR1cm4gUmVhZGFibGUuZnJvbSgoYXN5bmMgZnVuY3Rpb24gKigpIHtcbiAgICBmb3IoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgeWllbGQgYm91bmRhcnlCeXRlcztcbiAgICAgIHlpZWxkKiBwYXJ0LmVuY29kZSgpO1xuICAgIH1cblxuICAgIHlpZWxkIGZvb3RlckJ5dGVzO1xuICB9KSgpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1EYXRhVG9TdHJlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHN0cmVhbSBmcm9tIFwic3RyZWFtXCI7XG5cbmNsYXNzIFpsaWJIZWFkZXJUcmFuc2Zvcm1TdHJlYW0gZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcbiAgX190cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmIChjaHVuay5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRoaXMuX190cmFuc2Zvcm07XG5cbiAgICAgIC8vIEFkZCBEZWZhdWx0IENvbXByZXNzaW9uIGhlYWRlcnMgaWYgbm8gemxpYiBoZWFkZXJzIGFyZSBwcmVzZW50XG4gICAgICBpZiAoY2h1bmtbMF0gIT09IDEyMCkgeyAvLyBIZXg6IDc4XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IEJ1ZmZlci5hbGxvYygyKTtcbiAgICAgICAgaGVhZGVyWzBdID0gMTIwOyAvLyBIZXg6IDc4XG4gICAgICAgIGhlYWRlclsxXSA9IDE1NjsgLy8gSGV4OiA5QyBcbiAgICAgICAgdGhpcy5wdXNoKGhlYWRlciwgZW5jb2RpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX190cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWmxpYkhlYWRlclRyYW5zZm9ybVN0cmVhbTtcbiIsImltcG9ydCB1dGlscyBmcm9tIFwiLi4vdXRpbHMuanNcIjtcblxuY29uc3QgY2FsbGJhY2tpZnkgPSAoZm4sIHJlZHVjZXIpID0+IHtcbiAgcmV0dXJuIHV0aWxzLmlzQXN5bmNGbihmbikgPyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGNiID0gYXJncy5wb3AoKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmdzKS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVkdWNlciA/IGNiKG51bGwsIC4uLnJlZHVjZXIodmFsdWUpKSA6IGNiKG51bGwsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfVxuICAgIH0sIGNiKTtcbiAgfSA6IGZuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGF0YSBtYXhSYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZXNDb3VudD0gMTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbj0gMTAwMF1cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3BlZWRvbWV0ZXIoc2FtcGxlc0NvdW50LCBtaW4pIHtcbiAgc2FtcGxlc0NvdW50ID0gc2FtcGxlc0NvdW50IHx8IDEwO1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBjb25zdCB0aW1lc3RhbXBzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGxldCBoZWFkID0gMDtcbiAgbGV0IHRhaWwgPSAwO1xuICBsZXQgZmlyc3RTYW1wbGVUUztcblxuICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IDEwMDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1c2goY2h1bmtMZW5ndGgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gdGltZXN0YW1wc1t0YWlsXTtcblxuICAgIGlmICghZmlyc3RTYW1wbGVUUykge1xuICAgICAgZmlyc3RTYW1wbGVUUyA9IG5vdztcbiAgICB9XG5cbiAgICBieXRlc1toZWFkXSA9IGNodW5rTGVuZ3RoO1xuICAgIHRpbWVzdGFtcHNbaGVhZF0gPSBub3c7XG5cbiAgICBsZXQgaSA9IHRhaWw7XG4gICAgbGV0IGJ5dGVzQ291bnQgPSAwO1xuXG4gICAgd2hpbGUgKGkgIT09IGhlYWQpIHtcbiAgICAgIGJ5dGVzQ291bnQgKz0gYnl0ZXNbaSsrXTtcbiAgICAgIGkgPSBpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGhlYWQgPSAoaGVhZCArIDEpICUgc2FtcGxlc0NvdW50O1xuXG4gICAgaWYgKGhlYWQgPT09IHRhaWwpIHtcbiAgICAgIHRhaWwgPSAodGFpbCArIDEpICUgc2FtcGxlc0NvdW50O1xuICAgIH1cblxuICAgIGlmIChub3cgLSBmaXJzdFNhbXBsZVRTIDwgbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFzc2VkID0gc3RhcnRlZEF0ICYmIG5vdyAtIHN0YXJ0ZWRBdDtcblxuICAgIHJldHVybiBwYXNzZWQgPyBNYXRoLnJvdW5kKGJ5dGVzQ291bnQgKiAxMDAwIC8gcGFzc2VkKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3BlZWRvbWV0ZXI7XG4iLCIvKipcbiAqIFRocm90dGxlIGRlY29yYXRvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmVxXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIGZyZXEpIHtcbiAgbGV0IHRpbWVzdGFtcCA9IDA7XG4gIGxldCB0aHJlc2hvbGQgPSAxMDAwIC8gZnJlcTtcbiAgbGV0IGxhc3RBcmdzO1xuICBsZXQgdGltZXI7XG5cbiAgY29uc3QgaW52b2tlID0gKGFyZ3MsIG5vdyA9IERhdGUubm93KCkpID0+IHtcbiAgICB0aW1lc3RhbXAgPSBub3c7XG4gICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gIH1cblxuICBjb25zdCB0aHJvdHRsZWQgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcGFzc2VkID0gbm93IC0gdGltZXN0YW1wO1xuICAgIGlmICggcGFzc2VkID49IHRocmVzaG9sZCkge1xuICAgICAgaW52b2tlKGFyZ3MsIG5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgaW52b2tlKGxhc3RBcmdzKVxuICAgICAgICB9LCB0aHJlc2hvbGQgLSBwYXNzZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZsdXNoID0gKCkgPT4gbGFzdEFyZ3MgJiYgaW52b2tlKGxhc3RBcmdzKTtcblxuICByZXR1cm4gW3Rocm90dGxlZCwgZmx1c2hdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0aHJvdHRsZTtcbiIsImltcG9ydCBzcGVlZG9tZXRlciBmcm9tIFwiLi9zcGVlZG9tZXRlci5qc1wiO1xuaW1wb3J0IHRocm90dGxlIGZyb20gXCIuL3Rocm90dGxlLmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBwcm9ncmVzc0V2ZW50UmVkdWNlciA9IChsaXN0ZW5lciwgaXNEb3dubG9hZFN0cmVhbSwgZnJlcSA9IDMpID0+IHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gdGhyb3R0bGUoZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogZSxcbiAgICAgIGxlbmd0aENvbXB1dGFibGU6IHRvdGFsICE9IG51bGwsXG4gICAgICBbaXNEb3dubG9hZFN0cmVhbSA/ICdkb3dubG9hZCcgOiAndXBsb2FkJ106IHRydWVcbiAgICB9O1xuXG4gICAgbGlzdGVuZXIoZGF0YSk7XG4gIH0sIGZyZXEpO1xufVxuXG5leHBvcnQgY29uc3QgcHJvZ3Jlc3NFdmVudERlY29yYXRvciA9ICh0b3RhbCwgdGhyb3R0bGVkKSA9PiB7XG4gIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0b3RhbCAhPSBudWxsO1xuXG4gIHJldHVybiBbKGxvYWRlZCkgPT4gdGhyb3R0bGVkWzBdKHtcbiAgICBsZW5ndGhDb21wdXRhYmxlLFxuICAgIHRvdGFsLFxuICAgIGxvYWRlZFxuICB9KSwgdGhyb3R0bGVkWzFdXTtcbn1cblxuZXhwb3J0IGNvbnN0IGFzeW5jRGVjb3JhdG9yID0gKGZuKSA9PiAoLi4uYXJncykgPT4gdXRpbHMuYXNhcCgoKSA9PiBmbiguLi5hcmdzKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgYnVpbGRGdWxsUGF0aCBmcm9tICcuLi9jb3JlL2J1aWxkRnVsbFBhdGguanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4vLi4vaGVscGVycy9idWlsZFVSTC5qcyc7XG5pbXBvcnQgcHJveHlGcm9tRW52IGZyb20gJ3Byb3h5LWZyb20tZW52JztcbmltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0IGZvbGxvd1JlZGlyZWN0cyBmcm9tICdmb2xsb3ctcmVkaXJlY3RzJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IGZyb21EYXRhVVJJIGZyb20gJy4uL2hlbHBlcnMvZnJvbURhdGFVUkkuanMnO1xuaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuLi9jb3JlL0F4aW9zSGVhZGVycy5qcyc7XG5pbXBvcnQgQXhpb3NUcmFuc2Zvcm1TdHJlYW0gZnJvbSAnLi4vaGVscGVycy9BeGlvc1RyYW5zZm9ybVN0cmVhbS5qcyc7XG5pbXBvcnQge0V2ZW50RW1pdHRlcn0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBmb3JtRGF0YVRvU3RyZWFtIGZyb20gXCIuLi9oZWxwZXJzL2Zvcm1EYXRhVG9TdHJlYW0uanNcIjtcbmltcG9ydCByZWFkQmxvYiBmcm9tIFwiLi4vaGVscGVycy9yZWFkQmxvYi5qc1wiO1xuaW1wb3J0IFpsaWJIZWFkZXJUcmFuc2Zvcm1TdHJlYW0gZnJvbSAnLi4vaGVscGVycy9abGliSGVhZGVyVHJhbnNmb3JtU3RyZWFtLmpzJztcbmltcG9ydCBjYWxsYmFja2lmeSBmcm9tIFwiLi4vaGVscGVycy9jYWxsYmFja2lmeS5qc1wiO1xuaW1wb3J0IHtwcm9ncmVzc0V2ZW50UmVkdWNlciwgcHJvZ3Jlc3NFdmVudERlY29yYXRvciwgYXN5bmNEZWNvcmF0b3J9IGZyb20gXCIuLi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzXCI7XG5cbmNvbnN0IHpsaWJPcHRpb25zID0ge1xuICBmbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNILFxuICBmaW5pc2hGbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNIXG59O1xuXG5jb25zdCBicm90bGlPcHRpb25zID0ge1xuICBmbHVzaDogemxpYi5jb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSCxcbiAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRkxVU0hcbn1cblxuY29uc3QgaXNCcm90bGlTdXBwb3J0ZWQgPSB1dGlscy5pc0Z1bmN0aW9uKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyk7XG5cbmNvbnN0IHtodHRwOiBodHRwRm9sbG93LCBodHRwczogaHR0cHNGb2xsb3d9ID0gZm9sbG93UmVkaXJlY3RzO1xuXG5jb25zdCBpc0h0dHBzID0gL2h0dHBzOj8vO1xuXG5jb25zdCBzdXBwb3J0ZWRQcm90b2NvbHMgPSBwbGF0Zm9ybS5wcm90b2NvbHMubWFwKHByb3RvY29sID0+IHtcbiAgcmV0dXJuIHByb3RvY29sICsgJzonO1xufSk7XG5cbmNvbnN0IGZsdXNoT25GaW5pc2ggPSAoc3RyZWFtLCBbdGhyb3R0bGVkLCBmbHVzaF0pID0+IHtcbiAgc3RyZWFtXG4gICAgLm9uKCdlbmQnLCBmbHVzaClcbiAgICAub24oJ2Vycm9yJywgZmx1c2gpO1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59XG5cbi8qKlxuICogSWYgdGhlIHByb3h5IG9yIGNvbmZpZyBiZWZvcmVSZWRpcmVjdHMgZnVuY3Rpb25zIGFyZSBkZWZpbmVkLCBjYWxsIHRoZW0gd2l0aCB0aGUgb3B0aW9uc1xuICogb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT59XG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoQmVmb3JlUmVkaXJlY3Qob3B0aW9ucywgcmVzcG9uc2VEZXRhaWxzKSB7XG4gIGlmIChvcHRpb25zLmJlZm9yZVJlZGlyZWN0cy5wcm94eSkge1xuICAgIG9wdGlvbnMuYmVmb3JlUmVkaXJlY3RzLnByb3h5KG9wdGlvbnMpO1xuICB9XG4gIGlmIChvcHRpb25zLmJlZm9yZVJlZGlyZWN0cy5jb25maWcpIHtcbiAgICBvcHRpb25zLmJlZm9yZVJlZGlyZWN0cy5jb25maWcob3B0aW9ucywgcmVzcG9uc2VEZXRhaWxzKTtcbiAgfVxufVxuXG4vKipcbiAqIElmIHRoZSBwcm94eSBvciBjb25maWcgYWZ0ZXJSZWRpcmVjdHMgZnVuY3Rpb25zIGFyZSBkZWZpbmVkLCBjYWxsIHRoZW0gd2l0aCB0aGUgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7aHR0cC5DbGllbnRSZXF1ZXN0QXJnc30gb3B0aW9uc1xuICogQHBhcmFtIHtBeGlvc1Byb3h5Q29uZmlnfSBjb25maWdQcm94eSBjb25maWd1cmF0aW9uIGZyb20gQXhpb3Mgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICpcbiAqIEByZXR1cm5zIHtodHRwLkNsaWVudFJlcXVlc3RBcmdzfVxuICovXG5mdW5jdGlvbiBzZXRQcm94eShvcHRpb25zLCBjb25maWdQcm94eSwgbG9jYXRpb24pIHtcbiAgbGV0IHByb3h5ID0gY29uZmlnUHJveHk7XG4gIGlmICghcHJveHkgJiYgcHJveHkgIT09IGZhbHNlKSB7XG4gICAgY29uc3QgcHJveHlVcmwgPSBwcm94eUZyb21FbnYuZ2V0UHJveHlGb3JVcmwobG9jYXRpb24pO1xuICAgIGlmIChwcm94eVVybCkge1xuICAgICAgcHJveHkgPSBuZXcgVVJMKHByb3h5VXJsKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3h5KSB7XG4gICAgLy8gQmFzaWMgcHJveHkgYXV0aG9yaXphdGlvblxuICAgIGlmIChwcm94eS51c2VybmFtZSkge1xuICAgICAgcHJveHkuYXV0aCA9IChwcm94eS51c2VybmFtZSB8fCAnJykgKyAnOicgKyAocHJveHkucGFzc3dvcmQgfHwgJycpO1xuICAgIH1cblxuICAgIGlmIChwcm94eS5hdXRoKSB7XG4gICAgICAvLyBTdXBwb3J0IHByb3h5IGF1dGggb2JqZWN0IGZvcm1cbiAgICAgIGlmIChwcm94eS5hdXRoLnVzZXJuYW1lIHx8IHByb3h5LmF1dGgucGFzc3dvcmQpIHtcbiAgICAgICAgcHJveHkuYXV0aCA9IChwcm94eS5hdXRoLnVzZXJuYW1lIHx8ICcnKSArICc6JyArIChwcm94eS5hdXRoLnBhc3N3b3JkIHx8ICcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhc2U2NCA9IEJ1ZmZlclxuICAgICAgICAuZnJvbShwcm94eS5hdXRoLCAndXRmOCcpXG4gICAgICAgIC50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBvcHRpb25zLmhlYWRlcnNbJ1Byb3h5LUF1dGhvcml6YXRpb24nXSA9ICdCYXNpYyAnICsgYmFzZTY0O1xuICAgIH1cblxuICAgIG9wdGlvbnMuaGVhZGVycy5ob3N0ID0gb3B0aW9ucy5ob3N0bmFtZSArIChvcHRpb25zLnBvcnQgPyAnOicgKyBvcHRpb25zLnBvcnQgOiAnJyk7XG4gICAgY29uc3QgcHJveHlIb3N0ID0gcHJveHkuaG9zdG5hbWUgfHwgcHJveHkuaG9zdDtcbiAgICBvcHRpb25zLmhvc3RuYW1lID0gcHJveHlIb3N0O1xuICAgIC8vIFJlcGxhY2UgJ2hvc3QnIHNpbmNlIG9wdGlvbnMgaXMgbm90IGEgVVJMIG9iamVjdFxuICAgIG9wdGlvbnMuaG9zdCA9IHByb3h5SG9zdDtcbiAgICBvcHRpb25zLnBvcnQgPSBwcm94eS5wb3J0O1xuICAgIG9wdGlvbnMucGF0aCA9IGxvY2F0aW9uO1xuICAgIGlmIChwcm94eS5wcm90b2NvbCkge1xuICAgICAgb3B0aW9ucy5wcm90b2NvbCA9IHByb3h5LnByb3RvY29sLmluY2x1ZGVzKCc6JykgPyBwcm94eS5wcm90b2NvbCA6IGAke3Byb3h5LnByb3RvY29sfTpgO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMuYmVmb3JlUmVkaXJlY3RzLnByb3h5ID0gZnVuY3Rpb24gYmVmb3JlUmVkaXJlY3QocmVkaXJlY3RPcHRpb25zKSB7XG4gICAgLy8gQ29uZmlndXJlIHByb3h5IGZvciByZWRpcmVjdGVkIHJlcXVlc3QsIHBhc3NpbmcgdGhlIG9yaWdpbmFsIGNvbmZpZyBwcm94eSB0byBhcHBseVxuICAgIC8vIHRoZSBleGFjdCBzYW1lIGxvZ2ljIGFzIGlmIHRoZSByZWRpcmVjdGVkIHJlcXVlc3Qgd2FzIHBlcmZvcm1lZCBieSBheGlvcyBkaXJlY3RseS5cbiAgICBzZXRQcm94eShyZWRpcmVjdE9wdGlvbnMsIGNvbmZpZ1Byb3h5LCByZWRpcmVjdE9wdGlvbnMuaHJlZik7XG4gIH07XG59XG5cbmNvbnN0IGlzSHR0cEFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdXRpbHMua2luZE9mKHByb2Nlc3MpID09PSAncHJvY2Vzcyc7XG5cbi8vIHRlbXBvcmFyeSBob3RmaXhcblxuY29uc3Qgd3JhcEFzeW5jID0gKGFzeW5jRXhlY3V0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgb25Eb25lO1xuICAgIGxldCBpc0RvbmU7XG5cbiAgICBjb25zdCBkb25lID0gKHZhbHVlLCBpc1JlamVjdGVkKSA9PiB7XG4gICAgICBpZiAoaXNEb25lKSByZXR1cm47XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgb25Eb25lICYmIG9uRG9uZSh2YWx1ZSwgaXNSZWplY3RlZCk7XG4gICAgfVxuXG4gICAgY29uc3QgX3Jlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICAgIGRvbmUodmFsdWUpO1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IF9yZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICBkb25lKHJlYXNvbiwgdHJ1ZSk7XG4gICAgICByZWplY3QocmVhc29uKTtcbiAgICB9XG5cbiAgICBhc3luY0V4ZWN1dG9yKF9yZXNvbHZlLCBfcmVqZWN0LCAob25Eb25lSGFuZGxlcikgPT4gKG9uRG9uZSA9IG9uRG9uZUhhbmRsZXIpKS5jYXRjaChfcmVqZWN0KTtcbiAgfSlcbn07XG5cbmNvbnN0IHJlc29sdmVGYW1pbHkgPSAoe2FkZHJlc3MsIGZhbWlseX0pID0+IHtcbiAgaWYgKCF1dGlscy5pc1N0cmluZyhhZGRyZXNzKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignYWRkcmVzcyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuICh7XG4gICAgYWRkcmVzcyxcbiAgICBmYW1pbHk6IGZhbWlseSB8fCAoYWRkcmVzcy5pbmRleE9mKCcuJykgPCAwID8gNiA6IDQpXG4gIH0pO1xufVxuXG5jb25zdCBidWlsZEFkZHJlc3NFbnRyeSA9IChhZGRyZXNzLCBmYW1pbHkpID0+IHJlc29sdmVGYW1pbHkodXRpbHMuaXNPYmplY3QoYWRkcmVzcykgPyBhZGRyZXNzIDoge2FkZHJlc3MsIGZhbWlseX0pO1xuXG4vKmVzbGludCBjb25zaXN0ZW50LXJldHVybjowKi9cbmV4cG9ydCBkZWZhdWx0IGlzSHR0cEFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gaHR0cEFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiB3cmFwQXN5bmMoYXN5bmMgZnVuY3Rpb24gZGlzcGF0Y2hIdHRwUmVxdWVzdChyZXNvbHZlLCByZWplY3QsIG9uRG9uZSkge1xuICAgIGxldCB7ZGF0YSwgbG9va3VwLCBmYW1pbHl9ID0gY29uZmlnO1xuICAgIGNvbnN0IHtyZXNwb25zZVR5cGUsIHJlc3BvbnNlRW5jb2Rpbmd9ID0gY29uZmlnO1xuICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgaXNEb25lO1xuICAgIGxldCByZWplY3RlZCA9IGZhbHNlO1xuICAgIGxldCByZXE7XG5cbiAgICBpZiAobG9va3VwKSB7XG4gICAgICBjb25zdCBfbG9va3VwID0gY2FsbGJhY2tpZnkobG9va3VwLCAodmFsdWUpID0+IHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgIC8vIGhvdGZpeCB0byBzdXBwb3J0IG9wdC5hbGwgb3B0aW9uIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBub2RlIDIwLnhcbiAgICAgIGxvb2t1cCA9IChob3N0bmFtZSwgb3B0LCBjYikgPT4ge1xuICAgICAgICBfbG9va3VwKGhvc3RuYW1lLCBvcHQsIChlcnIsIGFyZzAsIGFyZzEpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSB1dGlscy5pc0FycmF5KGFyZzApID8gYXJnMC5tYXAoYWRkciA9PiBidWlsZEFkZHJlc3NFbnRyeShhZGRyKSkgOiBbYnVpbGRBZGRyZXNzRW50cnkoYXJnMCwgYXJnMSldO1xuXG4gICAgICAgICAgb3B0LmFsbCA/IGNiKGVyciwgYWRkcmVzc2VzKSA6IGNiKGVyciwgYWRkcmVzc2VzWzBdLmFkZHJlc3MsIGFkZHJlc3Nlc1swXS5mYW1pbHkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0ZW1wb3JhcnkgaW50ZXJuYWwgZW1pdHRlciB1bnRpbCB0aGUgQXhpb3NSZXF1ZXN0IGNsYXNzIHdpbGwgYmUgaW1wbGVtZW50ZWRcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgY29uc3Qgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKGFib3J0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KTtcbiAgICAgIH1cblxuICAgICAgZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBvbkRvbmUoKHZhbHVlLCBpc1JlamVjdGVkKSA9PiB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgaWYgKGlzUmVqZWN0ZWQpIHtcbiAgICAgICAgcmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICBvbkZpbmlzaGVkKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgIGVtaXR0ZXIuZW1pdCgnYWJvcnQnLCAhcmVhc29uIHx8IHJlYXNvbi50eXBlID8gbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnLCByZXEpIDogcmVhc29uKTtcbiAgICB9XG5cbiAgICBlbWl0dGVyLm9uY2UoJ2Fib3J0JywgcmVqZWN0KTtcblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4gfHwgY29uZmlnLnNpZ25hbCkge1xuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUoYWJvcnQpO1xuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gYWJvcnQoKSA6IGNvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdXJsXG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsLCBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMpO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBVUkwoZnVsbFBhdGgsIHBsYXRmb3JtLmhhc0Jyb3dzZXJFbnYgPyBwbGF0Zm9ybS5vcmlnaW4gOiB1bmRlZmluZWQpO1xuICAgIGNvbnN0IHByb3RvY29sID0gcGFyc2VkLnByb3RvY29sIHx8IHN1cHBvcnRlZFByb3RvY29sc1swXTtcblxuICAgIGlmIChwcm90b2NvbCA9PT0gJ2RhdGE6Jykge1xuICAgICAgbGV0IGNvbnZlcnRlZERhdGE7XG5cbiAgICAgIGlmIChtZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgICAgc3RhdHVzOiA0MDUsXG4gICAgICAgICAgc3RhdHVzVGV4dDogJ21ldGhvZCBub3QgYWxsb3dlZCcsXG4gICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb252ZXJ0ZWREYXRhID0gZnJvbURhdGFVUkkoY29uZmlnLnVybCwgcmVzcG9uc2VUeXBlID09PSAnYmxvYicsIHtcbiAgICAgICAgICBCbG9iOiBjb25maWcuZW52ICYmIGNvbmZpZy5lbnYuQmxvYlxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZXJyLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnZlcnRlZERhdGEgPSBjb252ZXJ0ZWREYXRhLnRvU3RyaW5nKHJlc3BvbnNlRW5jb2RpbmcpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2VFbmNvZGluZyB8fCByZXNwb25zZUVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICBjb252ZXJ0ZWREYXRhID0gdXRpbHMuc3RyaXBCT00oY29udmVydGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICBjb252ZXJ0ZWREYXRhID0gc3RyZWFtLlJlYWRhYmxlLmZyb20oY29udmVydGVkRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgIGRhdGE6IGNvbnZlcnRlZERhdGEsXG4gICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICBzdGF0dXNUZXh0OiAnT0snLFxuICAgICAgICBoZWFkZXJzOiBuZXcgQXhpb3NIZWFkZXJzKCksXG4gICAgICAgIGNvbmZpZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRlZFByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICdVbnN1cHBvcnRlZCBwcm90b2NvbCAnICsgcHJvdG9jb2wsXG4gICAgICAgIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULFxuICAgICAgICBjb25maWdcbiAgICAgICkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG5cbiAgICAvLyBTZXQgVXNlci1BZ2VudCAocmVxdWlyZWQgYnkgc29tZSBzZXJ2ZXJzKVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzY5XG4gICAgLy8gVXNlci1BZ2VudCBpcyBzcGVjaWZpZWQ7IGhhbmRsZSBjYXNlIHdoZXJlIG5vIFVBIGhlYWRlciBpcyBkZXNpcmVkXG4gICAgLy8gT25seSBzZXQgaGVhZGVyIGlmIGl0IGhhc24ndCBiZWVuIHNldCBpbiBjb25maWdcbiAgICBoZWFkZXJzLnNldCgnVXNlci1BZ2VudCcsICdheGlvcy8nICsgVkVSU0lPTiwgZmFsc2UpO1xuXG4gICAgY29uc3Qge29uVXBsb2FkUHJvZ3Jlc3MsIG9uRG93bmxvYWRQcm9ncmVzc30gPSBjb25maWc7XG4gICAgY29uc3QgbWF4UmF0ZSA9IGNvbmZpZy5tYXhSYXRlO1xuICAgIGxldCBtYXhVcGxvYWRSYXRlID0gdW5kZWZpbmVkO1xuICAgIGxldCBtYXhEb3dubG9hZFJhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBzdXBwb3J0IGZvciBzcGVjIGNvbXBsaWFudCBGb3JtRGF0YSBvYmplY3RzXG4gICAgaWYgKHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZGF0YSkpIHtcbiAgICAgIGNvbnN0IHVzZXJCb3VuZGFyeSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoL2JvdW5kYXJ5PShbLV9cXHdcXGRdezEwLDcwfSkvaSk7XG5cbiAgICAgIGRhdGEgPSBmb3JtRGF0YVRvU3RyZWFtKGRhdGEsIChmb3JtSGVhZGVycykgPT4ge1xuICAgICAgICBoZWFkZXJzLnNldChmb3JtSGVhZGVycyk7XG4gICAgICB9LCB7XG4gICAgICAgIHRhZzogYGF4aW9zLSR7VkVSU0lPTn0tYm91bmRhcnlgLFxuICAgICAgICBib3VuZGFyeTogdXNlckJvdW5kYXJ5ICYmIHVzZXJCb3VuZGFyeVsxXSB8fCB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgLy8gc3VwcG9ydCBmb3IgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZm9ybS1kYXRhIGFwaVxuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSAmJiB1dGlscy5pc0Z1bmN0aW9uKGRhdGEuZ2V0SGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuc2V0KGRhdGEuZ2V0SGVhZGVycygpKTtcblxuICAgICAgaWYgKCFoZWFkZXJzLmhhc0NvbnRlbnRMZW5ndGgoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGtub3duTGVuZ3RoID0gYXdhaXQgdXRpbC5wcm9taXNpZnkoZGF0YS5nZXRMZW5ndGgpLmNhbGwoZGF0YSk7XG4gICAgICAgICAgTnVtYmVyLmlzRmluaXRlKGtub3duTGVuZ3RoKSAmJiBrbm93bkxlbmd0aCA+PSAwICYmIGhlYWRlcnMuc2V0Q29udGVudExlbmd0aChrbm93bkxlbmd0aCk7XG4gICAgICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNCbG9iKGRhdGEpIHx8IHV0aWxzLmlzRmlsZShkYXRhKSkge1xuICAgICAgZGF0YS5zaXplICYmIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoZGF0YS50eXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudExlbmd0aChkYXRhLnNpemUgfHwgMCk7XG4gICAgICBkYXRhID0gc3RyZWFtLlJlYWRhYmxlLmZyb20ocmVhZEJsb2IoZGF0YSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAhdXRpbHMuaXNTdHJlYW0oZGF0YSkpIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkby4uLlxuICAgICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAndXRmLTgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICAgJ0RhdGEgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gbXVzdCBiZSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIGEgQnVmZmVyLCBvciBhIFN0cmVhbScsXG4gICAgICAgICAgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgQ29udGVudC1MZW5ndGggaGVhZGVyIGlmIGRhdGEgZXhpc3RzXG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRMZW5ndGgoZGF0YS5sZW5ndGgsIGZhbHNlKTtcblxuICAgICAgaWYgKGNvbmZpZy5tYXhCb2R5TGVuZ3RoID4gLTEgJiYgZGF0YS5sZW5ndGggPiBjb25maWcubWF4Qm9keUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICAgICdSZXF1ZXN0IGJvZHkgbGFyZ2VyIHRoYW4gbWF4Qm9keUxlbmd0aCBsaW1pdCcsXG4gICAgICAgICAgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB1dGlscy50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheShtYXhSYXRlKSkge1xuICAgICAgbWF4VXBsb2FkUmF0ZSA9IG1heFJhdGVbMF07XG4gICAgICBtYXhEb3dubG9hZFJhdGUgPSBtYXhSYXRlWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhVcGxvYWRSYXRlID0gbWF4RG93bmxvYWRSYXRlID0gbWF4UmF0ZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSAmJiAob25VcGxvYWRQcm9ncmVzcyB8fCBtYXhVcGxvYWRSYXRlKSkge1xuICAgICAgaWYgKCF1dGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICBkYXRhID0gc3RyZWFtLlJlYWRhYmxlLmZyb20oZGF0YSwge29iamVjdE1vZGU6IGZhbHNlfSk7XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBzdHJlYW0ucGlwZWxpbmUoW2RhdGEsIG5ldyBBeGlvc1RyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIG1heFJhdGU6IHV0aWxzLnRvRmluaXRlTnVtYmVyKG1heFVwbG9hZFJhdGUpXG4gICAgICB9KV0sIHV0aWxzLm5vb3ApO1xuXG4gICAgICBvblVwbG9hZFByb2dyZXNzICYmIGRhdGEub24oJ3Byb2dyZXNzJywgZmx1c2hPbkZpbmlzaChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGFzeW5jRGVjb3JhdG9yKG9uVXBsb2FkUHJvZ3Jlc3MpLCBmYWxzZSwgMylcbiAgICAgICAgKVxuICAgICAgKSk7XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGxldCBhdXRoID0gdW5kZWZpbmVkO1xuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgY29uc3QgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICBhdXRoID0gdXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZDtcbiAgICB9XG5cbiAgICBpZiAoIWF1dGggJiYgcGFyc2VkLnVzZXJuYW1lKSB7XG4gICAgICBjb25zdCB1cmxVc2VybmFtZSA9IHBhcnNlZC51c2VybmFtZTtcbiAgICAgIGNvbnN0IHVybFBhc3N3b3JkID0gcGFyc2VkLnBhc3N3b3JkO1xuICAgICAgYXV0aCA9IHVybFVzZXJuYW1lICsgJzonICsgdXJsUGFzc3dvcmQ7XG4gICAgfVxuXG4gICAgYXV0aCAmJiBoZWFkZXJzLmRlbGV0ZSgnYXV0aG9yaXphdGlvbicpO1xuXG4gICAgbGV0IHBhdGg7XG5cbiAgICB0cnkge1xuICAgICAgcGF0aCA9IGJ1aWxkVVJMKFxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgKyBwYXJzZWQuc2VhcmNoLFxuICAgICAgICBjb25maWcucGFyYW1zLFxuICAgICAgICBjb25maWcucGFyYW1zU2VyaWFsaXplclxuICAgICAgKS5yZXBsYWNlKC9eXFw/LywgJycpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgY3VzdG9tRXJyID0gbmV3IEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIGN1c3RvbUVyci5jb25maWcgPSBjb25maWc7XG4gICAgICBjdXN0b21FcnIudXJsID0gY29uZmlnLnVybDtcbiAgICAgIGN1c3RvbUVyci5leGlzdHMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlamVjdChjdXN0b21FcnIpO1xuICAgIH1cblxuICAgIGhlYWRlcnMuc2V0KFxuICAgICAgJ0FjY2VwdC1FbmNvZGluZycsXG4gICAgICAnZ3ppcCwgY29tcHJlc3MsIGRlZmxhdGUnICsgKGlzQnJvdGxpU3VwcG9ydGVkID8gJywgYnInIDogJycpLCBmYWxzZVxuICAgICAgKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBwYXRoLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLnRvSlNPTigpLFxuICAgICAgYWdlbnRzOiB7IGh0dHA6IGNvbmZpZy5odHRwQWdlbnQsIGh0dHBzOiBjb25maWcuaHR0cHNBZ2VudCB9LFxuICAgICAgYXV0aCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgZmFtaWx5LFxuICAgICAgYmVmb3JlUmVkaXJlY3Q6IGRpc3BhdGNoQmVmb3JlUmVkaXJlY3QsXG4gICAgICBiZWZvcmVSZWRpcmVjdHM6IHt9XG4gICAgfTtcblxuICAgIC8vIGNhY2hlYWJsZS1sb29rdXAgaW50ZWdyYXRpb24gaG90Zml4XG4gICAgIXV0aWxzLmlzVW5kZWZpbmVkKGxvb2t1cCkgJiYgKG9wdGlvbnMubG9va3VwID0gbG9va3VwKTtcblxuICAgIGlmIChjb25maWcuc29ja2V0UGF0aCkge1xuICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gY29uZmlnLnNvY2tldFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWUuc3RhcnRzV2l0aChcIltcIikgPyBwYXJzZWQuaG9zdG5hbWUuc2xpY2UoMSwgLTEpIDogcGFyc2VkLmhvc3RuYW1lO1xuICAgICAgb3B0aW9ucy5wb3J0ID0gcGFyc2VkLnBvcnQ7XG4gICAgICBzZXRQcm94eShvcHRpb25zLCBjb25maWcucHJveHksIHByb3RvY29sICsgJy8vJyArIHBhcnNlZC5ob3N0bmFtZSArIChwYXJzZWQucG9ydCA/ICc6JyArIHBhcnNlZC5wb3J0IDogJycpICsgb3B0aW9ucy5wYXRoKTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNwb3J0O1xuICAgIGNvbnN0IGlzSHR0cHNSZXF1ZXN0ID0gaXNIdHRwcy50ZXN0KG9wdGlvbnMucHJvdG9jb2wpO1xuICAgIG9wdGlvbnMuYWdlbnQgPSBpc0h0dHBzUmVxdWVzdCA/IGNvbmZpZy5odHRwc0FnZW50IDogY29uZmlnLmh0dHBBZ2VudDtcbiAgICBpZiAoY29uZmlnLnRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0ID0gY29uZmlnLnRyYW5zcG9ydDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5tYXhSZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHNSZXF1ZXN0ID8gaHR0cHMgOiBodHRwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZmlnLm1heFJlZGlyZWN0cykge1xuICAgICAgICBvcHRpb25zLm1heFJlZGlyZWN0cyA9IGNvbmZpZy5tYXhSZWRpcmVjdHM7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLmJlZm9yZVJlZGlyZWN0KSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlUmVkaXJlY3RzLmNvbmZpZyA9IGNvbmZpZy5iZWZvcmVSZWRpcmVjdDtcbiAgICAgIH1cbiAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHNSZXF1ZXN0ID8gaHR0cHNGb2xsb3cgOiBodHRwRm9sbG93O1xuICAgIH1cblxuICAgIGlmIChjb25maWcubWF4Qm9keUxlbmd0aCA+IC0xKSB7XG4gICAgICBvcHRpb25zLm1heEJvZHlMZW5ndGggPSBjb25maWcubWF4Qm9keUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9sbG93LXJlZGlyZWN0cyBkb2VzIG5vdCBza2lwIGNvbXBhcmlzb24sIHNvIGl0IHNob3VsZCBhbHdheXMgc3VjY2VlZCBmb3IgYXhpb3MgLTEgdW5saW1pdGVkXG4gICAgICBvcHRpb25zLm1heEJvZHlMZW5ndGggPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmluc2VjdXJlSFRUUFBhcnNlcikge1xuICAgICAgb3B0aW9ucy5pbnNlY3VyZUhUVFBQYXJzZXIgPSBjb25maWcuaW5zZWN1cmVIVFRQUGFyc2VyO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgIHJlcSA9IHRyYW5zcG9ydC5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlcykge1xuICAgICAgaWYgKHJlcS5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgICAgY29uc3Qgc3RyZWFtcyA9IFtyZXNdO1xuXG4gICAgICBjb25zdCByZXNwb25zZUxlbmd0aCA9ICtyZXMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcblxuICAgICAgaWYgKG9uRG93bmxvYWRQcm9ncmVzcyB8fCBtYXhEb3dubG9hZFJhdGUpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtID0gbmV3IEF4aW9zVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICBtYXhSYXRlOiB1dGlscy50b0Zpbml0ZU51bWJlcihtYXhEb3dubG9hZFJhdGUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uRG93bmxvYWRQcm9ncmVzcyAmJiB0cmFuc2Zvcm1TdHJlYW0ub24oJ3Byb2dyZXNzJywgZmx1c2hPbkZpbmlzaChcbiAgICAgICAgICB0cmFuc2Zvcm1TdHJlYW0sXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICAgIHJlc3BvbnNlTGVuZ3RoLFxuICAgICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25Eb3dubG9hZFByb2dyZXNzKSwgdHJ1ZSwgMylcbiAgICAgICAgICApXG4gICAgICAgICkpO1xuXG4gICAgICAgIHN0cmVhbXMucHVzaCh0cmFuc2Zvcm1TdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWNvbXByZXNzIHRoZSByZXNwb25zZSBib2R5IHRyYW5zcGFyZW50bHkgaWYgcmVxdWlyZWRcbiAgICAgIGxldCByZXNwb25zZVN0cmVhbSA9IHJlcztcblxuICAgICAgLy8gcmV0dXJuIHRoZSBsYXN0IHJlcXVlc3QgaW4gY2FzZSBvZiByZWRpcmVjdHNcbiAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0ID0gcmVzLnJlcSB8fCByZXE7XG5cbiAgICAgIC8vIGlmIGRlY29tcHJlc3MgZGlzYWJsZWQgd2Ugc2hvdWxkIG5vdCBkZWNvbXByZXNzXG4gICAgICBpZiAoY29uZmlnLmRlY29tcHJlc3MgIT09IGZhbHNlICYmIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pIHtcbiAgICAgICAgLy8gaWYgbm8gY29udGVudCwgYnV0IGhlYWRlcnMgc3RpbGwgc2F5IHRoYXQgaXQgaXMgZW5jb2RlZCxcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBoZWFkZXIgbm90IGNvbmZ1c2UgZG93bnN0cmVhbSBvcGVyYXRpb25zXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdIRUFEJyB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMjA0KSB7XG4gICAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKChyZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIC8qZXNsaW50IGRlZmF1bHQtY2FzZTowKi9cbiAgICAgICAgY2FzZSAnZ3ppcCc6XG4gICAgICAgIGNhc2UgJ3gtZ3ppcCc6XG4gICAgICAgIGNhc2UgJ2NvbXByZXNzJzpcbiAgICAgICAgY2FzZSAneC1jb21wcmVzcyc6XG4gICAgICAgICAgLy8gYWRkIHRoZSB1bnppcHBlciB0byB0aGUgYm9keSBzdHJlYW0gcHJvY2Vzc2luZyBwaXBlbGluZVxuICAgICAgICAgIHN0cmVhbXMucHVzaCh6bGliLmNyZWF0ZVVuemlwKHpsaWJPcHRpb25zKSk7XG5cbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGNvbnRlbnQtZW5jb2RpbmcgaW4gb3JkZXIgdG8gbm90IGNvbmZ1c2UgZG93bnN0cmVhbSBvcGVyYXRpb25zXG4gICAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgIHN0cmVhbXMucHVzaChuZXcgWmxpYkhlYWRlclRyYW5zZm9ybVN0cmVhbSgpKTtcblxuICAgICAgICAgIC8vIGFkZCB0aGUgdW56aXBwZXIgdG8gdGhlIGJvZHkgc3RyZWFtIHByb2Nlc3NpbmcgcGlwZWxpbmVcbiAgICAgICAgICBzdHJlYW1zLnB1c2goemxpYi5jcmVhdGVVbnppcCh6bGliT3B0aW9ucykpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb250ZW50LWVuY29kaW5nIGluIG9yZGVyIHRvIG5vdCBjb25mdXNlIGRvd25zdHJlYW0gb3BlcmF0aW9uc1xuICAgICAgICAgIGRlbGV0ZSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgaWYgKGlzQnJvdGxpU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBzdHJlYW1zLnB1c2goemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKGJyb3RsaU9wdGlvbnMpKTtcbiAgICAgICAgICAgIGRlbGV0ZSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNwb25zZVN0cmVhbSA9IHN0cmVhbXMubGVuZ3RoID4gMSA/IHN0cmVhbS5waXBlbGluZShzdHJlYW1zLCB1dGlscy5ub29wKSA6IHN0cmVhbXNbMF07XG5cbiAgICAgIGNvbnN0IG9mZkxpc3RlbmVycyA9IHN0cmVhbS5maW5pc2hlZChyZXNwb25zZVN0cmVhbSwgKCkgPT4ge1xuICAgICAgICBvZmZMaXN0ZW5lcnMoKTtcbiAgICAgICAgb25GaW5pc2hlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXMuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgaGVhZGVyczogbmV3IEF4aW9zSGVhZGVycyhyZXMuaGVhZGVycyksXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogbGFzdFJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZVN0cmVhbTtcbiAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsUmVzcG9uc2VCeXRlcyA9IDA7XG5cbiAgICAgICAgcmVzcG9uc2VTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiBoYW5kbGVTdHJlYW1EYXRhKGNodW5rKSB7XG4gICAgICAgICAgcmVzcG9uc2VCdWZmZXIucHVzaChjaHVuayk7XG4gICAgICAgICAgdG90YWxSZXNwb25zZUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgY29udGVudCBsZW5ndGggaXMgbm90IG92ZXIgdGhlIG1heENvbnRlbnRMZW5ndGggaWYgc3BlY2lmaWVkXG4gICAgICAgICAgaWYgKGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoID4gLTEgJiYgdG90YWxSZXNwb25zZUJ5dGVzID4gY29uZmlnLm1heENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHN0cmVhbS5kZXN0cm95KCkgZW1pdCBhYm9ydGVkIGV2ZW50IGJlZm9yZSBjYWxsaW5nIHJlamVjdCgpIG9uIE5vZGUuanMgdjE2XG4gICAgICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ21heENvbnRlbnRMZW5ndGggc2l6ZSBvZiAnICsgY29uZmlnLm1heENvbnRlbnRMZW5ndGggKyAnIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCBjb25maWcsIGxhc3RSZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNwb25zZVN0cmVhbS5vbignYWJvcnRlZCcsIGZ1bmN0aW9uIGhhbmRsZXJTdHJlYW1BYm9ydGVkKCkge1xuICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICAgICAgJ3N0cmVhbSBoYXMgYmVlbiBhYm9ydGVkJyxcbiAgICAgICAgICAgIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNwb25zZVN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVycm9yKGVycikge1xuICAgICAgICAgIGlmIChyZXEuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgcmVqZWN0KEF4aW9zRXJyb3IuZnJvbShlcnIsIG51bGwsIGNvbmZpZywgbGFzdFJlcXVlc3QpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzcG9uc2VTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uIGhhbmRsZVN0cmVhbUVuZCgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlQnVmZmVyLmxlbmd0aCA9PT0gMSA/IHJlc3BvbnNlQnVmZmVyWzBdIDogQnVmZmVyLmNvbmNhdChyZXNwb25zZUJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlRGF0YS50b1N0cmluZyhyZXNwb25zZUVuY29kaW5nKTtcbiAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZUVuY29kaW5nIHx8IHJlc3BvbnNlRW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IHV0aWxzLnN0cmlwQk9NKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZURhdGE7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KEF4aW9zRXJyb3IuZnJvbShlcnIsIG51bGwsIGNvbmZpZywgcmVzcG9uc2UucmVxdWVzdCwgcmVzcG9uc2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZW1pdHRlci5vbmNlKCdhYm9ydCcsIGVyciA9PiB7XG4gICAgICAgIGlmICghcmVzcG9uc2VTdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmVzcG9uc2VTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIHJlc3BvbnNlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBlbWl0dGVyLm9uY2UoJ2Fib3J0JywgZXJyID0+IHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgICAgcmVxLmRlc3Ryb3koZXJyKTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdEVycm9yKGVycikge1xuICAgICAgLy8gQHRvZG8gcmVtb3ZlXG4gICAgICAvLyBpZiAocmVxLmFib3J0ZWQgJiYgZXJyLmNvZGUgIT09IEF4aW9zRXJyb3IuRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUykgcmV0dXJuO1xuICAgICAgcmVqZWN0KEF4aW9zRXJyb3IuZnJvbShlcnIsIG51bGwsIGNvbmZpZywgcmVxKSk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdGNwIGtlZXAgYWxpdmUgdG8gcHJldmVudCBkcm9wIGNvbm5lY3Rpb24gYnkgcGVlclxuICAgIHJlcS5vbignc29ja2V0JywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFNvY2tldChzb2NrZXQpIHtcbiAgICAgIC8vIGRlZmF1bHQgaW50ZXJ2YWwgb2Ygc2VuZGluZyBhY2sgcGFja2V0IGlzIDEgbWludXRlXG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIDEwMDAgKiA2MCk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcmVxdWVzdCB0aW1lb3V0XG4gICAgaWYgKGNvbmZpZy50aW1lb3V0KSB7XG4gICAgICAvLyBUaGlzIGlzIGZvcmNpbmcgYSBpbnQgdGltZW91dCB0byBhdm9pZCBwcm9ibGVtcyBpZiB0aGUgYHJlcWAgaW50ZXJmYWNlIGRvZXNuJ3QgaGFuZGxlIG90aGVyIHR5cGVzLlxuICAgICAgY29uc3QgdGltZW91dCA9IHBhcnNlSW50KGNvbmZpZy50aW1lb3V0LCAxMCk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odGltZW91dCkpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICAgICdlcnJvciB0cnlpbmcgdG8gcGFyc2UgYGNvbmZpZy50aW1lb3V0YCB0byBpbnQnLFxuICAgICAgICAgIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlcVxuICAgICAgICApKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNvbWV0aW1lLCB0aGUgcmVzcG9uc2Ugd2lsbCBiZSB2ZXJ5IHNsb3csIGFuZCBkb2VzIG5vdCByZXNwb25kLCB0aGUgY29ubmVjdCBldmVudCB3aWxsIGJlIGJsb2NrIGJ5IGV2ZW50IGxvb3Agc3lzdGVtLlxuICAgICAgLy8gQW5kIHRpbWVyIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQsIGFuZCBhYm9ydCgpIHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgY29ubmVjdGlvbiwgdGhlbiBnZXQgXCJzb2NrZXQgaGFuZyB1cFwiIGFuZCBjb2RlIEVDT05OUkVTRVQuXG4gICAgICAvLyBBdCB0aGlzIHRpbWUsIGlmIHdlIGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgcmVxdWVzdCwgbm9kZWpzIHdpbGwgaGFuZyB1cCBzb21lIHNvY2tldCBvbiBiYWNrZ3JvdW5kLiBhbmQgdGhlIG51bWJlciB3aWxsIHVwIGFuZCB1cC5cbiAgICAgIC8vIEFuZCB0aGVuIHRoZXNlIHNvY2tldCB3aGljaCBiZSBoYW5nIHVwIHdpbGwgZGV2b3VyaW5nIENQVSBsaXR0bGUgYnkgbGl0dGxlLlxuICAgICAgLy8gQ2xpZW50UmVxdWVzdC5zZXRUaW1lb3V0IHdpbGwgYmUgZmlyZWQgb24gdGhlIHNwZWNpZnkgbWlsbGlzZWNvbmRzLCBhbmQgY2FuIG1ha2Ugc3VyZSB0aGF0IGFib3J0KCkgd2lsbCBiZSBmaXJlZCBhZnRlciBjb25uZWN0LlxuICAgICAgcmVxLnNldFRpbWVvdXQodGltZW91dCwgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFRpbWVvdXQoKSB7XG4gICAgICAgIGlmIChpc0RvbmUpIHJldHVybjtcbiAgICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHJlcVxuICAgICAgICApKTtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIGlmICh1dGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgICBsZXQgZXJyb3JlZCA9IGZhbHNlO1xuXG4gICAgICBkYXRhLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHJlcS5kZXN0cm95KGVycik7XG4gICAgICB9KTtcblxuICAgICAgZGF0YS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGlmICghZW5kZWQgJiYgIWVycm9yZWQpIHtcbiAgICAgICAgICBhYm9ydChuZXcgQ2FuY2VsZWRFcnJvcignUmVxdWVzdCBzdHJlYW0gaGFzIGJlZW4gYWJvcnRlZCcsIGNvbmZpZywgcmVxKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkYXRhLnBpcGUocmVxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLmVuZChkYXRhKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgX19zZXRQcm94eSA9IHNldFByb3h5O1xuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID8gKChvcmlnaW4sIGlzTVNJRSkgPT4gKHVybCkgPT4ge1xuICB1cmwgPSBuZXcgVVJMKHVybCwgcGxhdGZvcm0ub3JpZ2luKTtcblxuICByZXR1cm4gKFxuICAgIG9yaWdpbi5wcm90b2NvbCA9PT0gdXJsLnByb3RvY29sICYmXG4gICAgb3JpZ2luLmhvc3QgPT09IHVybC5ob3N0ICYmXG4gICAgKGlzTVNJRSB8fCBvcmlnaW4ucG9ydCA9PT0gdXJsLnBvcnQpXG4gICk7XG59KShcbiAgbmV3IFVSTChwbGF0Zm9ybS5vcmlnaW4pLFxuICBwbGF0Zm9ybS5uYXZpZ2F0b3IgJiYgLyhtc2llfHRyaWRlbnQpL2kudGVzdChwbGF0Zm9ybS5uYXZpZ2F0b3IudXNlckFnZW50KVxuKSA6ICgpID0+IHRydWU7XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICBjb25zdCBjb29raWUgPSBbbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSldO1xuXG4gICAgICB1dGlscy5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKHBhdGgpICYmIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcoZG9tYWluKSAmJiBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXG4gICAgICBzZWN1cmUgPT09IHRydWUgJiYgY29va2llLnB1c2goJ3NlY3VyZScpO1xuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICB9XG4gIH1cblxuICA6XG5cbiAgLy8gTm9uLXN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICB7XG4gICAgd3JpdGUoKSB7fSxcbiAgICByZWFkKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUoKSB7fVxuICB9O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL0F4aW9zSGVhZGVycy5qc1wiO1xuXG5jb25zdCBoZWFkZXJzVG9PYmplY3QgPSAodGhpbmcpID0+IHRoaW5nIGluc3RhbmNlb2YgQXhpb3NIZWFkZXJzID8geyAuLi50aGluZyB9IDogdGhpbmc7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIGNvbnN0IGNvbmZpZyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlLCBwcm9wLCBjYXNlbGVzcykge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UuY2FsbCh7Y2FzZWxlc3N9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZSh7fSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMoYSwgYiwgcHJvcCAsIGNhc2VsZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZU1hcCA9IHtcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgbWV0aG9kOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGRhdGE6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0TWVzc2FnZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aFhTUkZUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBhZGFwdGVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmQ29va2llTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB4c3JmSGVhZGVyTmFtZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uRG93bmxvYWRQcm9ncmVzczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBkZWNvbXByZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Qm9keUxlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBiZWZvcmVSZWRpcmVjdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cEFnZW50OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGh0dHBzQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgc29ja2V0UGF0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICByZXNwb25zZUVuY29kaW5nOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXG4gICAgaGVhZGVyczogKGEsIGIgLCBwcm9wKSA9PiBtZXJnZURlZXBQcm9wZXJ0aWVzKGhlYWRlcnNUb09iamVjdChhKSwgaGVhZGVyc1RvT2JqZWN0KGIpLHByb3AsIHRydWUpXG4gIH07XG5cbiAgdXRpbHMuZm9yRWFjaChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCBjb25maWcxLCBjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSwgcHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwiaW1wb3J0IHBsYXRmb3JtIGZyb20gXCIuLi9wbGF0Zm9ybS9pbmRleC5qc1wiO1xuaW1wb3J0IHV0aWxzIGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IGlzVVJMU2FtZU9yaWdpbiBmcm9tIFwiLi9pc1VSTFNhbWVPcmlnaW4uanNcIjtcbmltcG9ydCBjb29raWVzIGZyb20gXCIuL2Nvb2tpZXMuanNcIjtcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gXCIuLi9jb3JlL2J1aWxkRnVsbFBhdGguanNcIjtcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tIFwiLi4vY29yZS9tZXJnZUNvbmZpZy5qc1wiO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tIFwiLi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBidWlsZFVSTCBmcm9tIFwiLi9idWlsZFVSTC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCAoY29uZmlnKSA9PiB7XG4gIGNvbnN0IG5ld0NvbmZpZyA9IG1lcmdlQ29uZmlnKHt9LCBjb25maWcpO1xuXG4gIGxldCB7ZGF0YSwgd2l0aFhTUkZUb2tlbiwgeHNyZkhlYWRlck5hbWUsIHhzcmZDb29raWVOYW1lLCBoZWFkZXJzLCBhdXRofSA9IG5ld0NvbmZpZztcblxuICBuZXdDb25maWcuaGVhZGVycyA9IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShoZWFkZXJzKTtcblxuICBuZXdDb25maWcudXJsID0gYnVpbGRVUkwoYnVpbGRGdWxsUGF0aChuZXdDb25maWcuYmFzZVVSTCwgbmV3Q29uZmlnLnVybCwgbmV3Q29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKSwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuXG4gIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgaWYgKGF1dGgpIHtcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICtcbiAgICAgIGJ0b2EoKGF1dGgudXNlcm5hbWUgfHwgJycpICsgJzonICsgKGF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYXV0aC5wYXNzd29yZCkpIDogJycpKVxuICAgICk7XG4gIH1cblxuICBsZXQgY29udGVudFR5cGU7XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkpIHtcbiAgICBpZiAocGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52IHx8IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudikge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSh1bmRlZmluZWQpOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfSBlbHNlIGlmICgoY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkpICE9PSBmYWxzZSkge1xuICAgICAgLy8gZml4IHNlbWljb2xvbiBkdXBsaWNhdGlvbiBpc3N1ZSBmb3IgUmVhY3ROYXRpdmUgRm9ybURhdGEgaW1wbGVtZW50YXRpb25cbiAgICAgIGNvbnN0IFt0eXBlLCAuLi50b2tlbnNdID0gY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpLm1hcCh0b2tlbiA9PiB0b2tlbi50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShbdHlwZSB8fCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIC4uLnRva2Vuc10uam9pbignOyAnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuXG4gIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYpIHtcbiAgICB3aXRoWFNSRlRva2VuICYmIHV0aWxzLmlzRnVuY3Rpb24od2l0aFhTUkZUb2tlbikgJiYgKHdpdGhYU1JGVG9rZW4gPSB3aXRoWFNSRlRva2VuKG5ld0NvbmZpZykpO1xuXG4gICAgaWYgKHdpdGhYU1JGVG9rZW4gfHwgKHdpdGhYU1JGVG9rZW4gIT09IGZhbHNlICYmIGlzVVJMU2FtZU9yaWdpbihuZXdDb25maWcudXJsKSkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgY29uc3QgeHNyZlZhbHVlID0geHNyZkhlYWRlck5hbWUgJiYgeHNyZkNvb2tpZU5hbWUgJiYgY29va2llcy5yZWFkKHhzcmZDb29raWVOYW1lKTtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICBoZWFkZXJzLnNldCh4c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3Q29uZmlnO1xufVxuXG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgc2V0dGxlIGZyb20gJy4vLi4vY29yZS9zZXR0bGUuanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBhcnNlUHJvdG9jb2wgZnJvbSAnLi4vaGVscGVycy9wYXJzZVByb3RvY29sLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCB7cHJvZ3Jlc3NFdmVudFJlZHVjZXJ9IGZyb20gJy4uL2hlbHBlcnMvcHJvZ3Jlc3NFdmVudFJlZHVjZXIuanMnO1xuaW1wb3J0IHJlc29sdmVDb25maWcgZnJvbSBcIi4uL2hlbHBlcnMvcmVzb2x2ZUNvbmZpZy5qc1wiO1xuXG5jb25zdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbnN0IF9jb25maWcgPSByZXNvbHZlQ29uZmlnKGNvbmZpZyk7XG4gICAgbGV0IHJlcXVlc3REYXRhID0gX2NvbmZpZy5kYXRhO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oX2NvbmZpZy5oZWFkZXJzKS5ub3JtYWxpemUoKTtcbiAgICBsZXQge3Jlc3BvbnNlVHlwZSwgb25VcGxvYWRQcm9ncmVzcywgb25Eb3dubG9hZFByb2dyZXNzfSA9IF9jb25maWc7XG4gICAgbGV0IG9uQ2FuY2VsZWQ7XG4gICAgbGV0IHVwbG9hZFRocm90dGxlZCwgZG93bmxvYWRUaHJvdHRsZWQ7XG4gICAgbGV0IGZsdXNoVXBsb2FkLCBmbHVzaERvd25sb2FkO1xuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGZsdXNoVXBsb2FkICYmIGZsdXNoVXBsb2FkKCk7IC8vIGZsdXNoIGV2ZW50c1xuICAgICAgZmx1c2hEb3dubG9hZCAmJiBmbHVzaERvd25sb2FkKCk7IC8vIGZsdXNoIGV2ZW50c1xuXG4gICAgICBfY29uZmlnLmNhbmNlbFRva2VuICYmIF9jb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG5cbiAgICAgIF9jb25maWcuc2lnbmFsICYmIF9jb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHJlcXVlc3Qub3BlbihfY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBfY29uZmlnLnVybCwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IF9jb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oXG4gICAgICAgICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgJiYgcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgX2NvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IF9jb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKF9jb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgIHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQgJiYgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUobnVsbCk7XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycy50b0pTT04oKSwgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoX2NvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhX2NvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gX2NvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmIChvbkRvd25sb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIChbZG93bmxvYWRUaHJvdHRsZWQsIGZsdXNoRG93bmxvYWRdID0gcHJvZ3Jlc3NFdmVudFJlZHVjZXIob25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZG93bmxvYWRUaHJvdHRsZWQpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIChbdXBsb2FkVGhyb3R0bGVkLCBmbHVzaFVwbG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvblVwbG9hZFByb2dyZXNzKSk7XG5cbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdXBsb2FkVGhyb3R0bGVkKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZsdXNoVXBsb2FkKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbmZpZy5jYW5jZWxUb2tlbiB8fCBfY29uZmlnLnNpZ25hbCkge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgIG9uQ2FuY2VsZWQgPSBjYW5jZWwgPT4ge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgY2FuY2VsLnR5cGUgPyBuZXcgQ2FuY2VsZWRFcnJvcihudWxsLCBjb25maWcsIHJlcXVlc3QpIDogY2FuY2VsKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoX2NvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgX2NvbmZpZy5zaWduYWwuYWJvcnRlZCA/IG9uQ2FuY2VsZWQoKSA6IF9jb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKF9jb25maWcudXJsKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tIFwiLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanNcIjtcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gXCIuLi9jb3JlL0F4aW9zRXJyb3IuanNcIjtcbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNvbnN0IGNvbXBvc2VTaWduYWxzID0gKHNpZ25hbHMsIHRpbWVvdXQpID0+IHtcbiAgY29uc3Qge2xlbmd0aH0gPSAoc2lnbmFscyA9IHNpZ25hbHMgPyBzaWduYWxzLmZpbHRlcihCb29sZWFuKSA6IFtdKTtcblxuICBpZiAodGltZW91dCB8fCBsZW5ndGgpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAgIGxldCBhYm9ydGVkO1xuXG4gICAgY29uc3Qgb25hYm9ydCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmICghYWJvcnRlZCkge1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgY29uc3QgZXJyID0gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24gOiB0aGlzLnJlYXNvbjtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydChlcnIgaW5zdGFuY2VvZiBBeGlvc0Vycm9yID8gZXJyIDogbmV3IENhbmNlbGVkRXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IGVycikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0aW1lciA9IHRpbWVvdXQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBvbmFib3J0KG5ldyBBeGlvc0Vycm9yKGB0aW1lb3V0ICR7dGltZW91dH0gb2YgbXMgZXhjZWVkZWRgLCBBeGlvc0Vycm9yLkVUSU1FRE9VVCkpXG4gICAgfSwgdGltZW91dClcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbHMpIHtcbiAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBzaWduYWxzLmZvckVhY2goc2lnbmFsID0+IHtcbiAgICAgICAgICBzaWduYWwudW5zdWJzY3JpYmUgPyBzaWduYWwudW5zdWJzY3JpYmUob25hYm9ydCkgOiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZ25hbHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNpZ25hbHMuZm9yRWFjaCgoc2lnbmFsKSA9PiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KSk7XG5cbiAgICBjb25zdCB7c2lnbmFsfSA9IGNvbnRyb2xsZXI7XG5cbiAgICBzaWduYWwudW5zdWJzY3JpYmUgPSAoKSA9PiB1dGlscy5hc2FwKHVuc3Vic2NyaWJlKTtcblxuICAgIHJldHVybiBzaWduYWw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcG9zZVNpZ25hbHM7XG4iLCJcbmV4cG9ydCBjb25zdCBzdHJlYW1DaHVuayA9IGZ1bmN0aW9uKiAoY2h1bmssIGNodW5rU2l6ZSkge1xuICBsZXQgbGVuID0gY2h1bmsuYnl0ZUxlbmd0aDtcblxuICBpZiAoIWNodW5rU2l6ZSB8fCBsZW4gPCBjaHVua1NpemUpIHtcbiAgICB5aWVsZCBjaHVuaztcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgcG9zID0gMDtcbiAgbGV0IGVuZDtcblxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgZW5kID0gcG9zICsgY2h1bmtTaXplO1xuICAgIHlpZWxkIGNodW5rLnNsaWNlKHBvcywgZW5kKTtcbiAgICBwb3MgPSBlbmQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlYWRCeXRlcyA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRlcmFibGUsIGNodW5rU2l6ZSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlYWRTdHJlYW0oaXRlcmFibGUpKSB7XG4gICAgeWllbGQqIHN0cmVhbUNodW5rKGNodW5rLCBjaHVua1NpemUpO1xuICB9XG59XG5cbmNvbnN0IHJlYWRTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiogKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgIHlpZWxkKiBzdHJlYW07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0cmFja1N0cmVhbSA9IChzdHJlYW0sIGNodW5rU2l6ZSwgb25Qcm9ncmVzcywgb25GaW5pc2gpID0+IHtcbiAgY29uc3QgaXRlcmF0b3IgPSByZWFkQnl0ZXMoc3RyZWFtLCBjaHVua1NpemUpO1xuXG4gIGxldCBieXRlcyA9IDA7XG4gIGxldCBkb25lO1xuICBsZXQgX29uRmluaXNoID0gKGUpID0+IHtcbiAgICBpZiAoIWRvbmUpIHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgb25GaW5pc2ggJiYgb25GaW5pc2goZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7ZG9uZSwgdmFsdWV9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICBfb25GaW5pc2goKTtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgbGV0IGxvYWRlZEJ5dGVzID0gYnl0ZXMgKz0gbGVuO1xuICAgICAgICAgIG9uUHJvZ3Jlc3MobG9hZGVkQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9vbkZpbmlzaChlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICBfb25GaW5pc2gocmVhc29uKTtcbiAgICAgIHJldHVybiBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBoaWdoV2F0ZXJNYXJrOiAyXG4gIH0pXG59XG4iLCJpbXBvcnQgcGxhdGZvcm0gZnJvbSBcIi4uL3BsYXRmb3JtL2luZGV4LmpzXCI7XG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5pbXBvcnQgY29tcG9zZVNpZ25hbHMgZnJvbSBcIi4uL2hlbHBlcnMvY29tcG9zZVNpZ25hbHMuanNcIjtcbmltcG9ydCB7dHJhY2tTdHJlYW19IGZyb20gXCIuLi9oZWxwZXJzL3RyYWNrU3RyZWFtLmpzXCI7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuLi9jb3JlL0F4aW9zSGVhZGVycy5qc1wiO1xuaW1wb3J0IHtwcm9ncmVzc0V2ZW50UmVkdWNlciwgcHJvZ3Jlc3NFdmVudERlY29yYXRvciwgYXN5bmNEZWNvcmF0b3J9IGZyb20gXCIuLi9oZWxwZXJzL3Byb2dyZXNzRXZlbnRSZWR1Y2VyLmpzXCI7XG5pbXBvcnQgcmVzb2x2ZUNvbmZpZyBmcm9tIFwiLi4vaGVscGVycy9yZXNvbHZlQ29uZmlnLmpzXCI7XG5pbXBvcnQgc2V0dGxlIGZyb20gXCIuLi9jb3JlL3NldHRsZS5qc1wiO1xuXG5jb25zdCBpc0ZldGNoU3VwcG9ydGVkID0gdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgPSBpc0ZldGNoU3VwcG9ydGVkICYmIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gdXNlZCBvbmx5IGluc2lkZSB0aGUgZmV0Y2ggYWRhcHRlclxuY29uc3QgZW5jb2RlVGV4dCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgKChlbmNvZGVyKSA9PiAoc3RyKSA9PiBlbmNvZGVyLmVuY29kZShzdHIpKShuZXcgVGV4dEVuY29kZXIoKSkgOlxuICAgIGFzeW5jIChzdHIpID0+IG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXNwb25zZShzdHIpLmFycmF5QnVmZmVyKCkpXG4pO1xuXG5jb25zdCB0ZXN0ID0gKGZuLCAuLi5hcmdzKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZm4oLi4uYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5jb25zdCBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gPSBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmIHRlc3QoKCkgPT4ge1xuICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcblxuICBjb25zdCBoYXNDb250ZW50VHlwZSA9IG5ldyBSZXF1ZXN0KHBsYXRmb3JtLm9yaWdpbiwge1xuICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGdldCBkdXBsZXgoKSB7XG4gICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICByZXR1cm4gJ2hhbGYnO1xuICAgIH0sXG4gIH0pLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKTtcblxuICByZXR1cm4gZHVwbGV4QWNjZXNzZWQgJiYgIWhhc0NvbnRlbnRUeXBlO1xufSk7XG5cbmNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcblxuY29uc3Qgc3VwcG9ydHNSZXNwb25zZVN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiZcbiAgdGVzdCgoKSA9PiB1dGlscy5pc1JlYWRhYmxlU3RyZWFtKG5ldyBSZXNwb25zZSgnJykuYm9keSkpO1xuXG5cbmNvbnN0IHJlc29sdmVycyA9IHtcbiAgc3RyZWFtOiBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmICgocmVzKSA9PiByZXMuYm9keSlcbn07XG5cbmlzRmV0Y2hTdXBwb3J0ZWQgJiYgKCgocmVzKSA9PiB7XG4gIFsndGV4dCcsICdhcnJheUJ1ZmZlcicsICdibG9iJywgJ2Zvcm1EYXRhJywgJ3N0cmVhbSddLmZvckVhY2godHlwZSA9PiB7XG4gICAgIXJlc29sdmVyc1t0eXBlXSAmJiAocmVzb2x2ZXJzW3R5cGVdID0gdXRpbHMuaXNGdW5jdGlvbihyZXNbdHlwZV0pID8gKHJlcykgPT4gcmVzW3R5cGVdKCkgOlxuICAgICAgKF8sIGNvbmZpZykgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgUmVzcG9uc2UgdHlwZSAnJHt0eXBlfScgaXMgbm90IHN1cHBvcnRlZGAsIEF4aW9zRXJyb3IuRVJSX05PVF9TVVBQT1JULCBjb25maWcpO1xuICAgICAgfSlcbiAgfSk7XG59KShuZXcgUmVzcG9uc2UpKTtcblxuY29uc3QgZ2V0Qm9keUxlbmd0aCA9IGFzeW5jIChib2R5KSA9PiB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzQmxvYihib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemU7XG4gIH1cblxuICBpZih1dGlscy5pc1NwZWNDb21wbGlhbnRGb3JtKGJvZHkpKSB7XG4gICAgY29uc3QgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdChwbGF0Zm9ybS5vcmlnaW4sIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGF3YWl0IF9yZXF1ZXN0LmFycmF5QnVmZmVyKCkpLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBpZih1dGlscy5pc0FycmF5QnVmZmVyVmlldyhib2R5KSB8fCB1dGlscy5pc0FycmF5QnVmZmVyKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGlmKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG4gICAgYm9keSA9IGJvZHkgKyAnJztcbiAgfVxuXG4gIGlmKHV0aWxzLmlzU3RyaW5nKGJvZHkpKSB7XG4gICAgcmV0dXJuIChhd2FpdCBlbmNvZGVUZXh0KGJvZHkpKS5ieXRlTGVuZ3RoO1xuICB9XG59XG5cbmNvbnN0IHJlc29sdmVCb2R5TGVuZ3RoID0gYXN5bmMgKGhlYWRlcnMsIGJvZHkpID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIoaGVhZGVycy5nZXRDb250ZW50TGVuZ3RoKCkpO1xuXG4gIHJldHVybiBsZW5ndGggPT0gbnVsbCA/IGdldEJvZHlMZW5ndGgoYm9keSkgOiBsZW5ndGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKGFzeW5jIChjb25maWcpID0+IHtcbiAgbGV0IHtcbiAgICB1cmwsXG4gICAgbWV0aG9kLFxuICAgIGRhdGEsXG4gICAgc2lnbmFsLFxuICAgIGNhbmNlbFRva2VuLFxuICAgIHRpbWVvdXQsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXG4gICAgcmVzcG9uc2VUeXBlLFxuICAgIGhlYWRlcnMsXG4gICAgd2l0aENyZWRlbnRpYWxzID0gJ3NhbWUtb3JpZ2luJyxcbiAgICBmZXRjaE9wdGlvbnNcbiAgfSA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcblxuICByZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgPyAocmVzcG9uc2VUeXBlICsgJycpLnRvTG93ZXJDYXNlKCkgOiAndGV4dCc7XG5cbiAgbGV0IGNvbXBvc2VkU2lnbmFsID0gY29tcG9zZVNpZ25hbHMoW3NpZ25hbCwgY2FuY2VsVG9rZW4gJiYgY2FuY2VsVG9rZW4udG9BYm9ydFNpZ25hbCgpXSwgdGltZW91dCk7XG5cbiAgbGV0IHJlcXVlc3Q7XG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb21wb3NlZFNpZ25hbCAmJiBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSAmJiAoKCkgPT4ge1xuICAgICAgY29tcG9zZWRTaWduYWwudW5zdWJzY3JpYmUoKTtcbiAgfSk7XG5cbiAgbGV0IHJlcXVlc3RDb250ZW50TGVuZ3RoO1xuXG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgb25VcGxvYWRQcm9ncmVzcyAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gJiYgbWV0aG9kICE9PSAnZ2V0JyAmJiBtZXRob2QgIT09ICdoZWFkJyAmJlxuICAgICAgKHJlcXVlc3RDb250ZW50TGVuZ3RoID0gYXdhaXQgcmVzb2x2ZUJvZHlMZW5ndGgoaGVhZGVycywgZGF0YSkpICE9PSAwXG4gICAgKSB7XG4gICAgICBsZXQgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XG5cbiAgICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpICYmIChjb250ZW50VHlwZUhlYWRlciA9IF9yZXF1ZXN0LmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkpIHtcbiAgICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShjb250ZW50VHlwZUhlYWRlcilcbiAgICAgIH1cblxuICAgICAgaWYgKF9yZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgY29uc3QgW29uUHJvZ3Jlc3MsIGZsdXNoXSA9IHByb2dyZXNzRXZlbnREZWNvcmF0b3IoXG4gICAgICAgICAgcmVxdWVzdENvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25VcGxvYWRQcm9ncmVzcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgZGF0YSA9IHRyYWNrU3RyZWFtKF9yZXF1ZXN0LmJvZHksIERFRkFVTFRfQ0hVTktfU0laRSwgb25Qcm9ncmVzcywgZmx1c2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdXRpbHMuaXNTdHJpbmcod2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgd2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ29taXQnO1xuICAgIH1cblxuICAgIC8vIENsb3VkZmxhcmUgV29ya2VycyB0aHJvd3Mgd2hlbiBjcmVkZW50aWFscyBhcmUgZGVmaW5lZFxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS93b3JrZXJkL2lzc3Vlcy85MDJcbiAgICBjb25zdCBpc0NyZWRlbnRpYWxzU3VwcG9ydGVkID0gXCJjcmVkZW50aWFsc1wiIGluIFJlcXVlc3QucHJvdG90eXBlO1xuICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgIHNpZ25hbDogY29tcG9zZWRTaWduYWwsXG4gICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgaGVhZGVyczogaGVhZGVycy5ub3JtYWxpemUoKS50b0pTT04oKSxcbiAgICAgIGJvZHk6IGRhdGEsXG4gICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgY3JlZGVudGlhbHM6IGlzQ3JlZGVudGlhbHNTdXBwb3J0ZWQgPyB3aXRoQ3JlZGVudGlhbHMgOiB1bmRlZmluZWRcbiAgICB9KTtcblxuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuXG4gICAgY29uc3QgaXNTdHJlYW1SZXNwb25zZSA9IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKHJlc3BvbnNlVHlwZSA9PT0gJ3N0cmVhbScgfHwgcmVzcG9uc2VUeXBlID09PSAncmVzcG9uc2UnKTtcblxuICAgIGlmIChzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmIChvbkRvd25sb2FkUHJvZ3Jlc3MgfHwgKGlzU3RyZWFtUmVzcG9uc2UgJiYgdW5zdWJzY3JpYmUpKSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBbJ3N0YXR1cycsICdzdGF0dXNUZXh0JywgJ2hlYWRlcnMnXS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBvcHRpb25zW3Byb3BdID0gcmVzcG9uc2VbcHJvcF07XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50TGVuZ3RoID0gdXRpbHMudG9GaW5pdGVOdW1iZXIocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykpO1xuXG4gICAgICBjb25zdCBbb25Qcm9ncmVzcywgZmx1c2hdID0gb25Eb3dubG9hZFByb2dyZXNzICYmIHByb2dyZXNzRXZlbnREZWNvcmF0b3IoXG4gICAgICAgIHJlc3BvbnNlQ29udGVudExlbmd0aCxcbiAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25Eb3dubG9hZFByb2dyZXNzKSwgdHJ1ZSlcbiAgICAgICkgfHwgW107XG5cbiAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFxuICAgICAgICB0cmFja1N0cmVhbShyZXNwb25zZS5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uUHJvZ3Jlc3MsICgpID0+IHtcbiAgICAgICAgICBmbHVzaCAmJiBmbHVzaCgpO1xuICAgICAgICAgIHVuc3Vic2NyaWJlICYmIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZSB8fCAndGV4dCc7XG5cbiAgICBsZXQgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzb2x2ZXJzW3V0aWxzLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XG5cbiAgICAhaXNTdHJlYW1SZXNwb25zZSAmJiB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBoZWFkZXJzOiBBeGlvc0hlYWRlcnMuZnJvbShyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSlcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgaWYgKGVyciAmJiBlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgL0xvYWQgZmFpbGVkfGZldGNoL2kudGVzdChlcnIubWVzc2FnZSkpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSxcbiAgICAgICAge1xuICAgICAgICAgIGNhdXNlOiBlcnIuY2F1c2UgfHwgZXJyXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZXJyLCBlcnIgJiYgZXJyLmNvZGUsIGNvbmZpZywgcmVxdWVzdCk7XG4gIH1cbn0pO1xuXG5cbiIsImltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgaHR0cEFkYXB0ZXIgZnJvbSAnLi9odHRwLmpzJztcbmltcG9ydCB4aHJBZGFwdGVyIGZyb20gJy4veGhyLmpzJztcbmltcG9ydCBmZXRjaEFkYXB0ZXIgZnJvbSAnLi9mZXRjaC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5cbmNvbnN0IGtub3duQWRhcHRlcnMgPSB7XG4gIGh0dHA6IGh0dHBBZGFwdGVyLFxuICB4aHI6IHhockFkYXB0ZXIsXG4gIGZldGNoOiBmZXRjaEFkYXB0ZXJcbn1cblxudXRpbHMuZm9yRWFjaChrbm93bkFkYXB0ZXJzLCAoZm4sIHZhbHVlKSA9PiB7XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge3ZhbHVlfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ2FkYXB0ZXJOYW1lJywge3ZhbHVlfSk7XG4gIH1cbn0pO1xuXG5jb25zdCByZW5kZXJSZWFzb24gPSAocmVhc29uKSA9PiBgLSAke3JlYXNvbn1gO1xuXG5jb25zdCBpc1Jlc29sdmVkSGFuZGxlID0gKGFkYXB0ZXIpID0+IHV0aWxzLmlzRnVuY3Rpb24oYWRhcHRlcikgfHwgYWRhcHRlciA9PT0gbnVsbCB8fCBhZGFwdGVyID09PSBmYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXRBZGFwdGVyOiAoYWRhcHRlcnMpID0+IHtcbiAgICBhZGFwdGVycyA9IHV0aWxzLmlzQXJyYXkoYWRhcHRlcnMpID8gYWRhcHRlcnMgOiBbYWRhcHRlcnNdO1xuXG4gICAgY29uc3Qge2xlbmd0aH0gPSBhZGFwdGVycztcbiAgICBsZXQgbmFtZU9yQWRhcHRlcjtcbiAgICBsZXQgYWRhcHRlcjtcblxuICAgIGNvbnN0IHJlamVjdGVkUmVhc29ucyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbmFtZU9yQWRhcHRlciA9IGFkYXB0ZXJzW2ldO1xuICAgICAgbGV0IGlkO1xuXG4gICAgICBhZGFwdGVyID0gbmFtZU9yQWRhcHRlcjtcblxuICAgICAgaWYgKCFpc1Jlc29sdmVkSGFuZGxlKG5hbWVPckFkYXB0ZXIpKSB7XG4gICAgICAgIGFkYXB0ZXIgPSBrbm93bkFkYXB0ZXJzWyhpZCA9IFN0cmluZyhuYW1lT3JBZGFwdGVyKSkudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGFkYXB0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKGBVbmtub3duIGFkYXB0ZXIgJyR7aWR9J2ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGFwdGVyKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZWplY3RlZFJlYXNvbnNbaWQgfHwgJyMnICsgaV0gPSBhZGFwdGVyO1xuICAgIH1cblxuICAgIGlmICghYWRhcHRlcikge1xuXG4gICAgICBjb25zdCByZWFzb25zID0gT2JqZWN0LmVudHJpZXMocmVqZWN0ZWRSZWFzb25zKVxuICAgICAgICAubWFwKChbaWQsIHN0YXRlXSkgPT4gYGFkYXB0ZXIgJHtpZH0gYCArXG4gICAgICAgICAgKHN0YXRlID09PSBmYWxzZSA/ICdpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudCcgOiAnaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGQnKVxuICAgICAgICApO1xuXG4gICAgICBsZXQgcyA9IGxlbmd0aCA/XG4gICAgICAgIChyZWFzb25zLmxlbmd0aCA+IDEgPyAnc2luY2UgOlxcbicgKyByZWFzb25zLm1hcChyZW5kZXJSZWFzb24pLmpvaW4oJ1xcbicpIDogJyAnICsgcmVuZGVyUmVhc29uKHJlYXNvbnNbMF0pKSA6XG4gICAgICAgICdhcyBubyBhZGFwdGVyIHNwZWNpZmllZCc7XG5cbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gc3VpdGFibGUgYWRhcHRlciB0byBkaXNwYXRjaCB0aGUgcmVxdWVzdCBgICsgcyxcbiAgICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkYXB0ZXI7XG4gIH0sXG4gIGFkYXB0ZXJzOiBrbm93bkFkYXB0ZXJzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vdHJhbnNmb3JtRGF0YS5qcyc7XG5pbXBvcnQgaXNDYW5jZWwgZnJvbSAnLi4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBhZGFwdGVycyBmcm9tIFwiLi4vYWRhcHRlcnMvYWRhcHRlcnMuanNcIjtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbmZpZy5oZWFkZXJzKTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIGlmIChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uaW5kZXhPZihjb25maWcubWV0aG9kKSAhPT0gLTEpIHtcbiAgICBjb25maWcuaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgZmFsc2UpO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXIoY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcik7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gKHZhbHVlLCBvcHQsIG9wdHMpID0+IHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxudmFsaWRhdG9ycy5zcGVsbGluZyA9IGZ1bmN0aW9uIHNwZWxsaW5nKGNvcnJlY3RTcGVsbGluZykge1xuICByZXR1cm4gKHZhbHVlLCBvcHQpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihgJHtvcHR9IGlzIGxpa2VseSBhIG1pc3NwZWxsaW5nIG9mICR7Y29ycmVjdFNwZWxsaW5nfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWcgfHwge307XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgZHVtbXkgPSB7fTtcblxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGR1bW15KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcblxuICAgICAgICAvLyBzbGljZSBvZmYgdGhlIEVycm9yOiAuLi4gbGluZVxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgJycpIDogJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrICYmICFTdHJpbmcoZXJyLnN0YWNrKS5lbmRzV2l0aChzdGFjay5yZXBsYWNlKC9eLitcXG4uK1xcbi8sICcnKSkpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoZSBjYXNlIHdoZXJlIFwic3RhY2tcIiBpcyBhbiB1bi13cml0YWJsZSBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBfcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICAgIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZ09yVXJsIHx8IHt9O1xuICAgIH1cblxuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgICBjb25zdCB7dHJhbnNpdGlvbmFsLCBwYXJhbXNTZXJpYWxpemVyLCBoZWFkZXJzfSA9IGNvbmZpZztcblxuICAgIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXNTZXJpYWxpemVyICE9IG51bGwpIHtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcmFtc1NlcmlhbGl6ZXIpKSB7XG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgICAgZW5jb2RlOiB2YWxpZGF0b3JzLmZ1bmN0aW9uLFxuICAgICAgICAgIHNlcmlhbGl6ZTogdmFsaWRhdG9ycy5mdW5jdGlvblxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzXG4gICAgaWYgKGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLmFsbG93QWJzb2x1dGVVcmxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRoaXMuZGVmYXVsdHMuYWxsb3dBYnNvbHV0ZVVybHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMoY29uZmlnLCB7XG4gICAgICBiYXNlVXJsOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCdiYXNlVVJMJyksXG4gICAgICB3aXRoWHNyZlRva2VuOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCd3aXRoWFNSRlRva2VuJylcbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBoZWFkZXJzICYmIHV0aWxzLmZvckVhY2goXG4gICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbbWV0aG9kXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGNoYWluLnB1c2guYXBwbHkoY2hhaW4sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBsZW4gPSBjaGFpbi5sZW5ndGg7XG5cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbltpKytdLCBjaGFpbltpKytdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgbGVuID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgbGV0IG5ld0NvbmZpZyA9IGNvbmZpZztcblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCwgY29uZmlnLmFsbG93QWJzb2x1dGVVcmxzKTtcbiAgICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbiAgfVxufVxuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9DYW5jZWxlZEVycm9yLmpzJztcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7Q2FuY2VsVG9rZW59XG4gKi9cbmNsYXNzIENhbmNlbFRva2VuIHtcbiAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRva2VuID0gdGhpcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4oY2FuY2VsID0+IHtcbiAgICAgIGlmICghdG9rZW4uX2xpc3RlbmVycykgcmV0dXJuO1xuXG4gICAgICBsZXQgaSA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XG4gICAgICB9XG4gICAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgdGhpcy5wcm9taXNlLnRoZW4gPSBvbmZ1bGZpbGxlZCA9PiB7XG4gICAgICBsZXQgX3Jlc29sdmU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0b2tlbi5zdWJzY3JpYmUocmVzb2x2ZSk7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgICBwcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KTtcbiAgICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAqL1xuICB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAgICovXG5cbiAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICB0b0Fib3J0U2lnbmFsKCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICBjb25zdCBhYm9ydCA9IChlcnIpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoZXJyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJzY3JpYmUoYWJvcnQpO1xuXG4gICAgY29udHJvbGxlci5zaWduYWwudW5zdWJzY3JpYmUgPSAoKSA9PiB0aGlzLnVuc3Vic2NyaWJlKGFib3J0KTtcblxuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn1cbiIsImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIdHRwU3RhdHVzQ29kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBhZGFwdGVycyBmcm9tICcuL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzJztcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLmdldEFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyO1xuXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlO1xuXG5heGlvcy5kZWZhdWx0ID0gYXhpb3M7XG5cbi8vIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGhhdmUgYSBkZWZhdWx0IGV4cG9ydFxuZXhwb3J0IGRlZmF1bHQgYXhpb3NcbiIsIi8vIExvY2FsIExMTSBzZXJ2aWNlIGZvciBPbGxhbWEvTE0gU3R1ZGlvIGludGVncmF0aW9uXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuZXhwb3J0IGNsYXNzIExMTVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgYXN5bmMgY2hhdChtZXNzYWdlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByb3ZpZGVyID09PSAnb2xsYW1hJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXRXaXRoT2xsYW1hKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLnByb3ZpZGVyID09PSAnbG1zdHVkaW8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhdFdpdGhMTVN0dWRpbyhtZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIExMTSBwcm92aWRlcjogJHt0aGlzLmNvbmZpZy5wcm92aWRlcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xMTSBjaGF0IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21tdW5pY2F0ZSB3aXRoIGxvY2FsIExMTScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGlzQXZhaWxhYmxlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByb3ZpZGVyID09PSAnb2xsYW1hJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke3RoaXMuY29uZmlnLmJhc2VVcmx9L2FwaS90YWdzYCwge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5zdGF0dXMgPT09IDIwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLnByb3ZpZGVyID09PSAnbG1zdHVkaW8nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7dGhpcy5jb25maWcuYmFzZVVybH0vdjEvbW9kZWxzYCwge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5zdGF0dXMgPT09IDIwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGxvZyBjb25uZWN0aW9uIHJlZnVzZWQgZXJyb3JzIGFzIHRoZXkncmUgZXhwZWN0ZWQgd2hlbiBMTE0gaXMgbm90IHJ1bm5pbmdcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdjb2RlJyBpbiBlcnJvciAmJiBlcnJvci5jb2RlID09PSAnRUNPTk5SRUZVU0VEJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke3RoaXMuY29uZmlnLnByb3ZpZGVyfSBpcyBub3QgcnVubmluZyBhdCAke3RoaXMuY29uZmlnLmJhc2VVcmx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMTE0gYXZhaWxhYmlsaXR5IGNoZWNrIGZhaWxlZDonLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNoYXRXaXRoT2xsYW1hKG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG9sbGFtYU1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKG1zZyA9PiAoe1xuICAgICAgICAgICAgcm9sZTogbXNnLnJvbGUsXG4gICAgICAgICAgICBjb250ZW50OiBtc2cuY29udGVudCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhbiBleHBlcnQgTWljcm9zb2Z0IEVudHJhIChBenVyZSBBRCkgYW5kIE1pY3Jvc29mdCBHcmFwaCBBUEkgYXNzaXN0YW50IGludGVncmF0ZWQgaW50byBFbnRyYVB1bHNlIExpdGUuIFxyXG5cclxuWW91IGhhdmUgYWNjZXNzIHRvIE1pY3Jvc29mdCBHcmFwaCBBUElzIHRocm91Z2ggYnVpbHQtaW4gTUNQIHNlcnZlcnMgYW5kIGNhbiBoZWxwIHVzZXJzOlxyXG4tIFF1ZXJ5IHVzZXIgYWNjb3VudHMsIGdyb3VwcywgYXBwbGljYXRpb25zLCBhbmQgc2VydmljZSBwcmluY2lwYWxzXHJcbi0gVW5kZXJzdGFuZCBNaWNyb3NvZnQgRW50cmEgY29uY2VwdHMgYW5kIGJlc3QgcHJhY3RpY2VzXHJcbi0gQW5hbHl6ZSBwZXJtaXNzaW9ucyBhbmQgc2VjdXJpdHkgY29uZmlndXJhdGlvbnNcclxuLSBQcm92aWRlIG5hdHVyYWwgbGFuZ3VhZ2UgZXhwbGFuYXRpb25zIG9mIGNvbXBsZXggZGlyZWN0b3J5IHN0cnVjdHVyZXNcclxuXHJcbldoZW4gdXNlcnMgYXNrIHF1ZXN0aW9ucywgeW91IGNhbjpcclxuMS4gUXVlcnkgTWljcm9zb2Z0IEdyYXBoIEFQSXMgZGlyZWN0bHkgdXNpbmcgdGhlIGF2YWlsYWJsZSBNQ1AgdG9vbHNcclxuMi4gRXhwbGFpbiBNaWNyb3NvZnQgRW50cmEgY29uY2VwdHMgY2xlYXJseVxyXG4zLiBQcm92aWRlIGFjdGlvbmFibGUgaW5zaWdodHMgYWJvdXQgaWRlbnRpdHkgYW5kIGFjY2VzcyBtYW5hZ2VtZW50XHJcbjQuIEhlbHAgd2l0aCB0cm91Ymxlc2hvb3RpbmcgYW5kIHNlY3VyaXR5IGFuYWx5c2lzXHJcblxyXG5BbHdheXMgYmUgaGVscGZ1bCwgYWNjdXJhdGUsIGFuZCBzZWN1cml0eS1jb25zY2lvdXMgaW4geW91ciByZXNwb25zZXMuYDtcbiAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgeyByb2xlOiAnc3lzdGVtJywgY29udGVudDogc3lzdGVtUHJvbXB0IH0sXG4gICAgICAgICAgICAuLi5vbGxhbWFNZXNzYWdlc1xuICAgICAgICBdO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7dGhpcy5jb25maWcuYmFzZVVybH0vYXBpL2NoYXRgLCB7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5jb25maWcubW9kZWwsXG4gICAgICAgICAgICBtZXNzYWdlczogZnVsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgc3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogdGhpcy5jb25maWcudGVtcGVyYXR1cmUgfHwgMC43LFxuICAgICAgICAgICAgICAgIG51bV9wcmVkaWN0OiB0aGlzLmNvbmZpZy5tYXhUb2tlbnMgfHwgMjA0OCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tZXNzYWdlLmNvbnRlbnQ7XG4gICAgfVxuICAgIGFzeW5jIGNoYXRXaXRoTE1TdHVkaW8obWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3Qgb3BlbmFpTWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAobXNnID0+ICh7XG4gICAgICAgICAgICByb2xlOiBtc2cucm9sZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1zZy5jb250ZW50LFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHN5c3RlbVByb21wdCA9IGBZb3UgYXJlIGFuIGV4cGVydCBNaWNyb3NvZnQgRW50cmEgKEF6dXJlIEFEKSBhbmQgTWljcm9zb2Z0IEdyYXBoIEFQSSBhc3Npc3RhbnQgaW50ZWdyYXRlZCBpbnRvIEVudHJhUHVsc2UgTGl0ZS4gXHJcblxyXG5Zb3UgaGF2ZSBhY2Nlc3MgdG8gTWljcm9zb2Z0IEdyYXBoIEFQSXMgdGhyb3VnaCBidWlsdC1pbiBNQ1Agc2VydmVycyBhbmQgY2FuIGhlbHAgdXNlcnM6XHJcbi0gUXVlcnkgdXNlciBhY2NvdW50cywgZ3JvdXBzLCBhcHBsaWNhdGlvbnMsIGFuZCBzZXJ2aWNlIHByaW5jaXBhbHNcclxuLSBVbmRlcnN0YW5kIE1pY3Jvc29mdCBFbnRyYSBjb25jZXB0cyBhbmQgYmVzdCBwcmFjdGljZXNcclxuLSBBbmFseXplIHBlcm1pc3Npb25zIGFuZCBzZWN1cml0eSBjb25maWd1cmF0aW9uc1xyXG4tIFByb3ZpZGUgbmF0dXJhbCBsYW5ndWFnZSBleHBsYW5hdGlvbnMgb2YgY29tcGxleCBkaXJlY3Rvcnkgc3RydWN0dXJlc1xyXG5cclxuV2hlbiB1c2VycyBhc2sgcXVlc3Rpb25zLCB5b3UgY2FuOlxyXG4xLiBRdWVyeSBNaWNyb3NvZnQgR3JhcGggQVBJcyBkaXJlY3RseSB1c2luZyB0aGUgYXZhaWxhYmxlIE1DUCB0b29sc1xyXG4yLiBFeHBsYWluIE1pY3Jvc29mdCBFbnRyYSBjb25jZXB0cyBjbGVhcmx5XHJcbjMuIFByb3ZpZGUgYWN0aW9uYWJsZSBpbnNpZ2h0cyBhYm91dCBpZGVudGl0eSBhbmQgYWNjZXNzIG1hbmFnZW1lbnRcclxuNC4gSGVscCB3aXRoIHRyb3VibGVzaG9vdGluZyBhbmQgc2VjdXJpdHkgYW5hbHlzaXNcclxuXHJcbkFsd2F5cyBiZSBoZWxwZnVsLCBhY2N1cmF0ZSwgYW5kIHNlY3VyaXR5LWNvbnNjaW91cyBpbiB5b3VyIHJlc3BvbnNlcy5gO1xuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBzeXN0ZW1Qcm9tcHQgfSxcbiAgICAgICAgICAgIC4uLm9wZW5haU1lc3NhZ2VzXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHt0aGlzLmNvbmZpZy5iYXNlVXJsfS92MS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMuY29uZmlnLm1vZGVsLFxuICAgICAgICAgICAgbWVzc2FnZXM6IGZ1bGxNZXNzYWdlcyxcbiAgICAgICAgICAgIHRlbXBlcmF0dXJlOiB0aGlzLmNvbmZpZy50ZW1wZXJhdHVyZSB8fCAwLjcsXG4gICAgICAgICAgICBtYXhfdG9rZW5zOiB0aGlzLmNvbmZpZy5tYXhUb2tlbnMgfHwgMjA0OCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xuICAgIH1cbiAgICBhc3luYyBnZXRBdmFpbGFibGVNb2RlbHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcucHJvdmlkZXIgPT09ICdvbGxhbWEnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7dGhpcy5jb25maWcuYmFzZVVybH0vYXBpL3RhZ3NgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tb2RlbHM/Lm1hcCgobW9kZWwpID0+IG1vZGVsLm5hbWUpIHx8IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcucHJvdmlkZXIgPT09ICdsbXN0dWRpbycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHt0aGlzLmNvbmZpZy5iYXNlVXJsfS92MS9tb2RlbHNgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5kYXRhPy5tYXAoKG1vZGVsKSA9PiBtb2RlbC5pZCkgfHwgW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGF2YWlsYWJsZSBtb2RlbHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKiBNb2NrIE1DUCBTREsgdHlwZXMgYXMgYSBmYWxsYmFjayB1bnRpbCB3ZSBjYW4gaW5zdGFsbCB0aGUgcmVhbCBwYWNrYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBNQ1BDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgYXN5bmMgbGlzdFRvb2xzKCkge1xuICAgICAgICAvLyBNb2NrIGltcGxlbWVudGF0aW9uXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3NhbXBsZV90b29sJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1NhbXBsZSB0b29sIGRlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbFRvb2wodG9vbE5hbWUsIGFyZ3VtZW50c18pIHtcbiAgICAgICAgLy8gTW9jayBpbXBsZW1lbnRhdGlvblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBgUmVzcG9uc2UgZnJvbSB0b29sICR7dG9vbE5hbWV9IHdpdGggYXJncyAke0pTT04uc3RyaW5naWZ5KGFyZ3VtZW50c18pfWBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiLy8gTUNQQ2xpZW50LnRzIC0gU0RLIEltcGxlbWVudGF0aW9uXG4vLyBNQ1AgQ2xpZW50IHVzaW5nIHRoZSBNQ1AgVHlwZVNjcmlwdCBTREtcbi8vIEltcG9ydCBmcm9tIG1vY2sgZm9yIG5vdywgcmVwbGFjZSB3aXRoIGFjdHVhbCBTREsgd2hlbiBhdmFpbGFibGVcbmltcG9ydCB7IE1DUENsaWVudCBhcyBTREtNQ1BDbGllbnQgfSBmcm9tICcuLi9tb2NrJztcbmV4cG9ydCBjbGFzcyBNQ1BDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlckNvbmZpZ3MsIGF1dGhTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJDb25maWdzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1dGhTZXJ2aWNlID0gYXV0aFNlcnZpY2U7XG4gICAgICAgIC8vIFN0b3JlIHNlcnZlciBjb25maWdzIGZvciBsYXRlciByZWZlcmVuY2VcbiAgICAgICAgc2VydmVyQ29uZmlncy5mb3JFYWNoKGNvbmZpZyA9PiB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlckNvbmZpZ3Muc2V0KGNvbmZpZy5uYW1lLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY2xpZW50IGZvciBhIHNwZWNpZmljIHNlcnZlclxuICAgICAqIEBwYXJhbSBzZXJ2ZXJOYW1lIE5hbWUgb2YgdGhlIE1DUCBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJucyBTREsgTUNQIGNsaWVudCBmb3IgdGhlIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemVDbGllbnQoc2VydmVyTmFtZSkge1xuICAgICAgICAvLyBDaGVjayBpZiBjbGllbnQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50cy5oYXMoc2VydmVyTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudHMuZ2V0KHNlcnZlck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlckNvbmZpZyA9IHRoaXMuc2VydmVyQ29uZmlncy5nZXQoc2VydmVyTmFtZSk7XG4gICAgICAgIGlmICghc2VydmVyQ29uZmlnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1DUCBzZXJ2ZXIgJyR7c2VydmVyTmFtZX0nIG5vdCBmb3VuZCBvciBkaXNhYmxlZGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBhdXRoZW50aWNhdGlvbiBoZWFkZXJzIGZvciB0aGlzIHNlcnZlciB0eXBlXG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgdGhpcy5hdXRoU2VydmljZS5nZXRBdXRoSGVhZGVycyhzZXJ2ZXJDb25maWcudHlwZSk7XG4gICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgU0RLIGNsaWVudFxuICAgICAgICBjb25zdCBjbGllbnRDb25maWcgPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogc2VydmVyQ29uZmlnLnVybCB8fCBgaHR0cDovL2xvY2FsaG9zdDoke3NlcnZlckNvbmZpZy5wb3J0fWAsXG4gICAgICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyxcbiAgICAgICAgICAgIGFwaUtleTogc2VydmVyQ29uZmlnLmFwaUtleVxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgdGhlIFNESyBjbGllbnRcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IFNES01DUENsaWVudChjbGllbnRDb25maWcpO1xuICAgICAgICAvLyBTdG9yZSB0aGUgY2xpZW50IGZvciByZXVzZVxuICAgICAgICB0aGlzLmNsaWVudHMuc2V0KHNlcnZlck5hbWUsIGNsaWVudCk7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgYXZhaWxhYmxlIHNlcnZlcnNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGVuYWJsZWQgc2VydmVyIG5hbWVzXG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlU2VydmVycygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zZXJ2ZXJDb25maWdzLmtleXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIHNlcnZlciBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHNlcnZlck5hbWUgTmFtZSBvZiB0aGUgTUNQIHNlcnZlclxuICAgICAqIEByZXR1cm5zIFNlcnZlciBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgZ2V0U2VydmVyQ29uZmlnKHNlcnZlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29uZmlncy5nZXQoc2VydmVyTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIHRvb2xzIG9uIGFuIE1DUCBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gc2VydmVyTmFtZSBOYW1lIG9mIHRoZSBNQ1Agc2VydmVyXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBhdmFpbGFibGUgdG9vbHNcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VG9vbHMoc2VydmVyTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5pbml0aWFsaXplQ2xpZW50KHNlcnZlck5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0VG9vbHMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsaXN0IHRvb2xzIGZvciBzZXJ2ZXIgJHtzZXJ2ZXJOYW1lfTpgLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgdG9vbCBvbiBhbiBNQ1Agc2VydmVyXG4gICAgICogQHBhcmFtIHNlcnZlck5hbWUgTmFtZSBvZiB0aGUgTUNQIHNlcnZlclxuICAgICAqIEBwYXJhbSB0b29sTmFtZSBOYW1lIG9mIHRoZSB0b29sIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0gYXJndW1lbnRzXyBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgdG9vbFxuICAgICAqIEByZXR1cm5zIFRvb2wgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBhc3luYyBjYWxsVG9vbChzZXJ2ZXJOYW1lLCB0b29sTmFtZSwgYXJndW1lbnRzXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5pbml0aWFsaXplQ2xpZW50KHNlcnZlck5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuY2FsbFRvb2wodG9vbE5hbWUsIGFyZ3VtZW50c18pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNhbGwgdG9vbCAke3Rvb2xOYW1lfSBvbiBzZXJ2ZXIgJHtzZXJ2ZXJOYW1lfTpgLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjYWxsIHRvb2wgJHt0b29sTmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIE1DUEF1dGhTZXJ2aWNlLnRzXG4vLyBBdXRoZW50aWNhdGlvbiBzZXJ2aWNlIGZvciBNQ1Agc2VydmVyc1xuZXhwb3J0IGNsYXNzIE1DUEF1dGhTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoU2VydmljZSkge1xuICAgICAgICB0aGlzLmF1dGhTZXJ2aWNlID0gYXV0aFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhdXRoZW50aWNhdGlvbiBwcm92aWRlciBmb3IgTWljcm9zb2Z0IEdyYXBoIEFQSVxuICAgICAqIEByZXR1cm5zIEF1dGhlbnRpY2F0aW9uUHJvdmlkZXIgZm9yIE1pY3Jvc29mdCBHcmFwaFxuICAgICAqL1xuICAgIGFzeW5jIGdldEdyYXBoQXV0aFByb3ZpZGVyKCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBjdXN0b20gYXV0aGVudGljYXRpb24gcHJvdmlkZXIgZm9yIE1pY3Jvc29mdCBHcmFwaFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0QWNjZXNzVG9rZW46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHRoaXMuYXV0aFNlcnZpY2UuZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGF1dGhlbnRpY2F0aW9uIHRva2VuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGFjcXVpcmUgZ3JhcGggdG9rZW46JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBvcmlnaW5hbCBlcnJvciBzbyBpdCBjYW4gYmUgcHJvcGVybHkgaW5zcGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCBmb3IgTWljcm9zb2Z0IEdyYXBoIEFQSSc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR3JhcGggYXV0aGVudGljYXRpb24gZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGhlYWRlcnMgZm9yIGF1dGhlbnRpY2F0aW9uIHRvIE1DUCBzZXJ2ZXJzXG4gICAgICogQHBhcmFtIHNlcnZlclR5cGUgVHlwZSBvZiBNQ1Agc2VydmVyXG4gICAgICogQHJldHVybnMgQXV0aGVudGljYXRpb24gaGVhZGVyc1xuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgYXV0aGVudGljYXRpb24gZmFpbHNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdXRoSGVhZGVycyhzZXJ2ZXJUeXBlKSB7XG4gICAgICAgIC8vIERpZmZlcmVudCBzZXJ2ZXJzIG1heSByZXF1aXJlIGRpZmZlcmVudCBhdXRoZW50aWNhdGlvbiBoZWFkZXJzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNlcnZlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsb2trYSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5hdXRoU2VydmljZS5nZXRUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1dGhlbnRpY2F0aW9uIHRva2VuIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbi5hY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZldGNoJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggc2VydmVyIGRvZXNuJ3QgbmVlZCBhdXRoIGhlYWRlcnMgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiAnRW50cmFQdWxzZUxpdGUvMS4wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gc2VydmVyIHR5cGU6ICR7c2VydmVyVHlwZX0sIHJldHVybmluZyBkZWZhdWx0IGhlYWRlcnNgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgYXV0aGVudGljYXRpb24gaGVhZGVycyBmb3IgJHtzZXJ2ZXJUeXBlfSBzZXJ2ZXI6YCwgZXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBhdXRoZW50aWNhdGlvbiBlcnJvcic7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgYXV0aGVudGljYXRpb24gaGVhZGVycyBmb3IgJHtzZXJ2ZXJUeXBlfSBzZXJ2ZXI6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiB0b2tlblxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGF1dGggdG9rZW4gb3IgbnVsbCBpZiBub3QgYXV0aGVudGljYXRlZFxuICAgICAqL1xuICAgIGFzeW5jIGdldFRva2VuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYXV0aFNlcnZpY2UuZ2V0VG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdG9rZW46JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvLyBNQ1AgRXJyb3IgSGFuZGxlciB1dGlsaXR5IGZvciBpbXByb3ZlZCBlcnJvciBoYW5kbGluZyBhbmQgcmVwb3J0aW5nXG5leHBvcnQgdmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkJBRF9SRVFVRVNUXCJdID0gNDAwXSA9IFwiQkFEX1JFUVVFU1RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVU5BVVRIT1JJWkVEXCJdID0gNDAxXSA9IFwiVU5BVVRIT1JJWkVEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkZPUkJJRERFTlwiXSA9IDQwM10gPSBcIkZPUkJJRERFTlwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJOT1RfRk9VTkRcIl0gPSA0MDRdID0gXCJOT1RfRk9VTkRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTUVUSE9EX05PVF9BTExPV0VEXCJdID0gNDA1XSA9IFwiTUVUSE9EX05PVF9BTExPV0VEXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNPTkZMSUNUXCJdID0gNDA5XSA9IFwiQ09ORkxJQ1RcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCJdID0gNTAwXSA9IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlNFUlZJQ0VfVU5BVkFJTEFCTEVcIl0gPSA1MDNdID0gXCJTRVJWSUNFX1VOQVZBSUxBQkxFXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgTUNQRXJyb3JIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzdGFuZGFyZGl6ZWQgTUNQIGVycm9yIG9iamVjdFxuICAgICAqIEBwYXJhbSBjb2RlIEVycm9yIGNvZGVcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIGRhdGEgQWRkaXRpb25hbCBlcnJvciBkYXRhXG4gICAgICogQHJldHVybnMgTUNQIGVycm9yIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuZCBsb2cgYW4gZXJyb3JcbiAgICAgKiBAcGFyYW0gZXJyb3IgRXJyb3Igb2JqZWN0XG4gICAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBpbmZvcm1hdGlvbiBmb3IgbG9nZ2luZ1xuICAgICAqIEByZXR1cm5zIFN0YW5kYXJkaXplZCBNQ1AgZXJyb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgaGFuZGxlRXJyb3IoZXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gTG9nIHRoZSBlcnJvciB3aXRoIGNvbnRleHRcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gJHtjb250ZXh0fTpgLCBlcnJvcik7XG4gICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhbiBNQ1BFcnJvciwgcmV0dXJuIGl0XG4gICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdjb2RlJyBpbiBlcnJvciAmJiAnbWVzc2FnZScgaW4gZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IHRvIGludGVybmFsIHNlcnZlciBlcnJvclxuICAgICAgICBsZXQgY29kZSA9IEVycm9yQ29kZS5JTlRFUk5BTF9TRVJWRVJfRVJST1I7XG4gICAgICAgIGxldCBtZXNzYWdlID0gZXJyb3I/Lm1lc3NhZ2UgfHwgJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnO1xuICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBlcnJvciBjb2RlXG4gICAgICAgIGlmIChlcnJvcj8ubWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gZXJyb3IubWVzc2FnZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG1zZy5pbmNsdWRlcygnbm90IGZvdW5kJykgfHwgbXNnLmluY2x1ZGVzKCdkb2VzIG5vdCBleGlzdCcpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IEVycm9yQ29kZS5OT1RfRk9VTkQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtc2cuaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSB8fCBtc2cuaW5jbHVkZXMoJ2FjY2VzcycpIHx8IG1zZy5pbmNsdWRlcygnZm9yYmlkZGVuJykpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gRXJyb3JDb2RlLkZPUkJJRERFTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1zZy5pbmNsdWRlcygndW5hdXRob3JpemVkJykgfHwgbXNnLmluY2x1ZGVzKCd1bmF1dGhlbnRpY2F0ZWQnKSB8fCBtc2cuaW5jbHVkZXMoJ3Rva2VuJykpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gRXJyb3JDb2RlLlVOQVVUSE9SSVpFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1zZy5pbmNsdWRlcygnaW52YWxpZCcpIHx8IG1zZy5pbmNsdWRlcygncmVxdWlyZWQnKSB8fCBtc2cuaW5jbHVkZXMoJ21pc3NpbmcnKSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBFcnJvckNvZGUuQkFEX1JFUVVFU1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgc3RhY2s6IGVycm9yPy5zdGFjayxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IE1DUEVycm9ySGFuZGxlcjtcbiIsImV4cG9ydCAqIGZyb20gJy4vRXJyb3JIYW5kbGVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTUNQRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi9FcnJvckhhbmRsZXInO1xuIiwiLy8gTWFpbiBFbGVjdHJvbiBwcm9jZXNzIGZvciBFbnRyYVB1bHNlIExpdGVcbmltcG9ydCB7IGFwcCwgQnJvd3NlcldpbmRvdywgaXBjTWFpbiwgTWVudSB9IGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBBdXRoU2VydmljZSB9IGZyb20gJy4uL2F1dGgvQXV0aFNlcnZpY2UnO1xuaW1wb3J0IHsgR3JhcGhTZXJ2aWNlIH0gZnJvbSAnLi4vc2hhcmVkL0dyYXBoU2VydmljZSc7XG5pbXBvcnQgeyBMTE1TZXJ2aWNlIH0gZnJvbSAnLi4vbGxtL0xMTVNlcnZpY2UnO1xuaW1wb3J0IHsgTUNQQ2xpZW50IH0gZnJvbSAnLi4vbWNwL2NsaWVudHMvTUNQU0RLQ2xpZW50JztcbmltcG9ydCB7IE1DUEF1dGhTZXJ2aWNlIH0gZnJvbSAnLi4vbWNwL2F1dGgvTUNQQXV0aFNlcnZpY2UnO1xuaW1wb3J0IHsgTUNQRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vbWNwL3V0aWxzJztcbi8vIFNldCBhcHAgSUQgZm9yIFdpbmRvd3MgdGFza2JhciBpbnRlZ3JhdGlvblxuaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBhcHAuc2V0QXBwVXNlck1vZGVsSWQoJ2NvbS5pbmNyZW1lbnQuZW50cmFwdWxzZWxpdGUnKTtcbn1cbi8vIExvYWQgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5yZXF1aXJlKCdkb3RlbnYnKS5jb25maWcoKTtcbmNsYXNzIEVudHJhUHVsc2VMaXRlQXBwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYWluV2luZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU2VydmljZXMoKTtcbiAgICAgICAgdGhpcy5zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVNlcnZpY2VzKCkge1xuICAgICAgICAvLyBJbml0aWFsaXplIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHByb2Nlc3MuZW52Lk1TQUxfQ0xJRU5UX0lEICYmIHByb2Nlc3MuZW52Lk1TQUxfQ0xJRU5UX0lELnRyaW0oKSAhPT0gJydcbiAgICAgICAgICAgICAgICAgICAgPyBwcm9jZXNzLmVudi5NU0FMX0NMSUVOVF9JRFxuICAgICAgICAgICAgICAgICAgICA6ICcxNGQ4MmVlYy0yMDRiLTRjMmYtYjdlOC0yOTZhNzBkYWI2N2UnLCAvLyBNaWNyb3NvZnQgR3JhcGggUG93ZXJTaGVsbCBmYWxsYmFja1xuICAgICAgICAgICAgICAgIHRlbmFudElkOiBwcm9jZXNzLmVudi5NU0FMX1RFTkFOVF9JRCAmJiBwcm9jZXNzLmVudi5NU0FMX1RFTkFOVF9JRC50cmltKCkgIT09ICcnXG4gICAgICAgICAgICAgICAgICAgID8gcHJvY2Vzcy5lbnYuTVNBTF9URU5BTlRfSURcbiAgICAgICAgICAgICAgICAgICAgOiAnY29tbW9uJyxcbiAgICAgICAgICAgICAgICBzY29wZXM6IFsnVXNlci5SZWFkJywgJ1VzZXIuUmVhZEJhc2ljLkFsbCcsICdEaXJlY3RvcnkuUmVhZC5BbGwnLCAnR3JvdXAuUmVhZC5BbGwnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsbG06IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogcHJvY2Vzcy5lbnYuTExNX1BST1ZJREVSIHx8ICdvbGxhbWEnLFxuICAgICAgICAgICAgICAgIGJhc2VVcmw6IHByb2Nlc3MuZW52LkxMTV9QUk9WSURFUiA9PT0gJ2xtc3R1ZGlvJ1xuICAgICAgICAgICAgICAgICAgICA/IHByb2Nlc3MuZW52LkxNU1RVRElPX0JBU0VfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjEyMzQnXG4gICAgICAgICAgICAgICAgICAgIDogcHJvY2Vzcy5lbnYuT0xMQU1BX0JBU0VfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjExNDM0JyxcbiAgICAgICAgICAgICAgICBtb2RlbDogJ2xsYW1hMicsIC8vIERlZmF1bHQgbW9kZWxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtY3BTZXJ2ZXJzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbG9ra2EnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbG9ra2EnLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBwYXJzZUludChwcm9jZXNzLmVudi5NQ1BfTE9LS0FfUE9SVCB8fCAnMzAwMScpLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBwYXJzZUludChwcm9jZXNzLmVudi5NQ1BfRE9DU19QT1JUIHx8ICczMDAyJyksXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBmZWF0dXJlczoge1xuICAgICAgICAgICAgICAgIGVuYWJsZVByZW1pdW1GZWF0dXJlczogcHJvY2Vzcy5lbnYuRU5BQkxFX1BSRU1JVU1fRkVBVFVSRVMgPT09ICd0cnVlJyxcbiAgICAgICAgICAgICAgICBlbmFibGVUZWxlbWV0cnk6IHByb2Nlc3MuZW52LkVOQUJMRV9URUxFTUVUUlkgPT09ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07IC8vIFVwZGF0ZSBNQ1Agc2VydmVyIGNvbmZpZ3Mgd2l0aCBhdXRoIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgdGhpcy5jb25maWcubWNwU2VydmVycy5mb3JFYWNoKHNlcnZlciA9PiB7XG4gICAgICAgICAgICBpZiAoc2VydmVyLnR5cGUgPT09ICdsb2trYScpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYXV0aGVudGljYXRpb24gY29uZmlnIGZvciBHcmFwaCBBUElcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuYXV0aENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21zYWwnLFxuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IHRoaXMuY29uZmlnLmF1dGguc2NvcGVzLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuYXV0aC5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdGVuYW50SWQ6IHRoaXMuY29uZmlnLmF1dGgudGVuYW50SWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzZXJ2aWNlc1xuICAgICAgICB0aGlzLmF1dGhTZXJ2aWNlID0gbmV3IEF1dGhTZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhTZXJ2aWNlID0gbmV3IEdyYXBoU2VydmljZSh0aGlzLmF1dGhTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5sbG1TZXJ2aWNlID0gbmV3IExMTVNlcnZpY2UodGhpcy5jb25maWcubGxtKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBNQ1Agc2VydmljZXNcbiAgICAgICAgY29uc3QgbWNwQXV0aFNlcnZpY2UgPSBuZXcgTUNQQXV0aFNlcnZpY2UodGhpcy5hdXRoU2VydmljZSk7XG4gICAgICAgIHRoaXMubWNwQ2xpZW50ID0gbmV3IE1DUENsaWVudCh0aGlzLmNvbmZpZy5tY3BTZXJ2ZXJzLCBtY3BBdXRoU2VydmljZSk7XG4gICAgfVxuICAgIHNldHVwRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgLy8gU2V0IGFwcGxpY2F0aW9uIElEIGZvciBXaW5kb3dzIHRhc2tiYXJcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIGFwcC5zZXRBcHBVc2VyTW9kZWxJZCgnY29tLmluY3JlbWVudC5lbnRyYXB1bHNlbGl0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGFwcC53aGVuUmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlV2luZG93KCk7XG4gICAgICAgICAgICB0aGlzLnNldHVwTWVudSgpO1xuICAgICAgICAgICAgdGhpcy5zZXR1cElwY0hhbmRsZXJzKCk7XG4gICAgICAgICAgICBhcHAub24oJ2FjdGl2YXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlV2luZG93KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcC5vbignd2luZG93LWFsbC1jbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2RhcndpbicpXG4gICAgICAgICAgICAgICAgYXBwLnF1aXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVdpbmRvdygpIHtcbiAgICAgICAgdGhpcy5tYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coeyB3aWR0aDogMTI4MCxcbiAgICAgICAgICAgIGhlaWdodDogOTAwLFxuICAgICAgICAgICAgbWluV2lkdGg6IDkwMCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogNzAwLFxuICAgICAgICAgICAgaWNvbjogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICAgICAgICAgICAgICAgID8gcGF0aC5yZXNvbHZlKGFwcC5nZXRBcHBQYXRoKCksICdhc3NldHMnLCAnaWNvbi5pY28nKVxuICAgICAgICAgICAgICAgIDogcGF0aC5yZXNvbHZlKGFwcC5nZXRBcHBQYXRoKCksICdhc3NldHMnLCAnRW50cmFQdWxzZUxpdGVMb2dvLnBuZycpLFxuICAgICAgICAgICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgICAgICAgICAgICBub2RlSW50ZWdyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHRJc29sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgcHJlbG9hZDogcGF0aC5qb2luKF9fZGlybmFtZSwgJ3ByZWxvYWQuanMnKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aXRsZUJhclN0eWxlOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICBzaG93OiBmYWxzZSwgLy8gRG9uJ3Qgc2hvdyB1bnRpbCByZWFkeVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTG9hZCB0aGUgaW5kZXguaHRtbCBmcm9tIHRoZSBkaXN0IGRpcmVjdG9yeVxuICAgICAgICB0aGlzLm1haW5XaW5kb3cubG9hZEZpbGUocGF0aC5qb2luKF9fZGlybmFtZSwgJ2luZGV4Lmh0bWwnKSk7XG4gICAgICAgIC8vIFNob3cgd2luZG93IHdoZW4gcmVhZHlcbiAgICAgICAgdGhpcy5tYWluV2luZG93Lm9uY2UoJ3JlYWR5LXRvLXNob3cnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1haW5XaW5kb3c/LnNob3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9wZW4gRGV2VG9vbHMgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICB0aGlzLm1haW5XaW5kb3cud2ViQ29udGVudHMub3BlbkRldlRvb2xzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0dXBNZW51KCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0ZpbGUnLFxuICAgICAgICAgICAgICAgIHN1Ym1lbnU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdTZXR0aW5ncycsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlbGVyYXRvcjogJ0NtZE9yQ3RybCssJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiBzZXR0aW5ncyB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdRdWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VsZXJhdG9yOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJyA/ICdDbWQrUScgOiAnQ3RybCtRJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLnF1aXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFZGl0JyxcbiAgICAgICAgICAgICAgICBzdWJtZW51OiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcm9sZTogJ3VuZG8nIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcm9sZTogJ3JlZG8nIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcbiAgICAgICAgICAgICAgICAgICAgeyByb2xlOiAnY3V0JyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHJvbGU6ICdjb3B5JyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHJvbGU6ICdwYXN0ZScgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1ZpZXcnLFxuICAgICAgICAgICAgICAgIHN1Ym1lbnU6IFtcbiAgICAgICAgICAgICAgICAgICAgeyByb2xlOiAncmVsb2FkJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHJvbGU6ICdmb3JjZVJlbG9hZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgeyByb2xlOiAndG9nZ2xlRGV2VG9vbHMnIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcbiAgICAgICAgICAgICAgICAgICAgeyByb2xlOiAncmVzZXRab29tJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHJvbGU6ICd6b29tSW4nIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcm9sZTogJ3pvb21PdXQnIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NlcGFyYXRvcicgfSxcbiAgICAgICAgICAgICAgICAgICAgeyByb2xlOiAndG9nZ2xlZnVsbHNjcmVlbicgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0hlbHAnLFxuICAgICAgICAgICAgICAgIHN1Ym1lbnU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdBYm91dCBFbnRyYVB1bHNlIExpdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGFib3V0IGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbWVudSA9IE1lbnUuYnVpbGRGcm9tVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICBNZW51LnNldEFwcGxpY2F0aW9uTWVudShtZW51KTtcbiAgICB9XG4gICAgc2V0dXBJcGNIYW5kbGVycygpIHtcbiAgICAgICAgLy8gQXNzZXQgcGF0aCBoYW5kbGVyXG4gICAgICAgIGlwY01haW4uaGFuZGxlKCdhcHA6Z2V0QXNzZXRQYXRoJywgKGV2ZW50LCBhc3NldE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0UGF0aCA9IHBhdGguam9pbihhcHAuZ2V0QXBwUGF0aCgpLCAnYXNzZXRzJywgYXNzZXROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhc3NldFBhdGg7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBdXRoZW50aWNhdGlvbiBoYW5kbGVyc1xuICAgICAgICBpcGNNYWluLmhhbmRsZSgnYXV0aDpsb2dpbicsIGFzeW5jIChfLCB1c2VSZWRpcmVjdEZsb3cgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hdXRoU2VydmljZS5sb2dpbih1c2VSZWRpcmVjdEZsb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlwY01haW4uaGFuZGxlKCdhdXRoOmxvZ291dCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoU2VydmljZS5sb2dvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ291dCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXBjTWFpbi5oYW5kbGUoJ2F1dGg6Z2V0VG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmF1dGhTZXJ2aWNlLmdldFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHZXQgdG9rZW4gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlwY01haW4uaGFuZGxlKCdhdXRoOmdldEN1cnJlbnRVc2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hdXRoU2VydmljZS5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignR2V0IGN1cnJlbnQgdXNlciBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgcGVybWlzc2lvbiBoYW5kbGVyc1xuICAgICAgICBpcGNNYWluLmhhbmRsZSgnYXV0aDpyZXF1ZXN0UGVybWlzc2lvbnMnLCBhc3luYyAoZXZlbnQsIHBlcm1pc3Npb25zKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmF1dGhTZXJ2aWNlLnJlcXVlc3RBZGRpdGlvbmFsUGVybWlzc2lvbnMocGVybWlzc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmVxdWVzdCBwZXJtaXNzaW9ucyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXBjTWFpbi5oYW5kbGUoJ2F1dGg6Z2V0VG9rZW5XaXRoUGVybWlzc2lvbnMnLCBhc3luYyAoZXZlbnQsIHBlcm1pc3Npb25zKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmF1dGhTZXJ2aWNlLmdldFRva2VuV2l0aFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dldCB0b2tlbiB3aXRoIHBlcm1pc3Npb25zIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBNaWNyb3NvZnQgR3JhcGggaGFuZGxlcnNcbiAgICAgICAgaXBjTWFpbi5oYW5kbGUoJ2dyYXBoOnF1ZXJ5JywgYXN5bmMgKGV2ZW50LCBlbmRwb2ludCwgbWV0aG9kLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdyYXBoU2VydmljZS5xdWVyeShlbmRwb2ludCwgbWV0aG9kLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dyYXBoIHF1ZXJ5IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpcGNNYWluLmhhbmRsZSgnZ3JhcGg6Z2V0VXNlclBob3RvJywgYXN5bmMgKGV2ZW50LCB1c2VySWQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ3JhcGhTZXJ2aWNlLmdldFVzZXJQaG90byh1c2VySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignR2V0IHVzZXIgcGhvdG8gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExMTSBoYW5kbGVyc1xuICAgICAgICBpcGNNYWluLmhhbmRsZSgnbGxtOmNoYXQnLCBhc3luYyAoZXZlbnQsIG1lc3NhZ2VzKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxsbVNlcnZpY2UuY2hhdChtZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMTE0gY2hhdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXBjTWFpbi5oYW5kbGUoJ2xsbTppc0F2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubGxtU2VydmljZS5pc0F2YWlsYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTExNIGF2YWlsYWJpbGl0eSBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIE1DUCBoYW5kbGVyc1xuICAgICAgICBpcGNNYWluLmhhbmRsZSgnbWNwOmNhbGwnLCBhc3luYyAoZXZlbnQsIHNlcnZlciwgdG9vbE5hbWUsIGFyZ3VtZW50c18pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubWNwQ2xpZW50LmNhbGxUb29sKHNlcnZlciwgdG9vbE5hbWUsIGFyZ3VtZW50c18pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWNwRXJyb3IgPSBNQ1BFcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IsIGBtY3A6Y2FsbCgke3NlcnZlcn0sICR7dG9vbE5hbWV9KWApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01DUCB0b29sIGNhbGwgZmFpbGVkOicsIG1jcEVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGVycm9yIGluIGEgY29uc2lzdGVudCBmb3JtYXQgdGhhdCB0aGUgcmVuZGVyZXIgY2FuIGhhbmRsZVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBtY3BFcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWNwRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlwY01haW4uaGFuZGxlKCdtY3A6bGlzdFNlcnZlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1jcENsaWVudC5nZXRBdmFpbGFibGVTZXJ2ZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtY3BFcnJvciA9IE1DUEVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvciwgJ21jcDpsaXN0U2VydmVycycpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01DUCBsaXN0IHNlcnZlcnMgZmFpbGVkOicsIG1jcEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpcGNNYWluLmhhbmRsZSgnbWNwOmxpc3RUb29scycsIGFzeW5jIChldmVudCwgc2VydmVyKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1jcENsaWVudC5saXN0VG9vbHMoc2VydmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1jcEVycm9yID0gTUNQRXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yLCBgbWNwOmxpc3RUb29scygke3NlcnZlcn0pYCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTUNQIGxpc3QgdG9vbHMgZm9yIHNlcnZlciAke3NlcnZlcn0gZmFpbGVkOmAsIG1jcEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb25maWd1cmF0aW9uIGhhbmRsZXJzXG4gICAgICAgIGlwY01haW4uaGFuZGxlKCdjb25maWc6Z2V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgICAgICB9KTtcbiAgICAgICAgaXBjTWFpbi5oYW5kbGUoJ2NvbmZpZzp1cGRhdGUnLCBhc3luYyAoZXZlbnQsIG5ld0NvbmZpZykgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLm5ld0NvbmZpZyB9O1xuICAgICAgICAgICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgc2F2ZSB0byBmaWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ29uZmlnIHVwZGF0ZSBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBDcmVhdGUgYW5kIHN0YXJ0IHRoZSBhcHBsaWNhdGlvblxubmV3IEVudHJhUHVsc2VMaXRlQXBwKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7140\n')},7176:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar callBind = __webpack_require__(3126);\nvar gOPD = __webpack_require__(5795);\n\nvar hasProtoAccessor;\ntry {\n\t// eslint-disable-next-line no-extra-parens, no-proto\n\thasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;\n} catch (e) {\n\tif (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {\n\t\tthrow e;\n\t}\n}\n\n// eslint-disable-next-line no-extra-parens\nvar desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));\n\nvar $Object = Object;\nvar $getPrototypeOf = $Object.getPrototypeOf;\n\n/** @type {import('./get')} */\nmodule.exports = desc && typeof desc.get === 'function'\n\t? callBind([desc.get])\n\t: typeof $getPrototypeOf === 'function'\n\t\t? /** @type {import('./get')} */ function getDunder(value) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn $getPrototypeOf(value == null ? value : $Object(value));\n\t\t}\n\t\t: false;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsSUFBeUI7QUFDaEQsV0FBVyxtQkFBTyxDQUFDLElBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkUsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFLCtCQUErQjs7QUFFMUc7QUFDQTs7QUFFQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2R1bmRlci1wcm90by9nZXQuanM/YzNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC1hcHBseS1oZWxwZXJzJyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxudmFyIGhhc1Byb3RvQWNjZXNzb3I7XG50cnkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zLCBuby1wcm90b1xuXHRoYXNQcm90b0FjY2Vzc29yID0gLyoqIEB0eXBlIHt7IF9fcHJvdG9fXz86IHR5cGVvZiBBcnJheS5wcm90b3R5cGUgfX0gKi8gKFtdKS5fX3Byb3RvX18gPT09IEFycmF5LnByb3RvdHlwZTtcbn0gY2F0Y2ggKGUpIHtcblx0aWYgKCFlIHx8IHR5cGVvZiBlICE9PSAnb2JqZWN0JyB8fCAhKCdjb2RlJyBpbiBlKSB8fCBlLmNvZGUgIT09ICdFUlJfUFJPVE9fQUNDRVNTJykge1xuXHRcdHRocm93IGU7XG5cdH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xudmFyIGRlc2MgPSAhIWhhc1Byb3RvQWNjZXNzb3IgJiYgZ09QRCAmJiBnT1BEKE9iamVjdC5wcm90b3R5cGUsIC8qKiBAdHlwZSB7a2V5b2YgdHlwZW9mIE9iamVjdC5wcm90b3R5cGV9ICovICgnX19wcm90b19fJykpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSAkT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9nZXQnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZGVzYyAmJiB0eXBlb2YgZGVzYy5nZXQgPT09ICdmdW5jdGlvbidcblx0PyBjYWxsQmluZChbZGVzYy5nZXRdKVxuXHQ6IHR5cGVvZiAkZ2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbidcblx0XHQ/IC8qKiBAdHlwZSB7aW1wb3J0KCcuL2dldCcpfSAqLyBmdW5jdGlvbiBnZXREdW5kZXIodmFsdWUpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdHJldHVybiAkZ2V0UHJvdG90eXBlT2YodmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogJE9iamVjdCh2YWx1ZSkpO1xuXHRcdH1cblx0XHQ6IGZhbHNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7176\n")},7260:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var jws = __webpack_require__(5747);\n\nmodule.exports = function (jwt, options) {\n  options = options || {};\n  var decoded = jws.decode(jwt, options);\n  if (!decoded) { return null; }\n  var payload = decoded.payload;\n\n  //try parse the payload\n  if(typeof payload === 'string') {\n    try {\n      var obj = JSON.parse(payload);\n      if(obj !== null && typeof obj === 'object') {\n        payload = obj;\n      }\n    } catch (e) { }\n  }\n\n  //return header if `complete` option is enabled.  header includes claims\n  //such as `kid` and `alg` used to select the key within a JWKS needed to\n  //verify the signature\n  if (options.complete === true) {\n    return {\n      header: decoded.header,\n      payload: payload,\n      signature: decoded.signature\n    };\n  }\n  return payload;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI2MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBSzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9kZWNvZGUuanM/Mzk3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgandzID0gcmVxdWlyZSgnandzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGp3dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGRlY29kZWQgPSBqd3MuZGVjb2RlKGp3dCwgb3B0aW9ucyk7XG4gIGlmICghZGVjb2RlZCkgeyByZXR1cm4gbnVsbDsgfVxuICB2YXIgcGF5bG9hZCA9IGRlY29kZWQucGF5bG9hZDtcblxuICAvL3RyeSBwYXJzZSB0aGUgcGF5bG9hZFxuICBpZih0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgICBpZihvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcGF5bG9hZCA9IG9iajtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxuXG4gIC8vcmV0dXJuIGhlYWRlciBpZiBgY29tcGxldGVgIG9wdGlvbiBpcyBlbmFibGVkLiAgaGVhZGVyIGluY2x1ZGVzIGNsYWltc1xuICAvL3N1Y2ggYXMgYGtpZGAgYW5kIGBhbGdgIHVzZWQgdG8gc2VsZWN0IHRoZSBrZXkgd2l0aGluIGEgSldLUyBuZWVkZWQgdG9cbiAgLy92ZXJpZnkgdGhlIHNpZ25hdHVyZVxuICBpZiAob3B0aW9ucy5jb21wbGV0ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXI6IGRlY29kZWQuaGVhZGVyLFxuICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgIHNpZ25hdHVyZTogZGVjb2RlZC5zaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXlsb2FkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7260\n")},7272:module=>{"use strict";eval("\n\nconst debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9kZWJ1Zy5qcz8wZDdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWJ1ZyA9IChcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MuZW52ICYmXG4gIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRylcbikgPyAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvcignU0VNVkVSJywgLi4uYXJncylcbiAgOiAoKSA9PiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7272\n")},7414:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst parse = __webpack_require__(144)\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQxNC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsR0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcz9hMDE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgY2xlYW4gPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7414\n")},7507:(module,__unused_webpack_exports,__webpack_require__)=>{eval('var debug;\n\nmodule.exports = function () {\n  if (!debug) {\n    try {\n      /* eslint global-require: off */\n      debug = __webpack_require__(5753)("follow-redirects");\n    }\n    catch (error) { /* */ }\n    if (typeof debug !== "function") {\n      debug = function () { /* */ };\n    }\n  }\n  debug.apply(null, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUwNy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFPO0FBQzdCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcz82NzVjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWJ1ZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghZGVidWcpIHtcbiAgICB0cnkge1xuICAgICAgLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiBvZmYgKi9cbiAgICAgIGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwiZm9sbG93LXJlZGlyZWN0c1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IC8qICovIH1cbiAgICBpZiAodHlwZW9mIGRlYnVnICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRlYnVnID0gZnVuY3Rpb24gKCkgeyAvKiAqLyB9O1xuICAgIH1cbiAgfVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7507\n')},7598:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = __webpack_require__(1813)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU5OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL21pbWUtZGIvaW5kZXguanM/YjRmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIG1pbWUtZGJcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogQ29weXJpZ2h0KGMpIDIwMTUtMjAyMiBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGIuanNvbicpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7598\n")},7599:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*global module*/\nvar Buffer = (__webpack_require__(2861).Buffer);\nvar DataStream = __webpack_require__(8948);\nvar jwa = __webpack_require__(8789);\nvar Stream = __webpack_require__(2203);\nvar toString = __webpack_require__(2851);\nvar util = __webpack_require__(9023);\nvar JWS_REGEX = /^[a-zA-Z0-9\\-_]+?\\.[a-zA-Z0-9\\-_]+?\\.([a-zA-Z0-9\\-_]+)?$/;\n\nfunction isObject(thing) {\n  return Object.prototype.toString.call(thing) === '[object Object]';\n}\n\nfunction safeJsonParse(thing) {\n  if (isObject(thing))\n    return thing;\n  try { return JSON.parse(thing); }\n  catch (e) { return undefined; }\n}\n\nfunction headerFromJWS(jwsSig) {\n  var encodedHeader = jwsSig.split('.', 1)[0];\n  return safeJsonParse(Buffer.from(encodedHeader, 'base64').toString('binary'));\n}\n\nfunction securedInputFromJWS(jwsSig) {\n  return jwsSig.split('.', 2).join('.');\n}\n\nfunction signatureFromJWS(jwsSig) {\n  return jwsSig.split('.')[2];\n}\n\nfunction payloadFromJWS(jwsSig, encoding) {\n  encoding = encoding || 'utf8';\n  var payload = jwsSig.split('.')[1];\n  return Buffer.from(payload, 'base64').toString(encoding);\n}\n\nfunction isValidJws(string) {\n  return JWS_REGEX.test(string) && !!headerFromJWS(string);\n}\n\nfunction jwsVerify(jwsSig, algorithm, secretOrKey) {\n  if (!algorithm) {\n    var err = new Error(\"Missing algorithm parameter for jws.verify\");\n    err.code = \"MISSING_ALGORITHM\";\n    throw err;\n  }\n  jwsSig = toString(jwsSig);\n  var signature = signatureFromJWS(jwsSig);\n  var securedInput = securedInputFromJWS(jwsSig);\n  var algo = jwa(algorithm);\n  return algo.verify(securedInput, signature, secretOrKey);\n}\n\nfunction jwsDecode(jwsSig, opts) {\n  opts = opts || {};\n  jwsSig = toString(jwsSig);\n\n  if (!isValidJws(jwsSig))\n    return null;\n\n  var header = headerFromJWS(jwsSig);\n\n  if (!header)\n    return null;\n\n  var payload = payloadFromJWS(jwsSig);\n  if (header.typ === 'JWT' || opts.json)\n    payload = JSON.parse(payload, opts.encoding);\n\n  return {\n    header: header,\n    payload: payload,\n    signature: signatureFromJWS(jwsSig)\n  };\n}\n\nfunction VerifyStream(opts) {\n  opts = opts || {};\n  var secretOrKey = opts.secret||opts.publicKey||opts.key;\n  var secretStream = new DataStream(secretOrKey);\n  this.readable = true;\n  this.algorithm = opts.algorithm;\n  this.encoding = opts.encoding;\n  this.secret = this.publicKey = this.key = secretStream;\n  this.signature = new DataStream(opts.signature);\n  this.secret.once('close', function () {\n    if (!this.signature.writable && this.readable)\n      this.verify();\n  }.bind(this));\n\n  this.signature.once('close', function () {\n    if (!this.secret.writable && this.readable)\n      this.verify();\n  }.bind(this));\n}\nutil.inherits(VerifyStream, Stream);\nVerifyStream.prototype.verify = function verify() {\n  try {\n    var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);\n    var obj = jwsDecode(this.signature.buffer, this.encoding);\n    this.emit('done', valid, obj);\n    this.emit('data', valid);\n    this.emit('end');\n    this.readable = false;\n    return valid;\n  } catch (e) {\n    this.readable = false;\n    this.emit('error', e);\n    this.emit('close');\n  }\n};\n\nVerifyStream.decode = jwsDecode;\nVerifyStream.isValid = isValidJws;\nVerifyStream.verify = jwsVerify;\n\nmodule.exports = VerifyStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU5OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsa0NBQTZCO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLElBQWU7QUFDeEMsVUFBVSxtQkFBTyxDQUFDLElBQUs7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLElBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLElBQVk7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLElBQU07QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9qd3MvbGliL3ZlcmlmeS1zdHJlYW0uanM/MTgyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBtb2R1bGUqL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIERhdGFTdHJlYW0gPSByZXF1aXJlKCcuL2RhdGEtc3RyZWFtJyk7XG52YXIgandhID0gcmVxdWlyZSgnandhJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3Rvc3RyaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBKV1NfUkVHRVggPSAvXlthLXpBLVowLTlcXC1fXSs/XFwuW2EtekEtWjAtOVxcLV9dKz9cXC4oW2EtekEtWjAtOVxcLV9dKyk/JC87XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpbmcpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gc2FmZUpzb25QYXJzZSh0aGluZykge1xuICBpZiAoaXNPYmplY3QodGhpbmcpKVxuICAgIHJldHVybiB0aGluZztcbiAgdHJ5IHsgcmV0dXJuIEpTT04ucGFyc2UodGhpbmcpOyB9XG4gIGNhdGNoIChlKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbn1cblxuZnVuY3Rpb24gaGVhZGVyRnJvbUpXUyhqd3NTaWcpIHtcbiAgdmFyIGVuY29kZWRIZWFkZXIgPSBqd3NTaWcuc3BsaXQoJy4nLCAxKVswXTtcbiAgcmV0dXJuIHNhZmVKc29uUGFyc2UoQnVmZmVyLmZyb20oZW5jb2RlZEhlYWRlciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKSk7XG59XG5cbmZ1bmN0aW9uIHNlY3VyZWRJbnB1dEZyb21KV1MoandzU2lnKSB7XG4gIHJldHVybiBqd3NTaWcuc3BsaXQoJy4nLCAyKS5qb2luKCcuJyk7XG59XG5cbmZ1bmN0aW9uIHNpZ25hdHVyZUZyb21KV1MoandzU2lnKSB7XG4gIHJldHVybiBqd3NTaWcuc3BsaXQoJy4nKVsyXTtcbn1cblxuZnVuY3Rpb24gcGF5bG9hZEZyb21KV1MoandzU2lnLCBlbmNvZGluZykge1xuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JztcbiAgdmFyIHBheWxvYWQgPSBqd3NTaWcuc3BsaXQoJy4nKVsxXTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBheWxvYWQsICdiYXNlNjQnKS50b1N0cmluZyhlbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRKd3Moc3RyaW5nKSB7XG4gIHJldHVybiBKV1NfUkVHRVgudGVzdChzdHJpbmcpICYmICEhaGVhZGVyRnJvbUpXUyhzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiBqd3NWZXJpZnkoandzU2lnLCBhbGdvcml0aG0sIHNlY3JldE9yS2V5KSB7XG4gIGlmICghYWxnb3JpdGhtKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIk1pc3NpbmcgYWxnb3JpdGhtIHBhcmFtZXRlciBmb3IgandzLnZlcmlmeVwiKTtcbiAgICBlcnIuY29kZSA9IFwiTUlTU0lOR19BTEdPUklUSE1cIjtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgandzU2lnID0gdG9TdHJpbmcoandzU2lnKTtcbiAgdmFyIHNpZ25hdHVyZSA9IHNpZ25hdHVyZUZyb21KV1MoandzU2lnKTtcbiAgdmFyIHNlY3VyZWRJbnB1dCA9IHNlY3VyZWRJbnB1dEZyb21KV1MoandzU2lnKTtcbiAgdmFyIGFsZ28gPSBqd2EoYWxnb3JpdGhtKTtcbiAgcmV0dXJuIGFsZ28udmVyaWZ5KHNlY3VyZWRJbnB1dCwgc2lnbmF0dXJlLCBzZWNyZXRPcktleSk7XG59XG5cbmZ1bmN0aW9uIGp3c0RlY29kZShqd3NTaWcsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGp3c1NpZyA9IHRvU3RyaW5nKGp3c1NpZyk7XG5cbiAgaWYgKCFpc1ZhbGlkSndzKGp3c1NpZykpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGhlYWRlciA9IGhlYWRlckZyb21KV1MoandzU2lnKTtcblxuICBpZiAoIWhlYWRlcilcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgcGF5bG9hZCA9IHBheWxvYWRGcm9tSldTKGp3c1NpZyk7XG4gIGlmIChoZWFkZXIudHlwID09PSAnSldUJyB8fCBvcHRzLmpzb24pXG4gICAgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZCwgb3B0cy5lbmNvZGluZyk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6IGhlYWRlcixcbiAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlRnJvbUpXUyhqd3NTaWcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIFZlcmlmeVN0cmVhbShvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgc2VjcmV0T3JLZXkgPSBvcHRzLnNlY3JldHx8b3B0cy5wdWJsaWNLZXl8fG9wdHMua2V5O1xuICB2YXIgc2VjcmV0U3RyZWFtID0gbmV3IERhdGFTdHJlYW0oc2VjcmV0T3JLZXkpO1xuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5hbGdvcml0aG0gPSBvcHRzLmFsZ29yaXRobTtcbiAgdGhpcy5lbmNvZGluZyA9IG9wdHMuZW5jb2Rpbmc7XG4gIHRoaXMuc2VjcmV0ID0gdGhpcy5wdWJsaWNLZXkgPSB0aGlzLmtleSA9IHNlY3JldFN0cmVhbTtcbiAgdGhpcy5zaWduYXR1cmUgPSBuZXcgRGF0YVN0cmVhbShvcHRzLnNpZ25hdHVyZSk7XG4gIHRoaXMuc2VjcmV0Lm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5zaWduYXR1cmUud3JpdGFibGUgJiYgdGhpcy5yZWFkYWJsZSlcbiAgICAgIHRoaXMudmVyaWZ5KCk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5zaWduYXR1cmUub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnNlY3JldC53cml0YWJsZSAmJiB0aGlzLnJlYWRhYmxlKVxuICAgICAgdGhpcy52ZXJpZnkoKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn1cbnV0aWwuaW5oZXJpdHMoVmVyaWZ5U3RyZWFtLCBTdHJlYW0pO1xuVmVyaWZ5U3RyZWFtLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZhbGlkID0gandzVmVyaWZ5KHRoaXMuc2lnbmF0dXJlLmJ1ZmZlciwgdGhpcy5hbGdvcml0aG0sIHRoaXMua2V5LmJ1ZmZlcik7XG4gICAgdmFyIG9iaiA9IGp3c0RlY29kZSh0aGlzLnNpZ25hdHVyZS5idWZmZXIsIHRoaXMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW1pdCgnZG9uZScsIHZhbGlkLCBvYmopO1xuICAgIHRoaXMuZW1pdCgnZGF0YScsIHZhbGlkKTtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgfVxufTtcblxuVmVyaWZ5U3RyZWFtLmRlY29kZSA9IGp3c0RlY29kZTtcblZlcmlmeVN0cmVhbS5pc1ZhbGlkID0gaXNWYWxpZEp3cztcblZlcmlmeVN0cmVhbS52ZXJpZnkgPSBqd3NWZXJpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVyaWZ5U3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7599\n")},7631:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst Range = __webpack_require__(8311)\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYzMS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsSUFBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcz84ZjRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7631\n")},7638:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst Range = __webpack_require__(8311)\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYzOC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsSUFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3NhdGlzZmllcy5qcz8zMjljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7638\n")},7651:(module,__unused_webpack_exports,__webpack_require__)=>{eval("const timespan = __webpack_require__(855);\nconst PS_SUPPORTED = __webpack_require__(4977);\nconst validateAsymmetricKey = __webpack_require__(7019);\nconst jws = __webpack_require__(5747);\nconst includes = __webpack_require__(6111);\nconst isBoolean = __webpack_require__(7914);\nconst isInteger = __webpack_require__(8928);\nconst isNumber = __webpack_require__(3639);\nconst isPlainObject = __webpack_require__(9001);\nconst isString = __webpack_require__(5931);\nconst once = __webpack_require__(7083);\nconst { KeyObject, createSecretKey, createPrivateKey } = __webpack_require__(6982)\n\nconst SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];\nif (PS_SUPPORTED) {\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\n}\n\nconst sign_options_schema = {\n  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"expiresIn\" should be a number of seconds or string representing a timespan' },\n  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"notBefore\" should be a number of seconds or string representing a timespan' },\n  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '\"audience\" must be a string or array' },\n  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '\"algorithm\" must be a valid string enum value' },\n  header: { isValid: isPlainObject, message: '\"header\" must be an object' },\n  encoding: { isValid: isString, message: '\"encoding\" must be a string' },\n  issuer: { isValid: isString, message: '\"issuer\" must be a string' },\n  subject: { isValid: isString, message: '\"subject\" must be a string' },\n  jwtid: { isValid: isString, message: '\"jwtid\" must be a string' },\n  noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\n  keyid: { isValid: isString, message: '\"keyid\" must be a string' },\n  mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' },\n  allowInsecureKeySizes: { isValid: isBoolean, message: '\"allowInsecureKeySizes\" must be a boolean'},\n  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '\"allowInvalidAsymmetricKeyTypes\" must be a boolean'}\n};\n\nconst registered_claims_schema = {\n  iat: { isValid: isNumber, message: '\"iat\" should be a number of seconds' },\n  exp: { isValid: isNumber, message: '\"exp\" should be a number of seconds' },\n  nbf: { isValid: isNumber, message: '\"nbf\" should be a number of seconds' }\n};\n\nfunction validate(schema, allowUnknown, object, parameterName) {\n  if (!isPlainObject(object)) {\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\n  }\n  Object.keys(object)\n    .forEach(function(key) {\n      const validator = schema[key];\n      if (!validator) {\n        if (!allowUnknown) {\n          throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\n        }\n        return;\n      }\n      if (!validator.isValid(object[key])) {\n        throw new Error(validator.message);\n      }\n    });\n}\n\nfunction validateOptions(options) {\n  return validate(sign_options_schema, false, options, 'options');\n}\n\nfunction validatePayload(payload) {\n  return validate(registered_claims_schema, true, payload, 'payload');\n}\n\nconst options_to_payload = {\n  'audience': 'aud',\n  'issuer': 'iss',\n  'subject': 'sub',\n  'jwtid': 'jti'\n};\n\nconst options_for_objects = [\n  'expiresIn',\n  'notBefore',\n  'noTimestamp',\n  'audience',\n  'issuer',\n  'subject',\n  'jwtid',\n];\n\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else {\n    options = options || {};\n  }\n\n  const isObjectPayload = typeof payload === 'object' &&\n                        !Buffer.isBuffer(payload);\n\n  const header = Object.assign({\n    alg: options.algorithm || 'HS256',\n    typ: isObjectPayload ? 'JWT' : undefined,\n    kid: options.keyid\n  }, options.header);\n\n  function failure(err) {\n    if (callback) {\n      return callback(err);\n    }\n    throw err;\n  }\n\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\n    return failure(new Error('secretOrPrivateKey must have a value'));\n  }\n\n  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {\n    try {\n      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey)\n    } catch (_) {\n      try {\n        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey)\n      } catch (_) {\n        return failure(new Error('secretOrPrivateKey is not valid key material'));\n      }\n    }\n  }\n\n  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {\n    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)))\n  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {\n    if (secretOrPrivateKey.type !== 'private') {\n      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)))\n    }\n    if (!options.allowInsecureKeySizes &&\n      !header.alg.startsWith('ES') &&\n      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+\n      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {\n      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));\n    }\n  }\n\n  if (typeof payload === 'undefined') {\n    return failure(new Error('payload is required'));\n  } else if (isObjectPayload) {\n    try {\n      validatePayload(payload);\n    }\n    catch (error) {\n      return failure(error);\n    }\n    if (!options.mutatePayload) {\n      payload = Object.assign({},payload);\n    }\n  } else {\n    const invalid_options = options_for_objects.filter(function (opt) {\n      return typeof options[opt] !== 'undefined';\n    });\n\n    if (invalid_options.length > 0) {\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));\n    }\n  }\n\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\n  }\n\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\n  }\n\n  try {\n    validateOptions(options);\n  }\n  catch (error) {\n    return failure(error);\n  }\n\n  if (!options.allowInvalidAsymmetricKeyTypes) {\n    try {\n      validateAsymmetricKey(header.alg, secretOrPrivateKey);\n    } catch (error) {\n      return failure(error);\n    }\n  }\n\n  const timestamp = payload.iat || Math.floor(Date.now() / 1000);\n\n  if (options.noTimestamp) {\n    delete payload.iat;\n  } else if (isObjectPayload) {\n    payload.iat = timestamp;\n  }\n\n  if (typeof options.notBefore !== 'undefined') {\n    try {\n      payload.nbf = timespan(options.notBefore, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.nbf === 'undefined') {\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\n    try {\n      payload.exp = timespan(options.expiresIn, timestamp);\n    }\n    catch (err) {\n      return failure(err);\n    }\n    if (typeof payload.exp === 'undefined') {\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\n    }\n  }\n\n  Object.keys(options_to_payload).forEach(function (key) {\n    const claim = options_to_payload[key];\n    if (typeof options[key] !== 'undefined') {\n      if (typeof payload[claim] !== 'undefined') {\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\n      }\n      payload[claim] = options[key];\n    }\n  });\n\n  const encoding = options.encoding || 'utf8';\n\n  if (typeof callback === 'function') {\n    callback = callback && once(callback);\n\n    jws.createSign({\n      header: header,\n      privateKey: secretOrPrivateKey,\n      payload: payload,\n      encoding: encoding\n    }).once('error', callback)\n      .once('done', function (signature) {\n        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`))\n        }\n        callback(null, signature);\n      });\n  } else {\n    let signature = jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});\n    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version\n    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {\n      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)\n    }\n    return signature\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxrR0FBa0csV0FBVztBQUM3RztBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSiw4QkFBOEIsaUZBQWlGO0FBQy9HO0FBQ0E7QUFDQSxvRkFBb0YsV0FBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9zaWduLmpzPzI1NjciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdGltZXNwYW4gPSByZXF1aXJlKCcuL2xpYi90aW1lc3BhbicpO1xuY29uc3QgUFNfU1VQUE9SVEVEID0gcmVxdWlyZSgnLi9saWIvcHNTdXBwb3J0ZWQnKTtcbmNvbnN0IHZhbGlkYXRlQXN5bW1ldHJpY0tleSA9IHJlcXVpcmUoJy4vbGliL3ZhbGlkYXRlQXN5bW1ldHJpY0tleScpO1xuY29uc3QgandzID0gcmVxdWlyZSgnandzJyk7XG5jb25zdCBpbmNsdWRlcyA9IHJlcXVpcmUoJ2xvZGFzaC5pbmNsdWRlcycpO1xuY29uc3QgaXNCb29sZWFuID0gcmVxdWlyZSgnbG9kYXNoLmlzYm9vbGVhbicpO1xuY29uc3QgaXNJbnRlZ2VyID0gcmVxdWlyZSgnbG9kYXNoLmlzaW50ZWdlcicpO1xuY29uc3QgaXNOdW1iZXIgPSByZXF1aXJlKCdsb2Rhc2guaXNudW1iZXInKTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2guaXNwbGFpbm9iamVjdCcpO1xuY29uc3QgaXNTdHJpbmcgPSByZXF1aXJlKCdsb2Rhc2guaXNzdHJpbmcnKTtcbmNvbnN0IG9uY2UgPSByZXF1aXJlKCdsb2Rhc2gub25jZScpO1xuY29uc3QgeyBLZXlPYmplY3QsIGNyZWF0ZVNlY3JldEtleSwgY3JlYXRlUHJpdmF0ZUtleSB9ID0gcmVxdWlyZSgnY3J5cHRvJylcblxuY29uc3QgU1VQUE9SVEVEX0FMR1MgPSBbJ1JTMjU2JywgJ1JTMzg0JywgJ1JTNTEyJywgJ0VTMjU2JywgJ0VTMzg0JywgJ0VTNTEyJywgJ0hTMjU2JywgJ0hTMzg0JywgJ0hTNTEyJywgJ25vbmUnXTtcbmlmIChQU19TVVBQT1JURUQpIHtcbiAgU1VQUE9SVEVEX0FMR1Muc3BsaWNlKDMsIDAsICdQUzI1NicsICdQUzM4NCcsICdQUzUxMicpO1xufVxuXG5jb25zdCBzaWduX29wdGlvbnNfc2NoZW1hID0ge1xuICBleHBpcmVzSW46IHsgaXNWYWxpZDogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgfHwgKGlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSk7IH0sIG1lc3NhZ2U6ICdcImV4cGlyZXNJblwiIHNob3VsZCBiZSBhIG51bWJlciBvZiBzZWNvbmRzIG9yIHN0cmluZyByZXByZXNlbnRpbmcgYSB0aW1lc3BhbicgfSxcbiAgbm90QmVmb3JlOiB7IGlzVmFsaWQ6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBpc0ludGVnZXIodmFsdWUpIHx8IChpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUpOyB9LCBtZXNzYWdlOiAnXCJub3RCZWZvcmVcIiBzaG91bGQgYmUgYSBudW1iZXIgb2Ygc2Vjb25kcyBvciBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdGltZXNwYW4nIH0sXG4gIGF1ZGllbmNlOiB7IGlzVmFsaWQ6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBpc1N0cmluZyh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSk7IH0sIG1lc3NhZ2U6ICdcImF1ZGllbmNlXCIgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheScgfSxcbiAgYWxnb3JpdGhtOiB7IGlzVmFsaWQ6IGluY2x1ZGVzLmJpbmQobnVsbCwgU1VQUE9SVEVEX0FMR1MpLCBtZXNzYWdlOiAnXCJhbGdvcml0aG1cIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVudW0gdmFsdWUnIH0sXG4gIGhlYWRlcjogeyBpc1ZhbGlkOiBpc1BsYWluT2JqZWN0LCBtZXNzYWdlOiAnXCJoZWFkZXJcIiBtdXN0IGJlIGFuIG9iamVjdCcgfSxcbiAgZW5jb2Rpbmc6IHsgaXNWYWxpZDogaXNTdHJpbmcsIG1lc3NhZ2U6ICdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHN0cmluZycgfSxcbiAgaXNzdWVyOiB7IGlzVmFsaWQ6IGlzU3RyaW5nLCBtZXNzYWdlOiAnXCJpc3N1ZXJcIiBtdXN0IGJlIGEgc3RyaW5nJyB9LFxuICBzdWJqZWN0OiB7IGlzVmFsaWQ6IGlzU3RyaW5nLCBtZXNzYWdlOiAnXCJzdWJqZWN0XCIgbXVzdCBiZSBhIHN0cmluZycgfSxcbiAgand0aWQ6IHsgaXNWYWxpZDogaXNTdHJpbmcsIG1lc3NhZ2U6ICdcImp3dGlkXCIgbXVzdCBiZSBhIHN0cmluZycgfSxcbiAgbm9UaW1lc3RhbXA6IHsgaXNWYWxpZDogaXNCb29sZWFuLCBtZXNzYWdlOiAnXCJub1RpbWVzdGFtcFwiIG11c3QgYmUgYSBib29sZWFuJyB9LFxuICBrZXlpZDogeyBpc1ZhbGlkOiBpc1N0cmluZywgbWVzc2FnZTogJ1wia2V5aWRcIiBtdXN0IGJlIGEgc3RyaW5nJyB9LFxuICBtdXRhdGVQYXlsb2FkOiB7IGlzVmFsaWQ6IGlzQm9vbGVhbiwgbWVzc2FnZTogJ1wibXV0YXRlUGF5bG9hZFwiIG11c3QgYmUgYSBib29sZWFuJyB9LFxuICBhbGxvd0luc2VjdXJlS2V5U2l6ZXM6IHsgaXNWYWxpZDogaXNCb29sZWFuLCBtZXNzYWdlOiAnXCJhbGxvd0luc2VjdXJlS2V5U2l6ZXNcIiBtdXN0IGJlIGEgYm9vbGVhbid9LFxuICBhbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXM6IHsgaXNWYWxpZDogaXNCb29sZWFuLCBtZXNzYWdlOiAnXCJhbGxvd0ludmFsaWRBc3ltbWV0cmljS2V5VHlwZXNcIiBtdXN0IGJlIGEgYm9vbGVhbid9XG59O1xuXG5jb25zdCByZWdpc3RlcmVkX2NsYWltc19zY2hlbWEgPSB7XG4gIGlhdDogeyBpc1ZhbGlkOiBpc051bWJlciwgbWVzc2FnZTogJ1wiaWF0XCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMnIH0sXG4gIGV4cDogeyBpc1ZhbGlkOiBpc051bWJlciwgbWVzc2FnZTogJ1wiZXhwXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMnIH0sXG4gIG5iZjogeyBpc1ZhbGlkOiBpc051bWJlciwgbWVzc2FnZTogJ1wibmJmXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMnIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHNjaGVtYSwgYWxsb3dVbmtub3duLCBvYmplY3QsIHBhcmFtZXRlck5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHBhcmFtZXRlck5hbWUgKyAnXCIgdG8gYmUgYSBwbGFpbiBvYmplY3QuJyk7XG4gIH1cbiAgT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoIXZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIWFsbG93VW5rbm93bikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsga2V5ICsgJ1wiIGlzIG5vdCBhbGxvd2VkIGluIFwiJyArIHBhcmFtZXRlck5hbWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkYXRvci5pc1ZhbGlkKG9iamVjdFtrZXldKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdG9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gdmFsaWRhdGUoc2lnbl9vcHRpb25zX3NjaGVtYSwgZmFsc2UsIG9wdGlvbnMsICdvcHRpb25zJyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gIHJldHVybiB2YWxpZGF0ZShyZWdpc3RlcmVkX2NsYWltc19zY2hlbWEsIHRydWUsIHBheWxvYWQsICdwYXlsb2FkJyk7XG59XG5cbmNvbnN0IG9wdGlvbnNfdG9fcGF5bG9hZCA9IHtcbiAgJ2F1ZGllbmNlJzogJ2F1ZCcsXG4gICdpc3N1ZXInOiAnaXNzJyxcbiAgJ3N1YmplY3QnOiAnc3ViJyxcbiAgJ2p3dGlkJzogJ2p0aSdcbn07XG5cbmNvbnN0IG9wdGlvbnNfZm9yX29iamVjdHMgPSBbXG4gICdleHBpcmVzSW4nLFxuICAnbm90QmVmb3JlJyxcbiAgJ25vVGltZXN0YW1wJyxcbiAgJ2F1ZGllbmNlJyxcbiAgJ2lzc3VlcicsXG4gICdzdWJqZWN0JyxcbiAgJ2p3dGlkJyxcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBheWxvYWQsIHNlY3JldE9yUHJpdmF0ZUtleSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuXG4gIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKTtcblxuICBjb25zdCBoZWFkZXIgPSBPYmplY3QuYXNzaWduKHtcbiAgICBhbGc6IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdIUzI1NicsXG4gICAgdHlwOiBpc09iamVjdFBheWxvYWQgPyAnSldUJyA6IHVuZGVmaW5lZCxcbiAgICBraWQ6IG9wdGlvbnMua2V5aWRcbiAgfSwgb3B0aW9ucy5oZWFkZXIpO1xuXG4gIGZ1bmN0aW9uIGZhaWx1cmUoZXJyKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgaWYgKCFzZWNyZXRPclByaXZhdGVLZXkgJiYgb3B0aW9ucy5hbGdvcml0aG0gIT09ICdub25lJykge1xuICAgIHJldHVybiBmYWlsdXJlKG5ldyBFcnJvcignc2VjcmV0T3JQcml2YXRlS2V5IG11c3QgaGF2ZSBhIHZhbHVlJykpO1xuICB9XG5cbiAgaWYgKHNlY3JldE9yUHJpdmF0ZUtleSAhPSBudWxsICYmICEoc2VjcmV0T3JQcml2YXRlS2V5IGluc3RhbmNlb2YgS2V5T2JqZWN0KSkge1xuICAgIHRyeSB7XG4gICAgICBzZWNyZXRPclByaXZhdGVLZXkgPSBjcmVhdGVQcml2YXRlS2V5KHNlY3JldE9yUHJpdmF0ZUtleSlcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWNyZXRPclByaXZhdGVLZXkgPSBjcmVhdGVTZWNyZXRLZXkodHlwZW9mIHNlY3JldE9yUHJpdmF0ZUtleSA9PT0gJ3N0cmluZycgPyBCdWZmZXIuZnJvbShzZWNyZXRPclByaXZhdGVLZXkpIDogc2VjcmV0T3JQcml2YXRlS2V5KVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoJ3NlY3JldE9yUHJpdmF0ZUtleSBpcyBub3QgdmFsaWQga2V5IG1hdGVyaWFsJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoZWFkZXIuYWxnLnN0YXJ0c1dpdGgoJ0hTJykgJiYgc2VjcmV0T3JQcml2YXRlS2V5LnR5cGUgIT09ICdzZWNyZXQnKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKChgc2VjcmV0T3JQcml2YXRlS2V5IG11c3QgYmUgYSBzeW1tZXRyaWMga2V5IHdoZW4gdXNpbmcgJHtoZWFkZXIuYWxnfWApKSlcbiAgfSBlbHNlIGlmICgvXig/OlJTfFBTfEVTKS8udGVzdChoZWFkZXIuYWxnKSkge1xuICAgIGlmIChzZWNyZXRPclByaXZhdGVLZXkudHlwZSAhPT0gJ3ByaXZhdGUnKSB7XG4gICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoKGBzZWNyZXRPclByaXZhdGVLZXkgbXVzdCBiZSBhbiBhc3ltbWV0cmljIGtleSB3aGVuIHVzaW5nICR7aGVhZGVyLmFsZ31gKSkpXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd0luc2VjdXJlS2V5U2l6ZXMgJiZcbiAgICAgICFoZWFkZXIuYWxnLnN0YXJ0c1dpdGgoJ0VTJykgJiZcbiAgICAgIHNlY3JldE9yUHJpdmF0ZUtleS5hc3ltbWV0cmljS2V5RGV0YWlscyAhPT0gdW5kZWZpbmVkICYmIC8vS2V5T2JqZWN0LmFzeW1tZXRyaWNLZXlEZXRhaWxzIGlzIHN1cHBvcnRlZCBpbiBOb2RlIDE1K1xuICAgICAgc2VjcmV0T3JQcml2YXRlS2V5LmFzeW1tZXRyaWNLZXlEZXRhaWxzLm1vZHVsdXNMZW5ndGggPCAyMDQ4KSB7XG4gICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoYHNlY3JldE9yUHJpdmF0ZUtleSBoYXMgYSBtaW5pbXVtIGtleSBzaXplIG9mIDIwNDggYml0cyBmb3IgJHtoZWFkZXIuYWxnfWApKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKCdwYXlsb2FkIGlzIHJlcXVpcmVkJykpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMubXV0YXRlUGF5bG9hZCkge1xuICAgICAgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30scGF5bG9hZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGludmFsaWRfb3B0aW9ucyA9IG9wdGlvbnNfZm9yX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9uc1tvcHRdICE9PSAndW5kZWZpbmVkJztcbiAgICB9KTtcblxuICAgIGlmIChpbnZhbGlkX29wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKCdpbnZhbGlkICcgKyBpbnZhbGlkX29wdGlvbnMuam9pbignLCcpICsgJyBvcHRpb24gZm9yICcgKyAodHlwZW9mIHBheWxvYWQgKSArICcgcGF5bG9hZCcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQuZXhwICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0aW9ucy5leHBpcmVzSW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUobmV3IEVycm9yKCdCYWQgXCJvcHRpb25zLmV4cGlyZXNJblwiIG9wdGlvbiB0aGUgcGF5bG9hZCBhbHJlYWR5IGhhcyBhbiBcImV4cFwiIHByb3BlcnR5LicpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZC5uYmYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRpb25zLm5vdEJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoJ0JhZCBcIm9wdGlvbnMubm90QmVmb3JlXCIgb3B0aW9uIHRoZSBwYXlsb2FkIGFscmVhZHkgaGFzIGFuIFwibmJmXCIgcHJvcGVydHkuJykpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhaWx1cmUoZXJyb3IpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLmFsbG93SW52YWxpZEFzeW1tZXRyaWNLZXlUeXBlcykge1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0ZUFzeW1tZXRyaWNLZXkoaGVhZGVyLmFsZywgc2VjcmV0T3JQcml2YXRlS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IHBheWxvYWQuaWF0IHx8IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gIGlmIChvcHRpb25zLm5vVGltZXN0YW1wKSB7XG4gICAgZGVsZXRlIHBheWxvYWQuaWF0O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0UGF5bG9hZCkge1xuICAgIHBheWxvYWQuaWF0ID0gdGltZXN0YW1wO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm5vdEJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgcGF5bG9hZC5uYmYgPSB0aW1lc3BhbihvcHRpb25zLm5vdEJlZm9yZSwgdGltZXN0YW1wKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoZXJyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLm5iZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWlsdXJlKG5ldyBFcnJvcignXCJub3RCZWZvcmVcIiBzaG91bGQgYmUgYSBudW1iZXIgb2Ygc2Vjb25kcyBvciBzdHJpbmcgcmVwcmVzZW50aW5nIGEgdGltZXNwYW4gZWc6IFwiMWRcIiwgXCIyMGhcIiwgNjAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXNJbiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQuZXhwID0gdGltZXNwYW4ob3B0aW9ucy5leHBpcmVzSW4sIHRpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWlsdXJlKGVycik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF5bG9hZC5leHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFpbHVyZShuZXcgRXJyb3IoJ1wiZXhwaXJlc0luXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG9mIHNlY29uZHMgb3Igc3RyaW5nIHJlcHJlc2VudGluZyBhIHRpbWVzcGFuIGVnOiBcIjFkXCIsIFwiMjBoXCIsIDYwJykpO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnNfdG9fcGF5bG9hZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29uc3QgY2xhaW0gPSBvcHRpb25zX3RvX3BheWxvYWRba2V5XTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZFtjbGFpbV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWlsdXJlKG5ldyBFcnJvcignQmFkIFwib3B0aW9ucy4nICsga2V5ICsgJ1wiIG9wdGlvbi4gVGhlIHBheWxvYWQgYWxyZWFkeSBoYXMgYW4gXCInICsgY2xhaW0gKyAnXCIgcHJvcGVydHkuJykpO1xuICAgICAgfVxuICAgICAgcGF5bG9hZFtjbGFpbV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIG9uY2UoY2FsbGJhY2spO1xuXG4gICAgandzLmNyZWF0ZVNpZ24oe1xuICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICBwcml2YXRlS2V5OiBzZWNyZXRPclByaXZhdGVLZXksXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nXG4gICAgfSkub25jZSgnZXJyb3InLCBjYWxsYmFjaylcbiAgICAgIC5vbmNlKCdkb25lJywgZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgaW4gZmF2b3Igb2YgdGhlIG1vZHVsdXMgbGVuZ3RoIGNoZWNrIGJlZm9yZSBzaWduaW5nIG9uY2Ugbm9kZSAxNSsgaXMgdGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb25cbiAgICAgICAgaWYoIW9wdGlvbnMuYWxsb3dJbnNlY3VyZUtleVNpemVzICYmIC9eKD86UlN8UFMpLy50ZXN0KGhlYWRlci5hbGcpICYmIHNpZ25hdHVyZS5sZW5ndGggPCAyNTYpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKGBzZWNyZXRPclByaXZhdGVLZXkgaGFzIGEgbWluaW11bSBrZXkgc2l6ZSBvZiAyMDQ4IGJpdHMgZm9yICR7aGVhZGVyLmFsZ31gKSlcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBzaWduYXR1cmUpO1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHNpZ25hdHVyZSA9IGp3cy5zaWduKHtoZWFkZXI6IGhlYWRlciwgcGF5bG9hZDogcGF5bG9hZCwgc2VjcmV0OiBzZWNyZXRPclByaXZhdGVLZXksIGVuY29kaW5nOiBlbmNvZGluZ30pO1xuICAgIC8vIFRPRE86IFJlbW92ZSBpbiBmYXZvciBvZiB0aGUgbW9kdWx1cyBsZW5ndGggY2hlY2sgYmVmb3JlIHNpZ25pbmcgb25jZSBub2RlIDE1KyBpcyB0aGUgbWluaW11bSBzdXBwb3J0ZWQgdmVyc2lvblxuICAgIGlmKCFvcHRpb25zLmFsbG93SW5zZWN1cmVLZXlTaXplcyAmJiAvXig/OlJTfFBTKS8udGVzdChoZWFkZXIuYWxnKSAmJiBzaWduYXR1cmUubGVuZ3RoIDwgMjU2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNlY3JldE9yUHJpdmF0ZUtleSBoYXMgYSBtaW5pbXVtIGtleSBzaXplIG9mIDIwNDggYml0cyBmb3IgJHtoZWFkZXIuYWxnfWApXG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmVcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7651\n")},7833:(module,exports,__webpack_require__)=>{eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(9910);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsMENBQW1DO0FBQzdDLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLHFCQUFxQjtBQUMzQjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz8zNGViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7833\n")},7914:module=>{eval("/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a boolean primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isBoolean(false);\n * // => true\n *\n * _.isBoolean(null);\n * // => false\n */\nfunction isBoolean(value) {\n  return value === true || value === false ||\n    (isObjectLike(value) && objectToString.call(value) == boolTag);\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isBoolean;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkxNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzYm9vbGVhbi9pbmRleC5qcz8wMzU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCb29sZWFuKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQm9vbGVhbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7914\n")},8002:module=>{"use strict";eval("\n\n/** @type {import('./min')} */\nmodule.exports = Math.min;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAwMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGlCQUFpQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9taW4uanM/YWIyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL21pbicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLm1pbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8002\n")},8051:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var async = __webpack_require__(2313)\n  , abort = __webpack_require__(4555)\n  ;\n\n// API\nmodule.exports = iterate;\n\n/**\n * Iterates over each job object\n *\n * @param {array|object} list - array or object (named list) to iterate over\n * @param {function} iterator - iterator to run\n * @param {object} state - current job status\n * @param {function} callback - invoked when all elements processed\n */\nfunction iterate(list, iterator, state, callback)\n{\n  // store current index\n  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;\n\n  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)\n  {\n    // don't repeat yourself\n    // skip secondary callbacks\n    if (!(key in state.jobs))\n    {\n      return;\n    }\n\n    // clean up jobs\n    delete state.jobs[key];\n\n    if (error)\n    {\n      // don't process rest of the results\n      // stop still active jobs\n      // and reset the list\n      abort(state);\n    }\n    else\n    {\n      state.results[key] = output;\n    }\n\n    // return salvaged results\n    callback(error, state.results);\n  });\n}\n\n/**\n * Runs iterator over provided job element\n *\n * @param   {function} iterator - iterator to invoke\n * @param   {string|number} key - key/index of the element in the list of jobs\n * @param   {mixed} item - job description\n * @param   {function} callback - invoked after iterator is done with the job\n * @returns {function|mixed} - job abort function or something else\n */\nfunction runJob(iterator, key, item, callback)\n{\n  var aborter;\n\n  // allow shortcut if iterator expects only two arguments\n  if (iterator.length == 2)\n  {\n    aborter = iterator(item, async(callback));\n  }\n  // otherwise go with full three arguments\n  else\n  {\n    aborter = iterator(item, key, async(callback));\n  }\n\n  return aborter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA1MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsSUFBWTtBQUNoQyxZQUFZLG1CQUFPLENBQUMsSUFBWTtBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9saWIvaXRlcmF0ZS5qcz9iNTYxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMuanMnKVxuICAsIGFib3J0ID0gcmVxdWlyZSgnLi9hYm9ydC5qcycpXG4gIDtcblxuLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IGl0ZXJhdGU7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlYWNoIGpvYiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gbGlzdCAtIGFycmF5IG9yIG9iamVjdCAobmFtZWQgbGlzdCkgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRvciAtIGl0ZXJhdG9yIHRvIHJ1blxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gY3VycmVudCBqb2Igc3RhdHVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGludm9rZWQgd2hlbiBhbGwgZWxlbWVudHMgcHJvY2Vzc2VkXG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdGUobGlzdCwgaXRlcmF0b3IsIHN0YXRlLCBjYWxsYmFjaylcbntcbiAgLy8gc3RvcmUgY3VycmVudCBpbmRleFxuICB2YXIga2V5ID0gc3RhdGVbJ2tleWVkTGlzdCddID8gc3RhdGVbJ2tleWVkTGlzdCddW3N0YXRlLmluZGV4XSA6IHN0YXRlLmluZGV4O1xuXG4gIHN0YXRlLmpvYnNba2V5XSA9IHJ1bkpvYihpdGVyYXRvciwga2V5LCBsaXN0W2tleV0sIGZ1bmN0aW9uKGVycm9yLCBvdXRwdXQpXG4gIHtcbiAgICAvLyBkb24ndCByZXBlYXQgeW91cnNlbGZcbiAgICAvLyBza2lwIHNlY29uZGFyeSBjYWxsYmFja3NcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuam9icykpXG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNsZWFuIHVwIGpvYnNcbiAgICBkZWxldGUgc3RhdGUuam9ic1trZXldO1xuXG4gICAgaWYgKGVycm9yKVxuICAgIHtcbiAgICAgIC8vIGRvbid0IHByb2Nlc3MgcmVzdCBvZiB0aGUgcmVzdWx0c1xuICAgICAgLy8gc3RvcCBzdGlsbCBhY3RpdmUgam9ic1xuICAgICAgLy8gYW5kIHJlc2V0IHRoZSBsaXN0XG4gICAgICBhYm9ydChzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICBzdGF0ZS5yZXN1bHRzW2tleV0gPSBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHNhbHZhZ2VkIHJlc3VsdHNcbiAgICBjYWxsYmFjayhlcnJvciwgc3RhdGUucmVzdWx0cyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJ1bnMgaXRlcmF0b3Igb3ZlciBwcm92aWRlZCBqb2IgZWxlbWVudFxuICpcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBpdGVyYXRvciB0byBpbnZva2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd8bnVtYmVyfSBrZXkgLSBrZXkvaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGxpc3Qgb2Ygam9ic1xuICogQHBhcmFtICAge21peGVkfSBpdGVtIC0gam9iIGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaW52b2tlZCBhZnRlciBpdGVyYXRvciBpcyBkb25lIHdpdGggdGhlIGpvYlxuICogQHJldHVybnMge2Z1bmN0aW9ufG1peGVkfSAtIGpvYiBhYm9ydCBmdW5jdGlvbiBvciBzb21ldGhpbmcgZWxzZVxuICovXG5mdW5jdGlvbiBydW5Kb2IoaXRlcmF0b3IsIGtleSwgaXRlbSwgY2FsbGJhY2spXG57XG4gIHZhciBhYm9ydGVyO1xuXG4gIC8vIGFsbG93IHNob3J0Y3V0IGlmIGl0ZXJhdG9yIGV4cGVjdHMgb25seSB0d28gYXJndW1lbnRzXG4gIGlmIChpdGVyYXRvci5sZW5ndGggPT0gMilcbiAge1xuICAgIGFib3J0ZXIgPSBpdGVyYXRvcihpdGVtLCBhc3luYyhjYWxsYmFjaykpO1xuICB9XG4gIC8vIG90aGVyd2lzZSBnbyB3aXRoIGZ1bGwgdGhyZWUgYXJndW1lbnRzXG4gIGVsc2VcbiAge1xuICAgIGFib3J0ZXIgPSBpdGVyYXRvcihpdGVtLCBrZXksIGFzeW5jKGNhbGxiYWNrKSk7XG4gIH1cblxuICByZXR1cm4gYWJvcnRlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8051\n")},8068:module=>{"use strict";eval("\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA2OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG9CQUFvQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9zeW50YXguanM/NjdlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3N5bnRheCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBTeW50YXhFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8068\n")},8069:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var Stream = (__webpack_require__(2203).Stream);\nvar util = __webpack_require__(9023);\n\nmodule.exports = DelayedStream;\nfunction DelayedStream() {\n  this.source = null;\n  this.dataSize = 0;\n  this.maxDataSize = 1024 * 1024;\n  this.pauseStream = true;\n\n  this._maxDataSizeExceeded = false;\n  this._released = false;\n  this._bufferedEvents = [];\n}\nutil.inherits(DelayedStream, Stream);\n\nDelayedStream.create = function(source, options) {\n  var delayedStream = new this();\n\n  options = options || {};\n  for (var option in options) {\n    delayedStream[option] = options[option];\n  }\n\n  delayedStream.source = source;\n\n  var realEmit = source.emit;\n  source.emit = function() {\n    delayedStream._handleEmit(arguments);\n    return realEmit.apply(source, arguments);\n  };\n\n  source.on('error', function() {});\n  if (delayedStream.pauseStream) {\n    source.pause();\n  }\n\n  return delayedStream;\n};\n\nObject.defineProperty(DelayedStream.prototype, 'readable', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.source.readable;\n  }\n});\n\nDelayedStream.prototype.setEncoding = function() {\n  return this.source.setEncoding.apply(this.source, arguments);\n};\n\nDelayedStream.prototype.resume = function() {\n  if (!this._released) {\n    this.release();\n  }\n\n  this.source.resume();\n};\n\nDelayedStream.prototype.pause = function() {\n  this.source.pause();\n};\n\nDelayedStream.prototype.release = function() {\n  this._released = true;\n\n  this._bufferedEvents.forEach(function(args) {\n    this.emit.apply(this, args);\n  }.bind(this));\n  this._bufferedEvents = [];\n};\n\nDelayedStream.prototype.pipe = function() {\n  var r = Stream.prototype.pipe.apply(this, arguments);\n  this.resume();\n  return r;\n};\n\nDelayedStream.prototype._handleEmit = function(args) {\n  if (this._released) {\n    this.emit.apply(this, args);\n    return;\n  }\n\n  if (args[0] === 'data') {\n    this.dataSize += args[1].length;\n    this._checkIfMaxDataSizeExceeded();\n  }\n\n  this._bufferedEvents.push(args);\n};\n\nDelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {\n  if (this._maxDataSizeExceeded) {\n    return;\n  }\n\n  if (this.dataSize <= this.maxDataSize) {\n    return;\n  }\n\n  this._maxDataSizeExceeded = true;\n  var message =\n    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'\n  this.emit('error', new Error(message));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA2OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLGtDQUF3QjtBQUNyQyxXQUFXLG1CQUFPLENBQUMsSUFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2RlbGF5ZWQtc3RyZWFtL2xpYi9kZWxheWVkX3N0cmVhbS5qcz9kOTU2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWxheWVkU3RyZWFtO1xuZnVuY3Rpb24gRGVsYXllZFN0cmVhbSgpIHtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLmRhdGFTaXplID0gMDtcbiAgdGhpcy5tYXhEYXRhU2l6ZSA9IDEwMjQgKiAxMDI0O1xuICB0aGlzLnBhdXNlU3RyZWFtID0gdHJ1ZTtcblxuICB0aGlzLl9tYXhEYXRhU2l6ZUV4Y2VlZGVkID0gZmFsc2U7XG4gIHRoaXMuX3JlbGVhc2VkID0gZmFsc2U7XG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzID0gW107XG59XG51dGlsLmluaGVyaXRzKERlbGF5ZWRTdHJlYW0sIFN0cmVhbSk7XG5cbkRlbGF5ZWRTdHJlYW0uY3JlYXRlID0gZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBkZWxheWVkU3RyZWFtID0gbmV3IHRoaXMoKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBkZWxheWVkU3RyZWFtW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gIH1cblxuICBkZWxheWVkU3RyZWFtLnNvdXJjZSA9IHNvdXJjZTtcblxuICB2YXIgcmVhbEVtaXQgPSBzb3VyY2UuZW1pdDtcbiAgc291cmNlLmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxheWVkU3RyZWFtLl9oYW5kbGVFbWl0KGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlYWxFbWl0LmFwcGx5KHNvdXJjZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBzb3VyY2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7fSk7XG4gIGlmIChkZWxheWVkU3RyZWFtLnBhdXNlU3RyZWFtKSB7XG4gICAgc291cmNlLnBhdXNlKCk7XG4gIH1cblxuICByZXR1cm4gZGVsYXllZFN0cmVhbTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWxheWVkU3RyZWFtLnByb3RvdHlwZSwgJ3JlYWRhYmxlJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnJlYWRhYmxlO1xuICB9XG59KTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlLnNldEVuY29kaW5nLmFwcGx5KHRoaXMuc291cmNlLCBhcmd1bWVudHMpO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmVsZWFzZWQpIHtcbiAgICB0aGlzLnJlbGVhc2UoKTtcbiAgfVxuXG4gIHRoaXMuc291cmNlLnJlc3VtZSgpO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zb3VyY2UucGF1c2UoKTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVsZWFzZWQgPSB0cnVlO1xuXG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oYXJncykge1xuICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMgPSBbXTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHIgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5yZXN1bWUoKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5faGFuZGxlRW1pdCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgaWYgKHRoaXMuX3JlbGVhc2VkKSB7XG4gICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChhcmdzWzBdID09PSAnZGF0YScpIHtcbiAgICB0aGlzLmRhdGFTaXplICs9IGFyZ3NbMV0ubGVuZ3RoO1xuICAgIHRoaXMuX2NoZWNrSWZNYXhEYXRhU2l6ZUV4Y2VlZGVkKCk7XG4gIH1cblxuICB0aGlzLl9idWZmZXJlZEV2ZW50cy5wdXNoKGFyZ3MpO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUuX2NoZWNrSWZNYXhEYXRhU2l6ZUV4Y2VlZGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9tYXhEYXRhU2l6ZUV4Y2VlZGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuZGF0YVNpemUgPD0gdGhpcy5tYXhEYXRhU2l6ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX21heERhdGFTaXplRXhjZWVkZWQgPSB0cnVlO1xuICB2YXIgbWVzc2FnZSA9XG4gICAgJ0RlbGF5ZWRTdHJlYW0jbWF4RGF0YVNpemUgb2YgJyArIHRoaXMubWF4RGF0YVNpemUgKyAnIGJ5dGVzIGV4Y2VlZGVkLidcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8069\n")},8311:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = __webpack_require__(8794)\nconst cache = new LRU()\n\nconst parseOptions = __webpack_require__(8587)\nconst Comparator = __webpack_require__(3904)\nconst debug = __webpack_require__(7272)\nconst SemVer = __webpack_require__(3908)\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = __webpack_require__(9718)\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(6874)\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --\x3e * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --\x3e >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --\x3e >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --\x3e >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --\x3e >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --\x3e >=1.2.0 <1.3.0-0\n// ~0.0.1 --\x3e >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --\x3e * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --\x3e >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --\x3e >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --\x3e >=1.2.0 <2.0.0-0\n// ^1.2.3 --\x3e >=1.2.3 <2.0.0-0\n// ^1.2.0 --\x3e >=1.2.0 <2.0.0-0\n// ^0.0.1 --\x3e >=0.0.1 <0.0.2-0\n// ^0.1.0 --\x3e >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUs7QUFDckIsSUFBSTtBQUNKLGdCQUFnQixLQUFLLEVBQUUsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osYUFBYSxRQUFRO0FBQ3JCLElBQUk7QUFDSixhQUFhLEdBQUcsR0FBRyxRQUFRO0FBQzNCLElBQUk7QUFDSixjQUFjLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUk7QUFDcEMsSUFBSTtBQUNKLGFBQWEsR0FBRyxHQUFHLEdBQUcsR0FBRyxRQUFRO0FBQ2pDLElBQUk7QUFDSixjQUFjLEdBQUc7QUFDakI7O0FBRUEsWUFBWSxNQUFNLEVBQUUsR0FBRztBQUN2Qjs7QUFFQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcz83YjFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTUEFDRV9DSEFSQUNURVJTID0gL1xccysvZ1xuXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QgcmVkdWNlIGFsbCB3aGl0ZXNwYWNlIGFzIG11Y2ggYXMgcG9zc2libGUgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVseVxuICAgIC8vIG9uIHBvdGVudGlhbGx5IHNsb3cgcmVnZXhlcyBsaWtlIFxccyouIFRoaXMgaXMgdGhlbiBzdG9yZWQgYW5kIHVzZWQgZm9yXG4gICAgLy8gZnV0dXJlIGVycm9yIG1lc3NhZ2VzIGFzIHdlbGwuXG4gICAgdGhpcy5yYXcgPSByYW5nZS50cmltKCkucmVwbGFjZShTUEFDRV9DSEFSQUNURVJTLCAnICcpXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgb24gfHxcbiAgICB0aGlzLnNldCA9IHRoaXMucmF3XG4gICAgICAuc3BsaXQoJ3x8JylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyID0+IHRoaXMucGFyc2VSYW5nZShyLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHt0aGlzLnJhd31gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXR0ZWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCByYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0dGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJ3x8J1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy5zZXRbaV1cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb21wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJyAnXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkICs9IGNvbXBzW2tdLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSkgfFxuICAgICAgKHRoaXMub3B0aW9ucy5sb29zZSAmJiBGTEFHX0xPT1NFKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArICc6JyArIHJhbmdlXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygndGlsZGUgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY2FyZXQgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgbGV0IHJhbmdlTGlzdCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJyAnKVxuICAgICAgLm1hcChjb21wID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIGlmIChsb29zZSkge1xuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIHJhbmdlTGlzdCA9IHJhbmdlTGlzdC5maWx0ZXIoY29tcCA9PiB7XG4gICAgICAgIGRlYnVnKCdsb29zZSBpbnZhbGlkIGZpbHRlcicsIGNvbXAsIHRoaXMub3B0aW9ucylcbiAgICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChyZVt0LkNPTVBBUkFUT1JMT09TRV0pXG4gICAgICB9KVxuICAgIH1cbiAgICBkZWJ1ZygncmFuZ2UgbGlzdCcsIHJhbmdlTGlzdClcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCByYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2VMaXN0Lm1hcChjb21wID0+IG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKSB7XG4gICAgICAgIHJldHVybiBbY29tcF1cbiAgICAgIH1cbiAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKVxuICAgIH1cbiAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSkge1xuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV1cbiAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGludGVyc2VjdHMgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICByYW5nZS5zZXQuc29tZSgocmFuZ2VDb21wYXJhdG9ycykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2xydWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSgpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgc2FmZVJlOiByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlLFxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IHsgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UsIEZMQUdfTE9PU0UgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MC4wLjEgLS0+ID49MC4wLjEgPDAuMS4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VUaWxkZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tPiA+PTAuMC4xIDwwLjAuMi0wXG4vLyBeMC4xLjAgLS0+ID49MC4xLjAgPDAuMi4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VDYXJldChjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpKVxuICAgIC5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIHByID0gJy0wJ1xuICAgICAgfVxuXG4gICAgICByZXQgPSBgJHtndGx0ICsgTX0uJHttfS4ke3B9JHtwcn1gXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3ByfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuY29uc3QgcmVwbGFjZVN0YXJzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuY29uc3QgcmVwbGFjZUdURTAgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZUdURTAnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVtvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gdC5HVEUwUFJFIDogdC5HVEUwXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG4vLyBUT0RPIGJ1aWxkP1xuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwcikgPT4ge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4ke2ZtfS4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX1gXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX0ke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9IGA8JHsrdE0gKyAxfS4wLjAtMGBcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7K3RtICsgMX0uMC0wYFxuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gYDw9JHt0TX0uJHt0bX0uJHt0cH0tJHt0cHJ9YFxuICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7dG19LiR7K3RwICsgMX0tMGBcbiAgfSBlbHNlIHtcbiAgICB0byA9IGA8PSR7dG99YFxuICB9XG5cbiAgcmV0dXJuIGAke2Zyb219ICR7dG99YC50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8311\n")},8587:module=>{"use strict";eval("\n\n// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanM/ZTEyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dFxuY29uc3QgbG9vc2VPcHRpb24gPSBPYmplY3QuZnJlZXplKHsgbG9vc2U6IHRydWUgfSlcbmNvbnN0IGVtcHR5T3B0cyA9IE9iamVjdC5mcmVlemUoeyB9KVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBlbXB0eU9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbG9vc2VPcHRpb25cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8587\n")},8611:n=>{"use strict";n.exports=require("http")},8648:module=>{"use strict";eval("\n\n/** @type {import('./Reflect.getPrototypeOf')} */\nmodule.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG9DQUFvQztBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2dldC1wcm90by9SZWZsZWN0LmdldFByb3RvdHlwZU9mLmpzP2YyZTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9SZWZsZWN0LmdldFByb3RvdHlwZU9mJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9ICh0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdC5nZXRQcm90b3R5cGVPZikgfHwgbnVsbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8648\n")},8703:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  AuthenticationHandler: () => (/* reexport */ AuthenticationHandler),\n  AuthenticationHandlerOptions: () => (/* reexport */ AuthenticationHandlerOptions),\n  BatchRequestContent: () => (/* reexport */ BatchRequestContent),\n  BatchResponseContent: () => (/* reexport */ BatchResponseContent),\n  ChaosHandler: () => (/* reexport */ ChaosHandler),\n  ChaosHandlerOptions: () => (/* reexport */ ChaosHandlerOptions),\n  ChaosStrategy: () => (/* reexport */ ChaosStrategy),\n  Client: () => (/* reexport */ Client),\n  CustomAuthenticationProvider: () => (/* reexport */ CustomAuthenticationProvider),\n  FeatureUsageFlag: () => (/* reexport */ FeatureUsageFlag),\n  FileUpload: () => (/* reexport */ FileUpload),\n  GraphClientError: () => (/* reexport */ GraphClientError),\n  GraphError: () => (/* reexport */ GraphError),\n  GraphRequest: () => (/* reexport */ GraphRequest),\n  HTTPMessageHandler: () => (/* reexport */ HTTPMessageHandler),\n  LargeFileUploadTask: () => (/* reexport */ LargeFileUploadTask),\n  MiddlewareFactory: () => (/* reexport */ MiddlewareFactory),\n  OneDriveLargeFileUploadTask: () => (/* reexport */ OneDriveLargeFileUploadTask),\n  PageIterator: () => (/* reexport */ PageIterator),\n  Range: () => (/* reexport */ Range),\n  RedirectHandler: () => (/* reexport */ RedirectHandler),\n  RedirectHandlerOptions: () => (/* reexport */ RedirectHandlerOptions),\n  ResponseType: () => (/* reexport */ ResponseType),\n  RetryHandler: () => (/* reexport */ RetryHandler),\n  RetryHandlerOptions: () => (/* reexport */ RetryHandlerOptions),\n  StreamUpload: () => (/* reexport */ StreamUpload),\n  TelemetryHandler: () => (/* reexport */ TelemetryHandler),\n  TelemetryHandlerOptions: () => (/* reexport */ TelemetryHandlerOptions),\n  UploadResult: () => (/* reexport */ UploadResult),\n  getValidRangeSize: () => (/* reexport */ getValidRangeSize)\n});\n\n;// ./node_modules/tslib/tslib.es6.mjs\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== "function" && b !== null)\n      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === "function")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }\n  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";\n  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === "accessor") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== "object") throw new TypeError("Object expected");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === "field") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === "symbol" ? x : "".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";\n  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError("Generator is already executing.");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === "number") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === "function" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i["return"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume("next", value); }\n  function reject(value) { resume("throw", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n  o["default"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === "m") throw new TypeError("Private method is not writable");\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use \'in\' operator on non-object");\n  return typeof state === "function" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === "string" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");\n      });\n  }\n  return path;\n}\n\n/* harmony default export */ const tslib_es6 = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n});\n\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/RequestMethod.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @enum\n * Enum for RequestMethods\n * @property {string} GET - The get request type\n * @property {string} PATCH - The patch request type\n * @property {string} POST - The post request type\n * @property {string} PUT - The put request type\n * @property {string} DELETE - The delete request type\n */\nvar RequestMethod;\n(function (RequestMethod) {\n    RequestMethod["GET"] = "GET";\n    RequestMethod["PATCH"] = "PATCH";\n    RequestMethod["POST"] = "POST";\n    RequestMethod["PUT"] = "PUT";\n    RequestMethod["DELETE"] = "DELETE";\n})(RequestMethod || (RequestMethod = {}));\n//# sourceMappingURL=RequestMethod.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/content/BatchRequestContent.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module BatchRequestContent\n */\n\n/**\n * @class\n * Class for handling BatchRequestContent\n */\nclass BatchRequestContent {\n    /**\n     * @private\n     * @static\n     * Validates the dependency chain of the requests\n     *\n     * Note:\n     * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:\n     * 1. Parallel - no individual request states a dependency in the dependsOn property.\n     * 2. Serial - all individual requests depend on the previous individual request.\n     * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.\n     * As JSON batching matures, these limitations will be removed.\n     * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\n     *\n     * @param {Map<string, BatchRequestStep>} requests - The map of requests.\n     * @returns The boolean indicating the validation status\n     */\n    static validateDependencies(requests) {\n        const isParallel = (reqs) => {\n            const iterator = reqs.entries();\n            let cur = iterator.next();\n            while (!cur.done) {\n                const curReq = cur.value[1];\n                if (curReq.dependsOn !== undefined && curReq.dependsOn.length > 0) {\n                    return false;\n                }\n                cur = iterator.next();\n            }\n            return true;\n        };\n        const isSerial = (reqs) => {\n            const iterator = reqs.entries();\n            let cur = iterator.next();\n            const firstRequest = cur.value[1];\n            if (firstRequest.dependsOn !== undefined && firstRequest.dependsOn.length > 0) {\n                return false;\n            }\n            let prev = cur;\n            cur = iterator.next();\n            while (!cur.done) {\n                const curReq = cur.value[1];\n                if (curReq.dependsOn === undefined || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {\n                    return false;\n                }\n                prev = cur;\n                cur = iterator.next();\n            }\n            return true;\n        };\n        const isSame = (reqs) => {\n            const iterator = reqs.entries();\n            let cur = iterator.next();\n            const firstRequest = cur.value[1];\n            let dependencyId;\n            if (firstRequest.dependsOn === undefined || firstRequest.dependsOn.length === 0) {\n                dependencyId = firstRequest.id;\n            }\n            else {\n                if (firstRequest.dependsOn.length === 1) {\n                    const fDependencyId = firstRequest.dependsOn[0];\n                    if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {\n                        dependencyId = fDependencyId;\n                    }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    return false;\n                }\n            }\n            cur = iterator.next();\n            while (!cur.done) {\n                const curReq = cur.value[1];\n                if ((curReq.dependsOn === undefined || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {\n                    return false;\n                }\n                if (curReq.dependsOn !== undefined && curReq.dependsOn.length !== 0) {\n                    if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {\n                        return false;\n                    }\n                    if (curReq.dependsOn.length > 1) {\n                        return false;\n                    }\n                }\n                cur = iterator.next();\n            }\n            return true;\n        };\n        if (requests.size === 0) {\n            const error = new Error("Empty requests map, Please provide at least one request.");\n            error.name = "Empty Requests Error";\n            throw error;\n        }\n        return isParallel(requests) || isSerial(requests) || isSame(requests);\n    }\n    /**\n     * @private\n     * @static\n     * @async\n     * Converts Request Object instance to a JSON\n     * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance\n     * @returns A promise that resolves to JSON representation of a request\n     */\n    static getRequestData(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const requestData = {\n                url: "",\n            };\n            const hasHttpRegex = new RegExp("^https?://");\n            // Stripping off hostname, port and url scheme\n            requestData.url = hasHttpRegex.test(request.url) ? "/" + request.url.split(/.*?\\/\\/.*?\\//)[1] : request.url;\n            requestData.method = request.method;\n            const headers = {};\n            request.headers.forEach((value, key) => {\n                headers[key] = value;\n            });\n            if (Object.keys(headers).length) {\n                requestData.headers = headers;\n            }\n            if (request.method === RequestMethod.PATCH || request.method === RequestMethod.POST || request.method === RequestMethod.PUT) {\n                requestData.body = yield BatchRequestContent.getRequestBody(request);\n            }\n            /**\n             * TODO: Check any other property needs to be used from the Request object and add them\n             */\n            return requestData;\n        });\n    }\n    /**\n     * @private\n     * @static\n     * @async\n     * Gets the body of a Request object instance\n     * @param {IsomorphicRequest} request - The IsomorphicRequest object instance\n     * @returns The Promise that resolves to a body value of a Request\n     */\n    static getRequestBody(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let bodyParsed = false;\n            let body;\n            try {\n                const cloneReq = request.clone();\n                body = yield cloneReq.json();\n                bodyParsed = true;\n            }\n            catch (e) {\n                //TODO- Handle empty catches\n            }\n            if (!bodyParsed) {\n                try {\n                    if (typeof Blob !== "undefined") {\n                        const blob = yield request.blob();\n                        const reader = new FileReader();\n                        body = yield new Promise((resolve) => {\n                            reader.addEventListener("load", () => {\n                                const dataURL = reader.result;\n                                /**\n                                 * Some valid dataURL schemes:\n                                 *  1. data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh\n                                 *  2. data:text/plain;charset=UTF-8;page=21,the%20data:1234,5678\n                                 *  3. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\n                                 *  4. data:image/png,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\n                                 *  5. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\n                                 * @see Syntax {@link https://en.wikipedia.org/wiki/Data_URI_scheme} for more\n                                 */\n                                const regex = new RegExp("^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$");\n                                const segments = regex.exec(dataURL);\n                                resolve(segments[4]);\n                            }, false);\n                            reader.readAsDataURL(blob);\n                        });\n                    }\n                    else if (typeof Buffer !== "undefined") {\n                        const buffer = yield request.buffer();\n                        body = buffer.toString("base64");\n                    }\n                    bodyParsed = true;\n                }\n                catch (e) {\n                    // TODO-Handle empty catches\n                }\n            }\n            return body;\n        });\n    }\n    /**\n     * @public\n     * @constructor\n     * Constructs a BatchRequestContent instance\n     * @param {BatchRequestStep[]} [requests] - Array of requests value\n     * @returns An instance of a BatchRequestContent\n     */\n    constructor(requests) {\n        this.requests = new Map();\n        if (typeof requests !== "undefined") {\n            const limit = BatchRequestContent.requestLimit;\n            if (requests.length > limit) {\n                const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);\n                error.name = "Limit Exceeded Error";\n                throw error;\n            }\n            for (const req of requests) {\n                this.addRequest(req);\n            }\n        }\n    }\n    /**\n     * @public\n     * Adds a request to the batch request content\n     * @param {BatchRequestStep} request - The request value\n     * @returns The id of the added request\n     */\n    addRequest(request) {\n        const limit = BatchRequestContent.requestLimit;\n        if (request.id === "") {\n            const error = new Error(`Id for a request is empty, Please provide an unique id`);\n            error.name = "Empty Id For Request";\n            throw error;\n        }\n        if (this.requests.size === limit) {\n            const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);\n            error.name = "Limit Exceeded Error";\n            throw error;\n        }\n        if (this.requests.has(request.id)) {\n            const error = new Error(`Adding request with duplicate id ${request.id}, Make the id of the requests unique`);\n            error.name = "Duplicate RequestId Error";\n            throw error;\n        }\n        this.requests.set(request.id, request);\n        return request.id;\n    }\n    /**\n     * @public\n     * Removes request from the batch payload and its dependencies from all dependents\n     * @param {string} requestId - The id of a request that needs to be removed\n     * @returns The boolean indicating removed status\n     */\n    removeRequest(requestId) {\n        const deleteStatus = this.requests.delete(requestId);\n        const iterator = this.requests.entries();\n        let cur = iterator.next();\n        /**\n         * Removing dependencies where this request is present as a dependency\n         */\n        while (!cur.done) {\n            const dependencies = cur.value[1].dependsOn;\n            if (typeof dependencies !== "undefined") {\n                const index = dependencies.indexOf(requestId);\n                if (index !== -1) {\n                    dependencies.splice(index, 1);\n                }\n                if (dependencies.length === 0) {\n                    delete cur.value[1].dependsOn;\n                }\n            }\n            cur = iterator.next();\n        }\n        return deleteStatus;\n    }\n    /**\n     * @public\n     * @async\n     * Serialize content from BatchRequestContent instance\n     * @returns The body content to make batch request\n     */\n    getContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const requests = [];\n            const requestBody = {\n                requests,\n            };\n            const iterator = this.requests.entries();\n            let cur = iterator.next();\n            if (cur.done) {\n                const error = new Error("No requests added yet, Please add at least one request.");\n                error.name = "Empty Payload";\n                throw error;\n            }\n            if (!BatchRequestContent.validateDependencies(this.requests)) {\n                const error = new Error(`Invalid dependency found, Dependency should be:\n1. Parallel - no individual request states a dependency in the dependsOn property.\n2. Serial - all individual requests depend on the previous individual request.\n3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.`);\n                error.name = "Invalid Dependency";\n                throw error;\n            }\n            while (!cur.done) {\n                const requestStep = cur.value[1];\n                const batchRequestData = (yield BatchRequestContent.getRequestData(requestStep.request));\n                /**\n                 * @see{@https://tools.ietf.org/html/rfc7578#section-4.4}\n                 * TODO- Setting/Defaulting of content-type header to the correct value\n                 * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/json_batching#request-format}\n                 */\n                if (batchRequestData.body !== undefined && (batchRequestData.headers === undefined || batchRequestData.headers["content-type"] === undefined)) {\n                    const error = new Error(`Content-type header is not mentioned for request #${requestStep.id}, For request having body, Content-type header should be mentioned`);\n                    error.name = "Invalid Content-type header";\n                    throw error;\n                }\n                batchRequestData.id = requestStep.id;\n                if (requestStep.dependsOn !== undefined && requestStep.dependsOn.length > 0) {\n                    batchRequestData.dependsOn = requestStep.dependsOn;\n                }\n                requests.push(batchRequestData);\n                cur = iterator.next();\n            }\n            requestBody.requests = requests;\n            return requestBody;\n        });\n    }\n    /**\n     * @public\n     * Adds a dependency for a given dependent request\n     * @param {string} dependentId - The id of the dependent request\n     * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency\n     * @returns Nothing\n     */\n    addDependency(dependentId, dependencyId) {\n        if (!this.requests.has(dependentId)) {\n            const error = new Error(`Dependent ${dependentId} does not exists, Please check the id`);\n            error.name = "Invalid Dependent";\n            throw error;\n        }\n        if (typeof dependencyId !== "undefined" && !this.requests.has(dependencyId)) {\n            const error = new Error(`Dependency ${dependencyId} does not exists, Please check the id`);\n            error.name = "Invalid Dependency";\n            throw error;\n        }\n        if (typeof dependencyId !== "undefined") {\n            const dependent = this.requests.get(dependentId);\n            if (dependent.dependsOn === undefined) {\n                dependent.dependsOn = [];\n            }\n            if (dependent.dependsOn.indexOf(dependencyId) !== -1) {\n                const error = new Error(`Dependency ${dependencyId} is already added for the request ${dependentId}`);\n                error.name = "Duplicate Dependency";\n                throw error;\n            }\n            dependent.dependsOn.push(dependencyId);\n        }\n        else {\n            const iterator = this.requests.entries();\n            let prev;\n            let cur = iterator.next();\n            while (!cur.done && cur.value[1].id !== dependentId) {\n                prev = cur;\n                cur = iterator.next();\n            }\n            if (typeof prev !== "undefined") {\n                const dId = prev.value[0];\n                if (cur.value[1].dependsOn === undefined) {\n                    cur.value[1].dependsOn = [];\n                }\n                if (cur.value[1].dependsOn.indexOf(dId) !== -1) {\n                    const error = new Error(`Dependency ${dId} is already added for the request ${dependentId}`);\n                    error.name = "Duplicate Dependency";\n                    throw error;\n                }\n                cur.value[1].dependsOn.push(dId);\n            }\n            else {\n                const error = new Error(`Can\'t add dependency ${dependencyId}, There is only a dependent request in the batch`);\n                error.name = "Invalid Dependency Addition";\n                throw error;\n            }\n        }\n    }\n    /**\n     * @public\n     * Removes a dependency for a given dependent request id\n     * @param {string} dependentId - The id of the dependent request\n     * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request\n     * @returns The boolean indicating removed status\n     */\n    removeDependency(dependentId, dependencyId) {\n        const request = this.requests.get(dependentId);\n        if (typeof request === "undefined" || request.dependsOn === undefined || request.dependsOn.length === 0) {\n            return false;\n        }\n        if (typeof dependencyId !== "undefined") {\n            const index = request.dependsOn.indexOf(dependencyId);\n            if (index === -1) {\n                return false;\n            }\n            request.dependsOn.splice(index, 1);\n            return true;\n        }\n        else {\n            delete request.dependsOn;\n            return true;\n        }\n    }\n}\n/**\n * @private\n * @static\n * Limit for number of requests {@link - https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\n */\nBatchRequestContent.requestLimit = 20;\n//# sourceMappingURL=BatchRequestContent.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/content/BatchResponseContent.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @class\n * Class that handles BatchResponseContent\n */\nclass BatchResponseContent {\n    /**\n     * @public\n     * @constructor\n     * Creates the BatchResponseContent instance\n     * @param {BatchResponseBody} response - The response body returned for batch request from server\n     * @returns An instance of a BatchResponseContent\n     */\n    constructor(response) {\n        this.responses = new Map();\n        this.update(response);\n    }\n    /**\n     * @private\n     * Creates native Response object from the json representation of it.\n     * @param {KeyValuePairObject} responseJSON - The response json value\n     * @returns The Response Object instance\n     */\n    createResponseObject(responseJSON) {\n        const body = responseJSON.body;\n        const options = {};\n        options.status = responseJSON.status;\n        if (responseJSON.statusText !== undefined) {\n            options.statusText = responseJSON.statusText;\n        }\n        options.headers = responseJSON.headers;\n        if (options.headers !== undefined && options.headers["Content-Type"] !== undefined) {\n            if (options.headers["Content-Type"].split(";")[0] === "application/json") {\n                const bodyString = JSON.stringify(body);\n                return new Response(bodyString, options);\n            }\n        }\n        return new Response(body, options);\n    }\n    /**\n     * @public\n     * Updates the Batch response content instance with given responses.\n     * @param {BatchResponseBody} response - The response json representing batch response message\n     * @returns Nothing\n     */\n    update(response) {\n        this.nextLink = response["@odata.nextLink"];\n        const responses = response.responses;\n        for (let i = 0, l = responses.length; i < l; i++) {\n            this.responses.set(responses[i].id, this.createResponseObject(responses[i]));\n        }\n    }\n    /**\n     * @public\n     * To get the response of a request for a given request id\n     * @param {string} requestId - The request id value\n     * @returns The Response object instance for the particular request\n     */\n    getResponseById(requestId) {\n        return this.responses.get(requestId);\n    }\n    /**\n     * @public\n     * To get all the responses of the batch request\n     * @returns The Map of id and Response objects\n     */\n    getResponses() {\n        return this.responses;\n    }\n    /**\n     * @public\n     * To get the iterator for the responses\n     * @returns The Iterable generator for the response objects\n     */\n    *getResponsesIterator() {\n        const iterator = this.responses.entries();\n        let cur = iterator.next();\n        while (!cur.done) {\n            yield cur.value;\n            cur = iterator.next();\n        }\n    }\n}\n//# sourceMappingURL=BatchResponseContent.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/Constants.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module Constants\n */\n/**\n * @constant\n * A Default API endpoint version for a request\n */\nconst GRAPH_API_VERSION = "v1.0";\n/**\n * @constant\n * A Default base url for a request\n */\nconst GRAPH_BASE_URL = "https://graph.microsoft.com/";\n/**\n * To hold list of the service root endpoints for Microsoft Graph and Graph Explorer for each national cloud.\n * Set(iterable:Object) is not supported in Internet Explorer. The consumer is recommended to use a suitable polyfill.\n */\nconst GRAPH_URLS = new Set(["graph.microsoft.com", "graph.microsoft.us", "dod-graph.microsoft.us", "graph.microsoft.de", "microsoftgraph.chinacloudapi.cn", "canary.graph.microsoft.com"]);\n//# sourceMappingURL=Constants.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphClientError.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module GraphClientError\n */\n/**\n * @class\n * Create GraphClientError object to handle client-side errors\n * encountered within the JavaScript Client SDK.\n * Whereas GraphError Class should be used to handle errors in the response from the Graph API.\n */\nclass GraphClientError extends Error {\n    /**\n     * @public\n     * @static\n     * @async\n     * To set the GraphClientError object\n     * @param {any} error - The error returned encountered by the Graph JavaScript Client SDK while processing request\n     * @returns GraphClientError object set to the error passed\n     */\n    static setGraphClientError(error) {\n        let graphClientError;\n        if (error instanceof Error) {\n            graphClientError = error;\n        }\n        else {\n            graphClientError = new GraphClientError();\n            graphClientError.customError = error;\n        }\n        return graphClientError;\n    }\n    /**\n     * @public\n     * @constructor\n     * Creates an instance of GraphClientError\n     * @param {string} message? - Error message\n     * @returns An instance of GraphClientError\n     */\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, GraphClientError.prototype);\n    }\n}\n//# sourceMappingURL=GraphClientError.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequestUtil.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module GraphRequestUtil\n */\n\n\n/**\n * To hold list of OData query params\n */\nconst oDataQueryNames = ["$select", "$expand", "$orderby", "$filter", "$top", "$skip", "$skipToken", "$count"];\n/**\n * To construct the URL by appending the segments with "/"\n * @param {string[]} urlSegments - The array of strings\n * @returns The constructed URL string\n */\nconst urlJoin = (urlSegments) => {\n    const removePostSlash = (s) => s.replace(/\\/+$/, "");\n    const removePreSlash = (s) => s.replace(/^\\/+/, "");\n    const joiner = (pre, cur) => [removePostSlash(pre), removePreSlash(cur)].join("/");\n    const parts = Array.prototype.slice.call(urlSegments);\n    return parts.reduce(joiner);\n};\n/**\n * Serializes the content\n * @param {any} content - The content value that needs to be serialized\n * @returns The serialized content\n *\n * Note:\n * This conversion is required due to the following reasons:\n * Body parameter of Request method of isomorphic-fetch only accepts Blob, ArrayBuffer, FormData, TypedArrays string.\n * Node.js platform does not support Blob, FormData. Javascript File object inherits from Blob so it is also not supported in node. Therefore content of type Blob, File, FormData will only come from browsers.\n * Parallel to ArrayBuffer in javascript, node provides Buffer interface. Node\'s Buffer is able to send the arbitrary binary data to the server successfully for both Browser and Node platform. Whereas sending binary data via ArrayBuffer or TypedArrays was only possible using Browser. To support both Node and Browser, `serializeContent` converts TypedArrays or ArrayBuffer to `Node Buffer`.\n * If the data received is in JSON format, `serializeContent` converts the JSON to string.\n */\nconst serializeContent = (content) => {\n    const className = content && content.constructor && content.constructor.name;\n    if (className === "Buffer" || className === "Blob" || className === "File" || className === "FormData" || typeof content === "string") {\n        return content;\n    }\n    if (className === "ArrayBuffer") {\n        content = Buffer.from(content);\n    }\n    else if (className === "Int8Array" || className === "Int16Array" || className === "Int32Array" || className === "Uint8Array" || className === "Uint16Array" || className === "Uint32Array" || className === "Uint8ClampedArray" || className === "Float32Array" || className === "Float64Array" || className === "DataView") {\n        content = Buffer.from(content.buffer);\n    }\n    else {\n        try {\n            content = JSON.stringify(content);\n        }\n        catch (error) {\n            throw new Error("Unable to stringify the content");\n        }\n    }\n    return content;\n};\n/**\n * Checks if the url is one of the service root endpoints for Microsoft Graph and Graph Explorer.\n * @param {string} url - The url to be verified\n * @returns {boolean} - Returns true if the url is a Graph URL\n */\nconst isGraphURL = (url) => {\n    return isValidEndpoint(url);\n};\n/**\n * Checks if the url is for one of the custom hosts provided during client initialization\n * @param {string} url - The url to be verified\n * @param {Set} customHosts - The url to be verified\n * @returns {boolean} - Returns true if the url is a for a custom host\n */\nconst isCustomHost = (url, customHosts) => {\n    customHosts.forEach((host) => isCustomHostValid(host));\n    return isValidEndpoint(url, customHosts);\n};\n/**\n * Checks if the url is for one of the provided hosts.\n * @param {string} url - The url to be verified\n * @param {Set<string>} allowedHosts - A set of hosts.\n * @returns {boolean} - Returns true is for one of the provided endpoints.\n */\nconst isValidEndpoint = (url, allowedHosts = GRAPH_URLS) => {\n    // Valid Graph URL pattern - https://graph.microsoft.com/{version}/{resource}?{query-parameters}\n    // Valid Graph URL example - https://graph.microsoft.com/v1.0/\n    url = url.toLowerCase();\n    if (url.indexOf("https://") !== -1) {\n        url = url.replace("https://", "");\n        // Find where the host ends\n        const startofPortNoPos = url.indexOf(":");\n        const endOfHostStrPos = url.indexOf("/");\n        let hostName = "";\n        if (endOfHostStrPos !== -1) {\n            if (startofPortNoPos !== -1 && startofPortNoPos < endOfHostStrPos) {\n                hostName = url.substring(0, startofPortNoPos);\n                return allowedHosts.has(hostName);\n            }\n            // Parse out the host\n            hostName = url.substring(0, endOfHostStrPos);\n            return allowedHosts.has(hostName);\n        }\n    }\n    return false;\n};\n/**\n * Throws error if the string is not a valid host/hostname and contains other url parts.\n * @param {string} host - The host to be verified\n */\nconst isCustomHostValid = (host) => {\n    if (host.indexOf("/") !== -1) {\n        throw new GraphClientError("Please add only hosts or hostnames to the CustomHosts config. If the url is `http://example.com:3000/`, host is `example:3000`");\n    }\n};\n//# sourceMappingURL=GraphRequestUtil.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareControl.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @class\n * Class representing MiddlewareControl\n */\nclass MiddlewareControl {\n    /**\n     * @public\n     * @constructor\n     * Creates an instance of MiddlewareControl\n     * @param {MiddlewareOptions[]} [middlewareOptions = []] - The array of middlewareOptions\n     * @returns The instance of MiddlewareControl\n     */\n    constructor(middlewareOptions = []) {\n        this.middlewareOptions = new Map();\n        for (const option of middlewareOptions) {\n            const fn = option.constructor;\n            this.middlewareOptions.set(fn, option);\n        }\n    }\n    /**\n     * @public\n     * To get the middleware option using the class of the option\n     * @param {Function} fn - The class of the strongly typed option class\n     * @returns The middleware option\n     * @example\n     * // if you wanted to return the middleware option associated with this class (MiddlewareControl)\n     * // call this function like this:\n     * getMiddlewareOptions(MiddlewareControl)\n     */\n    getMiddlewareOptions(fn) {\n        return this.middlewareOptions.get(fn);\n    }\n    /**\n     * @public\n     * To set the middleware options using the class of the option\n     * @param {Function} fn - The class of the strongly typed option class\n     * @param {MiddlewareOptions} option - The strongly typed middleware option\n     * @returns nothing\n     */\n    setMiddlewareOptions(fn, option) {\n        this.middlewareOptions.set(fn, option);\n    }\n}\n//# sourceMappingURL=MiddlewareControl.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareUtil.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @constant\n * To generate the UUID\n * @returns The UUID string\n */\nconst generateUUID = () => {\n    let uuid = "";\n    for (let j = 0; j < 32; j++) {\n        if (j === 8 || j === 12 || j === 16 || j === 20) {\n            uuid += "-";\n        }\n        uuid += Math.floor(Math.random() * 16).toString(16);\n    }\n    return uuid;\n};\n/**\n * @constant\n * To get the request header from the request\n * @param {RequestInfo} request - The request object or the url string\n * @param {FetchOptions|undefined} options - The request options object\n * @param {string} key - The header key string\n * @returns A header value for the given key from the request\n */\nconst getRequestHeader = (request, options, key) => {\n    let value = null;\n    if (typeof Request !== "undefined" && request instanceof Request) {\n        value = request.headers.get(key);\n    }\n    else if (typeof options !== "undefined" && options.headers !== undefined) {\n        if (typeof Headers !== "undefined" && options.headers instanceof Headers) {\n            value = options.headers.get(key);\n        }\n        else if (options.headers instanceof Array) {\n            const headers = options.headers;\n            for (let i = 0, l = headers.length; i < l; i++) {\n                if (headers[i][0] === key) {\n                    value = headers[i][1];\n                    break;\n                }\n            }\n        }\n        else if (options.headers[key] !== undefined) {\n            value = options.headers[key];\n        }\n    }\n    return value;\n};\n/**\n * @constant\n * To set the header value to the given request\n * @param {RequestInfo} request - The request object or the url string\n * @param {FetchOptions|undefined} options - The request options object\n * @param {string} key - The header key string\n * @param {string } value - The header value string\n * @returns Nothing\n */\nconst setRequestHeader = (request, options, key, value) => {\n    if (typeof Request !== "undefined" && request instanceof Request) {\n        request.headers.set(key, value);\n    }\n    else if (typeof options !== "undefined") {\n        if (options.headers === undefined) {\n            options.headers = new Headers({\n                [key]: value,\n            });\n        }\n        else {\n            if (typeof Headers !== "undefined" && options.headers instanceof Headers) {\n                options.headers.set(key, value);\n            }\n            else if (options.headers instanceof Array) {\n                let i = 0;\n                const l = options.headers.length;\n                for (; i < l; i++) {\n                    const header = options.headers[i];\n                    if (header[0] === key) {\n                        header[1] = value;\n                        break;\n                    }\n                }\n                if (i === l) {\n                    options.headers.push([key, value]);\n                }\n            }\n            else {\n                Object.assign(options.headers, { [key]: value });\n            }\n        }\n    }\n};\n/**\n * @constant\n * To append the header value to the given request\n * @param {RequestInfo} request - The request object or the url string\n * @param {FetchOptions|undefined} options - The request options object\n * @param {string} key - The header key string\n * @param {string } value - The header value string\n * @returns Nothing\n */\nconst appendRequestHeader = (request, options, key, value) => {\n    if (typeof Request !== "undefined" && request instanceof Request) {\n        request.headers.append(key, value);\n    }\n    else if (typeof options !== "undefined") {\n        if (options.headers === undefined) {\n            options.headers = new Headers({\n                [key]: value,\n            });\n        }\n        else {\n            if (typeof Headers !== "undefined" && options.headers instanceof Headers) {\n                options.headers.append(key, value);\n            }\n            else if (options.headers instanceof Array) {\n                options.headers.push([key, value]);\n            }\n            else if (options.headers === undefined) {\n                options.headers = { [key]: value };\n            }\n            else if (options.headers[key] === undefined) {\n                options.headers[key] = value;\n            }\n            else {\n                options.headers[key] += `, ${value}`;\n            }\n        }\n    }\n};\n/**\n * @constant\n * To clone the request with the new url\n * @param {string} url - The new url string\n * @param {Request} request - The request object\n * @returns A promise that resolves to request object\n */\nconst cloneRequestWithNewUrl = (newUrl, request) => __awaiter(void 0, void 0, void 0, function* () {\n    const body = request.headers.get("Content-Type") ? yield request.blob() : yield Promise.resolve(undefined);\n    const { method, headers, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal } = request;\n    return new Request(newUrl, { method, headers, body, referrer, referrerPolicy, mode, credentials, cache, redirect, integrity, keepalive, signal });\n});\n//# sourceMappingURL=MiddlewareUtil.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/AuthenticationHandlerOptions.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @class\n * @implements MiddlewareOptions\n * Class representing AuthenticationHandlerOptions\n */\nclass AuthenticationHandlerOptions {\n    /**\n     * @public\n     * @constructor\n     * To create an instance of AuthenticationHandlerOptions\n     * @param {AuthenticationProvider} [authenticationProvider] - The authentication provider instance\n     * @param {AuthenticationProviderOptions} [authenticationProviderOptions] - The authentication provider options instance\n     * @returns An instance of AuthenticationHandlerOptions\n     */\n    constructor(authenticationProvider, authenticationProviderOptions) {\n        this.authenticationProvider = authenticationProvider;\n        this.authenticationProviderOptions = authenticationProviderOptions;\n    }\n}\n//# sourceMappingURL=AuthenticationHandlerOptions.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/TelemetryHandlerOptions.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @enum\n * @property {number} NONE - The hexadecimal flag value for nothing enabled\n * @property {number} REDIRECT_HANDLER_ENABLED - The hexadecimal flag value for redirect handler enabled\n * @property {number} RETRY_HANDLER_ENABLED - The hexadecimal flag value for retry handler enabled\n * @property {number} AUTHENTICATION_HANDLER_ENABLED - The hexadecimal flag value for the authentication handler enabled\n */\nvar FeatureUsageFlag;\n(function (FeatureUsageFlag) {\n    /* eslint-disable  @typescript-eslint/naming-convention */\n    FeatureUsageFlag[FeatureUsageFlag["NONE"] = 0] = "NONE";\n    FeatureUsageFlag[FeatureUsageFlag["REDIRECT_HANDLER_ENABLED"] = 1] = "REDIRECT_HANDLER_ENABLED";\n    FeatureUsageFlag[FeatureUsageFlag["RETRY_HANDLER_ENABLED"] = 2] = "RETRY_HANDLER_ENABLED";\n    FeatureUsageFlag[FeatureUsageFlag["AUTHENTICATION_HANDLER_ENABLED"] = 4] = "AUTHENTICATION_HANDLER_ENABLED";\n    /* eslint-enable  @typescript-eslint/naming-convention */\n})(FeatureUsageFlag || (FeatureUsageFlag = {}));\n/**\n * @class\n * @implements MiddlewareOptions\n * Class for TelemetryHandlerOptions\n */\nclass TelemetryHandlerOptions {\n    constructor() {\n        /**\n         * @private\n         * A member to hold the OR of feature usage flags\n         */\n        this.featureUsage = FeatureUsageFlag.NONE;\n    }\n    /**\n     * @public\n     * @static\n     * To update the feature usage in the context object\n     * @param {Context} context - The request context object containing middleware options\n     * @param {FeatureUsageFlag} flag - The flag value\n     * @returns nothing\n     */\n    static updateFeatureUsageFlag(context, flag) {\n        let options;\n        if (context.middlewareControl instanceof MiddlewareControl) {\n            options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);\n        }\n        else {\n            context.middlewareControl = new MiddlewareControl();\n        }\n        if (typeof options === "undefined") {\n            options = new TelemetryHandlerOptions();\n            context.middlewareControl.setMiddlewareOptions(TelemetryHandlerOptions, options);\n        }\n        options.setFeatureUsage(flag);\n    }\n    /**\n     * @private\n     * To set the feature usage flag\n     * @param {FeatureUsageFlag} flag - The flag value\n     * @returns nothing\n     */\n    setFeatureUsage(flag) {\n        this.featureUsage = this.featureUsage | flag;\n    }\n    /**\n     * @public\n     * To get the feature usage\n     * @returns A feature usage flag as hexadecimal string\n     */\n    getFeatureUsage() {\n        return this.featureUsage.toString(16);\n    }\n}\n//# sourceMappingURL=TelemetryHandlerOptions.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/AuthenticationHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module AuthenticationHandler\n */\n\n\n\n\n\n/**\n * @class\n * @implements Middleware\n * Class representing AuthenticationHandler\n */\nclass AuthenticationHandler {\n    /**\n     * @public\n     * @constructor\n     * Creates an instance of AuthenticationHandler\n     * @param {AuthenticationProvider} authenticationProvider - The authentication provider for the authentication handler\n     */\n    constructor(authenticationProvider) {\n        this.authenticationProvider = authenticationProvider;\n    }\n    /**\n     * @public\n     * @async\n     * To execute the current middleware\n     * @param {Context} context - The context object of the request\n     * @returns A Promise that resolves to nothing\n     */\n    execute(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = typeof context.request === "string" ? context.request : context.request.url;\n            if (isGraphURL(url) || (context.customHosts && isCustomHost(url, context.customHosts))) {\n                let options;\n                if (context.middlewareControl instanceof MiddlewareControl) {\n                    options = context.middlewareControl.getMiddlewareOptions(AuthenticationHandlerOptions);\n                }\n                let authenticationProvider;\n                let authenticationProviderOptions;\n                if (options) {\n                    authenticationProvider = options.authenticationProvider;\n                    authenticationProviderOptions = options.authenticationProviderOptions;\n                }\n                if (!authenticationProvider) {\n                    authenticationProvider = this.authenticationProvider;\n                }\n                const token = yield authenticationProvider.getAccessToken(authenticationProviderOptions);\n                const bearerKey = `Bearer ${token}`;\n                appendRequestHeader(context.request, context.options, AuthenticationHandler.AUTHORIZATION_HEADER, bearerKey);\n                TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.AUTHENTICATION_HANDLER_ENABLED);\n            }\n            else {\n                if (context.options.headers) {\n                    delete context.options.headers[AuthenticationHandler.AUTHORIZATION_HEADER];\n                }\n            }\n            return yield this.nextMiddleware.execute(context);\n        });\n    }\n    /**\n     * @public\n     * To set the next middleware in the chain\n     * @param {Middleware} next - The middleware instance\n     * @returns Nothing\n     */\n    setNext(next) {\n        this.nextMiddleware = next;\n    }\n}\n/**\n * @private\n * A member representing the authorization header name\n */\nAuthenticationHandler.AUTHORIZATION_HEADER = "Authorization";\n//# sourceMappingURL=AuthenticationHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/HTTPMessageHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @class\n * @implements Middleware\n * Class for HTTPMessageHandler\n */\nclass HTTPMessageHandler {\n    /**\n     * @public\n     * @async\n     * To execute the current middleware\n     * @param {Context} context - The request context object\n     * @returns A promise that resolves to nothing\n     */\n    execute(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            context.response = yield fetch(context.request, context.options);\n        });\n    }\n}\n//# sourceMappingURL=HTTPMessageHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RetryHandlerOptions.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @class\n * @implements MiddlewareOptions\n * Class for RetryHandlerOptions\n */\nclass RetryHandlerOptions {\n    /**\n     * @public\n     * @constructor\n     * To create an instance of RetryHandlerOptions\n     * @param {number} [delay = RetryHandlerOptions.DEFAULT_DELAY] - The delay value in seconds\n     * @param {number} [maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES] - The maxRetries value\n     * @param {ShouldRetry} [shouldRetry = RetryHandlerOptions.DEFAULT_SHOULD_RETRY] - The shouldRetry callback function\n     * @returns An instance of RetryHandlerOptions\n     */\n    constructor(delay = RetryHandlerOptions.DEFAULT_DELAY, maxRetries = RetryHandlerOptions.DEFAULT_MAX_RETRIES, shouldRetry = RetryHandlerOptions.defaultShouldRetry) {\n        if (delay > RetryHandlerOptions.MAX_DELAY && maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {\n            const error = new Error(`Delay and MaxRetries should not be more than ${RetryHandlerOptions.MAX_DELAY} and ${RetryHandlerOptions.MAX_MAX_RETRIES}`);\n            error.name = "MaxLimitExceeded";\n            throw error;\n        }\n        else if (delay > RetryHandlerOptions.MAX_DELAY) {\n            const error = new Error(`Delay should not be more than ${RetryHandlerOptions.MAX_DELAY}`);\n            error.name = "MaxLimitExceeded";\n            throw error;\n        }\n        else if (maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {\n            const error = new Error(`MaxRetries should not be more than ${RetryHandlerOptions.MAX_MAX_RETRIES}`);\n            error.name = "MaxLimitExceeded";\n            throw error;\n        }\n        else if (delay < 0 && maxRetries < 0) {\n            const error = new Error(`Delay and MaxRetries should not be negative`);\n            error.name = "MinExpectationNotMet";\n            throw error;\n        }\n        else if (delay < 0) {\n            const error = new Error(`Delay should not be negative`);\n            error.name = "MinExpectationNotMet";\n            throw error;\n        }\n        else if (maxRetries < 0) {\n            const error = new Error(`MaxRetries should not be negative`);\n            error.name = "MinExpectationNotMet";\n            throw error;\n        }\n        this.delay = Math.min(delay, RetryHandlerOptions.MAX_DELAY);\n        this.maxRetries = Math.min(maxRetries, RetryHandlerOptions.MAX_MAX_RETRIES);\n        this.shouldRetry = shouldRetry;\n    }\n    /**\n     * @public\n     * To get the maximum delay\n     * @returns A maximum delay\n     */\n    getMaxDelay() {\n        return RetryHandlerOptions.MAX_DELAY;\n    }\n}\n/**\n * @private\n * @static\n * A member holding default delay value in seconds\n */\nRetryHandlerOptions.DEFAULT_DELAY = 3;\n/**\n * @private\n * @static\n * A member holding default maxRetries value\n */\nRetryHandlerOptions.DEFAULT_MAX_RETRIES = 3;\n/**\n * @private\n * @static\n * A member holding maximum delay value in seconds\n */\nRetryHandlerOptions.MAX_DELAY = 180;\n/**\n * @private\n * @static\n * A member holding maximum maxRetries value\n */\nRetryHandlerOptions.MAX_MAX_RETRIES = 10;\n/**\n * @private\n * A member holding default shouldRetry callback\n */\nRetryHandlerOptions.defaultShouldRetry = () => true;\n//# sourceMappingURL=RetryHandlerOptions.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RetryHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n\n\n\n\n\n/**\n * @class\n * @implements Middleware\n * Class for RetryHandler\n */\nclass RetryHandler {\n    /**\n     * @public\n     * @constructor\n     * To create an instance of RetryHandler\n     * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value\n     * @returns An instance of RetryHandler\n     */\n    constructor(options = new RetryHandlerOptions()) {\n        this.options = options;\n    }\n    /**\n     *\n     * @private\n     * To check whether the response has the retry status code\n     * @param {Response} response - The response object\n     * @returns Whether the response has retry status code or not\n     */\n    isRetry(response) {\n        return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;\n    }\n    /**\n     * @private\n     * To check whether the payload is buffered or not\n     * @param {RequestInfo} request - The url string or the request object value\n     * @param {FetchOptions} options - The options of a request\n     * @returns Whether the payload is buffered or not\n     */\n    isBuffered(request, options) {\n        const method = typeof request === "string" ? options.method : request.method;\n        const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;\n        if (isPutPatchOrPost) {\n            const isStream = getRequestHeader(request, options, "Content-Type") === "application/octet-stream";\n            if (isStream) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @private\n     * To get the delay for a retry\n     * @param {Response} response - The response object\n     * @param {number} retryAttempts - The current attempt count\n     * @param {number} delay - The delay value in seconds\n     * @returns A delay for a retry\n     */\n    getDelay(response, retryAttempts, delay) {\n        const getRandomness = () => Number(Math.random().toFixed(3));\n        const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;\n        let newDelay;\n        if (retryAfter !== null) {\n            if (Number.isNaN(Number(retryAfter))) {\n                newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);\n            }\n            else {\n                newDelay = Number(retryAfter);\n            }\n        }\n        else {\n            // Adding randomness to avoid retrying at a same\n            newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();\n        }\n        return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());\n    }\n    /**\n     * @private\n     * To get an exponential back off value\n     * @param {number} attempts - The current attempt count\n     * @returns An exponential back off value\n     */\n    getExponentialBackOffTime(attempts) {\n        return Math.round((1 / 2) * (Math.pow(2, attempts) - 1));\n    }\n    /**\n     * @private\n     * @async\n     * To add delay for the execution\n     * @param {number} delaySeconds - The delay value in seconds\n     * @returns Nothing\n     */\n    sleep(delaySeconds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const delayMilliseconds = delaySeconds * 1000;\n            return new Promise((resolve) => setTimeout(resolve, delayMilliseconds));\n        });\n    }\n    getOptions(context) {\n        let options;\n        if (context.middlewareControl instanceof MiddlewareControl) {\n            options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);\n        }\n        if (typeof options === "undefined") {\n            options = Object.assign(new RetryHandlerOptions(), this.options);\n        }\n        return options;\n    }\n    /**\n     * @private\n     * @async\n     * To execute the middleware with retries\n     * @param {Context} context - The context object\n     * @param {number} retryAttempts - The current attempt count\n     * @param {RetryHandlerOptions} options - The retry middleware options instance\n     * @returns A Promise that resolves to nothing\n     */\n    executeWithRetry(context, retryAttempts, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.nextMiddleware.execute(context);\n            if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {\n                ++retryAttempts;\n                setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());\n                const delay = this.getDelay(context.response, retryAttempts, options.delay);\n                yield this.sleep(delay);\n                return yield this.executeWithRetry(context, retryAttempts, options);\n            }\n            else {\n                return;\n            }\n        });\n    }\n    /**\n     * @public\n     * @async\n     * To execute the current middleware\n     * @param {Context} context - The context object of the request\n     * @returns A Promise that resolves to nothing\n     */\n    execute(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const retryAttempts = 0;\n            const options = this.getOptions(context);\n            TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);\n            return yield this.executeWithRetry(context, retryAttempts, options);\n        });\n    }\n    /**\n     * @public\n     * To set the next middleware in the chain\n     * @param {Middleware} next - The middleware instance\n     * @returns Nothing\n     */\n    setNext(next) {\n        this.nextMiddleware = next;\n    }\n}\n/**\n * @private\n * @static\n * A list of status codes that needs to be retried\n */\nRetryHandler.RETRY_STATUS_CODES = [\n    429,\n    503,\n    504, // Gateway timeout\n];\n/**\n * @private\n * @static\n * A member holding the name of retry attempt header\n */\nRetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt";\n/**\n * @private\n * @static\n * A member holding the name of retry after header\n */\nRetryHandler.RETRY_AFTER_HEADER = "Retry-After";\n//# sourceMappingURL=RetryHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/RedirectHandlerOptions.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @class\n * @implements MiddlewareOptions\n * A class representing RedirectHandlerOptions\n */\nclass RedirectHandlerOptions {\n    /**\n     * @public\n     * @constructor\n     * To create an instance of RedirectHandlerOptions\n     * @param {number} [maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS] - The max redirects value\n     * @param {ShouldRedirect} [shouldRedirect = RedirectHandlerOptions.DEFAULT_SHOULD_RETRY] - The should redirect callback\n     * @returns An instance of RedirectHandlerOptions\n     */\n    constructor(maxRedirects = RedirectHandlerOptions.DEFAULT_MAX_REDIRECTS, shouldRedirect = RedirectHandlerOptions.defaultShouldRedirect) {\n        if (maxRedirects > RedirectHandlerOptions.MAX_MAX_REDIRECTS) {\n            const error = new Error(`MaxRedirects should not be more than ${RedirectHandlerOptions.MAX_MAX_REDIRECTS}`);\n            error.name = "MaxLimitExceeded";\n            throw error;\n        }\n        if (maxRedirects < 0) {\n            const error = new Error(`MaxRedirects should not be negative`);\n            error.name = "MinExpectationNotMet";\n            throw error;\n        }\n        this.maxRedirects = maxRedirects;\n        this.shouldRedirect = shouldRedirect;\n    }\n}\n/**\n * @private\n * @static\n * A member holding default max redirects value\n */\nRedirectHandlerOptions.DEFAULT_MAX_REDIRECTS = 5;\n/**\n * @private\n * @static\n * A member holding maximum max redirects value\n */\nRedirectHandlerOptions.MAX_MAX_REDIRECTS = 20;\n/**\n * @private\n * A member holding default shouldRedirect callback\n */\nRedirectHandlerOptions.defaultShouldRedirect = () => true;\n//# sourceMappingURL=RedirectHandlerOptions.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/RedirectHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n\n\n\n\n\n/**\n * @class\n * Class\n * @implements Middleware\n * Class representing RedirectHandler\n */\nclass RedirectHandler {\n    /**\n     * @public\n     * @constructor\n     * To create an instance of RedirectHandler\n     * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance\n     * @returns An instance of RedirectHandler\n     */\n    constructor(options = new RedirectHandlerOptions()) {\n        this.options = options;\n    }\n    /**\n     * @private\n     * To check whether the response has the redirect status code or not\n     * @param {Response} response - The response object\n     * @returns A boolean representing whether the response contains the redirect status code or not\n     */\n    isRedirect(response) {\n        return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;\n    }\n    /**\n     * @private\n     * To check whether the response has location header or not\n     * @param {Response} response - The response object\n     * @returns A boolean representing the whether the response has location header or not\n     */\n    hasLocationHeader(response) {\n        return response.headers.has(RedirectHandler.LOCATION_HEADER);\n    }\n    /**\n     * @private\n     * To get the redirect url from location header in response object\n     * @param {Response} response - The response object\n     * @returns A redirect url from location header\n     */\n    getLocationHeader(response) {\n        return response.headers.get(RedirectHandler.LOCATION_HEADER);\n    }\n    /**\n     * @private\n     * To check whether the given url is a relative url or not\n     * @param {string} url - The url string value\n     * @returns A boolean representing whether the given url is a relative url or not\n     */\n    isRelativeURL(url) {\n        return url.indexOf("://") === -1;\n    }\n    /**\n     * @private\n     * To check whether the authorization header in the request should be dropped for consequent redirected requests\n     * @param {string} requestUrl - The request url value\n     * @param {string} redirectUrl - The redirect url value\n     * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests\n     */\n    shouldDropAuthorizationHeader(requestUrl, redirectUrl) {\n        const schemeHostRegex = /^[A-Za-z].+?:\\/\\/.+?(?=\\/|$)/;\n        const requestMatches = schemeHostRegex.exec(requestUrl);\n        let requestAuthority;\n        let redirectAuthority;\n        if (requestMatches !== null) {\n            requestAuthority = requestMatches[0];\n        }\n        const redirectMatches = schemeHostRegex.exec(redirectUrl);\n        if (redirectMatches !== null) {\n            redirectAuthority = redirectMatches[0];\n        }\n        return typeof requestAuthority !== "undefined" && typeof redirectAuthority !== "undefined" && requestAuthority !== redirectAuthority;\n    }\n    /**\n     * @private\n     * @async\n     * To update a request url with the redirect url\n     * @param {string} redirectUrl - The redirect url value\n     * @param {Context} context - The context object value\n     * @returns Nothing\n     */\n    updateRequestUrl(redirectUrl, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            context.request = typeof context.request === "string" ? redirectUrl : yield cloneRequestWithNewUrl(redirectUrl, context.request);\n        });\n    }\n    /**\n     * @private\n     * To get the options for execution of the middleware\n     * @param {Context} context - The context object\n     * @returns A options for middleware execution\n     */\n    getOptions(context) {\n        let options;\n        if (context.middlewareControl instanceof MiddlewareControl) {\n            options = context.middlewareControl.getMiddlewareOptions(RedirectHandlerOptions);\n        }\n        if (typeof options === "undefined") {\n            options = Object.assign(new RedirectHandlerOptions(), this.options);\n        }\n        return options;\n    }\n    /**\n     * @private\n     * @async\n     * To execute the next middleware and to handle in case of redirect response returned by the server\n     * @param {Context} context - The context object\n     * @param {number} redirectCount - The redirect count value\n     * @param {RedirectHandlerOptions} options - The redirect handler options instance\n     * @returns A promise that resolves to nothing\n     */\n    executeWithRedirect(context, redirectCount, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.nextMiddleware.execute(context);\n            const response = context.response;\n            if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {\n                ++redirectCount;\n                if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {\n                    context.options.method = RequestMethod.GET;\n                    delete context.options.body;\n                }\n                else {\n                    const redirectUrl = this.getLocationHeader(response);\n                    if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {\n                        delete context.options.headers[RedirectHandler.AUTHORIZATION_HEADER];\n                    }\n                    yield this.updateRequestUrl(redirectUrl, context);\n                }\n                yield this.executeWithRedirect(context, redirectCount, options);\n            }\n            else {\n                return;\n            }\n        });\n    }\n    /**\n     * @public\n     * @async\n     * To execute the current middleware\n     * @param {Context} context - The context object of the request\n     * @returns A Promise that resolves to nothing\n     */\n    execute(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const redirectCount = 0;\n            const options = this.getOptions(context);\n            context.options.redirect = RedirectHandler.MANUAL_REDIRECT;\n            TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.REDIRECT_HANDLER_ENABLED);\n            return yield this.executeWithRedirect(context, redirectCount, options);\n        });\n    }\n    /**\n     * @public\n     * To set the next middleware in the chain\n     * @param {Middleware} next - The middleware instance\n     * @returns Nothing\n     */\n    setNext(next) {\n        this.nextMiddleware = next;\n    }\n}\n/**\n * @private\n * @static\n * A member holding the array of redirect status codes\n */\nRedirectHandler.REDIRECT_STATUS_CODES = [\n    301,\n    302,\n    303,\n    307,\n    308, // Moved Permanently\n];\n/**\n * @private\n * @static\n * A member holding SeeOther status code\n */\nRedirectHandler.STATUS_CODE_SEE_OTHER = 303;\n/**\n * @private\n * @static\n * A member holding the name of the location header\n */\nRedirectHandler.LOCATION_HEADER = "Location";\n/**\n * @private\n * @static\n * A member representing the authorization header name\n */\nRedirectHandler.AUTHORIZATION_HEADER = "Authorization";\n/**\n * @private\n * @static\n * A member holding the manual redirect value\n */\nRedirectHandler.MANUAL_REDIRECT = "manual";\n//# sourceMappingURL=RedirectHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/Version.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n// THIS FILE IS AUTO GENERATED\n// ANY CHANGES WILL BE LOST DURING BUILD\n/**\n * @module Version\n */\nconst PACKAGE_VERSION = "3.0.7";\n//# sourceMappingURL=Version.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/TelemetryHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module TelemetryHandler\n */\n\n\n\n\n\n/**\n * @class\n * @implements Middleware\n * Class for TelemetryHandler\n */\nclass TelemetryHandler {\n    /**\n     * @public\n     * @async\n     * To execute the current middleware\n     * @param {Context} context - The context object of the request\n     * @returns A Promise that resolves to nothing\n     */\n    execute(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = typeof context.request === "string" ? context.request : context.request.url;\n            if (isGraphURL(url) || (context.customHosts && isCustomHost(url, context.customHosts))) {\n                // Add telemetry only if the request url is a Graph URL.\n                // Errors are reported as in issue #265 if headers are present when redirecting to a non Graph URL\n                let clientRequestId = getRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER);\n                if (!clientRequestId) {\n                    clientRequestId = generateUUID();\n                    setRequestHeader(context.request, context.options, TelemetryHandler.CLIENT_REQUEST_ID_HEADER, clientRequestId);\n                }\n                let sdkVersionValue = `${TelemetryHandler.PRODUCT_NAME}/${PACKAGE_VERSION}`;\n                let options;\n                if (context.middlewareControl instanceof MiddlewareControl) {\n                    options = context.middlewareControl.getMiddlewareOptions(TelemetryHandlerOptions);\n                }\n                if (options) {\n                    const featureUsage = options.getFeatureUsage();\n                    sdkVersionValue += ` (${TelemetryHandler.FEATURE_USAGE_STRING}=${featureUsage})`;\n                }\n                appendRequestHeader(context.request, context.options, TelemetryHandler.SDK_VERSION_HEADER, sdkVersionValue);\n            }\n            else {\n                // Remove telemetry headers if present during redirection.\n                delete context.options.headers[TelemetryHandler.CLIENT_REQUEST_ID_HEADER];\n                delete context.options.headers[TelemetryHandler.SDK_VERSION_HEADER];\n            }\n            return yield this.nextMiddleware.execute(context);\n        });\n    }\n    /**\n     * @public\n     * To set the next middleware in the chain\n     * @param {Middleware} next - The middleware instance\n     * @returns Nothing\n     */\n    setNext(next) {\n        this.nextMiddleware = next;\n    }\n}\n/**\n * @private\n * @static\n * A member holding the name of the client request id header\n */\nTelemetryHandler.CLIENT_REQUEST_ID_HEADER = "client-request-id";\n/**\n * @private\n * @static\n * A member holding the name of the sdk version header\n */\nTelemetryHandler.SDK_VERSION_HEADER = "SdkVersion";\n/**\n * @private\n * @static\n * A member holding the language prefix for the sdk version header value\n */\nTelemetryHandler.PRODUCT_NAME = "graph-js";\n/**\n * @private\n * @static\n * A member holding the key for the feature usage metrics\n */\nTelemetryHandler.FEATURE_USAGE_STRING = "featureUsage";\n//# sourceMappingURL=TelemetryHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/MiddlewareFactory.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n\n\n\n\n\n\n/**\n * @private\n * To check whether the environment is node or not\n * @returns A boolean representing the environment is node or not\n */\nconst isNodeEnvironment = () => {\n    return typeof process === "object" && "function" === "function";\n};\n/**\n * @class\n * Class containing function(s) related to the middleware pipelines.\n */\nclass MiddlewareFactory {\n    /**\n     * @public\n     * @static\n     * Returns the default middleware chain an array with the  middleware handlers\n     * @param {AuthenticationProvider} authProvider - The authentication provider instance\n     * @returns an array of the middleware handlers of the default middleware chain\n     */\n    static getDefaultMiddlewareChain(authProvider) {\n        const middleware = [];\n        const authenticationHandler = new AuthenticationHandler(authProvider);\n        const retryHandler = new RetryHandler(new RetryHandlerOptions());\n        const telemetryHandler = new TelemetryHandler();\n        const httpMessageHandler = new HTTPMessageHandler();\n        middleware.push(authenticationHandler);\n        middleware.push(retryHandler);\n        if (isNodeEnvironment()) {\n            const redirectHandler = new RedirectHandler(new RedirectHandlerOptions());\n            middleware.push(redirectHandler);\n        }\n        middleware.push(telemetryHandler);\n        middleware.push(httpMessageHandler);\n        return middleware;\n    }\n}\n//# sourceMappingURL=MiddlewareFactory.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosStrategy.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module ChaosStrategy\n */\n/**\n * Strategy used for Testing Handler\n * @enum\n */\nvar ChaosStrategy;\n(function (ChaosStrategy) {\n    ChaosStrategy[ChaosStrategy["MANUAL"] = 0] = "MANUAL";\n    ChaosStrategy[ChaosStrategy["RANDOM"] = 1] = "RANDOM";\n})(ChaosStrategy || (ChaosStrategy = {}));\n//# sourceMappingURL=ChaosStrategy.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosHandlerOptions.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module ChaosHandlerOptions\n */\n\n/**\n * Class representing ChaosHandlerOptions\n * @class\n * Class\n * @implements MiddlewareOptions\n */\nclass ChaosHandlerOptions {\n    /**\n     * @public\n     * @constructor\n     * To create an instance of Testing Handler Options\n     * @param {ChaosStrategy} chaosStrategy - Specifies the startegy used for the Testing Handler -> RAMDOM/MANUAL\n     * @param {string} statusMessage - The Message to be returned in the response\n     * @param {number?} statusCode - The statusCode to be returned in the response\n     * @param {number?} chaosPercentage - The percentage of randomness/chaos in the handler\n     * @param {any?} responseBody - The response body to be returned in the response\n     * @returns An instance of ChaosHandlerOptions\n     */\n    constructor(chaosStrategy = ChaosStrategy.RANDOM, statusMessage = "Some error Happened", statusCode, chaosPercentage, responseBody, headers) {\n        this.chaosStrategy = chaosStrategy;\n        this.statusCode = statusCode;\n        this.statusMessage = statusMessage;\n        this.chaosPercentage = chaosPercentage !== undefined ? chaosPercentage : 10;\n        this.responseBody = responseBody;\n        this.headers = headers;\n        if (this.chaosPercentage > 100) {\n            throw new Error("Error Pecentage can not be more than 100");\n        }\n    }\n}\n//# sourceMappingURL=ChaosHandlerOptions.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/options/ChaosHandlerData.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module ChaosHandlerData\n */\n/**\n * Contains RequestMethod to corresponding array of possible status codes, used for Random mode\n */\nconst methodStatusCode = {\n    GET: [429, 500, 502, 503, 504],\n    POST: [429, 500, 502, 503, 504, 507],\n    PUT: [429, 500, 502, 503, 504, 507],\n    PATCH: [429, 500, 502, 503, 504],\n    DELETE: [429, 500, 502, 503, 504, 507],\n};\n/**\n * Contains statusCode to statusMessage map\n */\nconst httpStatusCode = {\n    100: "Continue",\n    101: "Switching Protocols",\n    102: "Processing",\n    103: "Early Hints",\n    200: "OK",\n    201: "Created",\n    202: "Accepted",\n    203: "Non-Authoritative Information",\n    204: "No Content",\n    205: "Reset Content",\n    206: "Partial Content",\n    207: "Multi-Status",\n    208: "Already Reported",\n    226: "IM Used",\n    300: "Multiple Choices",\n    301: "Moved Permanently",\n    302: "Found",\n    303: "See Other",\n    304: "Not Modified",\n    305: "Use Proxy",\n    307: "Temporary Redirect",\n    308: "Permanent Redirect",\n    400: "Bad Request",\n    401: "Unauthorized",\n    402: "Payment Required",\n    403: "Forbidden",\n    404: "Not Found",\n    405: "Method Not Allowed",\n    406: "Not Acceptable",\n    407: "Proxy Authentication Required",\n    408: "Request Timeout",\n    409: "Conflict",\n    410: "Gone",\n    411: "Length Required",\n    412: "Precondition Failed",\n    413: "Payload Too Large",\n    414: "URI Too Long",\n    415: "Unsupported Media Type",\n    416: "Range Not Satisfiable",\n    417: "Expectation Failed",\n    421: "Misdirected Request",\n    422: "Unprocessable Entity",\n    423: "Locked",\n    424: "Failed Dependency",\n    425: "Too Early",\n    426: "Upgrade Required",\n    428: "Precondition Required",\n    429: "Too Many Requests",\n    431: "Request Header Fields Too Large",\n    451: "Unavailable For Legal Reasons",\n    500: "Internal Server Error",\n    501: "Not Implemented",\n    502: "Bad Gateway",\n    503: "Service Unavailable",\n    504: "Gateway Timeout",\n    505: "HTTP Version Not Supported",\n    506: "Variant Also Negotiates",\n    507: "Insufficient Storage",\n    508: "Loop Detected",\n    510: "Not Extended",\n    511: "Network Authentication Required",\n};\n//# sourceMappingURL=ChaosHandlerData.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/middleware/ChaosHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n\n\n\n\n\n/**\n * Class representing ChaosHandler\n * @class\n * Class\n * @implements Middleware\n */\nclass ChaosHandler {\n    /**\n     * @public\n     * @constructor\n     * To create an instance of Testing Handler\n     * @param {ChaosHandlerOptions} [options = new ChaosHandlerOptions()] - The testing handler options instance\n     * @param manualMap - The Map passed by user containing url-statusCode info\n     * @returns An instance of Testing Handler\n     */\n    constructor(options = new ChaosHandlerOptions(), manualMap) {\n        this.options = options;\n        this.manualMap = manualMap;\n    }\n    /**\n     * Generates responseHeader\n     * @private\n     * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n     * @param {string} requestID - request id\n     * @param {string} requestDate - date of the request\n     * @returns response Header\n     */\n    createResponseHeaders(chaosHandlerOptions, requestID, requestDate) {\n        const responseHeader = chaosHandlerOptions.headers ? new Headers(chaosHandlerOptions.headers) : new Headers();\n        responseHeader.append("Cache-Control", "no-store");\n        responseHeader.append("request-id", requestID);\n        responseHeader.append("client-request-id", requestID);\n        responseHeader.append("x-ms-ags-diagnostic", "");\n        responseHeader.append("Date", requestDate);\n        responseHeader.append("Strict-Transport-Security", "");\n        if (chaosHandlerOptions.statusCode === 429) {\n            // throttling case has to have a timeout scenario\n            responseHeader.append("retry-after", "3");\n        }\n        return responseHeader;\n    }\n    /**\n     * Generates responseBody\n     * @private\n     * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n     * @param {string} requestID - request id\n     * @param {string} requestDate - date of the request\n     *  * @returns response body\n     */\n    createResponseBody(chaosHandlerOptions, requestID, requestDate) {\n        if (chaosHandlerOptions.responseBody) {\n            return chaosHandlerOptions.responseBody;\n        }\n        let body;\n        if (chaosHandlerOptions.statusCode >= 400) {\n            const codeMessage = httpStatusCode[chaosHandlerOptions.statusCode];\n            const errMessage = chaosHandlerOptions.statusMessage;\n            body = {\n                error: {\n                    code: codeMessage,\n                    message: errMessage,\n                    innerError: {\n                        "request-id": requestID,\n                        date: requestDate,\n                    },\n                },\n            };\n        }\n        else {\n            body = {};\n        }\n        return body;\n    }\n    /**\n     * creates a response\n     * @private\n     * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n     * @param {Context} context - Contains the context of the request\n     */\n    createResponse(chaosHandlerOptions, context) {\n        const requestURL = context.request;\n        const requestID = generateUUID();\n        const requestDate = new Date();\n        const responseHeader = this.createResponseHeaders(chaosHandlerOptions, requestID, requestDate.toString());\n        const responseBody = this.createResponseBody(chaosHandlerOptions, requestID, requestDate.toString());\n        const init = { url: requestURL, status: chaosHandlerOptions.statusCode, statusText: chaosHandlerOptions.statusMessage, headers: responseHeader };\n        context.response = new Response(typeof responseBody === "string" ? responseBody : JSON.stringify(responseBody), init);\n    }\n    /**\n     * Decides whether to send the request to the graph or not\n     * @private\n     * @param {ChaosHandlerOptions} chaosHandlerOptions - A ChaosHandlerOptions object\n     * @param {Context} context - Contains the context of the request\n     * @returns nothing\n     */\n    sendRequest(chaosHandlerOptions, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.setStatusCode(chaosHandlerOptions, context.request, context.options.method);\n            if ((chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL && !this.nextMiddleware) || Math.floor(Math.random() * 100) < chaosHandlerOptions.chaosPercentage) {\n                this.createResponse(chaosHandlerOptions, context);\n            }\n            else if (this.nextMiddleware) {\n                yield this.nextMiddleware.execute(context);\n            }\n        });\n    }\n    /**\n     * Fetches a random status code for the RANDOM mode from the predefined array\n     * @private\n     * @param {string} requestMethod - the API method for the request\n     * @returns a random status code from a given set of status codes\n     */\n    getRandomStatusCode(requestMethod) {\n        const statusCodeArray = methodStatusCode[requestMethod];\n        return statusCodeArray[Math.floor(Math.random() * statusCodeArray.length)];\n    }\n    /**\n     * To fetch the relative URL out of the complete URL using a predefined regex pattern\n     * @private\n     * @param {string} urlMethod - the complete URL\n     * @returns the string as relative URL\n     */\n    getRelativeURL(urlMethod) {\n        const pattern = /https?:\\/\\/graph\\.microsoft\\.com\\/[^/]+(.+?)(\\?|$)/;\n        let relativeURL;\n        if (pattern.exec(urlMethod) !== null) {\n            relativeURL = pattern.exec(urlMethod)[1];\n        }\n        return relativeURL;\n    }\n    /**\n     * To fetch the status code from the map(if needed), then returns response by calling createResponse\n     * @private\n     * @param {ChaosHandlerOptions} chaosHandlerOptions - The ChaosHandlerOptions object\n     * @param {string} requestURL - the URL for the request\n     * @param {string} requestMethod - the API method for the request\n     */\n    setStatusCode(chaosHandlerOptions, requestURL, requestMethod) {\n        if (chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL) {\n            if (chaosHandlerOptions.statusCode === undefined) {\n                // manual mode with no status code, can be a global level or request level without statusCode\n                const relativeURL = this.getRelativeURL(requestURL);\n                if (this.manualMap.get(relativeURL) !== undefined) {\n                    // checking Manual Map for exact match\n                    if (this.manualMap.get(relativeURL).get(requestMethod) !== undefined) {\n                        chaosHandlerOptions.statusCode = this.manualMap.get(relativeURL).get(requestMethod);\n                    }\n                    // else statusCode would be undefined\n                }\n                else {\n                    // checking for regex match if exact match doesn\'t work\n                    this.manualMap.forEach((value, key) => {\n                        const regexURL = new RegExp(key + "$");\n                        if (regexURL.test(relativeURL)) {\n                            if (this.manualMap.get(key).get(requestMethod) !== undefined) {\n                                chaosHandlerOptions.statusCode = this.manualMap.get(key).get(requestMethod);\n                            }\n                            // else statusCode would be undefined\n                        }\n                    });\n                }\n                // Case of redirection or request url not in map ---\x3e statusCode would be undefined\n            }\n        }\n        else {\n            // Handling the case of Random here\n            chaosHandlerOptions.statusCode = this.getRandomStatusCode(requestMethod);\n            // else statusCode would be undefined\n        }\n    }\n    /**\n     * To get the options for execution of the middleware\n     * @private\n     * @param {Context} context - The context object\n     * @returns options for middleware execution\n     */\n    getOptions(context) {\n        let options;\n        if (context.middlewareControl instanceof MiddlewareControl) {\n            options = context.middlewareControl.getMiddlewareOptions(ChaosHandlerOptions);\n        }\n        if (typeof options === "undefined") {\n            options = Object.assign(new ChaosHandlerOptions(), this.options);\n        }\n        return options;\n    }\n    /**\n     * To execute the current middleware\n     * @public\n     * @async\n     * @param {Context} context - The context object of the request\n     * @returns A Promise that resolves to nothing\n     */\n    execute(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const chaosHandlerOptions = this.getOptions(context);\n            return yield this.sendRequest(chaosHandlerOptions, context);\n        });\n    }\n    /**\n     * @public\n     * To set the next middleware in the chain\n     * @param {Middleware} next - The middleware instance\n     * @returns Nothing\n     */\n    setNext(next) {\n        this.nextMiddleware = next;\n    }\n}\n//# sourceMappingURL=ChaosHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/ResponseType.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @enum\n * Enum for ResponseType values\n * @property {string} ARRAYBUFFER - To download response content as an [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}\n * @property {string} BLOB - To download content as a [binary/blob] {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob}\n * @property {string} DOCUMENT - This downloads content as a document or stream\n * @property {string} JSON - To download response content as a json\n * @property {string} STREAM - To download response as a [stream]{@link https://nodejs.org/api/stream.html}\n * @property {string} TEXT - For downloading response as a text\n */\nvar ResponseType;\n(function (ResponseType) {\n    ResponseType["ARRAYBUFFER"] = "arraybuffer";\n    ResponseType["BLOB"] = "blob";\n    ResponseType["DOCUMENT"] = "document";\n    ResponseType["JSON"] = "json";\n    ResponseType["RAW"] = "raw";\n    ResponseType["STREAM"] = "stream";\n    ResponseType["TEXT"] = "text";\n})(ResponseType || (ResponseType = {}));\n//# sourceMappingURL=ResponseType.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphResponseHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n\n/**\n * @enum\n * Enum for document types\n * @property {string} TEXT_HTML - The text/html content type\n * @property {string} TEXT_XML - The text/xml content type\n * @property {string} APPLICATION_XML - The application/xml content type\n * @property {string} APPLICATION_XHTML - The application/xhml+xml content type\n */\nvar DocumentType;\n(function (DocumentType) {\n    DocumentType["TEXT_HTML"] = "text/html";\n    DocumentType["TEXT_XML"] = "text/xml";\n    DocumentType["APPLICATION_XML"] = "application/xml";\n    DocumentType["APPLICATION_XHTML"] = "application/xhtml+xml";\n})(DocumentType || (DocumentType = {}));\n/**\n * @enum\n * Enum for Content types\n * @property {string} TEXT_PLAIN - The text/plain content type\n * @property {string} APPLICATION_JSON - The application/json content type\n */\nvar ContentType;\n(function (ContentType) {\n    ContentType["TEXT_PLAIN"] = "text/plain";\n    ContentType["APPLICATION_JSON"] = "application/json";\n})(ContentType || (ContentType = {}));\n/**\n * @enum\n * Enum for Content type regex\n * @property {string} DOCUMENT - The regex to match document content types\n * @property {string} IMAGE - The regex to match image content types\n */\nvar ContentTypeRegexStr;\n(function (ContentTypeRegexStr) {\n    ContentTypeRegexStr["DOCUMENT"] = "^(text\\\\/(html|xml))|(application\\\\/(xml|xhtml\\\\+xml))$";\n    ContentTypeRegexStr["IMAGE"] = "^image\\\\/.+";\n})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));\n/**\n * @class\n * Class for GraphResponseHandler\n */\nclass GraphResponseHandler {\n    /**\n     * @private\n     * @static\n     * To parse Document response\n     * @param {Response} rawResponse - The response object\n     * @param {DocumentType} type - The type to which the document needs to be parsed\n     * @returns A promise that resolves to a document content\n     */\n    static parseDocumentResponse(rawResponse, type) {\n        if (typeof DOMParser !== "undefined") {\n            return new Promise((resolve, reject) => {\n                rawResponse.text().then((xmlString) => {\n                    try {\n                        const parser = new DOMParser();\n                        const xmlDoc = parser.parseFromString(xmlString, type);\n                        resolve(xmlDoc);\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                });\n            });\n        }\n        else {\n            return Promise.resolve(rawResponse.body);\n        }\n    }\n    /**\n     * @private\n     * @static\n     * @async\n     * To convert the native Response to response content\n     * @param {Response} rawResponse - The response object\n     * @param {ResponseType} [responseType] - The response type value\n     * @returns A promise that resolves to the converted response content\n     */\n    static convertResponse(rawResponse, responseType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (rawResponse.status === 204) {\n                // NO CONTENT\n                return Promise.resolve();\n            }\n            let responseValue;\n            const contentType = rawResponse.headers.get("Content-type");\n            switch (responseType) {\n                case ResponseType.ARRAYBUFFER:\n                    responseValue = yield rawResponse.arrayBuffer();\n                    break;\n                case ResponseType.BLOB:\n                    responseValue = yield rawResponse.blob();\n                    break;\n                case ResponseType.DOCUMENT:\n                    responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);\n                    break;\n                case ResponseType.JSON:\n                    responseValue = yield rawResponse.json();\n                    break;\n                case ResponseType.STREAM:\n                    responseValue = yield Promise.resolve(rawResponse.body);\n                    break;\n                case ResponseType.TEXT:\n                    responseValue = yield rawResponse.text();\n                    break;\n                default:\n                    if (contentType !== null) {\n                        const mimeType = contentType.split(";")[0];\n                        if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {\n                            responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);\n                        }\n                        else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {\n                            responseValue = rawResponse.blob();\n                        }\n                        else if (mimeType === ContentType.TEXT_PLAIN) {\n                            responseValue = yield rawResponse.text();\n                        }\n                        else if (mimeType === ContentType.APPLICATION_JSON) {\n                            responseValue = yield rawResponse.json();\n                        }\n                        else {\n                            responseValue = Promise.resolve(rawResponse.body);\n                        }\n                    }\n                    else {\n                        /**\n                         * RFC specification {@link https://tools.ietf.org/html/rfc7231#section-3.1.1.5} says:\n                         *  A sender that generates a message containing a payload body SHOULD\n                         *  generate a Content-Type header field in that message unless the\n                         *  intended media type of the enclosed representation is unknown to the\n                         *  sender.  If a Content-Type header field is not present, the recipient\n                         *  MAY either assume a media type of "application/octet-stream"\n                         *  ([RFC2046], Section 4.5.1) or examine the data to determine its type.\n                         *\n                         *  So assuming it as a stream type so returning the body.\n                         */\n                        responseValue = Promise.resolve(rawResponse.body);\n                    }\n                    break;\n            }\n            return responseValue;\n        });\n    }\n    /**\n     * @public\n     * @static\n     * @async\n     * To get the parsed response\n     * @param {Response} rawResponse - The response object\n     * @param {ResponseType} [responseType] - The response type value\n     * @param {GraphRequestCallback} [callback] - The graph request callback function\n     * @returns The parsed response\n     */\n    static getResponse(rawResponse, responseType, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (responseType === ResponseType.RAW) {\n                return Promise.resolve(rawResponse);\n            }\n            else {\n                const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);\n                if (rawResponse.ok) {\n                    // Status Code 2XX\n                    if (typeof callback === "function") {\n                        callback(null, response);\n                    }\n                    else {\n                        return response;\n                    }\n                }\n                else {\n                    // NOT OK Response\n                    throw response;\n                }\n            }\n        });\n    }\n}\n//# sourceMappingURL=GraphResponseHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/Range.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module Range\n */\n/**\n * @class\n * Class representing Range\n */\nclass Range {\n    /**\n     * @public\n     * @constructor\n     * Creates a range for given min and max values\n     * @param {number} [minVal = -1] - The minimum value.\n     * @param {number} [maxVal = -1] - The maximum value.\n     * @returns An instance of a Range\n     */\n    constructor(minVal = -1, maxVal = -1) {\n        this.minValue = minVal;\n        this.maxValue = maxVal;\n    }\n}\n//# sourceMappingURL=Range.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/UploadResult.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * Class representing a successful file upload result\n */\nclass UploadResult {\n    /**\n     * @public\n     * Get of the location value.\n     * Location value is looked up in the response header\n     */\n    get location() {\n        return this._location;\n    }\n    /**\n     * @public\n     * Set the location value\n     * Location value is looked up in the response header\n     */\n    set location(location) {\n        this._location = location;\n    }\n    /**\n     * @public\n     * Get The response body from the completed upload response\n     */\n    get responseBody() {\n        return this._responseBody;\n    }\n    /**\n     * @public\n     * Set the response body from the completed upload response\n     */\n    set responseBody(responseBody) {\n        this._responseBody = responseBody;\n    }\n    /**\n     * @public\n     * @param {responseBody} responsebody - The response body from the completed upload response\n     * @param {location} location - The location value from the headers from the completed upload response\n     */\n    constructor(responseBody, location) {\n        // Response body or the location parameter can be undefined.\n        this._location = location;\n        this._responseBody = responseBody;\n    }\n    /**\n     * @public\n     * @param {responseBody} responseBody - The response body from the completed upload response\n     * @param {responseHeaders} responseHeaders - The headers from the completed upload response\n     */\n    static CreateUploadResult(responseBody, responseHeaders) {\n        return new UploadResult(responseBody, responseHeaders.get("location"));\n    }\n}\n//# sourceMappingURL=UploadResult.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/LargeFileUploadTask.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module LargeFileUploadTask\n */\n\n\n\n\n\n/**\n * @class\n * Class representing LargeFileUploadTask\n */\nclass LargeFileUploadTask {\n    /**\n     * @public\n     * @static\n     * @async\n     * Makes request to the server to create an upload session\n     * @param {Client} client - The GraphClient instance\n     * @param {string} requestUrl - The URL to create the upload session\n     * @param {any} payload - The payload that needs to be sent\n     * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent\n     * @returns The promise that resolves to LargeFileUploadSession\n     */\n    static createUploadSession(client, requestUrl, payload, headers = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const session = yield client\n                .api(requestUrl)\n                .headers(headers)\n                .post(payload);\n            const largeFileUploadSession = {\n                url: session.uploadUrl,\n                expiry: new Date(session.expirationDateTime),\n                isCancelled: false,\n            };\n            return largeFileUploadSession;\n        });\n    }\n    /**\n     * @public\n     * @constructor\n     * Constructs a LargeFileUploadTask\n     * @param {Client} client - The GraphClient instance\n     * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded\n     * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done\n     * @param {LargeFileUploadTaskOptions} options - The upload task options\n     * @returns An instance of LargeFileUploadTask\n     */\n    constructor(client, file, uploadSession, options = {}) {\n        /**\n         * @private\n         * Default value for the rangeSize\n         */\n        this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;\n        this.client = client;\n        if (!file.sliceFile) {\n            throw new GraphClientError("Please pass the FileUpload object, StreamUpload object or any custom implementation of the FileObject interface");\n        }\n        else {\n            this.file = file;\n        }\n        this.file = file;\n        if (!options.rangeSize) {\n            options.rangeSize = this.DEFAULT_FILE_SIZE;\n        }\n        this.options = options;\n        this.uploadSession = uploadSession;\n        this.nextRange = new Range(0, this.options.rangeSize - 1);\n    }\n    /**\n     * @private\n     * Parses given range string to the Range instance\n     * @param {string[]} ranges - The ranges value\n     * @returns The range instance\n     */\n    parseRange(ranges) {\n        const rangeStr = ranges[0];\n        if (typeof rangeStr === "undefined" || rangeStr === "") {\n            return new Range();\n        }\n        const firstRange = rangeStr.split("-");\n        const minVal = parseInt(firstRange[0], 10);\n        let maxVal = parseInt(firstRange[1], 10);\n        if (Number.isNaN(maxVal)) {\n            maxVal = this.file.size - 1;\n        }\n        return new Range(minVal, maxVal);\n    }\n    /**\n     * @private\n     * Updates the expiration date and the next range\n     * @param {UploadStatusResponse} response - The response of the upload status\n     * @returns Nothing\n     */\n    updateTaskStatus(response) {\n        this.uploadSession.expiry = new Date(response.expirationDateTime);\n        this.nextRange = this.parseRange(response.nextExpectedRanges);\n    }\n    /**\n     * @public\n     * Gets next range that needs to be uploaded\n     * @returns The range instance\n     */\n    getNextRange() {\n        if (this.nextRange.minValue === -1) {\n            return this.nextRange;\n        }\n        const minVal = this.nextRange.minValue;\n        let maxValue = minVal + this.options.rangeSize - 1;\n        if (maxValue >= this.file.size) {\n            maxValue = this.file.size - 1;\n        }\n        return new Range(minVal, maxValue);\n    }\n    /**\n     * @deprecated This function has been moved into FileObject interface.\n     * @public\n     * Slices the file content to the given range\n     * @param {Range} range - The range value\n     * @returns The sliced ArrayBuffer or Blob\n     */\n    sliceFile(range) {\n        console.warn("The LargeFileUploadTask.sliceFile() function has been deprecated and moved into the FileObject interface.");\n        if (this.file.content instanceof ArrayBuffer || this.file.content instanceof Blob || this.file.content instanceof Uint8Array) {\n            return this.file.content.slice(range.minValue, range.maxValue + 1);\n        }\n        throw new GraphClientError("The LargeFileUploadTask.sliceFile() function expects only Blob, ArrayBuffer or Uint8Array file content. Please note that the sliceFile() function is deprecated.");\n    }\n    /**\n     * @public\n     * @async\n     * Uploads file to the server in a sequential order by slicing the file\n     * @returns The promise resolves to uploaded response\n     */\n    upload() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const uploadEventHandlers = this.options && this.options.uploadEventHandlers;\n            while (!this.uploadSession.isCancelled) {\n                const nextRange = this.getNextRange();\n                if (nextRange.maxValue === -1) {\n                    const err = new Error("Task with which you are trying to upload is already completed, Please check for your uploaded file");\n                    err.name = "Invalid Session";\n                    throw err;\n                }\n                const fileSlice = yield this.file.sliceFile(nextRange);\n                const rawResponse = yield this.uploadSliceGetRawResponse(fileSlice, nextRange, this.file.size);\n                if (!rawResponse) {\n                    throw new GraphClientError("Something went wrong! Large file upload slice response is null.");\n                }\n                const responseBody = yield GraphResponseHandler.getResponse(rawResponse);\n                /**\n                 * (rawResponse.status === 201) -> This condition is applicable for OneDrive, PrintDocument and Outlook APIs.\n                 * (rawResponse.status === 200 && responseBody.id) -> This additional condition is applicable only for OneDrive API.\n                 */\n                if (rawResponse.status === 201 || (rawResponse.status === 200 && responseBody.id)) {\n                    this.reportProgress(uploadEventHandlers, nextRange);\n                    return UploadResult.CreateUploadResult(responseBody, rawResponse.headers);\n                }\n                /* Handling the API issue where the case of Outlook upload response property -\'nextExpectedRanges\'  is not uniform.\n                 * https://github.com/microsoftgraph/msgraph-sdk-serviceissues/issues/39\n                 */\n                const res = {\n                    expirationDateTime: responseBody.expirationDateTime || responseBody.ExpirationDateTime,\n                    nextExpectedRanges: responseBody.NextExpectedRanges || responseBody.nextExpectedRanges,\n                };\n                this.updateTaskStatus(res);\n                this.reportProgress(uploadEventHandlers, nextRange);\n            }\n        });\n    }\n    reportProgress(uploadEventHandlers, nextRange) {\n        if (uploadEventHandlers && uploadEventHandlers.progress) {\n            uploadEventHandlers.progress(nextRange, uploadEventHandlers.extraCallbackParam);\n        }\n    }\n    /**\n     * @public\n     * @async\n     * Uploads given slice to the server\n     * @param {ArrayBuffer | Blob | File} fileSlice - The file slice\n     * @param {Range} range - The range value\n     * @param {number} totalSize - The total size of a complete file\n     * @returns The response body of the upload slice result\n     */\n    uploadSlice(fileSlice, range, totalSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.client\n                .api(this.uploadSession.url)\n                .headers({\n                "Content-Length": `${range.maxValue - range.minValue + 1}`,\n                "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,\n                "Content-Type": "application/octet-stream",\n            })\n                .put(fileSlice);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Uploads given slice to the server\n     * @param {unknown} fileSlice - The file slice\n     * @param {Range} range - The range value\n     * @param {number} totalSize - The total size of a complete file\n     * @returns The raw response of the upload slice result\n     */\n    uploadSliceGetRawResponse(fileSlice, range, totalSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.client\n                .api(this.uploadSession.url)\n                .headers({\n                "Content-Length": `${range.maxValue - range.minValue + 1}`,\n                "Content-Range": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,\n                "Content-Type": "application/octet-stream",\n            })\n                .responseType(ResponseType.RAW)\n                .put(fileSlice);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Deletes upload session in the server\n     * @returns The promise resolves to cancelled response\n     */\n    cancel() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cancelResponse = yield this.client\n                .api(this.uploadSession.url)\n                .responseType(ResponseType.RAW)\n                .delete();\n            if (cancelResponse.status === 204) {\n                this.uploadSession.isCancelled = true;\n            }\n            return cancelResponse;\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Gets status for the upload session\n     * @returns The promise resolves to the status enquiry response\n     */\n    getStatus() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.client.api(this.uploadSession.url).get();\n            this.updateTaskStatus(response);\n            return response;\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Resumes upload session and continue uploading the file from the last sent range\n     * @returns The promise resolves to the uploaded response\n     */\n    resume() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getStatus();\n            return yield this.upload();\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Get the upload session information\n     * @returns The large file upload session\n     */\n    getUploadSession() {\n        return this.uploadSession;\n    }\n}\n//# sourceMappingURL=LargeFileUploadTask.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/FileObjectClasses/FileUpload.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @class\n * Class used for creating LargeFileUploadTask fileobject.\n * This class accepts files of type ArrayBuffer, Blob, Uint8Array.\n */\nclass FileUpload {\n    /**\n     * @public\n     * @constructor\n     * @param {ArrayBuffer | Blob | Uint8Array} content - The file to be uploaded\n     * @param {string} name - The name of the file to be uploaded\n     * @param {number} size - The total size of the file to be uploaded\n     * @returns An instance of the FileUpload class\n     */\n    constructor(content, name, size) {\n        this.content = content;\n        this.name = name;\n        this.size = size;\n        if (!content || !name || !size) {\n            throw new GraphClientError("Please provide the upload content, name of the file and size of the file");\n        }\n    }\n    /**\n     * @public\n     * Slices the file content to the given range\n     * @param {Range} range - The range value\n     * @returns The sliced file part\n     */\n    sliceFile(range) {\n        return this.content.slice(range.minValue, range.maxValue + 1);\n    }\n}\n//# sourceMappingURL=FileUpload.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTaskUtil.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module OneDriveLargeFileUploadTaskUtil\n */\n/**\n * @constant\n * Default value for the rangeSize\n * Recommended size is between 5 - 10 MB {@link https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/driveitem_createuploadsession#best-practices}\n */\nconst DEFAULT_FILE_SIZE = 5 * 1024 * 1024;\n/**\n * @constant\n * Rounds off the given value to a multiple of 320 KB\n * @param {number} value - The value\n * @returns The rounded off value\n */\nconst roundTo320KB = (value) => {\n    if (value > 320 * 1024) {\n        value = Math.floor(value / (320 * 1024)) * 320 * 1024;\n    }\n    return value;\n};\n/**\n * @constant\n * Get the valid rangeSize for a file slicing (validity is based on the constrains mentioned in here\n * {@link https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/driveitem_createuploadsession#upload-bytes-to-the-upload-session})\n *\n * @param {number} [rangeSize = DEFAULT_FILE_SIZE] - The rangeSize value.\n * @returns The valid rangeSize\n */\nconst getValidRangeSize = (rangeSize = DEFAULT_FILE_SIZE) => {\n    const sixtyMB = 60 * 1024 * 1024;\n    if (rangeSize > sixtyMB) {\n        rangeSize = sixtyMB;\n    }\n    return roundTo320KB(rangeSize);\n};\n//# sourceMappingURL=OneDriveLargeFileUploadTaskUtil.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/OneDriveLargeFileUploadTask.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module OneDriveLargeFileUploadTask\n */\n\n\n\n\n/**\n * @class\n * Class representing OneDriveLargeFileUploadTask\n */\nclass OneDriveLargeFileUploadTask extends LargeFileUploadTask {\n    /**\n     * @private\n     * @static\n     * Constructs the create session url for Onedrive\n     * @param {string} fileName - The name of the file\n     * @param {path} [path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH] - The path for the upload\n     * @returns The constructed create session url\n     */\n    static constructCreateSessionUrl(fileName, path = OneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH) {\n        fileName = fileName.trim();\n        path = path.trim();\n        if (path === "") {\n            path = "/";\n        }\n        if (path[0] !== "/") {\n            path = `/${path}`;\n        }\n        if (path[path.length - 1] !== "/") {\n            path = `${path}/`;\n        }\n        // we choose to encode each component of the file path separately because when encoding full URI\n        // with encodeURI, special characters like # or % in the file name doesn\'t get encoded as desired\n        return `/me/drive/root:${path\n            .split("/")\n            .map((p) => encodeURIComponent(p))\n            .join("/")}${encodeURIComponent(fileName)}:/createUploadSession`;\n    }\n    /**\n     * @private\n     * @static\n     * Get file information\n     * @param {Blob | Uint8Array | File} file - The file entity\n     * @param {string} fileName - The file name\n     * @returns {FileInfo} The file information\n     */\n    static getFileInfo(file, fileName) {\n        let content;\n        let size;\n        if (typeof Blob !== "undefined" && file instanceof Blob) {\n            content = new File([file], fileName);\n            size = content.size;\n        }\n        else if (typeof File !== "undefined" && file instanceof File) {\n            content = file;\n            size = content.size;\n        }\n        else if (typeof Uint8Array !== "undefined" && file instanceof Uint8Array) {\n            const b = file;\n            size = b.byteLength;\n            content = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);\n        }\n        return {\n            content,\n            size,\n        };\n    }\n    /**\n     * @public\n     * @static\n     * @async\n     * Creates a OneDriveLargeFileUploadTask\n     * @param {Client} client - The GraphClient instance\n     * @param {Blob | Uint8Array | File} file - File represented as Blob, Uint8Array or File\n     * @param {OneDriveLargeFileUploadOptions} options - The options for upload task\n     * @returns The promise that will be resolves to OneDriveLargeFileUploadTask instance\n     */\n    static create(client, file, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!client || !file || !options) {\n                throw new GraphClientError("Please provide the Graph client instance, file object and OneDriveLargeFileUploadOptions value");\n            }\n            const fileName = options.fileName;\n            const fileInfo = OneDriveLargeFileUploadTask.getFileInfo(file, fileName);\n            const fileObj = new FileUpload(fileInfo.content, fileName, fileInfo.size);\n            return this.createTaskWithFileObject(client, fileObj, options);\n        });\n    }\n    /**\n     * @public\n     * @static\n     * @async\n     * Creates a OneDriveLargeFileUploadTask\n     * @param {Client} client - The GraphClient instance\n     * @param {FileObject} fileObject - FileObject instance\n     * @param {OneDriveLargeFileUploadOptions} options - The options for upload task\n     * @returns The promise that will be resolves to OneDriveLargeFileUploadTask instance\n     */\n    static createTaskWithFileObject(client, fileObject, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!client || !fileObject || !options) {\n                throw new GraphClientError("Please provide the Graph client instance, FileObject interface implementation and OneDriveLargeFileUploadOptions value");\n            }\n            const requestUrl = options.uploadSessionURL ? options.uploadSessionURL : OneDriveLargeFileUploadTask.constructCreateSessionUrl(options.fileName, options.path);\n            const uploadSessionPayload = {\n                fileName: options.fileName,\n                fileDescription: options.fileDescription,\n                conflictBehavior: options.conflictBehavior,\n            };\n            const session = yield OneDriveLargeFileUploadTask.createUploadSession(client, requestUrl, uploadSessionPayload);\n            const rangeSize = getValidRangeSize(options.rangeSize);\n            return new OneDriveLargeFileUploadTask(client, fileObject, session, {\n                rangeSize,\n                uploadEventHandlers: options.uploadEventHandlers,\n            });\n        });\n    }\n    /**\n     * @public\n     * @static\n     * @async\n     * Makes request to the server to create an upload session\n     * @param {Client} client - The GraphClient instance\n     * @param {string} requestUrl - The URL to create the upload session\n     * @param {string} payloadOptions - The payload option. Default conflictBehavior is \'rename\'\n     * @returns The promise that resolves to LargeFileUploadSession\n     */\n    static createUploadSession(client, requestUrl, payloadOptions) {\n        const _super = Object.create(null, {\n            createUploadSession: { get: () => super.createUploadSession }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const payload = {\n                item: {\n                    "@microsoft.graph.conflictBehavior": (payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.conflictBehavior) || "rename",\n                    name: payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.fileName,\n                    description: payloadOptions === null || payloadOptions === void 0 ? void 0 : payloadOptions.fileDescription,\n                },\n            };\n            return _super.createUploadSession.call(this, client, requestUrl, payload);\n        });\n    }\n    /**\n     * @public\n     * @constructor\n     * Constructs a OneDriveLargeFileUploadTask\n     * @param {Client} client - The GraphClient instance\n     * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded\n     * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done\n     * @param {LargeFileUploadTaskOptions} options - The upload task options\n     * @returns An instance of OneDriveLargeFileUploadTask\n     */\n    constructor(client, file, uploadSession, options) {\n        super(client, file, uploadSession, options);\n    }\n    /**\n     * @public\n     * Commits upload session to end uploading\n     * @param {string} requestUrl - The URL to commit the upload session\n     * @param {string} conflictBehavior - Conflict behaviour option. Default is \'rename\'\n     * @returns The promise resolves to committed response\n     */\n    commit(requestUrl, conflictBehavior = "rename") {\n        return __awaiter(this, void 0, void 0, function* () {\n            const payload = {\n                name: this.file.name,\n                "@microsoft.graph.conflictBehavior": conflictBehavior,\n                "@microsoft.graph.sourceUrl": this.uploadSession.url,\n            };\n            return yield this.client.api(requestUrl).put(payload);\n        });\n    }\n}\n/**\n * @private\n * @static\n * Default path for the file being uploaded\n */\nOneDriveLargeFileUploadTask.DEFAULT_UPLOAD_PATH = "/";\n//# sourceMappingURL=OneDriveLargeFileUploadTask.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/FileUploadTask/FileObjectClasses/StreamUpload.js\n\n\n/**\n * @class\n * FileObject class for Readable Stream upload\n */\nclass StreamUpload {\n    constructor(content, name, size) {\n        this.content = content;\n        this.name = name;\n        this.size = size;\n        if (!content || !name || !size) {\n            throw new GraphClientError("Please provide the Readable Stream content, name of the file and size of the file");\n        }\n    }\n    /**\n     * @public\n     * Slices the file content to the given range\n     * @param {Range} range - The range value\n     * @returns The sliced file part\n     */\n    sliceFile(range) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let rangeSize = range.maxValue - range.minValue + 1;\n            /* readable.readable Is true if it is safe to call readable.read(),\n             * which means the stream has not been destroyed or emitted \'error\' or \'end\'\n             */\n            const bufs = [];\n            /**\n             * The sliceFile reads the first `rangeSize` number of bytes from the stream.\n             * The previousSlice property is used to seek the range of bytes in the previous slice.\n             * Suppose, the sliceFile reads bytes from `10 - 20` from the stream but the upload of this slice fails.\n             * When the user resumes, the stream will have bytes from position 21.\n             * The previousSlice.Range is used to compare if the requested range is cached in the previousSlice property or present in the Readable Stream.\n             */\n            if (this.previousSlice) {\n                if (range.minValue < this.previousSlice.range.minValue) {\n                    throw new GraphClientError("An error occurred while uploading the stream. Please restart the stream upload from the first byte of the file.");\n                }\n                if (range.minValue < this.previousSlice.range.maxValue) {\n                    const previousRangeMin = this.previousSlice.range.minValue;\n                    const previousRangeMax = this.previousSlice.range.maxValue;\n                    // Check if the requested range is same as previously sliced range\n                    if (range.minValue === previousRangeMin && range.maxValue === previousRangeMax) {\n                        return this.previousSlice.fileSlice;\n                    }\n                    /**\n                     * The following check considers a possibility\n                     * of an upload failing after some of the bytes of the previous slice\n                     * were successfully uploaded.\n                     * Example - Previous slice range - `10 - 20`. Current requested range is `15 - 20`.\n                     */\n                    if (range.maxValue === previousRangeMax) {\n                        return this.previousSlice.fileSlice.slice(range.minValue, range.maxValue + 1);\n                    }\n                    /**\n                     * If an upload fails after some of the bytes of the previous slice\n                     * were successfully uploaded and the new Range.Maximum is greater than the previous Range.Maximum\n                     * Example - Previous slice range - `10 - 20`. Current requested range is `15 - 25`,\n                     * then read the bytes from position 15 to 20 from previousSlice.fileSlice and read bytes from position 21 to 25 from the Readable Stream\n                     */\n                    bufs.push(this.previousSlice.fileSlice.slice(range.minValue, previousRangeMax + 1));\n                    rangeSize = range.maxValue - previousRangeMax;\n                }\n            }\n            if (this.content && this.content.readable) {\n                if (this.content.readableLength >= rangeSize) {\n                    bufs.push(this.content.read(rangeSize));\n                }\n                else {\n                    bufs.push(yield this.readNBytesFromStream(rangeSize));\n                }\n            }\n            else {\n                throw new GraphClientError("Stream is not readable.");\n            }\n            const slicedChunk = Buffer.concat(bufs);\n            this.previousSlice = { fileSlice: slicedChunk, range };\n            return slicedChunk;\n        });\n    }\n    /**\n     * @private\n     * Reads the specified byte size from the stream\n     * @param {number} size - The size of bytes to be read\n     * @returns Buffer with the given length of data.\n     */\n    readNBytesFromStream(size) {\n        return new Promise((resolve, reject) => {\n            const chunks = [];\n            let remainder = size;\n            let length = 0;\n            this.content.on("end", () => {\n                if (remainder > 0) {\n                    return reject(new GraphClientError("Stream ended before reading required range size"));\n                }\n            });\n            this.content.on("readable", () => {\n                /**\n                 * (chunk = this.content.read(size)) can return null if size of stream is less than \'size\' parameter.\n                 * Read the remainder number of bytes from the stream iteratively as they are available.\n                 */\n                let chunk;\n                while (length < size && (chunk = this.content.read(remainder)) !== null) {\n                    length += chunk.length;\n                    chunks.push(chunk);\n                    if (remainder > 0) {\n                        remainder = size - length;\n                    }\n                }\n                if (length === size) {\n                    return resolve(Buffer.concat(chunks));\n                }\n                if (!this.content || !this.content.readable) {\n                    return reject(new GraphClientError("Error encountered while reading the stream during the upload"));\n                }\n            });\n        });\n    }\n}\n//# sourceMappingURL=StreamUpload.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/tasks/PageIterator.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @class\n * Class for PageIterator\n */\nclass PageIterator {\n    /**\n     * @public\n     * @constructor\n     * Creates new instance for PageIterator\n     * @param {Client} client - The graph client instance\n     * @param {PageCollection} pageCollection - The page collection object\n     * @param {PageIteratorCallback} callBack - The callback function\n     * @param {GraphRequestOptions} requestOptions - The request options\n     * @returns An instance of a PageIterator\n     */\n    constructor(client, pageCollection, callback, requestOptions) {\n        this.client = client;\n        this.collection = pageCollection.value;\n        this.nextLink = pageCollection["@odata.nextLink"];\n        this.deltaLink = pageCollection["@odata.deltaLink"];\n        this.callback = callback;\n        this.cursor = 0;\n        this.complete = false;\n        this.requestOptions = requestOptions;\n    }\n    /**\n     * @private\n     * Iterates over a collection by enqueuing entries one by one and kicking the callback with the enqueued entry\n     * @returns A boolean indicating the continue flag to process next page\n     */\n    iterationHelper() {\n        if (this.collection === undefined) {\n            return false;\n        }\n        let advance = true;\n        while (advance && this.cursor < this.collection.length) {\n            const item = this.collection[this.cursor];\n            advance = this.callback(item);\n            this.cursor++;\n        }\n        return advance;\n    }\n    /**\n     * @private\n     * @async\n     * Helper to make a get request to fetch next page with nextLink url and update the page iterator instance with the returned response\n     * @returns A promise that resolves to a response data with next page collection\n     */\n    fetchAndUpdateNextPageData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let graphRequest = this.client.api(this.nextLink);\n            if (this.requestOptions) {\n                if (this.requestOptions.headers) {\n                    graphRequest = graphRequest.headers(this.requestOptions.headers);\n                }\n                if (this.requestOptions.middlewareOptions) {\n                    graphRequest = graphRequest.middlewareOptions(this.requestOptions.middlewareOptions);\n                }\n                if (this.requestOptions.options) {\n                    graphRequest = graphRequest.options(this.requestOptions.options);\n                }\n            }\n            const response = yield graphRequest.get();\n            this.collection = response.value;\n            this.cursor = 0;\n            this.nextLink = response["@odata.nextLink"];\n            this.deltaLink = response["@odata.deltaLink"];\n        });\n    }\n    /**\n     * @public\n     * Getter to get the deltaLink in the current response\n     * @returns A deltaLink which is being used to make delta requests in future\n     */\n    getDeltaLink() {\n        return this.deltaLink;\n    }\n    /**\n     * @public\n     * @async\n     * Iterates over the collection and kicks callback for each item on iteration. Fetches next set of data through nextLink and iterates over again\n     * This happens until the nextLink is drained out or the user responds with a red flag to continue from callback\n     * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy.\n     */\n    iterate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let advance = this.iterationHelper();\n            while (advance) {\n                if (this.nextLink !== undefined) {\n                    yield this.fetchAndUpdateNextPageData();\n                    advance = this.iterationHelper();\n                }\n                else {\n                    advance = false;\n                }\n            }\n            if (this.nextLink === undefined && this.cursor >= this.collection.length) {\n                this.complete = true;\n            }\n        });\n    }\n    /**\n     * @public\n     * @async\n     * To resume the iteration\n     * Note: This internally calls the iterate method, It\'s just for more readability.\n     * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy\n     */\n    resume() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.iterate();\n        });\n    }\n    /**\n     * @public\n     * To get the completeness status of the iterator\n     * @returns Boolean indicating the completeness\n     */\n    isComplete() {\n        return this.complete;\n    }\n}\n//# sourceMappingURL=PageIterator.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/CustomAuthenticationProvider.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module CustomAuthenticationProvider\n */\n\n/**\n * @class\n * Class representing CustomAuthenticationProvider\n * @extends AuthenticationProvider\n */\nclass CustomAuthenticationProvider {\n    /**\n     * @public\n     * @constructor\n     * Creates an instance of CustomAuthenticationProvider\n     * @param {AuthProviderCallback} provider - An authProvider function\n     * @returns An instance of CustomAuthenticationProvider\n     */\n    constructor(provider) {\n        this.provider = provider;\n    }\n    /**\n     * @public\n     * @async\n     * To get the access token\n     * @returns The promise that resolves to an access token\n     */\n    getAccessToken() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.provider((error, accessToken) => __awaiter(this, void 0, void 0, function* () {\n                    if (accessToken) {\n                        resolve(accessToken);\n                    }\n                    else {\n                        if (!error) {\n                            const invalidTokenMessage = "Access token is undefined or empty.\\\n\t\t\t\t\t\tPlease provide a valid token.\\\n\t\t\t\t\t\tFor more help - https://github.com/microsoftgraph/msgraph-sdk-javascript/blob/dev/docs/CustomAuthenticationProvider.md";\n                            error = new GraphClientError(invalidTokenMessage);\n                        }\n                        const err = yield GraphClientError.setGraphClientError(error);\n                        reject(err);\n                    }\n                }));\n            });\n        });\n    }\n}\n//# sourceMappingURL=CustomAuthenticationProvider.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphError.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module GraphError\n */\n/**\n * @class\n * Class for GraphError\n * @NOTE: This is NOT what is returned from the Graph\n * GraphError is created from parsing JSON errors returned from the graph\n * Some fields are renamed ie, "request-id" => requestId so you can use dot notation\n */\nclass GraphError extends Error {\n    /**\n     * @public\n     * @constructor\n     * Creates an instance of GraphError\n     * @param {number} [statusCode = -1] - The status code of the error\n     * @param {string} [message] - The message of the error\n     * @param {Error} [baseError] - The base error\n     * @returns An instance of GraphError\n     */\n    constructor(statusCode = -1, message, baseError) {\n        super(message || (baseError && baseError.message));\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, GraphError.prototype);\n        this.statusCode = statusCode;\n        this.code = null;\n        this.requestId = null;\n        this.date = new Date();\n        this.body = null;\n        this.stack = baseError ? baseError.stack : this.stack;\n    }\n}\n//# sourceMappingURL=GraphError.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphErrorHandler.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module GraphErrorHandler\n */\n\n/**\n * @class\n * Class for GraphErrorHandler\n */\nclass GraphErrorHandler {\n    /**\n     * @private\n     * @static\n     * Populates the GraphError instance with Error instance values\n     * @param {Error} error - The error returned by graph service or some native error\n     * @param {number} [statusCode] - The status code of the response\n     * @returns The GraphError instance\n     */\n    static constructError(error, statusCode, rawResponse) {\n        const gError = new GraphError(statusCode, "", error);\n        if (error.name !== undefined) {\n            gError.code = error.name;\n        }\n        gError.body = error.toString();\n        gError.date = new Date();\n        gError.headers = rawResponse === null || rawResponse === void 0 ? void 0 : rawResponse.headers;\n        return gError;\n    }\n    /**\n     * @private\n     * @static\n     * @async\n     * Populates the GraphError instance from the Error returned by graph service\n     * @param {GraphAPIErrorResponse} graphError - The error possibly returned by graph service or some native error\n     * @param {number} statusCode - The status code of the response\n     * @returns A promise that resolves to GraphError instance\n     *\n     * Example error for https://graph.microsoft.com/v1.0/me/events?$top=3&$search=foo\n     * {\n     *      "error": {\n     *          "code": "SearchEvents",\n     *          "message": "The parameter $search is not currently supported on the Events resource.",\n     *          "innerError": {\n     *              "request-id": "b31c83fd-944c-4663-aa50-5d9ceb367e19",\n     *              "date": "2016-11-17T18:37:45"\n     *          }\n     *      }\n     *  }\n     */\n    static constructErrorFromResponse(graphError, statusCode, rawResponse) {\n        const error = graphError.error;\n        const gError = new GraphError(statusCode, error.message);\n        gError.code = error.code;\n        if (error.innerError !== undefined) {\n            gError.requestId = error.innerError["request-id"];\n            gError.date = new Date(error.innerError.date);\n        }\n        gError.body = JSON.stringify(error);\n        gError.headers = rawResponse === null || rawResponse === void 0 ? void 0 : rawResponse.headers;\n        return gError;\n    }\n    /**\n     * @public\n     * @static\n     * @async\n     * To get the GraphError object\n     * Reference - https://docs.microsoft.com/en-us/graph/errors\n     * @param {any} [error = null] - The error returned by graph service or some native error\n     * @param {number} [statusCode = -1] - The status code of the response\n     * @param {GraphRequestCallback} [callback] - The graph request callback function\n     * @returns A promise that resolves to GraphError instance\n     */\n    static getError(error = null, statusCode = -1, callback, rawResponse) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let gError;\n            if (error && error.error) {\n                gError = GraphErrorHandler.constructErrorFromResponse(error, statusCode, rawResponse);\n            }\n            else if (error instanceof Error) {\n                gError = GraphErrorHandler.constructError(error, statusCode, rawResponse);\n            }\n            else {\n                gError = new GraphError(statusCode);\n                gError.body = error; // if a custom error is passed which is not instance of Error object or a graph API response\n            }\n            if (typeof callback === "function") {\n                callback(gError, null);\n            }\n            else {\n                return gError;\n            }\n        });\n    }\n}\n//# sourceMappingURL=GraphErrorHandler.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/GraphRequest.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @module GraphRequest\n */\n\n\n\n\n\n\n\n/**\n * @class\n * A Class representing GraphRequest\n */\nclass GraphRequest {\n    /**\n     * @public\n     * @constructor\n     * Creates an instance of GraphRequest\n     * @param {HTTPClient} httpClient - The HTTPClient instance\n     * @param {ClientOptions} config - The options for making request\n     * @param {string} path - A path string\n     */\n    constructor(httpClient, config, path) {\n        /**\n         * @private\n         * Parses the path string and creates URLComponents out of it\n         * @param {string} path - The request path string\n         * @returns Nothing\n         */\n        this.parsePath = (path) => {\n            // Strips out the base of the url if they passed in\n            if (path.indexOf("https://") !== -1) {\n                path = path.replace("https://", "");\n                // Find where the host ends\n                const endOfHostStrPos = path.indexOf("/");\n                if (endOfHostStrPos !== -1) {\n                    // Parse out the host\n                    this.urlComponents.host = "https://" + path.substring(0, endOfHostStrPos);\n                    // Strip the host from path\n                    path = path.substring(endOfHostStrPos + 1, path.length);\n                }\n                // Remove the following version\n                const endOfVersionStrPos = path.indexOf("/");\n                if (endOfVersionStrPos !== -1) {\n                    // Parse out the version\n                    this.urlComponents.version = path.substring(0, endOfVersionStrPos);\n                    // Strip version from path\n                    path = path.substring(endOfVersionStrPos + 1, path.length);\n                }\n            }\n            // Strip out any leading "/"\n            if (path.charAt(0) === "/") {\n                path = path.substr(1);\n            }\n            const queryStrPos = path.indexOf("?");\n            if (queryStrPos === -1) {\n                // No query string\n                this.urlComponents.path = path;\n            }\n            else {\n                this.urlComponents.path = path.substr(0, queryStrPos);\n                // Capture query string into oDataQueryParams and otherURLQueryParams\n                const queryParams = path.substring(queryStrPos + 1, path.length).split("&");\n                for (const queryParam of queryParams) {\n                    this.parseQueryParameter(queryParam);\n                }\n            }\n        };\n        this.httpClient = httpClient;\n        this.config = config;\n        this.urlComponents = {\n            host: this.config.baseUrl,\n            version: this.config.defaultVersion,\n            oDataQueryParams: {},\n            otherURLQueryParams: {},\n            otherURLQueryOptions: [],\n        };\n        this._headers = {};\n        this._options = {};\n        this._middlewareOptions = [];\n        this.parsePath(path);\n    }\n    /**\n     * @private\n     * Adds the query parameter as comma separated values\n     * @param {string} propertyName - The name of a property\n     * @param {string|string[]} propertyValue - The vale of a property\n     * @param {IArguments} additionalProperties - The additional properties\n     * @returns Nothing\n     */\n    addCsvQueryParameter(propertyName, propertyValue, additionalProperties) {\n        // If there are already $propertyName value there, append a ","\n        this.urlComponents.oDataQueryParams[propertyName] = this.urlComponents.oDataQueryParams[propertyName] ? this.urlComponents.oDataQueryParams[propertyName] + "," : "";\n        let allValues = [];\n        if (additionalProperties.length > 1 && typeof propertyValue === "string") {\n            allValues = Array.prototype.slice.call(additionalProperties);\n        }\n        else if (typeof propertyValue === "string") {\n            allValues.push(propertyValue);\n        }\n        else {\n            allValues = allValues.concat(propertyValue);\n        }\n        this.urlComponents.oDataQueryParams[propertyName] += allValues.join(",");\n    }\n    /**\n     * @private\n     * Builds the full url from the URLComponents to make a request\n     * @returns The URL string that is qualified to make a request to graph endpoint\n     */\n    buildFullUrl() {\n        const url = urlJoin([this.urlComponents.host, this.urlComponents.version, this.urlComponents.path]) + this.createQueryString();\n        if (this.config.debugLogging) {\n            console.log(url);\n        }\n        return url;\n    }\n    /**\n     * @private\n     * Builds the query string from the URLComponents\n     * @returns The Constructed query string\n     */\n    createQueryString() {\n        // Combining query params from oDataQueryParams and otherURLQueryParams\n        const urlComponents = this.urlComponents;\n        const query = [];\n        if (Object.keys(urlComponents.oDataQueryParams).length !== 0) {\n            for (const property in urlComponents.oDataQueryParams) {\n                if (Object.prototype.hasOwnProperty.call(urlComponents.oDataQueryParams, property)) {\n                    query.push(property + "=" + urlComponents.oDataQueryParams[property]);\n                }\n            }\n        }\n        if (Object.keys(urlComponents.otherURLQueryParams).length !== 0) {\n            for (const property in urlComponents.otherURLQueryParams) {\n                if (Object.prototype.hasOwnProperty.call(urlComponents.otherURLQueryParams, property)) {\n                    query.push(property + "=" + urlComponents.otherURLQueryParams[property]);\n                }\n            }\n        }\n        if (urlComponents.otherURLQueryOptions.length !== 0) {\n            for (const str of urlComponents.otherURLQueryOptions) {\n                query.push(str);\n            }\n        }\n        return query.length > 0 ? "?" + query.join("&") : "";\n    }\n    /**\n     * @private\n     * Parses the query parameters to set the urlComponents property of the GraphRequest object\n     * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query parameter\n     * @returns The same GraphRequest instance that is being called with\n     */\n    parseQueryParameter(queryDictionaryOrString) {\n        if (typeof queryDictionaryOrString === "string") {\n            if (queryDictionaryOrString.charAt(0) === "?") {\n                queryDictionaryOrString = queryDictionaryOrString.substring(1);\n            }\n            if (queryDictionaryOrString.indexOf("&") !== -1) {\n                const queryParams = queryDictionaryOrString.split("&");\n                for (const str of queryParams) {\n                    this.parseQueryParamenterString(str);\n                }\n            }\n            else {\n                this.parseQueryParamenterString(queryDictionaryOrString);\n            }\n        }\n        else if (queryDictionaryOrString.constructor === Object) {\n            for (const key in queryDictionaryOrString) {\n                if (Object.prototype.hasOwnProperty.call(queryDictionaryOrString, key)) {\n                    this.setURLComponentsQueryParamater(key, queryDictionaryOrString[key]);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * @private\n     * Parses the query parameter of string type to set the urlComponents property of the GraphRequest object\n     * @param {string} queryParameter - the query parameters\n     * returns nothing\n     */\n    parseQueryParamenterString(queryParameter) {\n        /* The query key-value pair must be split on the first equals sign to avoid errors in parsing nested query parameters.\n                 Example-> "/me?$expand=home($select=city)" */\n        if (this.isValidQueryKeyValuePair(queryParameter)) {\n            const indexOfFirstEquals = queryParameter.indexOf("=");\n            const paramKey = queryParameter.substring(0, indexOfFirstEquals);\n            const paramValue = queryParameter.substring(indexOfFirstEquals + 1);\n            this.setURLComponentsQueryParamater(paramKey, paramValue);\n        }\n        else {\n            /* Push values which are not of key-value structure.\n            Example-> Handle an invalid input->.query(test), .query($select($select=name)) and let the Graph API respond with the error in the URL*/\n            this.urlComponents.otherURLQueryOptions.push(queryParameter);\n        }\n    }\n    /**\n     * @private\n     * Sets values into the urlComponents property of GraphRequest object.\n     * @param {string} paramKey - the query parameter key\n     * @param {string} paramValue - the query paramter value\n     * @returns nothing\n     */\n    setURLComponentsQueryParamater(paramKey, paramValue) {\n        if (oDataQueryNames.indexOf(paramKey) !== -1) {\n            const currentValue = this.urlComponents.oDataQueryParams[paramKey];\n            const isValueAppendable = currentValue && (paramKey === "$expand" || paramKey === "$select" || paramKey === "$orderby");\n            this.urlComponents.oDataQueryParams[paramKey] = isValueAppendable ? currentValue + "," + paramValue : paramValue;\n        }\n        else {\n            this.urlComponents.otherURLQueryParams[paramKey] = paramValue;\n        }\n    }\n    /**\n     * @private\n     * Check if the query parameter string has a valid key-value structure\n     * @param {string} queryString - the query parameter string. Example -> "name=value"\n     * #returns true if the query string has a valid key-value structure else false\n     */\n    isValidQueryKeyValuePair(queryString) {\n        const indexofFirstEquals = queryString.indexOf("=");\n        if (indexofFirstEquals === -1) {\n            return false;\n        }\n        const indexofOpeningParanthesis = queryString.indexOf("(");\n        if (indexofOpeningParanthesis !== -1 && queryString.indexOf("(") < indexofFirstEquals) {\n            // Example -> .query($select($expand=true));\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @private\n     * Updates the custom headers and options for a request\n     * @param {FetchOptions} options - The request options object\n     * @returns Nothing\n     */\n    updateRequestOptions(options) {\n        const optionsHeaders = Object.assign({}, options.headers);\n        if (this.config.fetchOptions !== undefined) {\n            const fetchOptions = Object.assign({}, this.config.fetchOptions);\n            Object.assign(options, fetchOptions);\n            if (typeof this.config.fetchOptions.headers !== undefined) {\n                options.headers = Object.assign({}, this.config.fetchOptions.headers);\n            }\n        }\n        Object.assign(options, this._options);\n        if (options.headers !== undefined) {\n            Object.assign(optionsHeaders, options.headers);\n        }\n        Object.assign(optionsHeaders, this._headers);\n        options.headers = optionsHeaders;\n    }\n    /**\n     * @private\n     * @async\n     * Adds the custom headers and options to the request and makes the HTTPClient send request call\n     * @param {RequestInfo} request - The request url string or the Request object value\n     * @param {FetchOptions} options - The options to make a request\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the response content\n     */\n    send(request, options, callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            let rawResponse;\n            const middlewareControl = new MiddlewareControl(this._middlewareOptions);\n            this.updateRequestOptions(options);\n            const customHosts = (_a = this.config) === null || _a === void 0 ? void 0 : _a.customHosts;\n            try {\n                const context = yield this.httpClient.sendRequest({\n                    request,\n                    options,\n                    middlewareControl,\n                    customHosts,\n                });\n                rawResponse = context.response;\n                const response = yield GraphResponseHandler.getResponse(rawResponse, this._responseType, callback);\n                return response;\n            }\n            catch (error) {\n                if (error instanceof GraphClientError) {\n                    throw error;\n                }\n                let statusCode;\n                if (rawResponse) {\n                    statusCode = rawResponse.status;\n                }\n                const gError = yield GraphErrorHandler.getError(error, statusCode, callback, rawResponse);\n                throw gError;\n            }\n        });\n    }\n    /**\n     * @private\n     * Checks if the content-type is present in the _headers property. If not present, defaults the content-type to application/json\n     * @param none\n     * @returns nothing\n     */\n    setHeaderContentType() {\n        if (!this._headers) {\n            this.header("Content-Type", "application/json");\n            return;\n        }\n        const headerKeys = Object.keys(this._headers);\n        for (const headerKey of headerKeys) {\n            if (headerKey.toLowerCase() === "content-type") {\n                return;\n            }\n        }\n        // Default the content-type to application/json in case the content-type is not present in the header\n        this.header("Content-Type", "application/json");\n    }\n    /**\n     * @public\n     * Sets the custom header for a request\n     * @param {string} headerKey - A header key\n     * @param {string} headerValue - A header value\n     * @returns The same GraphRequest instance that is being called with\n     */\n    header(headerKey, headerValue) {\n        this._headers[headerKey] = headerValue;\n        return this;\n    }\n    /**\n     * @public\n     * Sets the custom headers for a request\n     * @param {KeyValuePairObjectStringNumber | HeadersInit} headers - The request headers\n     * @returns The same GraphRequest instance that is being called with\n     */\n    headers(headers) {\n        for (const key in headers) {\n            if (Object.prototype.hasOwnProperty.call(headers, key)) {\n                this._headers[key] = headers[key];\n            }\n        }\n        return this;\n    }\n    /**\n     * @public\n     * Sets the option for making a request\n     * @param {string} key - The key value\n     * @param {any} value - The value\n     * @returns The same GraphRequest instance that is being called with\n     */\n    option(key, value) {\n        this._options[key] = value;\n        return this;\n    }\n    /**\n     * @public\n     * Sets the options for making a request\n     * @param {{ [key: string]: any }} options - The options key value pair\n     * @returns The same GraphRequest instance that is being called with\n     */\n    options(options) {\n        for (const key in options) {\n            if (Object.prototype.hasOwnProperty.call(options, key)) {\n                this._options[key] = options[key];\n            }\n        }\n        return this;\n    }\n    /**\n     * @public\n     * Sets the middleware options for a request\n     * @param {MiddlewareOptions[]} options - The array of middleware options\n     * @returns The same GraphRequest instance that is being called with\n     */\n    middlewareOptions(options) {\n        this._middlewareOptions = options;\n        return this;\n    }\n    /**\n     * @public\n     * Sets the api endpoint version for a request\n     * @param {string} version - The version value\n     * @returns The same GraphRequest instance that is being called with\n     */\n    version(version) {\n        this.urlComponents.version = version;\n        return this;\n    }\n    /**\n     * @public\n     * Sets the api endpoint version for a request\n     * @param {ResponseType} responseType - The response type value\n     * @returns The same GraphRequest instance that is being called with\n     */\n    responseType(responseType) {\n        this._responseType = responseType;\n        return this;\n    }\n    /**\n     * @public\n     * To add properties for select OData Query param\n     * @param {string|string[]} properties - The Properties value\n     * @returns The same GraphRequest instance that is being called with, after adding the properties for $select query\n     */\n    /*\n     * Accepts .select("displayName,birthday")\n     *     and .select(["displayName", "birthday"])\n     *     and .select("displayName", "birthday")\n     *\n     */\n    select(properties) {\n        this.addCsvQueryParameter("$select", properties, arguments);\n        return this;\n    }\n    /**\n     * @public\n     * To add properties for expand OData Query param\n     * @param {string|string[]} properties - The Properties value\n     * @returns The same GraphRequest instance that is being called with, after adding the properties for $expand query\n     */\n    expand(properties) {\n        this.addCsvQueryParameter("$expand", properties, arguments);\n        return this;\n    }\n    /**\n     * @public\n     * To add properties for orderby OData Query param\n     * @param {string|string[]} properties - The Properties value\n     * @returns The same GraphRequest instance that is being called with, after adding the properties for $orderby query\n     */\n    orderby(properties) {\n        this.addCsvQueryParameter("$orderby", properties, arguments);\n        return this;\n    }\n    /**\n     * @public\n     * To add query string for filter OData Query param. The request URL accepts only one $filter Odata Query option and its value is set to the most recently passed filter query string.\n     * @param {string} filterStr - The filter query string\n     * @returns The same GraphRequest instance that is being called with, after adding the $filter query\n     */\n    filter(filterStr) {\n        this.urlComponents.oDataQueryParams.$filter = filterStr;\n        return this;\n    }\n    /**\n     * @public\n     * To add criterion for search OData Query param. The request URL accepts only one $search Odata Query option and its value is set to the most recently passed search criterion string.\n     * @param {string} searchStr - The search criterion string\n     * @returns The same GraphRequest instance that is being called with, after adding the $search query criteria\n     */\n    search(searchStr) {\n        this.urlComponents.oDataQueryParams.$search = searchStr;\n        return this;\n    }\n    /**\n     * @public\n     * To add number for top OData Query param. The request URL accepts only one $top Odata Query option and its value is set to the most recently passed number value.\n     * @param {number} n - The number value\n     * @returns The same GraphRequest instance that is being called with, after adding the number for $top query\n     */\n    top(n) {\n        this.urlComponents.oDataQueryParams.$top = n;\n        return this;\n    }\n    /**\n     * @public\n     * To add number for skip OData Query param. The request URL accepts only one $skip Odata Query option and its value is set to the most recently passed number value.\n     * @param {number} n - The number value\n     * @returns The same GraphRequest instance that is being called with, after adding the number for the $skip query\n     */\n    skip(n) {\n        this.urlComponents.oDataQueryParams.$skip = n;\n        return this;\n    }\n    /**\n     * @public\n     * To add token string for skipToken OData Query param. The request URL accepts only one $skipToken Odata Query option and its value is set to the most recently passed token value.\n     * @param {string} token - The token value\n     * @returns The same GraphRequest instance that is being called with, after adding the token string for $skipToken query option\n     */\n    skipToken(token) {\n        this.urlComponents.oDataQueryParams.$skipToken = token;\n        return this;\n    }\n    /**\n     * @public\n     * To add boolean for count OData Query param. The URL accepts only one $count Odata Query option and its value is set to the most recently passed boolean value.\n     * @param {boolean} isCount - The count boolean\n     * @returns The same GraphRequest instance that is being called with, after adding the boolean value for the $count query option\n     */\n    count(isCount = true) {\n        this.urlComponents.oDataQueryParams.$count = isCount.toString();\n        return this;\n    }\n    /**\n     * @public\n     * Appends query string to the urlComponent\n     * @param {string|KeyValuePairObjectStringNumber} queryDictionaryOrString - The query value\n     * @returns The same GraphRequest instance that is being called with, after appending the query string to the url component\n     */\n    /*\n     * Accepts .query("displayName=xyz")\n     *     and .select({ name: "value" })\n     */\n    query(queryDictionaryOrString) {\n        return this.parseQueryParameter(queryDictionaryOrString);\n    }\n    /**\n     * @public\n     * @async\n     * Makes a http request with GET method\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the get response\n     */\n    get(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.buildFullUrl();\n            const options = {\n                method: RequestMethod.GET,\n            };\n            const response = yield this.send(url, options, callback);\n            return response;\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Makes a http request with POST method\n     * @param {any} content - The content that needs to be sent with the request\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the post response\n     */\n    post(content, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.buildFullUrl();\n            const options = {\n                method: RequestMethod.POST,\n                body: serializeContent(content),\n            };\n            const className = content && content.constructor && content.constructor.name;\n            if (className === "FormData") {\n                // Content-Type headers should not be specified in case the of FormData type content\n                options.headers = {};\n            }\n            else {\n                this.setHeaderContentType();\n                options.headers = this._headers;\n            }\n            return yield this.send(url, options, callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Alias for Post request call\n     * @param {any} content - The content that needs to be sent with the request\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the post response\n     */\n    create(content, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.post(content, callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Makes http request with PUT method\n     * @param {any} content - The content that needs to be sent with the request\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the put response\n     */\n    put(content, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.buildFullUrl();\n            this.setHeaderContentType();\n            const options = {\n                method: RequestMethod.PUT,\n                body: serializeContent(content),\n            };\n            return yield this.send(url, options, callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Makes http request with PATCH method\n     * @param {any} content - The content that needs to be sent with the request\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the patch response\n     */\n    patch(content, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.buildFullUrl();\n            this.setHeaderContentType();\n            const options = {\n                method: RequestMethod.PATCH,\n                body: serializeContent(content),\n            };\n            return yield this.send(url, options, callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Alias for PATCH request\n     * @param {any} content - The content that needs to be sent with the request\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the patch response\n     */\n    update(content, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.patch(content, callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Makes http request with DELETE method\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the delete response\n     */\n    delete(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.buildFullUrl();\n            const options = {\n                method: RequestMethod.DELETE,\n            };\n            return yield this.send(url, options, callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Alias for delete request call\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the delete response\n     */\n    del(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.delete(callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Makes a http request with GET method to read response as a stream.\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the getStream response\n     */\n    getStream(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.buildFullUrl();\n            const options = {\n                method: RequestMethod.GET,\n            };\n            this.responseType(ResponseType.STREAM);\n            return yield this.send(url, options, callback);\n        });\n    }\n    /**\n     * @public\n     * @async\n     * Makes a http request with GET method to read response as a stream.\n     * @param {any} stream - The stream instance\n     * @param {GraphRequestCallback} [callback] - The callback function to be called in response with async call\n     * @returns A promise that resolves to the putStream response\n     */\n    putStream(stream, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this.buildFullUrl();\n            const options = {\n                method: RequestMethod.PUT,\n                headers: {\n                    "Content-Type": "application/octet-stream",\n                },\n                body: stream,\n            };\n            return yield this.send(url, options, callback);\n        });\n    }\n}\n//# sourceMappingURL=GraphRequest.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClient.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * @class\n * Class representing HTTPClient\n */\nclass HTTPClient {\n    /**\n     * @public\n     * @constructor\n     * Creates an instance of a HTTPClient\n     * @param {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers\n     */\n    constructor(...middleware) {\n        if (!middleware || !middleware.length) {\n            const error = new Error();\n            error.name = "InvalidMiddlewareChain";\n            error.message = "Please provide a default middleware chain or custom middleware chain";\n            throw error;\n        }\n        this.setMiddleware(...middleware);\n    }\n    /**\n     * @private\n     * Processes the middleware parameter passed to set this.middleware property\n     * The calling function should validate if middleware is not undefined or not empty.\n     * @param {...Middleware} middleware - The middleware passed\n     * @returns Nothing\n     */\n    setMiddleware(...middleware) {\n        if (middleware.length > 1) {\n            this.parseMiddleWareArray(middleware);\n        }\n        else {\n            this.middleware = middleware[0];\n        }\n    }\n    /**\n     * @private\n     * Processes the middleware array to construct the chain\n     * and sets this.middleware property to the first middleware handler of the array\n     * The calling function should validate if middleware is not undefined or not empty\n     * @param {Middleware[]} middlewareArray - The array of middleware handlers\n     * @returns Nothing\n     */\n    parseMiddleWareArray(middlewareArray) {\n        middlewareArray.forEach((element, index) => {\n            if (index < middlewareArray.length - 1) {\n                element.setNext(middlewareArray[index + 1]);\n            }\n        });\n        this.middleware = middlewareArray[0];\n    }\n    /**\n     * @public\n     * @async\n     * To send the request through the middleware chain\n     * @param {Context} context - The context of a request\n     * @returns A promise that resolves to the Context\n     */\n    sendRequest(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof context.request === "string" && context.options === undefined) {\n                const error = new Error();\n                error.name = "InvalidRequestOptions";\n                error.message = "Unable to execute the middleware, Please provide valid options for a request";\n                throw error;\n            }\n            yield this.middleware.execute(context);\n            return context;\n        });\n    }\n}\n//# sourceMappingURL=HTTPClient.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/HTTPClientFactory.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module HTTPClientFactory\n */\n\n\n\n\n\n\n\n\n/**\n * @private\n * To check whether the environment is node or not\n * @returns A boolean representing the environment is node or not\n */\nconst HTTPClientFactory_isNodeEnvironment = () => {\n    return typeof process === "object" && "function" === "function";\n};\n/**\n * @class\n * Class representing HTTPClientFactory\n */\nclass HTTPClientFactory {\n    /**\n     * @public\n     * @static\n     * Creates HTTPClient with default middleware chain\n     * @param {AuthenticationProvider} authProvider - The authentication provider instance\n     * @returns A HTTPClient instance\n     *\n     * NOTE: These are the things that we need to remember while doing modifications in the below default pipeline.\n     * \t\t* HTTPMessageHandler should be the last one in the middleware pipeline, because this makes the actual network call of the request\n     * \t\t* TelemetryHandler should be the one prior to the last middleware in the chain, because this is the one which actually collects and appends the usage flag and placing this handler \t*\t\t  before making the actual network call ensures that the usage of all features are recorded in the flag.\n     * \t\t* The best place for AuthenticationHandler is in the starting of the pipeline, because every other handler might have to work for multiple times for a request but the auth token for\n     * \t\t  them will remain same. For example, Retry and Redirect handlers might be working multiple times for a request based on the response but their auth token would remain same.\n     */\n    static createWithAuthenticationProvider(authProvider) {\n        const authenticationHandler = new AuthenticationHandler(authProvider);\n        const retryHandler = new RetryHandler(new RetryHandlerOptions());\n        const telemetryHandler = new TelemetryHandler();\n        const httpMessageHandler = new HTTPMessageHandler();\n        authenticationHandler.setNext(retryHandler);\n        if (HTTPClientFactory_isNodeEnvironment()) {\n            const redirectHandler = new RedirectHandler(new RedirectHandlerOptions());\n            retryHandler.setNext(redirectHandler);\n            redirectHandler.setNext(telemetryHandler);\n        }\n        else {\n            retryHandler.setNext(telemetryHandler);\n        }\n        telemetryHandler.setNext(httpMessageHandler);\n        return HTTPClientFactory.createWithMiddleware(authenticationHandler);\n    }\n    /**\n     * @public\n     * @static\n     * Creates a middleware chain with the given one\n     * @property {...Middleware} middleware - The first middleware of the middleware chain or a sequence of all the Middleware handlers\n     * @returns A HTTPClient instance\n     */\n    static createWithMiddleware(...middleware) {\n        // Middleware should not empty or undefined. This is check is present in the HTTPClient constructor.\n        return new HTTPClient(...middleware);\n    }\n}\n//# sourceMappingURL=HTTPClientFactory.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/ValidatePolyFilling.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @constant\n * @function\n * Validates availability of Promise and fetch in global context\n * @returns The true in case the Promise and fetch available, otherwise throws error\n */\nconst validatePolyFilling = () => {\n    if (typeof Promise === "undefined" && typeof fetch === "undefined") {\n        const error = new Error("Library cannot function without Promise and fetch. So, please provide polyfill for them.");\n        error.name = "PolyFillNotAvailable";\n        throw error;\n    }\n    else if (typeof Promise === "undefined") {\n        const error = new Error("Library cannot function without Promise. So, please provide polyfill for it.");\n        error.name = "PolyFillNotAvailable";\n        throw error;\n    }\n    else if (typeof fetch === "undefined") {\n        const error = new Error("Library cannot function without fetch. So, please provide polyfill for it.");\n        error.name = "PolyFillNotAvailable";\n        throw error;\n    }\n    return true;\n};\n//# sourceMappingURL=ValidatePolyFilling.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/Client.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n/**\n * @module Client\n */\n\n\n\n\n\n\nclass Client {\n    /**\n     * @public\n     * @static\n     * To create a client instance with options and initializes the default middleware chain\n     * @param {Options} options - The options for client instance\n     * @returns The Client instance\n     */\n    static init(options) {\n        const clientOptions = {};\n        for (const i in options) {\n            if (Object.prototype.hasOwnProperty.call(options, i)) {\n                clientOptions[i] = i === "authProvider" ? new CustomAuthenticationProvider(options[i]) : options[i];\n            }\n        }\n        return Client.initWithMiddleware(clientOptions);\n    }\n    /**\n     * @public\n     * @static\n     * To create a client instance with the Client Options\n     * @param {ClientOptions} clientOptions - The options object for initializing the client\n     * @returns The Client instance\n     */\n    static initWithMiddleware(clientOptions) {\n        return new Client(clientOptions);\n    }\n    /**\n     * @private\n     * @constructor\n     * Creates an instance of Client\n     * @param {ClientOptions} clientOptions - The options to instantiate the client object\n     */\n    constructor(clientOptions) {\n        /**\n         * @private\n         * A member which stores the Client instance options\n         */\n        this.config = {\n            baseUrl: GRAPH_BASE_URL,\n            debugLogging: false,\n            defaultVersion: GRAPH_API_VERSION,\n        };\n        validatePolyFilling();\n        for (const key in clientOptions) {\n            if (Object.prototype.hasOwnProperty.call(clientOptions, key)) {\n                this.config[key] = clientOptions[key];\n            }\n        }\n        let httpClient;\n        if (clientOptions.authProvider !== undefined && clientOptions.middleware !== undefined) {\n            const error = new Error();\n            error.name = "AmbiguityInInitialization";\n            error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain not both";\n            throw error;\n        }\n        else if (clientOptions.authProvider !== undefined) {\n            httpClient = HTTPClientFactory.createWithAuthenticationProvider(clientOptions.authProvider);\n        }\n        else if (clientOptions.middleware !== undefined) {\n            httpClient = new HTTPClient(...[].concat(clientOptions.middleware));\n        }\n        else {\n            const error = new Error();\n            error.name = "InvalidMiddlewareChain";\n            error.message = "Unable to Create Client, Please provide either authentication provider for default middleware chain or custom middleware chain";\n            throw error;\n        }\n        this.httpClient = httpClient;\n    }\n    /**\n     * @public\n     * Entry point to make requests\n     * @param {string} path - The path string value\n     * @returns The graph request instance\n     */\n    api(path) {\n        return new GraphRequest(this.httpClient, this.config, path);\n    }\n}\n//# sourceMappingURL=Client.js.map\n;// ./node_modules/@microsoft/microsoft-graph-client/lib/es/src/index.js\n/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path= "./../shims.d.ts" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcwMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDakYsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFTztBQUNQO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTs7QUFFTztBQUNQLGtDQUFrQztBQUNsQzs7QUFFTztBQUNQLHVCQUF1Qix1RkFBdUY7QUFDOUc7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsOENBQThDLHlGQUF5RjtBQUN2SSw4REFBOEQsMkNBQTJDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBLDRDQUE0Qyx5RUFBeUU7QUFDckg7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1AsMEJBQTBCLCtEQUErRCxpQkFBaUI7QUFDMUc7QUFDQSxrQ0FBa0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNuRixpQ0FBaUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN0Riw4QkFBOEI7QUFDOUI7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUCxZQUFZLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDdEcsMklBQTJJLGNBQWM7QUFDekoscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsaUNBQWlDLFNBQVM7QUFDMUMsaUNBQWlDLFdBQVcsVUFBVTtBQUN0RCx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBLDRHQUE0RyxPQUFPO0FBQ25ILCtFQUErRSxpQkFBaUI7QUFDaEcsdURBQXVELGdCQUFnQixRQUFRO0FBQy9FLDZDQUE2QyxnQkFBZ0IsZ0JBQWdCO0FBQzdFO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxRQUFRLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDcEQsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1AsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQLGdEQUFnRCxRQUFRO0FBQ3hELHVDQUF1QyxRQUFRO0FBQy9DLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTs7QUFFTztBQUNQLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSx3TUFBd00sY0FBYztBQUN0Tiw0QkFBNEIsc0JBQXNCO0FBQ2xELHdCQUF3QixZQUFZLHNCQUFzQixxQ0FBcUMsMkNBQTJDLE1BQU07QUFDaEosMEJBQTBCLE1BQU0saUJBQWlCLFlBQVk7QUFDN0QscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCOztBQUVPO0FBQ1A7QUFDQSxlQUFlLDZDQUE2QyxVQUFVLHNEQUFzRCxjQUFjO0FBQzFJLHdCQUF3Qiw2QkFBNkIsb0JBQW9CLHVDQUF1QyxrQkFBa0I7QUFDbEk7O0FBRU87QUFDUDtBQUNBO0FBQ0EseUdBQXlHLHVGQUF1RixjQUFjO0FBQzlNLHFCQUFxQiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUMzSiwyQ0FBMkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDbEg7O0FBRU87QUFDUCwrQkFBK0IsdUNBQXVDLFlBQVksS0FBSyxPQUFPO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1AsMkNBQTJDO0FBQzNDOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTSxvQkFBb0IsWUFBWTtBQUM1RSxxQkFBcUIsOENBQThDO0FBQ25FO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFNBQVMsZ0JBQWdCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7QUNoWkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkMseUM7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUNsQztBQUNBO0FBQ0E7QUFDaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhLDZCQUE2QixhQUFhLDRCQUE0QixhQUFhO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxRQUFRO0FBQ3pFLHVEQUF1RCxjQUFjO0FBQ3JFLHNEQUFzRDtBQUN0RDtBQUNBLHNEQUFzRDtBQUN0RCxnREFBZ0QscURBQXFEO0FBQ3JHO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLE1BQU07QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLE1BQU07QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGNBQWMsbUNBQW1DLFlBQVk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsS0FBSyxtQ0FBbUMsWUFBWTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsYUFBYTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLCtDOztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0Q7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFDOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDYTtBQUN0RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQsOERBQThELFFBQVEsRUFBRSxTQUFTLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0EsNEM7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ08sb0RBQW9ELFNBQVM7QUFDcEU7QUFDQSxZQUFZLDhHQUE4RztBQUMxSCxpQ0FBaUMsbUhBQW1IO0FBQ3BKLENBQUM7QUFDRCwwQzs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQ7QUFDekQ7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDbEM7QUFDQTtBQUNBO0FBQytEO0FBQ1A7QUFDRDtBQUMrQjtBQUNRO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxnQkFBZ0IsVUFBVSxpQ0FBaUMsWUFBWTtBQUN2RTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUUsNkVBQTZFLDRCQUE0QjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsdUJBQXVCLGlDQUFpQyxnQkFBZ0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4Qzs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiwrQkFBK0IsTUFBTSxvQ0FBb0M7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsOEJBQThCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLG9DQUFvQztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2U7QUFDTztBQUNjO0FBQ0Y7QUFDMEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYSxtQkFBbUIsYUFBYSxxQkFBcUIsYUFBYTtBQUMzSDtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsWUFBWSx1QkFBdUIsaUNBQWlDLGdCQUFnQjtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx5Q0FBeUM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDZTtBQUNPO0FBQ0U7QUFDZ0I7QUFDb0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLHdGQUF3RixzQkFBc0I7QUFDOUcsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRSxxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUIsaUNBQWlDLGdCQUFnQjtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQzs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUM7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUMrRDtBQUNsQjtBQUNXO0FBQ2lEO0FBQzdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGdCQUFnQixVQUFVLGlDQUFpQyxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHlDQUF5Qyw4QkFBOEIsR0FBRyxlQUFlLENBQUM7QUFDMUY7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFLDZFQUE2RSx1QkFBdUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNDQUFzQyxHQUFHLGFBQWE7QUFDbEc7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0U7QUFDTjtBQUNnQjtBQUNOO0FBQ2hCO0FBQ047QUFDUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQjtBQUMvRCxpQ0FBaUMsWUFBWSxLQUFLLG1CQUFtQjtBQUNyRSxxQ0FBcUMsZ0JBQWdCO0FBQ3JELHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWUsS0FBSyxzQkFBc0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDLHlDOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ3NCO0FBQ1I7QUFDOEI7QUFDVjtBQUNaO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFLHFFQUFxRSxtQkFBbUI7QUFDeEY7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSwrREFBK0Q7QUFDckYsY0FBYyxRQUFRLCtDQUErQztBQUNyRSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUSw0Q0FBNEM7QUFDbEUsY0FBYyxRQUFRO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckMsd0M7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUNZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJEQUEyRDtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0Q7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qzs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUN1RDtBQUNRO0FBQ2hCO0FBQ0E7QUFDYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsd0JBQXdCO0FBQ3ZDLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBLDJDQUEyQyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekUsMENBQTBDLGVBQWUsR0FBRyxlQUFlLEdBQUcsVUFBVTtBQUN4RjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQ0FBb0M7QUFDekUsMENBQTBDLGVBQWUsR0FBRyxlQUFlLEdBQUcsVUFBVTtBQUN4RjtBQUNBLGFBQWE7QUFDYiw4QkFBOEIsWUFBWTtBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0M7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRCxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrSUFBK0k7QUFDbko7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkQ7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUNsQztBQUNBO0FBQ0E7QUFDdUQ7QUFDb0I7QUFDZjtBQUNVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsWUFBWTtBQUMzQixlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNULGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFlBQVk7QUFDM0IsZUFBZSx3QkFBd0I7QUFDdkMsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUQ7O0FDM0xrQztBQUMyQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSx3Qzs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0Q7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUMwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkM7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUNsQztBQUNBO0FBQ0E7QUFDc0Q7QUFDRTtBQUN3QjtBQUNsQjtBQUNLO0FBQ25CO0FBQ0Y7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDTTtBQUNFO0FBQ0U7QUFDOEI7QUFDbEI7QUFDTTtBQUNvQjtBQUMxQjtBQUNaO0FBQ1Y7QUFDUztBQUNnQjtBQUNOO0FBQ1M7QUFDSjtBQUNkO0FBQ2Q7QUFDRDtBQUNsQjtBQUM0QztBQUNwQztBQUNZO0FBQ1I7QUFDQTtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanM/NDMzZiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9SZXF1ZXN0TWV0aG9kLmpzPzNkZjMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvY29udGVudC9CYXRjaFJlcXVlc3RDb250ZW50LmpzPzYxNzQiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvY29udGVudC9CYXRjaFJlc3BvbnNlQ29udGVudC5qcz82NzlkIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL0NvbnN0YW50cy5qcz8zNjY0Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL0dyYXBoQ2xpZW50RXJyb3IuanM/OWEyYiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9HcmFwaFJlcXVlc3RVdGlsLmpzPzIzYWEiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvbWlkZGxld2FyZS9NaWRkbGV3YXJlQ29udHJvbC5qcz9hMGI3Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL21pZGRsZXdhcmUvTWlkZGxld2FyZVV0aWwuanM/ODMwZCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9taWRkbGV3YXJlL29wdGlvbnMvQXV0aGVudGljYXRpb25IYW5kbGVyT3B0aW9ucy5qcz83MzM4Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL21pZGRsZXdhcmUvb3B0aW9ucy9UZWxlbWV0cnlIYW5kbGVyT3B0aW9ucy5qcz9jMjNlIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL21pZGRsZXdhcmUvQXV0aGVudGljYXRpb25IYW5kbGVyLmpzP2Y4YTAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvbWlkZGxld2FyZS9IVFRQTWVzc2FnZUhhbmRsZXIuanM/Nzk4YSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9taWRkbGV3YXJlL29wdGlvbnMvUmV0cnlIYW5kbGVyT3B0aW9ucy5qcz9iNWY2Iiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL21pZGRsZXdhcmUvUmV0cnlIYW5kbGVyLmpzPzQ2ZjMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvbWlkZGxld2FyZS9vcHRpb25zL1JlZGlyZWN0SGFuZGxlck9wdGlvbnMuanM/NzdkYSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9taWRkbGV3YXJlL1JlZGlyZWN0SGFuZGxlci5qcz84NGNlIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL1ZlcnNpb24uanM/YTYyYyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9taWRkbGV3YXJlL1RlbGVtZXRyeUhhbmRsZXIuanM/OTYzNCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9taWRkbGV3YXJlL01pZGRsZXdhcmVGYWN0b3J5LmpzPzNlYmIiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvbWlkZGxld2FyZS9vcHRpb25zL0NoYW9zU3RyYXRlZ3kuanM/NWRkZCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9taWRkbGV3YXJlL29wdGlvbnMvQ2hhb3NIYW5kbGVyT3B0aW9ucy5qcz85ODNkIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL21pZGRsZXdhcmUvb3B0aW9ucy9DaGFvc0hhbmRsZXJEYXRhLmpzP2U3ZmIiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvbWlkZGxld2FyZS9DaGFvc0hhbmRsZXIuanM/NzQzNSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9SZXNwb25zZVR5cGUuanM/NmViMyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9HcmFwaFJlc3BvbnNlSGFuZGxlci5qcz9hY2FmIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL3Rhc2tzL0ZpbGVVcGxvYWRUYXNrL1JhbmdlLmpzP2M3ZWUiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvdGFza3MvRmlsZVVwbG9hZFRhc2svVXBsb2FkUmVzdWx0LmpzPzBiYTgiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvdGFza3MvTGFyZ2VGaWxlVXBsb2FkVGFzay5qcz81NTFiIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL3Rhc2tzL0ZpbGVVcGxvYWRUYXNrL0ZpbGVPYmplY3RDbGFzc2VzL0ZpbGVVcGxvYWQuanM/NTZjYSIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy90YXNrcy9PbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2tVdGlsLmpzPzEwMDAiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvdGFza3MvT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrLmpzPzU2MDQiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvdGFza3MvRmlsZVVwbG9hZFRhc2svRmlsZU9iamVjdENsYXNzZXMvU3RyZWFtVXBsb2FkLmpzPzIyYjgiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvdGFza3MvUGFnZUl0ZXJhdG9yLmpzP2RiMTMiLCJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvQG1pY3Jvc29mdC9taWNyb3NvZnQtZ3JhcGgtY2xpZW50L2xpYi9lcy9zcmMvQ3VzdG9tQXV0aGVudGljYXRpb25Qcm92aWRlci5qcz9lNTFmIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL0dyYXBoRXJyb3IuanM/Mzg2MCIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9HcmFwaEVycm9ySGFuZGxlci5qcz80NzJjIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL0dyYXBoUmVxdWVzdC5qcz9hM2VhIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL0hUVFBDbGllbnQuanM/MjNhMiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9IVFRQQ2xpZW50RmFjdG9yeS5qcz9kNjZkIiwid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL0BtaWNyb3NvZnQvbWljcm9zb2Z0LWdyYXBoLWNsaWVudC9saWIvZXMvc3JjL1ZhbGlkYXRlUG9seUZpbGxpbmcuanM/ODNjMiIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9DbGllbnQuanM/OTAzYyIsIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L21pY3Jvc29mdC1ncmFwaC1jbGllbnQvbGliL2VzL3NyYy9pbmRleC5qcz80NWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcbiAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG52YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGFyID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICByZXR1cm4gYXI7XG4gIH07XG4gIHJldHVybiBvd25LZXlzKG8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICBpZiAoYXN5bmMpIGlubmVyID0gZGlzcG9zZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkgeyB0cnkgeyBpbm5lci5jYWxsKHRoaXMpOyB9IGNhdGNoIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSB9O1xuICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gIH1cbiAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xuICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgfVxuICB2YXIgciwgcyA9IDA7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKHIgPSBlbnYuc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghci5hc3luYyAmJiBzID09PSAxKSByZXR1cm4gcyA9IDAsIGVudi5zdGFjay5wdXNoKHIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xuICAgICAgICBpZiAoci5kaXNwb3NlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHIuZGlzcG9zZS5jYWxsKHIudmFsdWUpO1xuICAgICAgICAgIGlmIChyLmFzeW5jKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzIHw9IDE7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA9PT0gMSkgcmV0dXJuIGVudi5oYXNFcnJvciA/IFByb21pc2UucmVqZWN0KGVudi5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uKHBhdGgsIHByZXNlcnZlSnN4KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLlxcLj9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLih0c3gpJHwoKD86XFwuZCk/KSgoPzpcXC5bXi4vXSs/KT8pXFwuKFtjbV0/KXRzJC9pLCBmdW5jdGlvbiAobSwgdHN4LCBkLCBleHQsIGNtKSB7XG4gICAgICAgICAgcmV0dXJuIHRzeCA/IHByZXNlcnZlSnN4ID8gXCIuanN4XCIgOiBcIi5qc1wiIDogZCAmJiAoIWV4dCB8fCAhY20pID8gbSA6IChkICsgZXh0ICsgXCIuXCIgKyBjbS50b0xvd2VyQ2FzZSgpICsgXCJqc1wiKTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19lc0RlY29yYXRlLFxuICBfX3J1bkluaXRpYWxpemVycyxcbiAgX19wcm9wS2V5LFxuICBfX3NldEZ1bmN0aW9uTmFtZSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG4gIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uLFxufTtcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiBAZW51bVxuICogRW51bSBmb3IgUmVxdWVzdE1ldGhvZHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBHRVQgLSBUaGUgZ2V0IHJlcXVlc3QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFBBVENIIC0gVGhlIHBhdGNoIHJlcXVlc3QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFBPU1QgLSBUaGUgcG9zdCByZXF1ZXN0IHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBQVVQgLSBUaGUgcHV0IHJlcXVlc3QgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IERFTEVURSAtIFRoZSBkZWxldGUgcmVxdWVzdCB0eXBlXG4gKi9cbmV4cG9ydCB2YXIgUmVxdWVzdE1ldGhvZDtcbihmdW5jdGlvbiAoUmVxdWVzdE1ldGhvZCkge1xuICAgIFJlcXVlc3RNZXRob2RbXCJHRVRcIl0gPSBcIkdFVFwiO1xuICAgIFJlcXVlc3RNZXRob2RbXCJQQVRDSFwiXSA9IFwiUEFUQ0hcIjtcbiAgICBSZXF1ZXN0TWV0aG9kW1wiUE9TVFwiXSA9IFwiUE9TVFwiO1xuICAgIFJlcXVlc3RNZXRob2RbXCJQVVRcIl0gPSBcIlBVVFwiO1xuICAgIFJlcXVlc3RNZXRob2RbXCJERUxFVEVcIl0gPSBcIkRFTEVURVwiO1xufSkoUmVxdWVzdE1ldGhvZCB8fCAoUmVxdWVzdE1ldGhvZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXF1ZXN0TWV0aG9kLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBtb2R1bGUgQmF0Y2hSZXF1ZXN0Q29udGVudFxuICovXG5pbXBvcnQgeyBSZXF1ZXN0TWV0aG9kIH0gZnJvbSBcIi4uL1JlcXVlc3RNZXRob2RcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBDbGFzcyBmb3IgaGFuZGxpbmcgQmF0Y2hSZXF1ZXN0Q29udGVudFxuICovXG5leHBvcnQgY2xhc3MgQmF0Y2hSZXF1ZXN0Q29udGVudCB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogVmFsaWRhdGVzIHRoZSBkZXBlbmRlbmN5IGNoYWluIG9mIHRoZSByZXF1ZXN0c1xuICAgICAqXG4gICAgICogTm90ZTpcbiAgICAgKiBJbmRpdmlkdWFsIHJlcXVlc3RzIGNhbiBkZXBlbmQgb24gb3RoZXIgaW5kaXZpZHVhbCByZXF1ZXN0cy4gQ3VycmVudGx5LCByZXF1ZXN0cyBjYW4gb25seSBkZXBlbmQgb24gYSBzaW5nbGUgb3RoZXIgcmVxdWVzdCwgYW5kIG11c3QgZm9sbG93IG9uZSBvZiB0aGVzZSB0aHJlZSBwYXR0ZXJuczpcbiAgICAgKiAxLiBQYXJhbGxlbCAtIG5vIGluZGl2aWR1YWwgcmVxdWVzdCBzdGF0ZXMgYSBkZXBlbmRlbmN5IGluIHRoZSBkZXBlbmRzT24gcHJvcGVydHkuXG4gICAgICogMi4gU2VyaWFsIC0gYWxsIGluZGl2aWR1YWwgcmVxdWVzdHMgZGVwZW5kIG9uIHRoZSBwcmV2aW91cyBpbmRpdmlkdWFsIHJlcXVlc3QuXG4gICAgICogMy4gU2FtZSAtIGFsbCBpbmRpdmlkdWFsIHJlcXVlc3RzIHRoYXQgc3RhdGUgYSBkZXBlbmRlbmN5IGluIHRoZSBkZXBlbmRzT24gcHJvcGVydHksIHN0YXRlIHRoZSBzYW1lIGRlcGVuZGVuY3kuXG4gICAgICogQXMgSlNPTiBiYXRjaGluZyBtYXR1cmVzLCB0aGVzZSBsaW1pdGF0aW9ucyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9ncmFwaC9kb2NzL2NvbmNlcHRzL2tub3duX2lzc3VlcyNqc29uLWJhdGNoaW5nfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBCYXRjaFJlcXVlc3RTdGVwPn0gcmVxdWVzdHMgLSBUaGUgbWFwIG9mIHJlcXVlc3RzLlxuICAgICAqIEByZXR1cm5zIFRoZSBib29sZWFuIGluZGljYXRpbmcgdGhlIHZhbGlkYXRpb24gc3RhdHVzXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlRGVwZW5kZW5jaWVzKHJlcXVlc3RzKSB7XG4gICAgICAgIGNvbnN0IGlzUGFyYWxsZWwgPSAocmVxcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSByZXFzLmVudHJpZXMoKTtcbiAgICAgICAgICAgIGxldCBjdXIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIWN1ci5kb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUmVxID0gY3VyLnZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJSZXEuZGVwZW5kc09uICE9PSB1bmRlZmluZWQgJiYgY3VyUmVxLmRlcGVuZHNPbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlzU2VyaWFsID0gKHJlcXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVxcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICBsZXQgY3VyID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZXF1ZXN0ID0gY3VyLnZhbHVlWzFdO1xuICAgICAgICAgICAgaWYgKGZpcnN0UmVxdWVzdC5kZXBlbmRzT24gIT09IHVuZGVmaW5lZCAmJiBmaXJzdFJlcXVlc3QuZGVwZW5kc09uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJldiA9IGN1cjtcbiAgICAgICAgICAgIGN1ciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlICghY3VyLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJSZXEgPSBjdXIudmFsdWVbMV07XG4gICAgICAgICAgICAgICAgaWYgKGN1clJlcS5kZXBlbmRzT24gPT09IHVuZGVmaW5lZCB8fCBjdXJSZXEuZGVwZW5kc09uLmxlbmd0aCAhPT0gMSB8fCBjdXJSZXEuZGVwZW5kc09uWzBdICE9PSBwcmV2LnZhbHVlWzFdLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgICAgICAgICBjdXIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXNTYW1lID0gKHJlcXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVxcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICBsZXQgY3VyID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZXF1ZXN0ID0gY3VyLnZhbHVlWzFdO1xuICAgICAgICAgICAgbGV0IGRlcGVuZGVuY3lJZDtcbiAgICAgICAgICAgIGlmIChmaXJzdFJlcXVlc3QuZGVwZW5kc09uID09PSB1bmRlZmluZWQgfHwgZmlyc3RSZXF1ZXN0LmRlcGVuZHNPbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5SWQgPSBmaXJzdFJlcXVlc3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXF1ZXN0LmRlcGVuZHNPbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZkRlcGVuZGVuY3lJZCA9IGZpcnN0UmVxdWVzdC5kZXBlbmRzT25bMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmRGVwZW5kZW5jeUlkICE9PSBmaXJzdFJlcXVlc3QuaWQgJiYgcmVxcy5oYXMoZkRlcGVuZGVuY3lJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lJZCA9IGZEZXBlbmRlbmN5SWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIWN1ci5kb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUmVxID0gY3VyLnZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIGlmICgoY3VyUmVxLmRlcGVuZHNPbiA9PT0gdW5kZWZpbmVkIHx8IGN1clJlcS5kZXBlbmRzT24ubGVuZ3RoID09PSAwKSAmJiBkZXBlbmRlbmN5SWQgIT09IGN1clJlcS5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJSZXEuZGVwZW5kc09uICE9PSB1bmRlZmluZWQgJiYgY3VyUmVxLmRlcGVuZHNPbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clJlcS5kZXBlbmRzT24ubGVuZ3RoID09PSAxICYmIChjdXJSZXEuaWQgPT09IGRlcGVuZGVuY3lJZCB8fCBjdXJSZXEuZGVwZW5kc09uWzBdICE9PSBkZXBlbmRlbmN5SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clJlcS5kZXBlbmRzT24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxdWVzdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJFbXB0eSByZXF1ZXN0cyBtYXAsIFBsZWFzZSBwcm92aWRlIGF0IGxlYXN0IG9uZSByZXF1ZXN0LlwiKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkVtcHR5IFJlcXVlc3RzIEVycm9yXCI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNQYXJhbGxlbChyZXF1ZXN0cykgfHwgaXNTZXJpYWwocmVxdWVzdHMpIHx8IGlzU2FtZShyZXF1ZXN0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhc3luY1xuICAgICAqIENvbnZlcnRzIFJlcXVlc3QgT2JqZWN0IGluc3RhbmNlIHRvIGEgSlNPTlxuICAgICAqIEBwYXJhbSB7SXNvbW9ycGhpY1JlcXVlc3R9IHJlcXVlc3QgLSBUaGUgSXNvbW9ycGhpY1JlcXVlc3QgT2JqZWN0IGluc3RhbmNlXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJlcXVlc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVxdWVzdERhdGEocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0h0dHBSZWdleCA9IG5ldyBSZWdFeHAoXCJeaHR0cHM/Oi8vXCIpO1xuICAgICAgICAgICAgLy8gU3RyaXBwaW5nIG9mZiBob3N0bmFtZSwgcG9ydCBhbmQgdXJsIHNjaGVtZVxuICAgICAgICAgICAgcmVxdWVzdERhdGEudXJsID0gaGFzSHR0cFJlZ2V4LnRlc3QocmVxdWVzdC51cmwpID8gXCIvXCIgKyByZXF1ZXN0LnVybC5zcGxpdCgvLio/XFwvXFwvLio/XFwvLylbMV0gOiByZXF1ZXN0LnVybDtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGhlYWRlcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBSZXF1ZXN0TWV0aG9kLlBBVENIIHx8IHJlcXVlc3QubWV0aG9kID09PSBSZXF1ZXN0TWV0aG9kLlBPU1QgfHwgcmVxdWVzdC5tZXRob2QgPT09IFJlcXVlc3RNZXRob2QuUFVUKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGEuYm9keSA9IHlpZWxkIEJhdGNoUmVxdWVzdENvbnRlbnQuZ2V0UmVxdWVzdEJvZHkocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE86IENoZWNrIGFueSBvdGhlciBwcm9wZXJ0eSBuZWVkcyB0byBiZSB1c2VkIGZyb20gdGhlIFJlcXVlc3Qgb2JqZWN0IGFuZCBhZGQgdGhlbVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdERhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBHZXRzIHRoZSBib2R5IG9mIGEgUmVxdWVzdCBvYmplY3QgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0lzb21vcnBoaWNSZXF1ZXN0fSByZXF1ZXN0IC0gVGhlIElzb21vcnBoaWNSZXF1ZXN0IG9iamVjdCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIFRoZSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBib2R5IHZhbHVlIG9mIGEgUmVxdWVzdFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXF1ZXN0Qm9keShyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgYm9keVBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lUmVxID0gcmVxdWVzdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGJvZHkgPSB5aWVsZCBjbG9uZVJlcS5qc29uKCk7XG4gICAgICAgICAgICAgICAgYm9keVBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vVE9ETy0gSGFuZGxlIGVtcHR5IGNhdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYm9keVBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHlpZWxkIHJlcXVlc3QuYmxvYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFVUkwgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29tZSB2YWxpZCBkYXRhVVJMIHNjaGVtZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAxLiBkYXRhOnRleHQvdm5kLWV4YW1wbGUreHl6O2Zvbz1iYXI7YmFzZTY0LFIwbEdPRGRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAyLiBkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1VVEYtODtwYWdlPTIxLHRoZSUyMGRhdGE6MTIzNCw1Njc4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAzLiBkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBSEVsRVFWUUkxMlA0Ly84L3czOEdJQVhESUJLRTBESHhnbGpOQkFBTzlUWEwwWTRPSHdBQUFBQkpSVTVFcmtKZ2dnPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIDQuIGRhdGE6aW1hZ2UvcG5nLGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQUhFbEVRVlFJMTJQNC8vOC93MzhHSUFYRElCS0UwREh4Z2xqTkJBQU85VFhMMFk0T0h3QUFBQUJKUlU1RXJrSmdnZz09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICA1LiBkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBSEVsRVFWUUkxMlA0Ly84L3czOEdJQVhESUJLRTBESHhnbGpOQkFBTzlUWEwwWTRPSHdBQUFBQkpSVTVFcmtKZ2dnPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHNlZSBTeW50YXgge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdGFfVVJJX3NjaGVtZX0gZm9yIG1vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5zKmRhdGE6KC4rPy8uKz8oOy4rPz0uKz8pKik/KDtiYXNlNjQpPywoLiopcyokXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IHJlZ2V4LmV4ZWMoZGF0YVVSTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VnbWVudHNbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHlpZWxkIHJlcXVlc3QuYnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gYnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJvZHlQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUhhbmRsZSBlbXB0eSBjYXRjaGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQ29uc3RydWN0cyBhIEJhdGNoUmVxdWVzdENvbnRlbnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0JhdGNoUmVxdWVzdFN0ZXBbXX0gW3JlcXVlc3RzXSAtIEFycmF5IG9mIHJlcXVlc3RzIHZhbHVlXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYSBCYXRjaFJlcXVlc3RDb250ZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxdWVzdHMpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgbGltaXQgPSBCYXRjaFJlcXVlc3RDb250ZW50LnJlcXVlc3RMaW1pdDtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0cy5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBNYXhpbXVtIHJlcXVlc3RzIGxpbWl0IGV4Y2VlZGVkLCBNYXggYWxsb3dlZCBudW1iZXIgb2YgcmVxdWVzdHMgYXJlICR7bGltaXR9YCk7XG4gICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTGltaXQgRXhjZWVkZWQgRXJyb3JcIjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxIG9mIHJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSZXF1ZXN0KHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEFkZHMgYSByZXF1ZXN0IHRvIHRoZSBiYXRjaCByZXF1ZXN0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge0JhdGNoUmVxdWVzdFN0ZXB9IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBpZCBvZiB0aGUgYWRkZWQgcmVxdWVzdFxuICAgICAqL1xuICAgIGFkZFJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBsaW1pdCA9IEJhdGNoUmVxdWVzdENvbnRlbnQucmVxdWVzdExpbWl0O1xuICAgICAgICBpZiAocmVxdWVzdC5pZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYElkIGZvciBhIHJlcXVlc3QgaXMgZW1wdHksIFBsZWFzZSBwcm92aWRlIGFuIHVuaXF1ZSBpZGApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiRW1wdHkgSWQgRm9yIFJlcXVlc3RcIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RzLnNpemUgPT09IGxpbWl0KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTWF4aW11bSByZXF1ZXN0cyBsaW1pdCBleGNlZWRlZCwgTWF4IGFsbG93ZWQgbnVtYmVyIG9mIHJlcXVlc3RzIGFyZSAke2xpbWl0fWApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTGltaXQgRXhjZWVkZWQgRXJyb3JcIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RzLmhhcyhyZXF1ZXN0LmlkKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEFkZGluZyByZXF1ZXN0IHdpdGggZHVwbGljYXRlIGlkICR7cmVxdWVzdC5pZH0sIE1ha2UgdGhlIGlkIG9mIHRoZSByZXF1ZXN0cyB1bmlxdWVgKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkR1cGxpY2F0ZSBSZXF1ZXN0SWQgRXJyb3JcIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdHMuc2V0KHJlcXVlc3QuaWQsIHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdC5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFJlbW92ZXMgcmVxdWVzdCBmcm9tIHRoZSBiYXRjaCBwYXlsb2FkIGFuZCBpdHMgZGVwZW5kZW5jaWVzIGZyb20gYWxsIGRlcGVuZGVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdElkIC0gVGhlIGlkIG9mIGEgcmVxdWVzdCB0aGF0IG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcmV0dXJucyBUaGUgYm9vbGVhbiBpbmRpY2F0aW5nIHJlbW92ZWQgc3RhdHVzXG4gICAgICovXG4gICAgcmVtb3ZlUmVxdWVzdChyZXF1ZXN0SWQpIHtcbiAgICAgICAgY29uc3QgZGVsZXRlU3RhdHVzID0gdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLnJlcXVlc3RzLmVudHJpZXMoKTtcbiAgICAgICAgbGV0IGN1ciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92aW5nIGRlcGVuZGVuY2llcyB3aGVyZSB0aGlzIHJlcXVlc3QgaXMgcHJlc2VudCBhcyBhIGRlcGVuZGVuY3lcbiAgICAgICAgICovXG4gICAgICAgIHdoaWxlICghY3VyLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGN1ci52YWx1ZVsxXS5kZXBlbmRzT247XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlcGVuZGVuY2llcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGVwZW5kZW5jaWVzLmluZGV4T2YocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VyLnZhbHVlWzFdLmRlcGVuZHNPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGV0ZVN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFNlcmlhbGl6ZSBjb250ZW50IGZyb20gQmF0Y2hSZXF1ZXN0Q29udGVudCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIFRoZSBib2R5IGNvbnRlbnQgdG8gbWFrZSBiYXRjaCByZXF1ZXN0XG4gICAgICovXG4gICAgZ2V0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RzID0gW107XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMucmVxdWVzdHMuZW50cmllcygpO1xuICAgICAgICAgICAgbGV0IGN1ciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChjdXIuZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiTm8gcmVxdWVzdHMgYWRkZWQgeWV0LCBQbGVhc2UgYWRkIGF0IGxlYXN0IG9uZSByZXF1ZXN0LlwiKTtcbiAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJFbXB0eSBQYXlsb2FkXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUJhdGNoUmVxdWVzdENvbnRlbnQudmFsaWRhdGVEZXBlbmRlbmNpZXModGhpcy5yZXF1ZXN0cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSW52YWxpZCBkZXBlbmRlbmN5IGZvdW5kLCBEZXBlbmRlbmN5IHNob3VsZCBiZTpcbjEuIFBhcmFsbGVsIC0gbm8gaW5kaXZpZHVhbCByZXF1ZXN0IHN0YXRlcyBhIGRlcGVuZGVuY3kgaW4gdGhlIGRlcGVuZHNPbiBwcm9wZXJ0eS5cbjIuIFNlcmlhbCAtIGFsbCBpbmRpdmlkdWFsIHJlcXVlc3RzIGRlcGVuZCBvbiB0aGUgcHJldmlvdXMgaW5kaXZpZHVhbCByZXF1ZXN0LlxuMy4gU2FtZSAtIGFsbCBpbmRpdmlkdWFsIHJlcXVlc3RzIHRoYXQgc3RhdGUgYSBkZXBlbmRlbmN5IGluIHRoZSBkZXBlbmRzT24gcHJvcGVydHksIHN0YXRlIHRoZSBzYW1lIGRlcGVuZGVuY3kuYCk7XG4gICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiSW52YWxpZCBEZXBlbmRlbmN5XCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoIWN1ci5kb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFN0ZXAgPSBjdXIudmFsdWVbMV07XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hSZXF1ZXN0RGF0YSA9ICh5aWVsZCBCYXRjaFJlcXVlc3RDb250ZW50LmdldFJlcXVlc3REYXRhKHJlcXVlc3RTdGVwLnJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAc2Vle0BodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzU3OCNzZWN0aW9uLTQuNH1cbiAgICAgICAgICAgICAgICAgKiBUT0RPLSBTZXR0aW5nL0RlZmF1bHRpbmcgb2YgY29udGVudC10eXBlIGhlYWRlciB0byB0aGUgY29ycmVjdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvZ3JhcGgvZG9jcy9jb25jZXB0cy9qc29uX2JhdGNoaW5nI3JlcXVlc3QtZm9ybWF0fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaFJlcXVlc3REYXRhLmJvZHkgIT09IHVuZGVmaW5lZCAmJiAoYmF0Y2hSZXF1ZXN0RGF0YS5oZWFkZXJzID09PSB1bmRlZmluZWQgfHwgYmF0Y2hSZXF1ZXN0RGF0YS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBDb250ZW50LXR5cGUgaGVhZGVyIGlzIG5vdCBtZW50aW9uZWQgZm9yIHJlcXVlc3QgIyR7cmVxdWVzdFN0ZXAuaWR9LCBGb3IgcmVxdWVzdCBoYXZpbmcgYm9keSwgQ29udGVudC10eXBlIGhlYWRlciBzaG91bGQgYmUgbWVudGlvbmVkYCk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkludmFsaWQgQ29udGVudC10eXBlIGhlYWRlclwiO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmF0Y2hSZXF1ZXN0RGF0YS5pZCA9IHJlcXVlc3RTdGVwLmlkO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0U3RlcC5kZXBlbmRzT24gIT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0U3RlcC5kZXBlbmRzT24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaFJlcXVlc3REYXRhLmRlcGVuZHNPbiA9IHJlcXVlc3RTdGVwLmRlcGVuZHNPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdHMucHVzaChiYXRjaFJlcXVlc3REYXRhKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0Qm9keS5yZXF1ZXN0cyA9IHJlcXVlc3RzO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RCb2R5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEFkZHMgYSBkZXBlbmRlbmN5IGZvciBhIGdpdmVuIGRlcGVuZGVudCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlcGVuZGVudElkIC0gVGhlIGlkIG9mIHRoZSBkZXBlbmRlbnQgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVwZW5kZW5jeUlkXSAtIFRoZSBpZCBvZiB0aGUgZGVwZW5kZW5jeSByZXF1ZXN0LCBpZiBub3Qgc3BlY2lmaWVkIHRoZSBwcmVjZWRpbmcgcmVxdWVzdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSBkZXBlbmRlbmN5XG4gICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAqL1xuICAgIGFkZERlcGVuZGVuY3koZGVwZW5kZW50SWQsIGRlcGVuZGVuY3lJZCkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdHMuaGFzKGRlcGVuZGVudElkKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYERlcGVuZGVudCAke2RlcGVuZGVudElkfSBkb2VzIG5vdCBleGlzdHMsIFBsZWFzZSBjaGVjayB0aGUgaWRgKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkludmFsaWQgRGVwZW5kZW50XCI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRlcGVuZGVuY3lJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhdGhpcy5yZXF1ZXN0cy5oYXMoZGVwZW5kZW5jeUlkKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYERlcGVuZGVuY3kgJHtkZXBlbmRlbmN5SWR9IGRvZXMgbm90IGV4aXN0cywgUGxlYXNlIGNoZWNrIHRoZSBpZGApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiSW52YWxpZCBEZXBlbmRlbmN5XCI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRlcGVuZGVuY3lJZCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgZGVwZW5kZW50ID0gdGhpcy5yZXF1ZXN0cy5nZXQoZGVwZW5kZW50SWQpO1xuICAgICAgICAgICAgaWYgKGRlcGVuZGVudC5kZXBlbmRzT24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVudC5kZXBlbmRzT24gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXBlbmRlbnQuZGVwZW5kc09uLmluZGV4T2YoZGVwZW5kZW5jeUlkKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRGVwZW5kZW5jeSAke2RlcGVuZGVuY3lJZH0gaXMgYWxyZWFkeSBhZGRlZCBmb3IgdGhlIHJlcXVlc3QgJHtkZXBlbmRlbnRJZH1gKTtcbiAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJEdXBsaWNhdGUgRGVwZW5kZW5jeVwiO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVwZW5kZW50LmRlcGVuZHNPbi5wdXNoKGRlcGVuZGVuY3lJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMucmVxdWVzdHMuZW50cmllcygpO1xuICAgICAgICAgICAgbGV0IHByZXY7XG4gICAgICAgICAgICBsZXQgY3VyID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXIuZG9uZSAmJiBjdXIudmFsdWVbMV0uaWQgIT09IGRlcGVuZGVudElkKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgICAgICAgICBjdXIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkSWQgPSBwcmV2LnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjdXIudmFsdWVbMV0uZGVwZW5kc09uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLnZhbHVlWzFdLmRlcGVuZHNPbiA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VyLnZhbHVlWzFdLmRlcGVuZHNPbi5pbmRleE9mKGRJZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBEZXBlbmRlbmN5ICR7ZElkfSBpcyBhbHJlYWR5IGFkZGVkIGZvciB0aGUgcmVxdWVzdCAke2RlcGVuZGVudElkfWApO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJEdXBsaWNhdGUgRGVwZW5kZW5jeVwiO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLnZhbHVlWzFdLmRlcGVuZHNPbi5wdXNoKGRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQ2FuJ3QgYWRkIGRlcGVuZGVuY3kgJHtkZXBlbmRlbmN5SWR9LCBUaGVyZSBpcyBvbmx5IGEgZGVwZW5kZW50IHJlcXVlc3QgaW4gdGhlIGJhdGNoYCk7XG4gICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiSW52YWxpZCBEZXBlbmRlbmN5IEFkZGl0aW9uXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFJlbW92ZXMgYSBkZXBlbmRlbmN5IGZvciBhIGdpdmVuIGRlcGVuZGVudCByZXF1ZXN0IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlcGVuZGVudElkIC0gVGhlIGlkIG9mIHRoZSBkZXBlbmRlbnQgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVwZW5kZW5jeUlkXSAtIFRoZSBpZCBvZiB0aGUgZGVwZW5kZW5jeSByZXF1ZXN0LCBpZiBub3Qgc3BlY2lmaWVkIHdpbGwgcmVtb3ZlIGFsbCB0aGUgZGVwZW5kZW5jaWVzIG9mIHRoYXQgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIFRoZSBib29sZWFuIGluZGljYXRpbmcgcmVtb3ZlZCBzdGF0dXNcbiAgICAgKi9cbiAgICByZW1vdmVEZXBlbmRlbmN5KGRlcGVuZGVudElkLCBkZXBlbmRlbmN5SWQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KGRlcGVuZGVudElkKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSBcInVuZGVmaW5lZFwiIHx8IHJlcXVlc3QuZGVwZW5kc09uID09PSB1bmRlZmluZWQgfHwgcmVxdWVzdC5kZXBlbmRzT24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBlbmRlbmN5SWQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVxdWVzdC5kZXBlbmRzT24uaW5kZXhPZihkZXBlbmRlbmN5SWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QuZGVwZW5kc09uLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0LmRlcGVuZHNPbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogTGltaXQgZm9yIG51bWJlciBvZiByZXF1ZXN0cyB7QGxpbmsgLSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL2dyYXBoL2RvY3MvY29uY2VwdHMva25vd25faXNzdWVzI2pzb24tYmF0Y2hpbmd9XG4gKi9cbkJhdGNoUmVxdWVzdENvbnRlbnQucmVxdWVzdExpbWl0ID0gMjA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFJlcXVlc3RDb250ZW50LmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIHRoYXQgaGFuZGxlcyBCYXRjaFJlc3BvbnNlQ29udGVudFxuICovXG5leHBvcnQgY2xhc3MgQmF0Y2hSZXNwb25zZUNvbnRlbnQge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBDcmVhdGVzIHRoZSBCYXRjaFJlc3BvbnNlQ29udGVudCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QmF0Y2hSZXNwb25zZUJvZHl9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIGJvZHkgcmV0dXJuZWQgZm9yIGJhdGNoIHJlcXVlc3QgZnJvbSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBhIEJhdGNoUmVzcG9uc2VDb250ZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDcmVhdGVzIG5hdGl2ZSBSZXNwb25zZSBvYmplY3QgZnJvbSB0aGUganNvbiByZXByZXNlbnRhdGlvbiBvZiBpdC5cbiAgICAgKiBAcGFyYW0ge0tleVZhbHVlUGFpck9iamVjdH0gcmVzcG9uc2VKU09OIC0gVGhlIHJlc3BvbnNlIGpzb24gdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgUmVzcG9uc2UgT2JqZWN0IGluc3RhbmNlXG4gICAgICovXG4gICAgY3JlYXRlUmVzcG9uc2VPYmplY3QocmVzcG9uc2VKU09OKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZUpTT04uYm9keTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IHJlc3BvbnNlSlNPTi5zdGF0dXM7XG4gICAgICAgIGlmIChyZXNwb25zZUpTT04uc3RhdHVzVGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN0YXR1c1RleHQgPSByZXNwb25zZUpTT04uc3RhdHVzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSByZXNwb25zZUpTT04uaGVhZGVycztcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdLnNwbGl0KFwiO1wiKVswXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5U3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5U3RyaW5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVXBkYXRlcyB0aGUgQmF0Y2ggcmVzcG9uc2UgY29udGVudCBpbnN0YW5jZSB3aXRoIGdpdmVuIHJlc3BvbnNlcy5cbiAgICAgKiBAcGFyYW0ge0JhdGNoUmVzcG9uc2VCb2R5fSByZXNwb25zZSAtIFRoZSByZXNwb25zZSBqc29uIHJlcHJlc2VudGluZyBiYXRjaCByZXNwb25zZSBtZXNzYWdlXG4gICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAqL1xuICAgIHVwZGF0ZShyZXNwb25zZSkge1xuICAgICAgICB0aGlzLm5leHRMaW5rID0gcmVzcG9uc2VbXCJAb2RhdGEubmV4dExpbmtcIl07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IHJlc3BvbnNlLnJlc3BvbnNlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByZXNwb25zZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlcy5zZXQocmVzcG9uc2VzW2ldLmlkLCB0aGlzLmNyZWF0ZVJlc3BvbnNlT2JqZWN0KHJlc3BvbnNlc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUbyBnZXQgdGhlIHJlc3BvbnNlIG9mIGEgcmVxdWVzdCBmb3IgYSBnaXZlbiByZXF1ZXN0IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RJZCAtIFRoZSByZXF1ZXN0IGlkIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIFJlc3BvbnNlIG9iamVjdCBpbnN0YW5jZSBmb3IgdGhlIHBhcnRpY3VsYXIgcmVxdWVzdFxuICAgICAqL1xuICAgIGdldFJlc3BvbnNlQnlJZChyZXF1ZXN0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VzLmdldChyZXF1ZXN0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVG8gZ2V0IGFsbCB0aGUgcmVzcG9uc2VzIG9mIHRoZSBiYXRjaCByZXF1ZXN0XG4gICAgICogQHJldHVybnMgVGhlIE1hcCBvZiBpZCBhbmQgUmVzcG9uc2Ugb2JqZWN0c1xuICAgICAqL1xuICAgIGdldFJlc3BvbnNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVG8gZ2V0IHRoZSBpdGVyYXRvciBmb3IgdGhlIHJlc3BvbnNlc1xuICAgICAqIEByZXR1cm5zIFRoZSBJdGVyYWJsZSBnZW5lcmF0b3IgZm9yIHRoZSByZXNwb25zZSBvYmplY3RzXG4gICAgICovXG4gICAgKmdldFJlc3BvbnNlc0l0ZXJhdG9yKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMucmVzcG9uc2VzLmVudHJpZXMoKTtcbiAgICAgICAgbGV0IGN1ciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFjdXIuZG9uZSkge1xuICAgICAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgICAgICAgICAgY3VyID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hSZXNwb25zZUNvbnRlbnQuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBtb2R1bGUgQ29uc3RhbnRzXG4gKi9cbi8qKlxuICogQGNvbnN0YW50XG4gKiBBIERlZmF1bHQgQVBJIGVuZHBvaW50IHZlcnNpb24gZm9yIGEgcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgR1JBUEhfQVBJX1ZFUlNJT04gPSBcInYxLjBcIjtcbi8qKlxuICogQGNvbnN0YW50XG4gKiBBIERlZmF1bHQgYmFzZSB1cmwgZm9yIGEgcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgR1JBUEhfQkFTRV9VUkwgPSBcImh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS9cIjtcbi8qKlxuICogVG8gaG9sZCBsaXN0IG9mIHRoZSBzZXJ2aWNlIHJvb3QgZW5kcG9pbnRzIGZvciBNaWNyb3NvZnQgR3JhcGggYW5kIEdyYXBoIEV4cGxvcmVyIGZvciBlYWNoIG5hdGlvbmFsIGNsb3VkLlxuICogU2V0KGl0ZXJhYmxlOk9iamVjdCkgaXMgbm90IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci4gVGhlIGNvbnN1bWVyIGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhIHN1aXRhYmxlIHBvbHlmaWxsLlxuICovXG5leHBvcnQgY29uc3QgR1JBUEhfVVJMUyA9IG5ldyBTZXQoW1wiZ3JhcGgubWljcm9zb2Z0LmNvbVwiLCBcImdyYXBoLm1pY3Jvc29mdC51c1wiLCBcImRvZC1ncmFwaC5taWNyb3NvZnQudXNcIiwgXCJncmFwaC5taWNyb3NvZnQuZGVcIiwgXCJtaWNyb3NvZnRncmFwaC5jaGluYWNsb3VkYXBpLmNuXCIsIFwiY2FuYXJ5LmdyYXBoLm1pY3Jvc29mdC5jb21cIl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uc3RhbnRzLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiBAbW9kdWxlIEdyYXBoQ2xpZW50RXJyb3JcbiAqL1xuLyoqXG4gKiBAY2xhc3NcbiAqIENyZWF0ZSBHcmFwaENsaWVudEVycm9yIG9iamVjdCB0byBoYW5kbGUgY2xpZW50LXNpZGUgZXJyb3JzXG4gKiBlbmNvdW50ZXJlZCB3aXRoaW4gdGhlIEphdmFTY3JpcHQgQ2xpZW50IFNESy5cbiAqIFdoZXJlYXMgR3JhcGhFcnJvciBDbGFzcyBzaG91bGQgYmUgdXNlZCB0byBoYW5kbGUgZXJyb3JzIGluIHRoZSByZXNwb25zZSBmcm9tIHRoZSBHcmFwaCBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBHcmFwaENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGFzeW5jXG4gICAgICogVG8gc2V0IHRoZSBHcmFwaENsaWVudEVycm9yIG9iamVjdFxuICAgICAqIEBwYXJhbSB7YW55fSBlcnJvciAtIFRoZSBlcnJvciByZXR1cm5lZCBlbmNvdW50ZXJlZCBieSB0aGUgR3JhcGggSmF2YVNjcmlwdCBDbGllbnQgU0RLIHdoaWxlIHByb2Nlc3NpbmcgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIEdyYXBoQ2xpZW50RXJyb3Igb2JqZWN0IHNldCB0byB0aGUgZXJyb3IgcGFzc2VkXG4gICAgICovXG4gICAgc3RhdGljIHNldEdyYXBoQ2xpZW50RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgbGV0IGdyYXBoQ2xpZW50RXJyb3I7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBncmFwaENsaWVudEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBncmFwaENsaWVudEVycm9yID0gbmV3IEdyYXBoQ2xpZW50RXJyb3IoKTtcbiAgICAgICAgICAgIGdyYXBoQ2xpZW50RXJyb3IuY3VzdG9tRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhcGhDbGllbnRFcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR3JhcGhDbGllbnRFcnJvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlPyAtIEVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBHcmFwaENsaWVudEVycm9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEdyYXBoQ2xpZW50RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaENsaWVudEVycm9yLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiBAbW9kdWxlIEdyYXBoUmVxdWVzdFV0aWxcbiAqL1xuaW1wb3J0IHsgR1JBUEhfVVJMUyB9IGZyb20gXCIuL0NvbnN0YW50c1wiO1xuaW1wb3J0IHsgR3JhcGhDbGllbnRFcnJvciB9IGZyb20gXCIuL0dyYXBoQ2xpZW50RXJyb3JcIjtcbi8qKlxuICogVG8gaG9sZCBsaXN0IG9mIE9EYXRhIHF1ZXJ5IHBhcmFtc1xuICovXG5leHBvcnQgY29uc3Qgb0RhdGFRdWVyeU5hbWVzID0gW1wiJHNlbGVjdFwiLCBcIiRleHBhbmRcIiwgXCIkb3JkZXJieVwiLCBcIiRmaWx0ZXJcIiwgXCIkdG9wXCIsIFwiJHNraXBcIiwgXCIkc2tpcFRva2VuXCIsIFwiJGNvdW50XCJdO1xuLyoqXG4gKiBUbyBjb25zdHJ1Y3QgdGhlIFVSTCBieSBhcHBlbmRpbmcgdGhlIHNlZ21lbnRzIHdpdGggXCIvXCJcbiAqIEBwYXJhbSB7c3RyaW5nW119IHVybFNlZ21lbnRzIC0gVGhlIGFycmF5IG9mIHN0cmluZ3NcbiAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RlZCBVUkwgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB1cmxKb2luID0gKHVybFNlZ21lbnRzKSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlUG9zdFNsYXNoID0gKHMpID0+IHMucmVwbGFjZSgvXFwvKyQvLCBcIlwiKTtcbiAgICBjb25zdCByZW1vdmVQcmVTbGFzaCA9IChzKSA9PiBzLnJlcGxhY2UoL15cXC8rLywgXCJcIik7XG4gICAgY29uc3Qgam9pbmVyID0gKHByZSwgY3VyKSA9PiBbcmVtb3ZlUG9zdFNsYXNoKHByZSksIHJlbW92ZVByZVNsYXNoKGN1cildLmpvaW4oXCIvXCIpO1xuICAgIGNvbnN0IHBhcnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodXJsU2VnbWVudHMpO1xuICAgIHJldHVybiBwYXJ0cy5yZWR1Y2Uoam9pbmVyKTtcbn07XG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhlIGNvbnRlbnRcbiAqIEBwYXJhbSB7YW55fSBjb250ZW50IC0gVGhlIGNvbnRlbnQgdmFsdWUgdGhhdCBuZWVkcyB0byBiZSBzZXJpYWxpemVkXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBjb250ZW50XG4gKlxuICogTm90ZTpcbiAqIFRoaXMgY29udmVyc2lvbiBpcyByZXF1aXJlZCBkdWUgdG8gdGhlIGZvbGxvd2luZyByZWFzb25zOlxuICogQm9keSBwYXJhbWV0ZXIgb2YgUmVxdWVzdCBtZXRob2Qgb2YgaXNvbW9ycGhpYy1mZXRjaCBvbmx5IGFjY2VwdHMgQmxvYiwgQXJyYXlCdWZmZXIsIEZvcm1EYXRhLCBUeXBlZEFycmF5cyBzdHJpbmcuXG4gKiBOb2RlLmpzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQmxvYiwgRm9ybURhdGEuIEphdmFzY3JpcHQgRmlsZSBvYmplY3QgaW5oZXJpdHMgZnJvbSBCbG9iIHNvIGl0IGlzIGFsc28gbm90IHN1cHBvcnRlZCBpbiBub2RlLiBUaGVyZWZvcmUgY29udGVudCBvZiB0eXBlIEJsb2IsIEZpbGUsIEZvcm1EYXRhIHdpbGwgb25seSBjb21lIGZyb20gYnJvd3NlcnMuXG4gKiBQYXJhbGxlbCB0byBBcnJheUJ1ZmZlciBpbiBqYXZhc2NyaXB0LCBub2RlIHByb3ZpZGVzIEJ1ZmZlciBpbnRlcmZhY2UuIE5vZGUncyBCdWZmZXIgaXMgYWJsZSB0byBzZW5kIHRoZSBhcmJpdHJhcnkgYmluYXJ5IGRhdGEgdG8gdGhlIHNlcnZlciBzdWNjZXNzZnVsbHkgZm9yIGJvdGggQnJvd3NlciBhbmQgTm9kZSBwbGF0Zm9ybS4gV2hlcmVhcyBzZW5kaW5nIGJpbmFyeSBkYXRhIHZpYSBBcnJheUJ1ZmZlciBvciBUeXBlZEFycmF5cyB3YXMgb25seSBwb3NzaWJsZSB1c2luZyBCcm93c2VyLiBUbyBzdXBwb3J0IGJvdGggTm9kZSBhbmQgQnJvd3NlciwgYHNlcmlhbGl6ZUNvbnRlbnRgIGNvbnZlcnRzIFR5cGVkQXJyYXlzIG9yIEFycmF5QnVmZmVyIHRvIGBOb2RlIEJ1ZmZlcmAuXG4gKiBJZiB0aGUgZGF0YSByZWNlaXZlZCBpcyBpbiBKU09OIGZvcm1hdCwgYHNlcmlhbGl6ZUNvbnRlbnRgIGNvbnZlcnRzIHRoZSBKU09OIHRvIHN0cmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZUNvbnRlbnQgPSAoY29udGVudCkgPT4ge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNvbnRlbnQgJiYgY29udGVudC5jb25zdHJ1Y3RvciAmJiBjb250ZW50LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKGNsYXNzTmFtZSA9PT0gXCJCdWZmZXJcIiB8fCBjbGFzc05hbWUgPT09IFwiQmxvYlwiIHx8IGNsYXNzTmFtZSA9PT0gXCJGaWxlXCIgfHwgY2xhc3NOYW1lID09PSBcIkZvcm1EYXRhXCIgfHwgdHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWUgPT09IFwiQXJyYXlCdWZmZXJcIikge1xuICAgICAgICBjb250ZW50ID0gQnVmZmVyLmZyb20oY29udGVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJJbnQ4QXJyYXlcIiB8fCBjbGFzc05hbWUgPT09IFwiSW50MTZBcnJheVwiIHx8IGNsYXNzTmFtZSA9PT0gXCJJbnQzMkFycmF5XCIgfHwgY2xhc3NOYW1lID09PSBcIlVpbnQ4QXJyYXlcIiB8fCBjbGFzc05hbWUgPT09IFwiVWludDE2QXJyYXlcIiB8fCBjbGFzc05hbWUgPT09IFwiVWludDMyQXJyYXlcIiB8fCBjbGFzc05hbWUgPT09IFwiVWludDhDbGFtcGVkQXJyYXlcIiB8fCBjbGFzc05hbWUgPT09IFwiRmxvYXQzMkFycmF5XCIgfHwgY2xhc3NOYW1lID09PSBcIkZsb2F0NjRBcnJheVwiIHx8IGNsYXNzTmFtZSA9PT0gXCJEYXRhVmlld1wiKSB7XG4gICAgICAgIGNvbnRlbnQgPSBCdWZmZXIuZnJvbShjb250ZW50LmJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHN0cmluZ2lmeSB0aGUgY29udGVudFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdXJsIGlzIG9uZSBvZiB0aGUgc2VydmljZSByb290IGVuZHBvaW50cyBmb3IgTWljcm9zb2Z0IEdyYXBoIGFuZCBHcmFwaCBFeHBsb3Jlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIGJlIHZlcmlmaWVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHVybCBpcyBhIEdyYXBoIFVSTFxuICovXG5leHBvcnQgY29uc3QgaXNHcmFwaFVSTCA9ICh1cmwpID0+IHtcbiAgICByZXR1cm4gaXNWYWxpZEVuZHBvaW50KHVybCk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHVybCBpcyBmb3Igb25lIG9mIHRoZSBjdXN0b20gaG9zdHMgcHJvdmlkZWQgZHVyaW5nIGNsaWVudCBpbml0aWFsaXphdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB1cmwgdG8gYmUgdmVyaWZpZWRcbiAqIEBwYXJhbSB7U2V0fSBjdXN0b21Ib3N0cyAtIFRoZSB1cmwgdG8gYmUgdmVyaWZpZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXJsIGlzIGEgZm9yIGEgY3VzdG9tIGhvc3RcbiAqL1xuZXhwb3J0IGNvbnN0IGlzQ3VzdG9tSG9zdCA9ICh1cmwsIGN1c3RvbUhvc3RzKSA9PiB7XG4gICAgY3VzdG9tSG9zdHMuZm9yRWFjaCgoaG9zdCkgPT4gaXNDdXN0b21Ib3N0VmFsaWQoaG9zdCkpO1xuICAgIHJldHVybiBpc1ZhbGlkRW5kcG9pbnQodXJsLCBjdXN0b21Ib3N0cyk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHVybCBpcyBmb3Igb25lIG9mIHRoZSBwcm92aWRlZCBob3N0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIGJlIHZlcmlmaWVkXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBhbGxvd2VkSG9zdHMgLSBBIHNldCBvZiBob3N0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpcyBmb3Igb25lIG9mIHRoZSBwcm92aWRlZCBlbmRwb2ludHMuXG4gKi9cbmNvbnN0IGlzVmFsaWRFbmRwb2ludCA9ICh1cmwsIGFsbG93ZWRIb3N0cyA9IEdSQVBIX1VSTFMpID0+IHtcbiAgICAvLyBWYWxpZCBHcmFwaCBVUkwgcGF0dGVybiAtIGh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS97dmVyc2lvbn0ve3Jlc291cmNlfT97cXVlcnktcGFyYW1ldGVyc31cbiAgICAvLyBWYWxpZCBHcmFwaCBVUkwgZXhhbXBsZSAtIGh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS92MS4wL1xuICAgIHVybCA9IHVybC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh1cmwuaW5kZXhPZihcImh0dHBzOi8vXCIpICE9PSAtMSkge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiXCIpO1xuICAgICAgICAvLyBGaW5kIHdoZXJlIHRoZSBob3N0IGVuZHNcbiAgICAgICAgY29uc3Qgc3RhcnRvZlBvcnROb1BvcyA9IHVybC5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgY29uc3QgZW5kT2ZIb3N0U3RyUG9zID0gdXJsLmluZGV4T2YoXCIvXCIpO1xuICAgICAgICBsZXQgaG9zdE5hbWUgPSBcIlwiO1xuICAgICAgICBpZiAoZW5kT2ZIb3N0U3RyUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0b2ZQb3J0Tm9Qb3MgIT09IC0xICYmIHN0YXJ0b2ZQb3J0Tm9Qb3MgPCBlbmRPZkhvc3RTdHJQb3MpIHtcbiAgICAgICAgICAgICAgICBob3N0TmFtZSA9IHVybC5zdWJzdHJpbmcoMCwgc3RhcnRvZlBvcnROb1Bvcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93ZWRIb3N0cy5oYXMoaG9zdE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBob3N0XG4gICAgICAgICAgICBob3N0TmFtZSA9IHVybC5zdWJzdHJpbmcoMCwgZW5kT2ZIb3N0U3RyUG9zKTtcbiAgICAgICAgICAgIHJldHVybiBhbGxvd2VkSG9zdHMuaGFzKGhvc3ROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBUaHJvd3MgZXJyb3IgaWYgdGhlIHN0cmluZyBpcyBub3QgYSB2YWxpZCBob3N0L2hvc3RuYW1lIGFuZCBjb250YWlucyBvdGhlciB1cmwgcGFydHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdCAtIFRoZSBob3N0IHRvIGJlIHZlcmlmaWVkXG4gKi9cbmNvbnN0IGlzQ3VzdG9tSG9zdFZhbGlkID0gKGhvc3QpID0+IHtcbiAgICBpZiAoaG9zdC5pbmRleE9mKFwiL1wiKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdyYXBoQ2xpZW50RXJyb3IoXCJQbGVhc2UgYWRkIG9ubHkgaG9zdHMgb3IgaG9zdG5hbWVzIHRvIHRoZSBDdXN0b21Ib3N0cyBjb25maWcuIElmIHRoZSB1cmwgaXMgYGh0dHA6Ly9leGFtcGxlLmNvbTozMDAwL2AsIGhvc3QgaXMgYGV4YW1wbGU6MzAwMGBcIik7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoUmVxdWVzdFV0aWwuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBjbGFzc1xuICogQ2xhc3MgcmVwcmVzZW50aW5nIE1pZGRsZXdhcmVDb250cm9sXG4gKi9cbmV4cG9ydCBjbGFzcyBNaWRkbGV3YXJlQ29udHJvbCB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWlkZGxld2FyZUNvbnRyb2xcbiAgICAgKiBAcGFyYW0ge01pZGRsZXdhcmVPcHRpb25zW119IFttaWRkbGV3YXJlT3B0aW9ucyA9IFtdXSAtIFRoZSBhcnJheSBvZiBtaWRkbGV3YXJlT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiBNaWRkbGV3YXJlQ29udHJvbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1pZGRsZXdhcmVPcHRpb25zID0gW10pIHtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgbWlkZGxld2FyZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gb3B0aW9uLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdGhpcy5taWRkbGV3YXJlT3B0aW9ucy5zZXQoZm4sIG9wdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIGdldCB0aGUgbWlkZGxld2FyZSBvcHRpb24gdXNpbmcgdGhlIGNsYXNzIG9mIHRoZSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBjbGFzcyBvZiB0aGUgc3Ryb25nbHkgdHlwZWQgb3B0aW9uIGNsYXNzXG4gICAgICogQHJldHVybnMgVGhlIG1pZGRsZXdhcmUgb3B0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBpZiB5b3Ugd2FudGVkIHRvIHJldHVybiB0aGUgbWlkZGxld2FyZSBvcHRpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgY2xhc3MgKE1pZGRsZXdhcmVDb250cm9sKVxuICAgICAqIC8vIGNhbGwgdGhpcyBmdW5jdGlvbiBsaWtlIHRoaXM6XG4gICAgICogZ2V0TWlkZGxld2FyZU9wdGlvbnMoTWlkZGxld2FyZUNvbnRyb2wpXG4gICAgICovXG4gICAgZ2V0TWlkZGxld2FyZU9wdGlvbnMoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlkZGxld2FyZU9wdGlvbnMuZ2V0KGZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIHNldCB0aGUgbWlkZGxld2FyZSBvcHRpb25zIHVzaW5nIHRoZSBjbGFzcyBvZiB0aGUgb3B0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgY2xhc3Mgb2YgdGhlIHN0cm9uZ2x5IHR5cGVkIG9wdGlvbiBjbGFzc1xuICAgICAqIEBwYXJhbSB7TWlkZGxld2FyZU9wdGlvbnN9IG9wdGlvbiAtIFRoZSBzdHJvbmdseSB0eXBlZCBtaWRkbGV3YXJlIG9wdGlvblxuICAgICAqIEByZXR1cm5zIG5vdGhpbmdcbiAgICAgKi9cbiAgICBzZXRNaWRkbGV3YXJlT3B0aW9ucyhmbiwgb3B0aW9uKSB7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZU9wdGlvbnMuc2V0KGZuLCBvcHRpb24pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pZGRsZXdhcmVDb250cm9sLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBjb25zdGFudFxuICogVG8gZ2VuZXJhdGUgdGhlIFVVSURcbiAqIEByZXR1cm5zIFRoZSBVVUlEIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVVVUlEID0gKCkgPT4ge1xuICAgIGxldCB1dWlkID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICAgICAgaWYgKGogPT09IDggfHwgaiA9PT0gMTIgfHwgaiA9PT0gMTYgfHwgaiA9PT0gMjApIHtcbiAgICAgICAgICAgIHV1aWQgKz0gXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgdXVpZCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNikudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICByZXR1cm4gdXVpZDtcbn07XG4vKipcbiAqIEBjb25zdGFudFxuICogVG8gZ2V0IHRoZSByZXF1ZXN0IGhlYWRlciBmcm9tIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge1JlcXVlc3RJbmZvfSByZXF1ZXN0IC0gVGhlIHJlcXVlc3Qgb2JqZWN0IG9yIHRoZSB1cmwgc3RyaW5nXG4gKiBAcGFyYW0ge0ZldGNoT3B0aW9uc3x1bmRlZmluZWR9IG9wdGlvbnMgLSBUaGUgcmVxdWVzdCBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBoZWFkZXIga2V5IHN0cmluZ1xuICogQHJldHVybnMgQSBoZWFkZXIgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkgZnJvbSB0aGUgcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgZ2V0UmVxdWVzdEhlYWRlciA9IChyZXF1ZXN0LCBvcHRpb25zLCBrZXkpID0+IHtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICB2YWx1ZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoa2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwidW5kZWZpbmVkXCIgJiYgb3B0aW9ucy5oZWFkZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiICYmIG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gb3B0aW9ucy5oZWFkZXJzLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBoZWFkZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzW2ldWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBvcHRpb25zLmhlYWRlcnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBAY29uc3RhbnRcbiAqIFRvIHNldCB0aGUgaGVhZGVyIHZhbHVlIHRvIHRoZSBnaXZlbiByZXF1ZXN0XG4gKiBAcGFyYW0ge1JlcXVlc3RJbmZvfSByZXF1ZXN0IC0gVGhlIHJlcXVlc3Qgb2JqZWN0IG9yIHRoZSB1cmwgc3RyaW5nXG4gKiBAcGFyYW0ge0ZldGNoT3B0aW9uc3x1bmRlZmluZWR9IG9wdGlvbnMgLSBUaGUgcmVxdWVzdCBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBoZWFkZXIga2V5IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmcgfSB2YWx1ZSAtIFRoZSBoZWFkZXIgdmFsdWUgc3RyaW5nXG4gKiBAcmV0dXJucyBOb3RoaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRSZXF1ZXN0SGVhZGVyID0gKHJlcXVlc3QsIG9wdGlvbnMsIGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIFJlcXVlc3QgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgW2tleV06IHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEhlYWRlcnMgIT09IFwidW5kZWZpbmVkXCIgJiYgb3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gb3B0aW9ucy5oZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBvcHRpb25zLmhlYWRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyWzFdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5oZWFkZXJzLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEBjb25zdGFudFxuICogVG8gYXBwZW5kIHRoZSBoZWFkZXIgdmFsdWUgdG8gdGhlIGdpdmVuIHJlcXVlc3RcbiAqIEBwYXJhbSB7UmVxdWVzdEluZm99IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCBvYmplY3Qgb3IgdGhlIHVybCBzdHJpbmdcbiAqIEBwYXJhbSB7RmV0Y2hPcHRpb25zfHVuZGVmaW5lZH0gb3B0aW9ucyAtIFRoZSByZXF1ZXN0IG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGhlYWRlciBrZXkgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZyB9IHZhbHVlIC0gVGhlIGhlYWRlciB2YWx1ZSBzdHJpbmdcbiAqIEByZXR1cm5zIE5vdGhpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZFJlcXVlc3RIZWFkZXIgPSAocmVxdWVzdCwgb3B0aW9ucywga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICBba2V5XTogdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0geyBba2V5XTogdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleV0gKz0gYCwgJHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQGNvbnN0YW50XG4gKiBUbyBjbG9uZSB0aGUgcmVxdWVzdCB3aXRoIHRoZSBuZXcgdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIG5ldyB1cmwgc3RyaW5nXG4gKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHJlcXVlc3Qgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZVJlcXVlc3RXaXRoTmV3VXJsID0gKG5ld1VybCwgcmVxdWVzdCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYm9keSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgPyB5aWVsZCByZXF1ZXN0LmJsb2IoKSA6IHlpZWxkIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIGNvbnN0IHsgbWV0aG9kLCBoZWFkZXJzLCByZWZlcnJlciwgcmVmZXJyZXJQb2xpY3ksIG1vZGUsIGNyZWRlbnRpYWxzLCBjYWNoZSwgcmVkaXJlY3QsIGludGVncml0eSwga2VlcGFsaXZlLCBzaWduYWwgfSA9IHJlcXVlc3Q7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG5ld1VybCwgeyBtZXRob2QsIGhlYWRlcnMsIGJvZHksIHJlZmVycmVyLCByZWZlcnJlclBvbGljeSwgbW9kZSwgY3JlZGVudGlhbHMsIGNhY2hlLCByZWRpcmVjdCwgaW50ZWdyaXR5LCBrZWVwYWxpdmUsIHNpZ25hbCB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWlkZGxld2FyZVV0aWwuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBjbGFzc1xuICogQGltcGxlbWVudHMgTWlkZGxld2FyZU9wdGlvbnNcbiAqIENsYXNzIHJlcHJlc2VudGluZyBBdXRoZW50aWNhdGlvbkhhbmRsZXJPcHRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGlvbkhhbmRsZXJPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogVG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIEF1dGhlbnRpY2F0aW9uSGFuZGxlck9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0F1dGhlbnRpY2F0aW9uUHJvdmlkZXJ9IFthdXRoZW50aWNhdGlvblByb3ZpZGVyXSAtIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25Qcm92aWRlck9wdGlvbnN9IFthdXRoZW50aWNhdGlvblByb3ZpZGVyT3B0aW9uc10gLSBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgb3B0aW9ucyBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIEF1dGhlbnRpY2F0aW9uSGFuZGxlck9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoZW50aWNhdGlvblByb3ZpZGVyLCBhdXRoZW50aWNhdGlvblByb3ZpZGVyT3B0aW9ucykge1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uUHJvdmlkZXIgPSBhdXRoZW50aWNhdGlvblByb3ZpZGVyO1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uUHJvdmlkZXJPcHRpb25zID0gYXV0aGVudGljYXRpb25Qcm92aWRlck9wdGlvbnM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aGVudGljYXRpb25IYW5kbGVyT3B0aW9ucy5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmltcG9ydCB7IE1pZGRsZXdhcmVDb250cm9sIH0gZnJvbSBcIi4uL01pZGRsZXdhcmVDb250cm9sXCI7XG4vKipcbiAqIEBlbnVtXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9ORSAtIFRoZSBoZXhhZGVjaW1hbCBmbGFnIHZhbHVlIGZvciBub3RoaW5nIGVuYWJsZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRURJUkVDVF9IQU5ETEVSX0VOQUJMRUQgLSBUaGUgaGV4YWRlY2ltYWwgZmxhZyB2YWx1ZSBmb3IgcmVkaXJlY3QgaGFuZGxlciBlbmFibGVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gUkVUUllfSEFORExFUl9FTkFCTEVEIC0gVGhlIGhleGFkZWNpbWFsIGZsYWcgdmFsdWUgZm9yIHJldHJ5IGhhbmRsZXIgZW5hYmxlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEFVVEhFTlRJQ0FUSU9OX0hBTkRMRVJfRU5BQkxFRCAtIFRoZSBoZXhhZGVjaW1hbCBmbGFnIHZhbHVlIGZvciB0aGUgYXV0aGVudGljYXRpb24gaGFuZGxlciBlbmFibGVkXG4gKi9cbmV4cG9ydCB2YXIgRmVhdHVyZVVzYWdlRmxhZztcbihmdW5jdGlvbiAoRmVhdHVyZVVzYWdlRmxhZykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlICBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbiAgICBGZWF0dXJlVXNhZ2VGbGFnW0ZlYXR1cmVVc2FnZUZsYWdbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBGZWF0dXJlVXNhZ2VGbGFnW0ZlYXR1cmVVc2FnZUZsYWdbXCJSRURJUkVDVF9IQU5ETEVSX0VOQUJMRURcIl0gPSAxXSA9IFwiUkVESVJFQ1RfSEFORExFUl9FTkFCTEVEXCI7XG4gICAgRmVhdHVyZVVzYWdlRmxhZ1tGZWF0dXJlVXNhZ2VGbGFnW1wiUkVUUllfSEFORExFUl9FTkFCTEVEXCJdID0gMl0gPSBcIlJFVFJZX0hBTkRMRVJfRU5BQkxFRFwiO1xuICAgIEZlYXR1cmVVc2FnZUZsYWdbRmVhdHVyZVVzYWdlRmxhZ1tcIkFVVEhFTlRJQ0FUSU9OX0hBTkRMRVJfRU5BQkxFRFwiXSA9IDRdID0gXCJBVVRIRU5USUNBVElPTl9IQU5ETEVSX0VOQUJMRURcIjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlICBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbn0pKEZlYXR1cmVVc2FnZUZsYWcgfHwgKEZlYXR1cmVVc2FnZUZsYWcgPSB7fSkpO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBpbXBsZW1lbnRzIE1pZGRsZXdhcmVPcHRpb25zXG4gKiBDbGFzcyBmb3IgVGVsZW1ldHJ5SGFuZGxlck9wdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFRlbGVtZXRyeUhhbmRsZXJPcHRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEEgbWVtYmVyIHRvIGhvbGQgdGhlIE9SIG9mIGZlYXR1cmUgdXNhZ2UgZmxhZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmVhdHVyZVVzYWdlID0gRmVhdHVyZVVzYWdlRmxhZy5OT05FO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIFRvIHVwZGF0ZSB0aGUgZmVhdHVyZSB1c2FnZSBpbiB0aGUgY29udGV4dCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBUaGUgcmVxdWVzdCBjb250ZXh0IG9iamVjdCBjb250YWluaW5nIG1pZGRsZXdhcmUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RmVhdHVyZVVzYWdlRmxhZ30gZmxhZyAtIFRoZSBmbGFnIHZhbHVlXG4gICAgICogQHJldHVybnMgbm90aGluZ1xuICAgICAqL1xuICAgIHN0YXRpYyB1cGRhdGVGZWF0dXJlVXNhZ2VGbGFnKGNvbnRleHQsIGZsYWcpIHtcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChjb250ZXh0Lm1pZGRsZXdhcmVDb250cm9sIGluc3RhbmNlb2YgTWlkZGxld2FyZUNvbnRyb2wpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb250ZXh0Lm1pZGRsZXdhcmVDb250cm9sLmdldE1pZGRsZXdhcmVPcHRpb25zKFRlbGVtZXRyeUhhbmRsZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQubWlkZGxld2FyZUNvbnRyb2wgPSBuZXcgTWlkZGxld2FyZUNvbnRyb2woKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBuZXcgVGVsZW1ldHJ5SGFuZGxlck9wdGlvbnMoKTtcbiAgICAgICAgICAgIGNvbnRleHQubWlkZGxld2FyZUNvbnRyb2wuc2V0TWlkZGxld2FyZU9wdGlvbnMoVGVsZW1ldHJ5SGFuZGxlck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuc2V0RmVhdHVyZVVzYWdlKGZsYWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFRvIHNldCB0aGUgZmVhdHVyZSB1c2FnZSBmbGFnXG4gICAgICogQHBhcmFtIHtGZWF0dXJlVXNhZ2VGbGFnfSBmbGFnIC0gVGhlIGZsYWcgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBub3RoaW5nXG4gICAgICovXG4gICAgc2V0RmVhdHVyZVVzYWdlKGZsYWcpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlVXNhZ2UgPSB0aGlzLmZlYXR1cmVVc2FnZSB8IGZsYWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUbyBnZXQgdGhlIGZlYXR1cmUgdXNhZ2VcbiAgICAgKiBAcmV0dXJucyBBIGZlYXR1cmUgdXNhZ2UgZmxhZyBhcyBoZXhhZGVjaW1hbCBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlVXNhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVVc2FnZS50b1N0cmluZygxNik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGVsZW1ldHJ5SGFuZGxlck9wdGlvbnMuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5pbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbi8qKlxuICogQG1vZHVsZSBBdXRoZW50aWNhdGlvbkhhbmRsZXJcbiAqL1xuaW1wb3J0IHsgaXNDdXN0b21Ib3N0LCBpc0dyYXBoVVJMIH0gZnJvbSBcIi4uL0dyYXBoUmVxdWVzdFV0aWxcIjtcbmltcG9ydCB7IE1pZGRsZXdhcmVDb250cm9sIH0gZnJvbSBcIi4vTWlkZGxld2FyZUNvbnRyb2xcIjtcbmltcG9ydCB7IGFwcGVuZFJlcXVlc3RIZWFkZXIgfSBmcm9tIFwiLi9NaWRkbGV3YXJlVXRpbFwiO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb25IYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL29wdGlvbnMvQXV0aGVudGljYXRpb25IYW5kbGVyT3B0aW9uc1wiO1xuaW1wb3J0IHsgRmVhdHVyZVVzYWdlRmxhZywgVGVsZW1ldHJ5SGFuZGxlck9wdGlvbnMgfSBmcm9tIFwiLi9vcHRpb25zL1RlbGVtZXRyeUhhbmRsZXJPcHRpb25zXCI7XG4vKipcbiAqIEBjbGFzc1xuICogQGltcGxlbWVudHMgTWlkZGxld2FyZVxuICogQ2xhc3MgcmVwcmVzZW50aW5nIEF1dGhlbnRpY2F0aW9uSGFuZGxlclxuICovXG5leHBvcnQgY2xhc3MgQXV0aGVudGljYXRpb25IYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBBdXRoZW50aWNhdGlvbkhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0F1dGhlbnRpY2F0aW9uUHJvdmlkZXJ9IGF1dGhlbnRpY2F0aW9uUHJvdmlkZXIgLSBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgZm9yIHRoZSBhdXRoZW50aWNhdGlvbiBoYW5kbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXV0aGVudGljYXRpb25Qcm92aWRlcikge1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uUHJvdmlkZXIgPSBhdXRoZW50aWNhdGlvblByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogVG8gZXhlY3V0ZSB0aGUgY3VycmVudCBtaWRkbGV3YXJlXG4gICAgICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgb2JqZWN0IG9mIHRoZSByZXF1ZXN0XG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbm90aGluZ1xuICAgICAqL1xuICAgIGV4ZWN1dGUoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdHlwZW9mIGNvbnRleHQucmVxdWVzdCA9PT0gXCJzdHJpbmdcIiA/IGNvbnRleHQucmVxdWVzdCA6IGNvbnRleHQucmVxdWVzdC51cmw7XG4gICAgICAgICAgICBpZiAoaXNHcmFwaFVSTCh1cmwpIHx8IChjb250ZXh0LmN1c3RvbUhvc3RzICYmIGlzQ3VzdG9tSG9zdCh1cmwsIGNvbnRleHQuY3VzdG9tSG9zdHMpKSkge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm1pZGRsZXdhcmVDb250cm9sIGluc3RhbmNlb2YgTWlkZGxld2FyZUNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnRleHQubWlkZGxld2FyZUNvbnRyb2wuZ2V0TWlkZGxld2FyZU9wdGlvbnMoQXV0aGVudGljYXRpb25IYW5kbGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBhdXRoZW50aWNhdGlvblByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGxldCBhdXRoZW50aWNhdGlvblByb3ZpZGVyT3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvblByb3ZpZGVyID0gb3B0aW9ucy5hdXRoZW50aWNhdGlvblByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvblByb3ZpZGVyT3B0aW9ucyA9IG9wdGlvbnMuYXV0aGVudGljYXRpb25Qcm92aWRlck9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYXV0aGVudGljYXRpb25Qcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvblByb3ZpZGVyID0gdGhpcy5hdXRoZW50aWNhdGlvblByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHlpZWxkIGF1dGhlbnRpY2F0aW9uUHJvdmlkZXIuZ2V0QWNjZXNzVG9rZW4oYXV0aGVudGljYXRpb25Qcm92aWRlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlYXJlcktleSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgICAgICAgICAgIGFwcGVuZFJlcXVlc3RIZWFkZXIoY29udGV4dC5yZXF1ZXN0LCBjb250ZXh0Lm9wdGlvbnMsIEF1dGhlbnRpY2F0aW9uSGFuZGxlci5BVVRIT1JJWkFUSU9OX0hFQURFUiwgYmVhcmVyS2V5KTtcbiAgICAgICAgICAgICAgICBUZWxlbWV0cnlIYW5kbGVyT3B0aW9ucy51cGRhdGVGZWF0dXJlVXNhZ2VGbGFnKGNvbnRleHQsIEZlYXR1cmVVc2FnZUZsYWcuQVVUSEVOVElDQVRJT05fSEFORExFUl9FTkFCTEVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29udGV4dC5vcHRpb25zLmhlYWRlcnNbQXV0aGVudGljYXRpb25IYW5kbGVyLkFVVEhPUklaQVRJT05fSEVBREVSXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5uZXh0TWlkZGxld2FyZS5leGVjdXRlKGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIHNldCB0aGUgbmV4dCBtaWRkbGV3YXJlIGluIHRoZSBjaGFpblxuICAgICAqIEBwYXJhbSB7TWlkZGxld2FyZX0gbmV4dCAtIFRoZSBtaWRkbGV3YXJlIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAqL1xuICAgIHNldE5leHQobmV4dCkge1xuICAgICAgICB0aGlzLm5leHRNaWRkbGV3YXJlID0gbmV4dDtcbiAgICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBBIG1lbWJlciByZXByZXNlbnRpbmcgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyIG5hbWVcbiAqL1xuQXV0aGVudGljYXRpb25IYW5kbGVyLkFVVEhPUklaQVRJT05fSEVBREVSID0gXCJBdXRob3JpemF0aW9uXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoZW50aWNhdGlvbkhhbmRsZXIuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5pbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAaW1wbGVtZW50cyBNaWRkbGV3YXJlXG4gKiBDbGFzcyBmb3IgSFRUUE1lc3NhZ2VIYW5kbGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBIVFRQTWVzc2FnZUhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBUbyBleGVjdXRlIHRoZSBjdXJyZW50IG1pZGRsZXdhcmVcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBUaGUgcmVxdWVzdCBjb250ZXh0IG9iamVjdFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG5vdGhpbmdcbiAgICAgKi9cbiAgICBleGVjdXRlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVzcG9uc2UgPSB5aWVsZCBmZXRjaChjb250ZXh0LnJlcXVlc3QsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUVFBNZXNzYWdlSGFuZGxlci5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogQGNsYXNzXG4gKiBAaW1wbGVtZW50cyBNaWRkbGV3YXJlT3B0aW9uc1xuICogQ2xhc3MgZm9yIFJldHJ5SGFuZGxlck9wdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFJldHJ5SGFuZGxlck9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgUmV0cnlIYW5kbGVyT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXkgPSBSZXRyeUhhbmRsZXJPcHRpb25zLkRFRkFVTFRfREVMQVldIC0gVGhlIGRlbGF5IHZhbHVlIGluIHNlY29uZHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFJldHJpZXMgPSBSZXRyeUhhbmRsZXJPcHRpb25zLkRFRkFVTFRfTUFYX1JFVFJJRVNdIC0gVGhlIG1heFJldHJpZXMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge1Nob3VsZFJldHJ5fSBbc2hvdWxkUmV0cnkgPSBSZXRyeUhhbmRsZXJPcHRpb25zLkRFRkFVTFRfU0hPVUxEX1JFVFJZXSAtIFRoZSBzaG91bGRSZXRyeSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFJldHJ5SGFuZGxlck9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkZWxheSA9IFJldHJ5SGFuZGxlck9wdGlvbnMuREVGQVVMVF9ERUxBWSwgbWF4UmV0cmllcyA9IFJldHJ5SGFuZGxlck9wdGlvbnMuREVGQVVMVF9NQVhfUkVUUklFUywgc2hvdWxkUmV0cnkgPSBSZXRyeUhhbmRsZXJPcHRpb25zLmRlZmF1bHRTaG91bGRSZXRyeSkge1xuICAgICAgICBpZiAoZGVsYXkgPiBSZXRyeUhhbmRsZXJPcHRpb25zLk1BWF9ERUxBWSAmJiBtYXhSZXRyaWVzID4gUmV0cnlIYW5kbGVyT3B0aW9ucy5NQVhfTUFYX1JFVFJJRVMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBEZWxheSBhbmQgTWF4UmV0cmllcyBzaG91bGQgbm90IGJlIG1vcmUgdGhhbiAke1JldHJ5SGFuZGxlck9wdGlvbnMuTUFYX0RFTEFZfSBhbmQgJHtSZXRyeUhhbmRsZXJPcHRpb25zLk1BWF9NQVhfUkVUUklFU31gKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIk1heExpbWl0RXhjZWVkZWRcIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbGF5ID4gUmV0cnlIYW5kbGVyT3B0aW9ucy5NQVhfREVMQVkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBEZWxheSBzaG91bGQgbm90IGJlIG1vcmUgdGhhbiAke1JldHJ5SGFuZGxlck9wdGlvbnMuTUFYX0RFTEFZfWApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTWF4TGltaXRFeGNlZWRlZFwiO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF4UmV0cmllcyA+IFJldHJ5SGFuZGxlck9wdGlvbnMuTUFYX01BWF9SRVRSSUVTKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTWF4UmV0cmllcyBzaG91bGQgbm90IGJlIG1vcmUgdGhhbiAke1JldHJ5SGFuZGxlck9wdGlvbnMuTUFYX01BWF9SRVRSSUVTfWApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTWF4TGltaXRFeGNlZWRlZFwiO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsYXkgPCAwICYmIG1heFJldHJpZXMgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRGVsYXkgYW5kIE1heFJldHJpZXMgc2hvdWxkIG5vdCBiZSBuZWdhdGl2ZWApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTWluRXhwZWN0YXRpb25Ob3RNZXRcIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYERlbGF5IHNob3VsZCBub3QgYmUgbmVnYXRpdmVgKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIk1pbkV4cGVjdGF0aW9uTm90TWV0XCI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE1heFJldHJpZXMgc2hvdWxkIG5vdCBiZSBuZWdhdGl2ZWApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTWluRXhwZWN0YXRpb25Ob3RNZXRcIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBNYXRoLm1pbihkZWxheSwgUmV0cnlIYW5kbGVyT3B0aW9ucy5NQVhfREVMQVkpO1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBNYXRoLm1pbihtYXhSZXRyaWVzLCBSZXRyeUhhbmRsZXJPcHRpb25zLk1BWF9NQVhfUkVUUklFUyk7XG4gICAgICAgIHRoaXMuc2hvdWxkUmV0cnkgPSBzaG91bGRSZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIGdldCB0aGUgbWF4aW11bSBkZWxheVxuICAgICAqIEByZXR1cm5zIEEgbWF4aW11bSBkZWxheVxuICAgICAqL1xuICAgIGdldE1heERlbGF5KCkge1xuICAgICAgICByZXR1cm4gUmV0cnlIYW5kbGVyT3B0aW9ucy5NQVhfREVMQVk7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyBkZWZhdWx0IGRlbGF5IHZhbHVlIGluIHNlY29uZHNcbiAqL1xuUmV0cnlIYW5kbGVyT3B0aW9ucy5ERUZBVUxUX0RFTEFZID0gMztcbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEEgbWVtYmVyIGhvbGRpbmcgZGVmYXVsdCBtYXhSZXRyaWVzIHZhbHVlXG4gKi9cblJldHJ5SGFuZGxlck9wdGlvbnMuREVGQVVMVF9NQVhfUkVUUklFUyA9IDM7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBBIG1lbWJlciBob2xkaW5nIG1heGltdW0gZGVsYXkgdmFsdWUgaW4gc2Vjb25kc1xuICovXG5SZXRyeUhhbmRsZXJPcHRpb25zLk1BWF9ERUxBWSA9IDE4MDtcbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEEgbWVtYmVyIGhvbGRpbmcgbWF4aW11bSBtYXhSZXRyaWVzIHZhbHVlXG4gKi9cblJldHJ5SGFuZGxlck9wdGlvbnMuTUFYX01BWF9SRVRSSUVTID0gMTA7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBBIG1lbWJlciBob2xkaW5nIGRlZmF1bHQgc2hvdWxkUmV0cnkgY2FsbGJhY2tcbiAqL1xuUmV0cnlIYW5kbGVyT3B0aW9ucy5kZWZhdWx0U2hvdWxkUmV0cnkgPSAoKSA9PiB0cnVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmV0cnlIYW5kbGVyT3B0aW9ucy5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgUmVxdWVzdE1ldGhvZCB9IGZyb20gXCIuLi9SZXF1ZXN0TWV0aG9kXCI7XG5pbXBvcnQgeyBNaWRkbGV3YXJlQ29udHJvbCB9IGZyb20gXCIuL01pZGRsZXdhcmVDb250cm9sXCI7XG5pbXBvcnQgeyBnZXRSZXF1ZXN0SGVhZGVyLCBzZXRSZXF1ZXN0SGVhZGVyIH0gZnJvbSBcIi4vTWlkZGxld2FyZVV0aWxcIjtcbmltcG9ydCB7IFJldHJ5SGFuZGxlck9wdGlvbnMgfSBmcm9tIFwiLi9vcHRpb25zL1JldHJ5SGFuZGxlck9wdGlvbnNcIjtcbmltcG9ydCB7IEZlYXR1cmVVc2FnZUZsYWcsIFRlbGVtZXRyeUhhbmRsZXJPcHRpb25zIH0gZnJvbSBcIi4vb3B0aW9ucy9UZWxlbWV0cnlIYW5kbGVyT3B0aW9uc1wiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIEBpbXBsZW1lbnRzIE1pZGRsZXdhcmVcbiAqIENsYXNzIGZvciBSZXRyeUhhbmRsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFJldHJ5SGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIFRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBSZXRyeUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge1JldHJ5SGFuZGxlck9wdGlvbnN9IFtvcHRpb25zID0gbmV3IFJldHJ5SGFuZGxlck9wdGlvbnMoKV0gLSBUaGUgcmV0cnkgaGFuZGxlciBvcHRpb25zIHZhbHVlXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgUmV0cnlIYW5kbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IG5ldyBSZXRyeUhhbmRsZXJPcHRpb25zKCkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFRvIGNoZWNrIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyB0aGUgcmV0cnkgc3RhdHVzIGNvZGVcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZSAtIFRoZSByZXNwb25zZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSByZXNwb25zZSBoYXMgcmV0cnkgc3RhdHVzIGNvZGUgb3Igbm90XG4gICAgICovXG4gICAgaXNSZXRyeShyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gUmV0cnlIYW5kbGVyLlJFVFJZX1NUQVRVU19DT0RFUy5pbmRleE9mKHJlc3BvbnNlLnN0YXR1cykgIT09IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFRvIGNoZWNrIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYnVmZmVyZWQgb3Igbm90XG4gICAgICogQHBhcmFtIHtSZXF1ZXN0SW5mb30gcmVxdWVzdCAtIFRoZSB1cmwgc3RyaW5nIG9yIHRoZSByZXF1ZXN0IG9iamVjdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RmV0Y2hPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2YgYSByZXF1ZXN0XG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgcGF5bG9hZCBpcyBidWZmZXJlZCBvciBub3RcbiAgICAgKi9cbiAgICBpc0J1ZmZlcmVkKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdHlwZW9mIHJlcXVlc3QgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLm1ldGhvZCA6IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICBjb25zdCBpc1B1dFBhdGNoT3JQb3N0ID0gbWV0aG9kID09PSBSZXF1ZXN0TWV0aG9kLlBVVCB8fCBtZXRob2QgPT09IFJlcXVlc3RNZXRob2QuUEFUQ0ggfHwgbWV0aG9kID09PSBSZXF1ZXN0TWV0aG9kLlBPU1Q7XG4gICAgICAgIGlmIChpc1B1dFBhdGNoT3JQb3N0KSB7XG4gICAgICAgICAgICBjb25zdCBpc1N0cmVhbSA9IGdldFJlcXVlc3RIZWFkZXIocmVxdWVzdCwgb3B0aW9ucywgXCJDb250ZW50LVR5cGVcIikgPT09IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgICAgICBpZiAoaXNTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVG8gZ2V0IHRoZSBkZWxheSBmb3IgYSByZXRyeVxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeUF0dGVtcHRzIC0gVGhlIGN1cnJlbnQgYXR0ZW1wdCBjb3VudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIFRoZSBkZWxheSB2YWx1ZSBpbiBzZWNvbmRzXG4gICAgICogQHJldHVybnMgQSBkZWxheSBmb3IgYSByZXRyeVxuICAgICAqL1xuICAgIGdldERlbGF5KHJlc3BvbnNlLCByZXRyeUF0dGVtcHRzLCBkZWxheSkge1xuICAgICAgICBjb25zdCBnZXRSYW5kb21uZXNzID0gKCkgPT4gTnVtYmVyKE1hdGgucmFuZG9tKCkudG9GaXhlZCgzKSk7XG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzICE9PSB1bmRlZmluZWQgPyByZXNwb25zZS5oZWFkZXJzLmdldChSZXRyeUhhbmRsZXIuUkVUUllfQUZURVJfSEVBREVSKSA6IG51bGw7XG4gICAgICAgIGxldCBuZXdEZWxheTtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oTnVtYmVyKHJldHJ5QWZ0ZXIpKSkge1xuICAgICAgICAgICAgICAgIG5ld0RlbGF5ID0gTWF0aC5yb3VuZCgobmV3IERhdGUocmV0cnlBZnRlcikuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSkgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0RlbGF5ID0gTnVtYmVyKHJldHJ5QWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkaW5nIHJhbmRvbW5lc3MgdG8gYXZvaWQgcmV0cnlpbmcgYXQgYSBzYW1lXG4gICAgICAgICAgICBuZXdEZWxheSA9IHJldHJ5QXR0ZW1wdHMgPj0gMiA/IHRoaXMuZ2V0RXhwb25lbnRpYWxCYWNrT2ZmVGltZShyZXRyeUF0dGVtcHRzKSArIGRlbGF5ICsgZ2V0UmFuZG9tbmVzcygpIDogZGVsYXkgKyBnZXRSYW5kb21uZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG5ld0RlbGF5LCB0aGlzLm9wdGlvbnMuZ2V0TWF4RGVsYXkoKSArIGdldFJhbmRvbW5lc3MoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVG8gZ2V0IGFuIGV4cG9uZW50aWFsIGJhY2sgb2ZmIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF0dGVtcHRzIC0gVGhlIGN1cnJlbnQgYXR0ZW1wdCBjb3VudFxuICAgICAqIEByZXR1cm5zIEFuIGV4cG9uZW50aWFsIGJhY2sgb2ZmIHZhbHVlXG4gICAgICovXG4gICAgZ2V0RXhwb25lbnRpYWxCYWNrT2ZmVGltZShhdHRlbXB0cykge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgoMSAvIDIpICogKE1hdGgucG93KDIsIGF0dGVtcHRzKSAtIDEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBUbyBhZGQgZGVsYXkgZm9yIHRoZSBleGVjdXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXlTZWNvbmRzIC0gVGhlIGRlbGF5IHZhbHVlIGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJucyBOb3RoaW5nXG4gICAgICovXG4gICAgc2xlZXAoZGVsYXlTZWNvbmRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheU1pbGxpc2Vjb25kcyA9IGRlbGF5U2Vjb25kcyAqIDEwMDA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlNaWxsaXNlY29uZHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoY29udGV4dCkge1xuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKGNvbnRleHQubWlkZGxld2FyZUNvbnRyb2wgaW5zdGFuY2VvZiBNaWRkbGV3YXJlQ29udHJvbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnRleHQubWlkZGxld2FyZUNvbnRyb2wuZ2V0TWlkZGxld2FyZU9wdGlvbnModGhpcy5vcHRpb25zLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG5ldyBSZXRyeUhhbmRsZXJPcHRpb25zKCksIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFzeW5jXG4gICAgICogVG8gZXhlY3V0ZSB0aGUgbWlkZGxld2FyZSB3aXRoIHJldHJpZXNcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmV0cnlBdHRlbXB0cyAtIFRoZSBjdXJyZW50IGF0dGVtcHQgY291bnRcbiAgICAgKiBAcGFyYW0ge1JldHJ5SGFuZGxlck9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgcmV0cnkgbWlkZGxld2FyZSBvcHRpb25zIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbm90aGluZ1xuICAgICAqL1xuICAgIGV4ZWN1dGVXaXRoUmV0cnkoY29udGV4dCwgcmV0cnlBdHRlbXB0cywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5uZXh0TWlkZGxld2FyZS5leGVjdXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHJldHJ5QXR0ZW1wdHMgPCBvcHRpb25zLm1heFJldHJpZXMgJiYgdGhpcy5pc1JldHJ5KGNvbnRleHQucmVzcG9uc2UpICYmIHRoaXMuaXNCdWZmZXJlZChjb250ZXh0LnJlcXVlc3QsIGNvbnRleHQub3B0aW9ucykgJiYgb3B0aW9ucy5zaG91bGRSZXRyeShvcHRpb25zLmRlbGF5LCByZXRyeUF0dGVtcHRzLCBjb250ZXh0LnJlcXVlc3QsIGNvbnRleHQub3B0aW9ucywgY29udGV4dC5yZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICArK3JldHJ5QXR0ZW1wdHM7XG4gICAgICAgICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcihjb250ZXh0LnJlcXVlc3QsIGNvbnRleHQub3B0aW9ucywgUmV0cnlIYW5kbGVyLlJFVFJZX0FUVEVNUFRfSEVBREVSLCByZXRyeUF0dGVtcHRzLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5nZXREZWxheShjb250ZXh0LnJlc3BvbnNlLCByZXRyeUF0dGVtcHRzLCBvcHRpb25zLmRlbGF5KTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNsZWVwKGRlbGF5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5leGVjdXRlV2l0aFJldHJ5KGNvbnRleHQsIHJldHJ5QXR0ZW1wdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFRvIGV4ZWN1dGUgdGhlIGN1cnJlbnQgbWlkZGxld2FyZVxuICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9iamVjdCBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG5vdGhpbmdcbiAgICAgKi9cbiAgICBleGVjdXRlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucyhjb250ZXh0KTtcbiAgICAgICAgICAgIFRlbGVtZXRyeUhhbmRsZXJPcHRpb25zLnVwZGF0ZUZlYXR1cmVVc2FnZUZsYWcoY29udGV4dCwgRmVhdHVyZVVzYWdlRmxhZy5SRVRSWV9IQU5ETEVSX0VOQUJMRUQpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZXhlY3V0ZVdpdGhSZXRyeShjb250ZXh0LCByZXRyeUF0dGVtcHRzLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUbyBzZXQgdGhlIG5leHQgbWlkZGxld2FyZSBpbiB0aGUgY2hhaW5cbiAgICAgKiBAcGFyYW0ge01pZGRsZXdhcmV9IG5leHQgLSBUaGUgbWlkZGxld2FyZSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIE5vdGhpbmdcbiAgICAgKi9cbiAgICBzZXROZXh0KG5leHQpIHtcbiAgICAgICAgdGhpcy5uZXh0TWlkZGxld2FyZSA9IG5leHQ7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBsaXN0IG9mIHN0YXR1cyBjb2RlcyB0aGF0IG5lZWRzIHRvIGJlIHJldHJpZWRcbiAqL1xuUmV0cnlIYW5kbGVyLlJFVFJZX1NUQVRVU19DT0RFUyA9IFtcbiAgICA0MjksXG4gICAgNTAzLFxuICAgIDUwNCwgLy8gR2F0ZXdheSB0aW1lb3V0XG5dO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyB0aGUgbmFtZSBvZiByZXRyeSBhdHRlbXB0IGhlYWRlclxuICovXG5SZXRyeUhhbmRsZXIuUkVUUllfQVRURU1QVF9IRUFERVIgPSBcIlJldHJ5LUF0dGVtcHRcIjtcbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEEgbWVtYmVyIGhvbGRpbmcgdGhlIG5hbWUgb2YgcmV0cnkgYWZ0ZXIgaGVhZGVyXG4gKi9cblJldHJ5SGFuZGxlci5SRVRSWV9BRlRFUl9IRUFERVIgPSBcIlJldHJ5LUFmdGVyXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXRyeUhhbmRsZXIuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBjbGFzc1xuICogQGltcGxlbWVudHMgTWlkZGxld2FyZU9wdGlvbnNcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIFJlZGlyZWN0SGFuZGxlck9wdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZGlyZWN0SGFuZGxlck9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgUmVkaXJlY3RIYW5kbGVyT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4UmVkaXJlY3RzID0gUmVkaXJlY3RIYW5kbGVyT3B0aW9ucy5ERUZBVUxUX01BWF9SRURJUkVDVFNdIC0gVGhlIG1heCByZWRpcmVjdHMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge1Nob3VsZFJlZGlyZWN0fSBbc2hvdWxkUmVkaXJlY3QgPSBSZWRpcmVjdEhhbmRsZXJPcHRpb25zLkRFRkFVTFRfU0hPVUxEX1JFVFJZXSAtIFRoZSBzaG91bGQgcmVkaXJlY3QgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBSZWRpcmVjdEhhbmRsZXJPcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF4UmVkaXJlY3RzID0gUmVkaXJlY3RIYW5kbGVyT3B0aW9ucy5ERUZBVUxUX01BWF9SRURJUkVDVFMsIHNob3VsZFJlZGlyZWN0ID0gUmVkaXJlY3RIYW5kbGVyT3B0aW9ucy5kZWZhdWx0U2hvdWxkUmVkaXJlY3QpIHtcbiAgICAgICAgaWYgKG1heFJlZGlyZWN0cyA+IFJlZGlyZWN0SGFuZGxlck9wdGlvbnMuTUFYX01BWF9SRURJUkVDVFMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBNYXhSZWRpcmVjdHMgc2hvdWxkIG5vdCBiZSBtb3JlIHRoYW4gJHtSZWRpcmVjdEhhbmRsZXJPcHRpb25zLk1BWF9NQVhfUkVESVJFQ1RTfWApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTWF4TGltaXRFeGNlZWRlZFwiO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFJlZGlyZWN0cyA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBNYXhSZWRpcmVjdHMgc2hvdWxkIG5vdCBiZSBuZWdhdGl2ZWApO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiTWluRXhwZWN0YXRpb25Ob3RNZXRcIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4UmVkaXJlY3RzID0gbWF4UmVkaXJlY3RzO1xuICAgICAgICB0aGlzLnNob3VsZFJlZGlyZWN0ID0gc2hvdWxkUmVkaXJlY3Q7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyBkZWZhdWx0IG1heCByZWRpcmVjdHMgdmFsdWVcbiAqL1xuUmVkaXJlY3RIYW5kbGVyT3B0aW9ucy5ERUZBVUxUX01BWF9SRURJUkVDVFMgPSA1O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyBtYXhpbXVtIG1heCByZWRpcmVjdHMgdmFsdWVcbiAqL1xuUmVkaXJlY3RIYW5kbGVyT3B0aW9ucy5NQVhfTUFYX1JFRElSRUNUUyA9IDIwO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQSBtZW1iZXIgaG9sZGluZyBkZWZhdWx0IHNob3VsZFJlZGlyZWN0IGNhbGxiYWNrXG4gKi9cblJlZGlyZWN0SGFuZGxlck9wdGlvbnMuZGVmYXVsdFNob3VsZFJlZGlyZWN0ID0gKCkgPT4gdHJ1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZGlyZWN0SGFuZGxlck9wdGlvbnMuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5pbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFJlcXVlc3RNZXRob2QgfSBmcm9tIFwiLi4vUmVxdWVzdE1ldGhvZFwiO1xuaW1wb3J0IHsgTWlkZGxld2FyZUNvbnRyb2wgfSBmcm9tIFwiLi9NaWRkbGV3YXJlQ29udHJvbFwiO1xuaW1wb3J0IHsgY2xvbmVSZXF1ZXN0V2l0aE5ld1VybCB9IGZyb20gXCIuL01pZGRsZXdhcmVVdGlsXCI7XG5pbXBvcnQgeyBSZWRpcmVjdEhhbmRsZXJPcHRpb25zIH0gZnJvbSBcIi4vb3B0aW9ucy9SZWRpcmVjdEhhbmRsZXJPcHRpb25zXCI7XG5pbXBvcnQgeyBGZWF0dXJlVXNhZ2VGbGFnLCBUZWxlbWV0cnlIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL29wdGlvbnMvVGVsZW1ldHJ5SGFuZGxlck9wdGlvbnNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBDbGFzc1xuICogQGltcGxlbWVudHMgTWlkZGxld2FyZVxuICogQ2xhc3MgcmVwcmVzZW50aW5nIFJlZGlyZWN0SGFuZGxlclxuICovXG5leHBvcnQgY2xhc3MgUmVkaXJlY3RIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogVG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIFJlZGlyZWN0SGFuZGxlclxuICAgICAqIEBwYXJhbSB7UmVkaXJlY3RIYW5kbGVyT3B0aW9uc30gW29wdGlvbnMgPSBuZXcgUmVkaXJlY3RIYW5kbGVyT3B0aW9ucygpXSAtIFRoZSByZWRpcmVjdCBoYW5kbGVyIG9wdGlvbnMgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBSZWRpcmVjdEhhbmRsZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0gbmV3IFJlZGlyZWN0SGFuZGxlck9wdGlvbnMoKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFRvIGNoZWNrIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyB0aGUgcmVkaXJlY3Qgc3RhdHVzIGNvZGUgb3Igbm90XG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSByZXNwb25zZSBjb250YWlucyB0aGUgcmVkaXJlY3Qgc3RhdHVzIGNvZGUgb3Igbm90XG4gICAgICovXG4gICAgaXNSZWRpcmVjdChyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gUmVkaXJlY3RIYW5kbGVyLlJFRElSRUNUX1NUQVRVU19DT0RFUy5pbmRleE9mKHJlc3BvbnNlLnN0YXR1cykgIT09IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFRvIGNoZWNrIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBsb2NhdGlvbiBoZWFkZXIgb3Igbm90XG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgd2hldGhlciB0aGUgcmVzcG9uc2UgaGFzIGxvY2F0aW9uIGhlYWRlciBvciBub3RcbiAgICAgKi9cbiAgICBoYXNMb2NhdGlvbkhlYWRlcihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5oYXMoUmVkaXJlY3RIYW5kbGVyLkxPQ0FUSU9OX0hFQURFUik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVG8gZ2V0IHRoZSByZWRpcmVjdCB1cmwgZnJvbSBsb2NhdGlvbiBoZWFkZXIgaW4gcmVzcG9uc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICogQHJldHVybnMgQSByZWRpcmVjdCB1cmwgZnJvbSBsb2NhdGlvbiBoZWFkZXJcbiAgICAgKi9cbiAgICBnZXRMb2NhdGlvbkhlYWRlcihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoUmVkaXJlY3RIYW5kbGVyLkxPQ0FUSU9OX0hFQURFUik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVG8gY2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdXJsIGlzIGEgcmVsYXRpdmUgdXJsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHN0cmluZyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gdXJsIGlzIGEgcmVsYXRpdmUgdXJsIG9yIG5vdFxuICAgICAqL1xuICAgIGlzUmVsYXRpdmVVUkwodXJsKSB7XG4gICAgICAgIHJldHVybiB1cmwuaW5kZXhPZihcIjovL1wiKSA9PT0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVG8gY2hlY2sgd2hldGhlciB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXIgaW4gdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIGRyb3BwZWQgZm9yIGNvbnNlcXVlbnQgcmVkaXJlY3RlZCByZXF1ZXN0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VXJsIC0gVGhlIHJlcXVlc3QgdXJsIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlZGlyZWN0VXJsIC0gVGhlIHJlZGlyZWN0IHVybCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXIgaW4gdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIGRyb3BwZWQgZm9yIGNvbnNlcXVlbnQgcmVkaXJlY3RlZCByZXF1ZXN0c1xuICAgICAqL1xuICAgIHNob3VsZERyb3BBdXRob3JpemF0aW9uSGVhZGVyKHJlcXVlc3RVcmwsIHJlZGlyZWN0VXJsKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtZUhvc3RSZWdleCA9IC9eW0EtWmEtel0uKz86XFwvXFwvLis/KD89XFwvfCQpLztcbiAgICAgICAgY29uc3QgcmVxdWVzdE1hdGNoZXMgPSBzY2hlbWVIb3N0UmVnZXguZXhlYyhyZXF1ZXN0VXJsKTtcbiAgICAgICAgbGV0IHJlcXVlc3RBdXRob3JpdHk7XG4gICAgICAgIGxldCByZWRpcmVjdEF1dGhvcml0eTtcbiAgICAgICAgaWYgKHJlcXVlc3RNYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXF1ZXN0QXV0aG9yaXR5ID0gcmVxdWVzdE1hdGNoZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVkaXJlY3RNYXRjaGVzID0gc2NoZW1lSG9zdFJlZ2V4LmV4ZWMocmVkaXJlY3RVcmwpO1xuICAgICAgICBpZiAocmVkaXJlY3RNYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWRpcmVjdEF1dGhvcml0eSA9IHJlZGlyZWN0TWF0Y2hlc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHJlcXVlc3RBdXRob3JpdHkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJlZGlyZWN0QXV0aG9yaXR5ICE9PSBcInVuZGVmaW5lZFwiICYmIHJlcXVlc3RBdXRob3JpdHkgIT09IHJlZGlyZWN0QXV0aG9yaXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhc3luY1xuICAgICAqIFRvIHVwZGF0ZSBhIHJlcXVlc3QgdXJsIHdpdGggdGhlIHJlZGlyZWN0IHVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWRpcmVjdFVybCAtIFRoZSByZWRpcmVjdCB1cmwgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvYmplY3QgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBOb3RoaW5nXG4gICAgICovXG4gICAgdXBkYXRlUmVxdWVzdFVybChyZWRpcmVjdFVybCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29udGV4dC5yZXF1ZXN0ID0gdHlwZW9mIGNvbnRleHQucmVxdWVzdCA9PT0gXCJzdHJpbmdcIiA/IHJlZGlyZWN0VXJsIDogeWllbGQgY2xvbmVSZXF1ZXN0V2l0aE5ld1VybChyZWRpcmVjdFVybCwgY29udGV4dC5yZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVG8gZ2V0IHRoZSBvcHRpb25zIGZvciBleGVjdXRpb24gb2YgdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBBIG9wdGlvbnMgZm9yIG1pZGRsZXdhcmUgZXhlY3V0aW9uXG4gICAgICovXG4gICAgZ2V0T3B0aW9ucyhjb250ZXh0KSB7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoY29udGV4dC5taWRkbGV3YXJlQ29udHJvbCBpbnN0YW5jZW9mIE1pZGRsZXdhcmVDb250cm9sKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gY29udGV4dC5taWRkbGV3YXJlQ29udHJvbC5nZXRNaWRkbGV3YXJlT3B0aW9ucyhSZWRpcmVjdEhhbmRsZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG5ldyBSZWRpcmVjdEhhbmRsZXJPcHRpb25zKCksIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFzeW5jXG4gICAgICogVG8gZXhlY3V0ZSB0aGUgbmV4dCBtaWRkbGV3YXJlIGFuZCB0byBoYW5kbGUgaW4gY2FzZSBvZiByZWRpcmVjdCByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG4gICAgICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlZGlyZWN0Q291bnQgLSBUaGUgcmVkaXJlY3QgY291bnQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge1JlZGlyZWN0SGFuZGxlck9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgcmVkaXJlY3QgaGFuZGxlciBvcHRpb25zIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbm90aGluZ1xuICAgICAqL1xuICAgIGV4ZWN1dGVXaXRoUmVkaXJlY3QoY29udGV4dCwgcmVkaXJlY3RDb3VudCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5uZXh0TWlkZGxld2FyZS5leGVjdXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBjb250ZXh0LnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPCBvcHRpb25zLm1heFJlZGlyZWN0cyAmJiB0aGlzLmlzUmVkaXJlY3QocmVzcG9uc2UpICYmIHRoaXMuaGFzTG9jYXRpb25IZWFkZXIocmVzcG9uc2UpICYmIG9wdGlvbnMuc2hvdWxkUmVkaXJlY3QocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgKytyZWRpcmVjdENvdW50O1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IFJlZGlyZWN0SGFuZGxlci5TVEFUVVNfQ09ERV9TRUVfT1RIRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLm1ldGhvZCA9IFJlcXVlc3RNZXRob2QuR0VUO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29udGV4dC5vcHRpb25zLmJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFVybCA9IHRoaXMuZ2V0TG9jYXRpb25IZWFkZXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSZWxhdGl2ZVVSTChyZWRpcmVjdFVybCkgJiYgdGhpcy5zaG91bGREcm9wQXV0aG9yaXphdGlvbkhlYWRlcihyZXNwb25zZS51cmwsIHJlZGlyZWN0VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQub3B0aW9ucy5oZWFkZXJzW1JlZGlyZWN0SGFuZGxlci5BVVRIT1JJWkFUSU9OX0hFQURFUl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVSZXF1ZXN0VXJsKHJlZGlyZWN0VXJsLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5leGVjdXRlV2l0aFJlZGlyZWN0KGNvbnRleHQsIHJlZGlyZWN0Q291bnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFRvIGV4ZWN1dGUgdGhlIGN1cnJlbnQgbWlkZGxld2FyZVxuICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9iamVjdCBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG5vdGhpbmdcbiAgICAgKi9cbiAgICBleGVjdXRlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0Q291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucyhjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5yZWRpcmVjdCA9IFJlZGlyZWN0SGFuZGxlci5NQU5VQUxfUkVESVJFQ1Q7XG4gICAgICAgICAgICBUZWxlbWV0cnlIYW5kbGVyT3B0aW9ucy51cGRhdGVGZWF0dXJlVXNhZ2VGbGFnKGNvbnRleHQsIEZlYXR1cmVVc2FnZUZsYWcuUkVESVJFQ1RfSEFORExFUl9FTkFCTEVEKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmV4ZWN1dGVXaXRoUmVkaXJlY3QoY29udGV4dCwgcmVkaXJlY3RDb3VudCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVG8gc2V0IHRoZSBuZXh0IG1pZGRsZXdhcmUgaW4gdGhlIGNoYWluXG4gICAgICogQHBhcmFtIHtNaWRkbGV3YXJlfSBuZXh0IC0gVGhlIG1pZGRsZXdhcmUgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBOb3RoaW5nXG4gICAgICovXG4gICAgc2V0TmV4dChuZXh0KSB7XG4gICAgICAgIHRoaXMubmV4dE1pZGRsZXdhcmUgPSBuZXh0O1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEEgbWVtYmVyIGhvbGRpbmcgdGhlIGFycmF5IG9mIHJlZGlyZWN0IHN0YXR1cyBjb2Rlc1xuICovXG5SZWRpcmVjdEhhbmRsZXIuUkVESVJFQ1RfU1RBVFVTX0NPREVTID0gW1xuICAgIDMwMSxcbiAgICAzMDIsXG4gICAgMzAzLFxuICAgIDMwNyxcbiAgICAzMDgsIC8vIE1vdmVkIFBlcm1hbmVudGx5XG5dO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyBTZWVPdGhlciBzdGF0dXMgY29kZVxuICovXG5SZWRpcmVjdEhhbmRsZXIuU1RBVFVTX0NPREVfU0VFX09USEVSID0gMzAzO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyB0aGUgbmFtZSBvZiB0aGUgbG9jYXRpb24gaGVhZGVyXG4gKi9cblJlZGlyZWN0SGFuZGxlci5MT0NBVElPTl9IRUFERVIgPSBcIkxvY2F0aW9uXCI7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBBIG1lbWJlciByZXByZXNlbnRpbmcgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyIG5hbWVcbiAqL1xuUmVkaXJlY3RIYW5kbGVyLkFVVEhPUklaQVRJT05fSEVBREVSID0gXCJBdXRob3JpemF0aW9uXCI7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBBIG1lbWJlciBob2xkaW5nIHRoZSBtYW51YWwgcmVkaXJlY3QgdmFsdWVcbiAqL1xuUmVkaXJlY3RIYW5kbGVyLk1BTlVBTF9SRURJUkVDVCA9IFwibWFudWFsXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWRpcmVjdEhhbmRsZXIuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vLyBUSElTIEZJTEUgSVMgQVVUTyBHRU5FUkFURURcbi8vIEFOWSBDSEFOR0VTIFdJTEwgQkUgTE9TVCBEVVJJTkcgQlVJTERcbi8qKlxuICogQG1vZHVsZSBWZXJzaW9uXG4gKi9cbmV4cG9ydCBjb25zdCBQQUNLQUdFX1ZFUlNJT04gPSBcIjMuMC43XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZXJzaW9uLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBtb2R1bGUgVGVsZW1ldHJ5SGFuZGxlclxuICovXG5pbXBvcnQgeyBpc0N1c3RvbUhvc3QsIGlzR3JhcGhVUkwgfSBmcm9tIFwiLi4vR3JhcGhSZXF1ZXN0VXRpbFwiO1xuaW1wb3J0IHsgUEFDS0FHRV9WRVJTSU9OIH0gZnJvbSBcIi4uL1ZlcnNpb25cIjtcbmltcG9ydCB7IE1pZGRsZXdhcmVDb250cm9sIH0gZnJvbSBcIi4vTWlkZGxld2FyZUNvbnRyb2xcIjtcbmltcG9ydCB7IGFwcGVuZFJlcXVlc3RIZWFkZXIsIGdlbmVyYXRlVVVJRCwgZ2V0UmVxdWVzdEhlYWRlciwgc2V0UmVxdWVzdEhlYWRlciB9IGZyb20gXCIuL01pZGRsZXdhcmVVdGlsXCI7XG5pbXBvcnQgeyBUZWxlbWV0cnlIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL29wdGlvbnMvVGVsZW1ldHJ5SGFuZGxlck9wdGlvbnNcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBAaW1wbGVtZW50cyBNaWRkbGV3YXJlXG4gKiBDbGFzcyBmb3IgVGVsZW1ldHJ5SGFuZGxlclxuICovXG5leHBvcnQgY2xhc3MgVGVsZW1ldHJ5SGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFRvIGV4ZWN1dGUgdGhlIGN1cnJlbnQgbWlkZGxld2FyZVxuICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9iamVjdCBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG5vdGhpbmdcbiAgICAgKi9cbiAgICBleGVjdXRlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHR5cGVvZiBjb250ZXh0LnJlcXVlc3QgPT09IFwic3RyaW5nXCIgPyBjb250ZXh0LnJlcXVlc3QgOiBjb250ZXh0LnJlcXVlc3QudXJsO1xuICAgICAgICAgICAgaWYgKGlzR3JhcGhVUkwodXJsKSB8fCAoY29udGV4dC5jdXN0b21Ib3N0cyAmJiBpc0N1c3RvbUhvc3QodXJsLCBjb250ZXh0LmN1c3RvbUhvc3RzKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGVsZW1ldHJ5IG9ubHkgaWYgdGhlIHJlcXVlc3QgdXJsIGlzIGEgR3JhcGggVVJMLlxuICAgICAgICAgICAgICAgIC8vIEVycm9ycyBhcmUgcmVwb3J0ZWQgYXMgaW4gaXNzdWUgIzI2NSBpZiBoZWFkZXJzIGFyZSBwcmVzZW50IHdoZW4gcmVkaXJlY3RpbmcgdG8gYSBub24gR3JhcGggVVJMXG4gICAgICAgICAgICAgICAgbGV0IGNsaWVudFJlcXVlc3RJZCA9IGdldFJlcXVlc3RIZWFkZXIoY29udGV4dC5yZXF1ZXN0LCBjb250ZXh0Lm9wdGlvbnMsIFRlbGVtZXRyeUhhbmRsZXIuQ0xJRU5UX1JFUVVFU1RfSURfSEVBREVSKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaWVudFJlcXVlc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRSZXF1ZXN0SWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcihjb250ZXh0LnJlcXVlc3QsIGNvbnRleHQub3B0aW9ucywgVGVsZW1ldHJ5SGFuZGxlci5DTElFTlRfUkVRVUVTVF9JRF9IRUFERVIsIGNsaWVudFJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzZGtWZXJzaW9uVmFsdWUgPSBgJHtUZWxlbWV0cnlIYW5kbGVyLlBST0RVQ1RfTkFNRX0vJHtQQUNLQUdFX1ZFUlNJT059YDtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5taWRkbGV3YXJlQ29udHJvbCBpbnN0YW5jZW9mIE1pZGRsZXdhcmVDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb250ZXh0Lm1pZGRsZXdhcmVDb250cm9sLmdldE1pZGRsZXdhcmVPcHRpb25zKFRlbGVtZXRyeUhhbmRsZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZVVzYWdlID0gb3B0aW9ucy5nZXRGZWF0dXJlVXNhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc2RrVmVyc2lvblZhbHVlICs9IGAgKCR7VGVsZW1ldHJ5SGFuZGxlci5GRUFUVVJFX1VTQUdFX1NUUklOR309JHtmZWF0dXJlVXNhZ2V9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGVuZFJlcXVlc3RIZWFkZXIoY29udGV4dC5yZXF1ZXN0LCBjb250ZXh0Lm9wdGlvbnMsIFRlbGVtZXRyeUhhbmRsZXIuU0RLX1ZFUlNJT05fSEVBREVSLCBzZGtWZXJzaW9uVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRlbGVtZXRyeSBoZWFkZXJzIGlmIHByZXNlbnQgZHVyaW5nIHJlZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0Lm9wdGlvbnMuaGVhZGVyc1tUZWxlbWV0cnlIYW5kbGVyLkNMSUVOVF9SRVFVRVNUX0lEX0hFQURFUl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQub3B0aW9ucy5oZWFkZXJzW1RlbGVtZXRyeUhhbmRsZXIuU0RLX1ZFUlNJT05fSEVBREVSXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLm5leHRNaWRkbGV3YXJlLmV4ZWN1dGUoY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVG8gc2V0IHRoZSBuZXh0IG1pZGRsZXdhcmUgaW4gdGhlIGNoYWluXG4gICAgICogQHBhcmFtIHtNaWRkbGV3YXJlfSBuZXh0IC0gVGhlIG1pZGRsZXdhcmUgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBOb3RoaW5nXG4gICAgICovXG4gICAgc2V0TmV4dChuZXh0KSB7XG4gICAgICAgIHRoaXMubmV4dE1pZGRsZXdhcmUgPSBuZXh0O1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEEgbWVtYmVyIGhvbGRpbmcgdGhlIG5hbWUgb2YgdGhlIGNsaWVudCByZXF1ZXN0IGlkIGhlYWRlclxuICovXG5UZWxlbWV0cnlIYW5kbGVyLkNMSUVOVF9SRVFVRVNUX0lEX0hFQURFUiA9IFwiY2xpZW50LXJlcXVlc3QtaWRcIjtcbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdGF0aWNcbiAqIEEgbWVtYmVyIGhvbGRpbmcgdGhlIG5hbWUgb2YgdGhlIHNkayB2ZXJzaW9uIGhlYWRlclxuICovXG5UZWxlbWV0cnlIYW5kbGVyLlNES19WRVJTSU9OX0hFQURFUiA9IFwiU2RrVmVyc2lvblwiO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyB0aGUgbGFuZ3VhZ2UgcHJlZml4IGZvciB0aGUgc2RrIHZlcnNpb24gaGVhZGVyIHZhbHVlXG4gKi9cblRlbGVtZXRyeUhhbmRsZXIuUFJPRFVDVF9OQU1FID0gXCJncmFwaC1qc1wiO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICogQSBtZW1iZXIgaG9sZGluZyB0aGUga2V5IGZvciB0aGUgZmVhdHVyZSB1c2FnZSBtZXRyaWNzXG4gKi9cblRlbGVtZXRyeUhhbmRsZXIuRkVBVFVSRV9VU0FHRV9TVFJJTkcgPSBcImZlYXR1cmVVc2FnZVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGVsZW1ldHJ5SGFuZGxlci5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uSGFuZGxlciB9IGZyb20gXCIuL0F1dGhlbnRpY2F0aW9uSGFuZGxlclwiO1xuaW1wb3J0IHsgSFRUUE1lc3NhZ2VIYW5kbGVyIH0gZnJvbSBcIi4vSFRUUE1lc3NhZ2VIYW5kbGVyXCI7XG5pbXBvcnQgeyBSZWRpcmVjdEhhbmRsZXJPcHRpb25zIH0gZnJvbSBcIi4vb3B0aW9ucy9SZWRpcmVjdEhhbmRsZXJPcHRpb25zXCI7XG5pbXBvcnQgeyBSZXRyeUhhbmRsZXJPcHRpb25zIH0gZnJvbSBcIi4vb3B0aW9ucy9SZXRyeUhhbmRsZXJPcHRpb25zXCI7XG5pbXBvcnQgeyBSZWRpcmVjdEhhbmRsZXIgfSBmcm9tIFwiLi9SZWRpcmVjdEhhbmRsZXJcIjtcbmltcG9ydCB7IFJldHJ5SGFuZGxlciB9IGZyb20gXCIuL1JldHJ5SGFuZGxlclwiO1xuaW1wb3J0IHsgVGVsZW1ldHJ5SGFuZGxlciB9IGZyb20gXCIuL1RlbGVtZXRyeUhhbmRsZXJcIjtcbi8qKlxuICogQHByaXZhdGVcbiAqIFRvIGNoZWNrIHdoZXRoZXIgdGhlIGVudmlyb25tZW50IGlzIG5vZGUgb3Igbm90XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlbnZpcm9ubWVudCBpcyBub2RlIG9yIG5vdFxuICovXG5jb25zdCBpc05vZGVFbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIjtcbn07XG4vKipcbiAqIEBjbGFzc1xuICogQ2xhc3MgY29udGFpbmluZyBmdW5jdGlvbihzKSByZWxhdGVkIHRvIHRoZSBtaWRkbGV3YXJlIHBpcGVsaW5lcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1pZGRsZXdhcmVGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgbWlkZGxld2FyZSBjaGFpbiBhbiBhcnJheSB3aXRoIHRoZSAgbWlkZGxld2FyZSBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25Qcm92aWRlcn0gYXV0aFByb3ZpZGVyIC0gVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIG1pZGRsZXdhcmUgaGFuZGxlcnMgb2YgdGhlIGRlZmF1bHQgbWlkZGxld2FyZSBjaGFpblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREZWZhdWx0TWlkZGxld2FyZUNoYWluKGF1dGhQcm92aWRlcikge1xuICAgICAgICBjb25zdCBtaWRkbGV3YXJlID0gW107XG4gICAgICAgIGNvbnN0IGF1dGhlbnRpY2F0aW9uSGFuZGxlciA9IG5ldyBBdXRoZW50aWNhdGlvbkhhbmRsZXIoYXV0aFByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgcmV0cnlIYW5kbGVyID0gbmV3IFJldHJ5SGFuZGxlcihuZXcgUmV0cnlIYW5kbGVyT3B0aW9ucygpKTtcbiAgICAgICAgY29uc3QgdGVsZW1ldHJ5SGFuZGxlciA9IG5ldyBUZWxlbWV0cnlIYW5kbGVyKCk7XG4gICAgICAgIGNvbnN0IGh0dHBNZXNzYWdlSGFuZGxlciA9IG5ldyBIVFRQTWVzc2FnZUhhbmRsZXIoKTtcbiAgICAgICAgbWlkZGxld2FyZS5wdXNoKGF1dGhlbnRpY2F0aW9uSGFuZGxlcik7XG4gICAgICAgIG1pZGRsZXdhcmUucHVzaChyZXRyeUhhbmRsZXIpO1xuICAgICAgICBpZiAoaXNOb2RlRW52aXJvbm1lbnQoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RIYW5kbGVyID0gbmV3IFJlZGlyZWN0SGFuZGxlcihuZXcgUmVkaXJlY3RIYW5kbGVyT3B0aW9ucygpKTtcbiAgICAgICAgICAgIG1pZGRsZXdhcmUucHVzaChyZWRpcmVjdEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIG1pZGRsZXdhcmUucHVzaCh0ZWxlbWV0cnlIYW5kbGVyKTtcbiAgICAgICAgbWlkZGxld2FyZS5wdXNoKGh0dHBNZXNzYWdlSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pZGRsZXdhcmVGYWN0b3J5LmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiBAbW9kdWxlIENoYW9zU3RyYXRlZ3lcbiAqL1xuLyoqXG4gKiBTdHJhdGVneSB1c2VkIGZvciBUZXN0aW5nIEhhbmRsZXJcbiAqIEBlbnVtXG4gKi9cbmV4cG9ydCB2YXIgQ2hhb3NTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2hhb3NTdHJhdGVneSkge1xuICAgIENoYW9zU3RyYXRlZ3lbQ2hhb3NTdHJhdGVneVtcIk1BTlVBTFwiXSA9IDBdID0gXCJNQU5VQUxcIjtcbiAgICBDaGFvc1N0cmF0ZWd5W0NoYW9zU3RyYXRlZ3lbXCJSQU5ET01cIl0gPSAxXSA9IFwiUkFORE9NXCI7XG59KShDaGFvc1N0cmF0ZWd5IHx8IChDaGFvc1N0cmF0ZWd5ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW9zU3RyYXRlZ3kuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBtb2R1bGUgQ2hhb3NIYW5kbGVyT3B0aW9uc1xuICovXG5pbXBvcnQgeyBDaGFvc1N0cmF0ZWd5IH0gZnJvbSBcIi4vQ2hhb3NTdHJhdGVneVwiO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgQ2hhb3NIYW5kbGVyT3B0aW9uc1xuICogQGNsYXNzXG4gKiBDbGFzc1xuICogQGltcGxlbWVudHMgTWlkZGxld2FyZU9wdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIENoYW9zSGFuZGxlck9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVGVzdGluZyBIYW5kbGVyIE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0NoYW9zU3RyYXRlZ3l9IGNoYW9zU3RyYXRlZ3kgLSBTcGVjaWZpZXMgdGhlIHN0YXJ0ZWd5IHVzZWQgZm9yIHRoZSBUZXN0aW5nIEhhbmRsZXIgLT4gUkFNRE9NL01BTlVBTFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXNNZXNzYWdlIC0gVGhlIE1lc3NhZ2UgdG8gYmUgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBzdGF0dXNDb2RlIC0gVGhlIHN0YXR1c0NvZGUgdG8gYmUgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBjaGFvc1BlcmNlbnRhZ2UgLSBUaGUgcGVyY2VudGFnZSBvZiByYW5kb21uZXNzL2NoYW9zIGluIHRoZSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHthbnk/fSByZXNwb25zZUJvZHkgLSBUaGUgcmVzcG9uc2UgYm9keSB0byBiZSByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBDaGFvc0hhbmRsZXJPcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhb3NTdHJhdGVneSA9IENoYW9zU3RyYXRlZ3kuUkFORE9NLCBzdGF0dXNNZXNzYWdlID0gXCJTb21lIGVycm9yIEhhcHBlbmVkXCIsIHN0YXR1c0NvZGUsIGNoYW9zUGVyY2VudGFnZSwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuY2hhb3NTdHJhdGVneSA9IGNoYW9zU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIHRoaXMuc3RhdHVzTWVzc2FnZSA9IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIHRoaXMuY2hhb3NQZXJjZW50YWdlID0gY2hhb3NQZXJjZW50YWdlICE9PSB1bmRlZmluZWQgPyBjaGFvc1BlcmNlbnRhZ2UgOiAxMDtcbiAgICAgICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIGlmICh0aGlzLmNoYW9zUGVyY2VudGFnZSA+IDEwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgUGVjZW50YWdlIGNhbiBub3QgYmUgbW9yZSB0aGFuIDEwMFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW9zSGFuZGxlck9wdGlvbnMuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBtb2R1bGUgQ2hhb3NIYW5kbGVyRGF0YVxuICovXG4vKipcbiAqIENvbnRhaW5zIFJlcXVlc3RNZXRob2QgdG8gY29ycmVzcG9uZGluZyBhcnJheSBvZiBwb3NzaWJsZSBzdGF0dXMgY29kZXMsIHVzZWQgZm9yIFJhbmRvbSBtb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBtZXRob2RTdGF0dXNDb2RlID0ge1xuICAgIEdFVDogWzQyOSwgNTAwLCA1MDIsIDUwMywgNTA0XSxcbiAgICBQT1NUOiBbNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDQsIDUwN10sXG4gICAgUFVUOiBbNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDQsIDUwN10sXG4gICAgUEFUQ0g6IFs0MjksIDUwMCwgNTAyLCA1MDMsIDUwNF0sXG4gICAgREVMRVRFOiBbNDI5LCA1MDAsIDUwMiwgNTAzLCA1MDQsIDUwN10sXG59O1xuLyoqXG4gKiBDb250YWlucyBzdGF0dXNDb2RlIHRvIHN0YXR1c01lc3NhZ2UgbWFwXG4gKi9cbmV4cG9ydCBjb25zdCBodHRwU3RhdHVzQ29kZSA9IHtcbiAgICAxMDA6IFwiQ29udGludWVcIixcbiAgICAxMDE6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICAgIDEwMjogXCJQcm9jZXNzaW5nXCIsXG4gICAgMTAzOiBcIkVhcmx5IEhpbnRzXCIsXG4gICAgMjAwOiBcIk9LXCIsXG4gICAgMjAxOiBcIkNyZWF0ZWRcIixcbiAgICAyMDI6IFwiQWNjZXB0ZWRcIixcbiAgICAyMDM6IFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcbiAgICAyMDQ6IFwiTm8gQ29udGVudFwiLFxuICAgIDIwNTogXCJSZXNldCBDb250ZW50XCIsXG4gICAgMjA2OiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICAgIDIwNzogXCJNdWx0aS1TdGF0dXNcIixcbiAgICAyMDg6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICAgIDIyNjogXCJJTSBVc2VkXCIsXG4gICAgMzAwOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgICAzMDE6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgICAzMDI6IFwiRm91bmRcIixcbiAgICAzMDM6IFwiU2VlIE90aGVyXCIsXG4gICAgMzA0OiBcIk5vdCBNb2RpZmllZFwiLFxuICAgIDMwNTogXCJVc2UgUHJveHlcIixcbiAgICAzMDc6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gICAgMzA4OiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICAgIDQwMDogXCJCYWQgUmVxdWVzdFwiLFxuICAgIDQwMTogXCJVbmF1dGhvcml6ZWRcIixcbiAgICA0MDI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICAgIDQwMzogXCJGb3JiaWRkZW5cIixcbiAgICA0MDQ6IFwiTm90IEZvdW5kXCIsXG4gICAgNDA1OiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICAgIDQwNjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICAgIDQwNzogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICAgIDQwODogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgICA0MDk6IFwiQ29uZmxpY3RcIixcbiAgICA0MTA6IFwiR29uZVwiLFxuICAgIDQxMTogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgICA0MTI6IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFxuICAgIDQxMzogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICAgIDQxNDogXCJVUkkgVG9vIExvbmdcIixcbiAgICA0MTU6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICAgIDQxNjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgICA0MTc6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gICAgNDIxOiBcIk1pc2RpcmVjdGVkIFJlcXVlc3RcIixcbiAgICA0MjI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgICA0MjM6IFwiTG9ja2VkXCIsXG4gICAgNDI0OiBcIkZhaWxlZCBEZXBlbmRlbmN5XCIsXG4gICAgNDI1OiBcIlRvbyBFYXJseVwiLFxuICAgIDQyNjogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gICAgNDI4OiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICAgIDQyOTogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICAgIDQzMTogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gICAgNDUxOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gICAgNTAwOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICAgIDUwMTogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgICA1MDI6IFwiQmFkIEdhdGV3YXlcIixcbiAgICA1MDM6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICAgIDUwNDogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgICA1MDU6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgICA1MDY6IFwiVmFyaWFudCBBbHNvIE5lZ290aWF0ZXNcIixcbiAgICA1MDc6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgICA1MDg6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICAgIDUxMDogXCJOb3QgRXh0ZW5kZWRcIixcbiAgICA1MTE6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW9zSGFuZGxlckRhdGEuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5pbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IE1pZGRsZXdhcmVDb250cm9sIH0gZnJvbSBcIi4vTWlkZGxld2FyZUNvbnRyb2xcIjtcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gXCIuL01pZGRsZXdhcmVVdGlsXCI7XG5pbXBvcnQgeyBodHRwU3RhdHVzQ29kZSwgbWV0aG9kU3RhdHVzQ29kZSB9IGZyb20gXCIuL29wdGlvbnMvQ2hhb3NIYW5kbGVyRGF0YVwiO1xuaW1wb3J0IHsgQ2hhb3NIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL29wdGlvbnMvQ2hhb3NIYW5kbGVyT3B0aW9uc1wiO1xuaW1wb3J0IHsgQ2hhb3NTdHJhdGVneSB9IGZyb20gXCIuL29wdGlvbnMvQ2hhb3NTdHJhdGVneVwiO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgQ2hhb3NIYW5kbGVyXG4gKiBAY2xhc3NcbiAqIENsYXNzXG4gKiBAaW1wbGVtZW50cyBNaWRkbGV3YXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFvc0hhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVGVzdGluZyBIYW5kbGVyXG4gICAgICogQHBhcmFtIHtDaGFvc0hhbmRsZXJPcHRpb25zfSBbb3B0aW9ucyA9IG5ldyBDaGFvc0hhbmRsZXJPcHRpb25zKCldIC0gVGhlIHRlc3RpbmcgaGFuZGxlciBvcHRpb25zIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG1hbnVhbE1hcCAtIFRoZSBNYXAgcGFzc2VkIGJ5IHVzZXIgY29udGFpbmluZyB1cmwtc3RhdHVzQ29kZSBpbmZvXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVGVzdGluZyBIYW5kbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IG5ldyBDaGFvc0hhbmRsZXJPcHRpb25zKCksIG1hbnVhbE1hcCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm1hbnVhbE1hcCA9IG1hbnVhbE1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHJlc3BvbnNlSGVhZGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NoYW9zSGFuZGxlck9wdGlvbnN9IGNoYW9zSGFuZGxlck9wdGlvbnMgLSBUaGUgQ2hhb3NIYW5kbGVyT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdElEIC0gcmVxdWVzdCBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0RGF0ZSAtIGRhdGUgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyByZXNwb25zZSBIZWFkZXJcbiAgICAgKi9cbiAgICBjcmVhdGVSZXNwb25zZUhlYWRlcnMoY2hhb3NIYW5kbGVyT3B0aW9ucywgcmVxdWVzdElELCByZXF1ZXN0RGF0ZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZUhlYWRlciA9IGNoYW9zSGFuZGxlck9wdGlvbnMuaGVhZGVycyA/IG5ldyBIZWFkZXJzKGNoYW9zSGFuZGxlck9wdGlvbnMuaGVhZGVycykgOiBuZXcgSGVhZGVycygpO1xuICAgICAgICByZXNwb25zZUhlYWRlci5hcHBlbmQoXCJDYWNoZS1Db250cm9sXCIsIFwibm8tc3RvcmVcIik7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLmFwcGVuZChcInJlcXVlc3QtaWRcIiwgcmVxdWVzdElEKTtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIuYXBwZW5kKFwiY2xpZW50LXJlcXVlc3QtaWRcIiwgcmVxdWVzdElEKTtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIuYXBwZW5kKFwieC1tcy1hZ3MtZGlhZ25vc3RpY1wiLCBcIlwiKTtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIuYXBwZW5kKFwiRGF0ZVwiLCByZXF1ZXN0RGF0ZSk7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLmFwcGVuZChcIlN0cmljdC1UcmFuc3BvcnQtU2VjdXJpdHlcIiwgXCJcIik7XG4gICAgICAgIGlmIChjaGFvc0hhbmRsZXJPcHRpb25zLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgLy8gdGhyb3R0bGluZyBjYXNlIGhhcyB0byBoYXZlIGEgdGltZW91dCBzY2VuYXJpb1xuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXIuYXBwZW5kKFwicmV0cnktYWZ0ZXJcIiwgXCIzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZUhlYWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHJlc3BvbnNlQm9keVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDaGFvc0hhbmRsZXJPcHRpb25zfSBjaGFvc0hhbmRsZXJPcHRpb25zIC0gVGhlIENoYW9zSGFuZGxlck9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RJRCAtIHJlcXVlc3QgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdERhdGUgLSBkYXRlIG9mIHRoZSByZXF1ZXN0XG4gICAgICogICogQHJldHVybnMgcmVzcG9uc2UgYm9keVxuICAgICAqL1xuICAgIGNyZWF0ZVJlc3BvbnNlQm9keShjaGFvc0hhbmRsZXJPcHRpb25zLCByZXF1ZXN0SUQsIHJlcXVlc3REYXRlKSB7XG4gICAgICAgIGlmIChjaGFvc0hhbmRsZXJPcHRpb25zLnJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW9zSGFuZGxlck9wdGlvbnMucmVzcG9uc2VCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAoY2hhb3NIYW5kbGVyT3B0aW9ucy5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgY29uc3QgY29kZU1lc3NhZ2UgPSBodHRwU3RhdHVzQ29kZVtjaGFvc0hhbmRsZXJPcHRpb25zLnN0YXR1c0NvZGVdO1xuICAgICAgICAgICAgY29uc3QgZXJyTWVzc2FnZSA9IGNoYW9zSGFuZGxlck9wdGlvbnMuc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgICAgIGJvZHkgPSB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVxdWVzdC1pZFwiOiByZXF1ZXN0SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiByZXF1ZXN0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBhIHJlc3BvbnNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NoYW9zSGFuZGxlck9wdGlvbnN9IGNoYW9zSGFuZGxlck9wdGlvbnMgLSBUaGUgQ2hhb3NIYW5kbGVyT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBDb250YWlucyB0aGUgY29udGV4dCBvZiB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIGNyZWF0ZVJlc3BvbnNlKGNoYW9zSGFuZGxlck9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFVSTCA9IGNvbnRleHQucmVxdWVzdDtcbiAgICAgICAgY29uc3QgcmVxdWVzdElEID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3REYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXIgPSB0aGlzLmNyZWF0ZVJlc3BvbnNlSGVhZGVycyhjaGFvc0hhbmRsZXJPcHRpb25zLCByZXF1ZXN0SUQsIHJlcXVlc3REYXRlLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSB0aGlzLmNyZWF0ZVJlc3BvbnNlQm9keShjaGFvc0hhbmRsZXJPcHRpb25zLCByZXF1ZXN0SUQsIHJlcXVlc3REYXRlLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBpbml0ID0geyB1cmw6IHJlcXVlc3RVUkwsIHN0YXR1czogY2hhb3NIYW5kbGVyT3B0aW9ucy5zdGF0dXNDb2RlLCBzdGF0dXNUZXh0OiBjaGFvc0hhbmRsZXJPcHRpb25zLnN0YXR1c01lc3NhZ2UsIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVyIH07XG4gICAgICAgIGNvbnRleHQucmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UodHlwZW9mIHJlc3BvbnNlQm9keSA9PT0gXCJzdHJpbmdcIiA/IHJlc3BvbnNlQm9keSA6IEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlQm9keSksIGluaXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNpZGVzIHdoZXRoZXIgdG8gc2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgZ3JhcGggb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NoYW9zSGFuZGxlck9wdGlvbnN9IGNoYW9zSGFuZGxlck9wdGlvbnMgLSBBIENoYW9zSGFuZGxlck9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0IC0gQ29udGFpbnMgdGhlIGNvbnRleHQgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyBub3RoaW5nXG4gICAgICovXG4gICAgc2VuZFJlcXVlc3QoY2hhb3NIYW5kbGVyT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXNDb2RlKGNoYW9zSGFuZGxlck9wdGlvbnMsIGNvbnRleHQucmVxdWVzdCwgY29udGV4dC5vcHRpb25zLm1ldGhvZCk7XG4gICAgICAgICAgICBpZiAoKGNoYW9zSGFuZGxlck9wdGlvbnMuY2hhb3NTdHJhdGVneSA9PT0gQ2hhb3NTdHJhdGVneS5NQU5VQUwgJiYgIXRoaXMubmV4dE1pZGRsZXdhcmUpIHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCkgPCBjaGFvc0hhbmRsZXJPcHRpb25zLmNoYW9zUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVzcG9uc2UoY2hhb3NIYW5kbGVyT3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHRNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5uZXh0TWlkZGxld2FyZS5leGVjdXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIHJhbmRvbSBzdGF0dXMgY29kZSBmb3IgdGhlIFJBTkRPTSBtb2RlIGZyb20gdGhlIHByZWRlZmluZWQgYXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0TWV0aG9kIC0gdGhlIEFQSSBtZXRob2QgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHJldHVybnMgYSByYW5kb20gc3RhdHVzIGNvZGUgZnJvbSBhIGdpdmVuIHNldCBvZiBzdGF0dXMgY29kZXNcbiAgICAgKi9cbiAgICBnZXRSYW5kb21TdGF0dXNDb2RlKHJlcXVlc3RNZXRob2QpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZUFycmF5ID0gbWV0aG9kU3RhdHVzQ29kZVtyZXF1ZXN0TWV0aG9kXTtcbiAgICAgICAgcmV0dXJuIHN0YXR1c0NvZGVBcnJheVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzdGF0dXNDb2RlQXJyYXkubGVuZ3RoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGZldGNoIHRoZSByZWxhdGl2ZSBVUkwgb3V0IG9mIHRoZSBjb21wbGV0ZSBVUkwgdXNpbmcgYSBwcmVkZWZpbmVkIHJlZ2V4IHBhdHRlcm5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxNZXRob2QgLSB0aGUgY29tcGxldGUgVVJMXG4gICAgICogQHJldHVybnMgdGhlIHN0cmluZyBhcyByZWxhdGl2ZSBVUkxcbiAgICAgKi9cbiAgICBnZXRSZWxhdGl2ZVVSTCh1cmxNZXRob2QpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IC9odHRwcz86XFwvXFwvZ3JhcGhcXC5taWNyb3NvZnRcXC5jb21cXC9bXi9dKyguKz8pKFxcP3wkKS87XG4gICAgICAgIGxldCByZWxhdGl2ZVVSTDtcbiAgICAgICAgaWYgKHBhdHRlcm4uZXhlYyh1cmxNZXRob2QpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWxhdGl2ZVVSTCA9IHBhdHRlcm4uZXhlYyh1cmxNZXRob2QpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gZmV0Y2ggdGhlIHN0YXR1cyBjb2RlIGZyb20gdGhlIG1hcChpZiBuZWVkZWQpLCB0aGVuIHJldHVybnMgcmVzcG9uc2UgYnkgY2FsbGluZyBjcmVhdGVSZXNwb25zZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDaGFvc0hhbmRsZXJPcHRpb25zfSBjaGFvc0hhbmRsZXJPcHRpb25zIC0gVGhlIENoYW9zSGFuZGxlck9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RVUkwgLSB0aGUgVVJMIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0TWV0aG9kIC0gdGhlIEFQSSBtZXRob2QgZm9yIHRoZSByZXF1ZXN0XG4gICAgICovXG4gICAgc2V0U3RhdHVzQ29kZShjaGFvc0hhbmRsZXJPcHRpb25zLCByZXF1ZXN0VVJMLCByZXF1ZXN0TWV0aG9kKSB7XG4gICAgICAgIGlmIChjaGFvc0hhbmRsZXJPcHRpb25zLmNoYW9zU3RyYXRlZ3kgPT09IENoYW9zU3RyYXRlZ3kuTUFOVUFMKSB7XG4gICAgICAgICAgICBpZiAoY2hhb3NIYW5kbGVyT3B0aW9ucy5zdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBtYW51YWwgbW9kZSB3aXRoIG5vIHN0YXR1cyBjb2RlLCBjYW4gYmUgYSBnbG9iYWwgbGV2ZWwgb3IgcmVxdWVzdCBsZXZlbCB3aXRob3V0IHN0YXR1c0NvZGVcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVVSTCA9IHRoaXMuZ2V0UmVsYXRpdmVVUkwocmVxdWVzdFVSTCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsTWFwLmdldChyZWxhdGl2ZVVSTCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVja2luZyBNYW51YWwgTWFwIGZvciBleGFjdCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYW51YWxNYXAuZ2V0KHJlbGF0aXZlVVJMKS5nZXQocmVxdWVzdE1ldGhvZCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhb3NIYW5kbGVyT3B0aW9ucy5zdGF0dXNDb2RlID0gdGhpcy5tYW51YWxNYXAuZ2V0KHJlbGF0aXZlVVJMKS5nZXQocmVxdWVzdE1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzdGF0dXNDb2RlIHdvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tpbmcgZm9yIHJlZ2V4IG1hdGNoIGlmIGV4YWN0IG1hdGNoIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbnVhbE1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleFVSTCA9IG5ldyBSZWdFeHAoa2V5ICsgXCIkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4VVJMLnRlc3QocmVsYXRpdmVVUkwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFudWFsTWFwLmdldChrZXkpLmdldChyZXF1ZXN0TWV0aG9kKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW9zSGFuZGxlck9wdGlvbnMuc3RhdHVzQ29kZSA9IHRoaXMubWFudWFsTWFwLmdldChrZXkpLmdldChyZXF1ZXN0TWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzdGF0dXNDb2RlIHdvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSBvZiByZWRpcmVjdGlvbiBvciByZXF1ZXN0IHVybCBub3QgaW4gbWFwIC0tLT4gc3RhdHVzQ29kZSB3b3VsZCBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsaW5nIHRoZSBjYXNlIG9mIFJhbmRvbSBoZXJlXG4gICAgICAgICAgICBjaGFvc0hhbmRsZXJPcHRpb25zLnN0YXR1c0NvZGUgPSB0aGlzLmdldFJhbmRvbVN0YXR1c0NvZGUocmVxdWVzdE1ldGhvZCk7XG4gICAgICAgICAgICAvLyBlbHNlIHN0YXR1c0NvZGUgd291bGQgYmUgdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gZ2V0IHRoZSBvcHRpb25zIGZvciBleGVjdXRpb24gb2YgdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9iamVjdFxuICAgICAqIEByZXR1cm5zIG9wdGlvbnMgZm9yIG1pZGRsZXdhcmUgZXhlY3V0aW9uXG4gICAgICovXG4gICAgZ2V0T3B0aW9ucyhjb250ZXh0KSB7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoY29udGV4dC5taWRkbGV3YXJlQ29udHJvbCBpbnN0YW5jZW9mIE1pZGRsZXdhcmVDb250cm9sKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gY29udGV4dC5taWRkbGV3YXJlQ29udHJvbC5nZXRNaWRkbGV3YXJlT3B0aW9ucyhDaGFvc0hhbmRsZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG5ldyBDaGFvc0hhbmRsZXJPcHRpb25zKCksIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGV4ZWN1dGUgdGhlIGN1cnJlbnQgbWlkZGxld2FyZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvYmplY3Qgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBub3RoaW5nXG4gICAgICovXG4gICAgZXhlY3V0ZShjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFvc0hhbmRsZXJPcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuc2VuZFJlcXVlc3QoY2hhb3NIYW5kbGVyT3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVG8gc2V0IHRoZSBuZXh0IG1pZGRsZXdhcmUgaW4gdGhlIGNoYWluXG4gICAgICogQHBhcmFtIHtNaWRkbGV3YXJlfSBuZXh0IC0gVGhlIG1pZGRsZXdhcmUgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBOb3RoaW5nXG4gICAgICovXG4gICAgc2V0TmV4dChuZXh0KSB7XG4gICAgICAgIHRoaXMubmV4dE1pZGRsZXdhcmUgPSBuZXh0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW9zSGFuZGxlci5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogQGVudW1cbiAqIEVudW0gZm9yIFJlc3BvbnNlVHlwZSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBBUlJBWUJVRkZFUiAtIFRvIGRvd25sb2FkIHJlc3BvbnNlIGNvbnRlbnQgYXMgYW4gW0FycmF5QnVmZmVyXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheUJ1ZmZlcn1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBCTE9CIC0gVG8gZG93bmxvYWQgY29udGVudCBhcyBhIFtiaW5hcnkvYmxvYl0ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9ifVxuICogQHByb3BlcnR5IHtzdHJpbmd9IERPQ1VNRU5UIC0gVGhpcyBkb3dubG9hZHMgY29udGVudCBhcyBhIGRvY3VtZW50IG9yIHN0cmVhbVxuICogQHByb3BlcnR5IHtzdHJpbmd9IEpTT04gLSBUbyBkb3dubG9hZCByZXNwb25zZSBjb250ZW50IGFzIGEganNvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFNUUkVBTSAtIFRvIGRvd25sb2FkIHJlc3BvbnNlIGFzIGEgW3N0cmVhbV17QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBURVhUIC0gRm9yIGRvd25sb2FkaW5nIHJlc3BvbnNlIGFzIGEgdGV4dFxuICovXG5leHBvcnQgdmFyIFJlc3BvbnNlVHlwZTtcbihmdW5jdGlvbiAoUmVzcG9uc2VUeXBlKSB7XG4gICAgUmVzcG9uc2VUeXBlW1wiQVJSQVlCVUZGRVJcIl0gPSBcImFycmF5YnVmZmVyXCI7XG4gICAgUmVzcG9uc2VUeXBlW1wiQkxPQlwiXSA9IFwiYmxvYlwiO1xuICAgIFJlc3BvbnNlVHlwZVtcIkRPQ1VNRU5UXCJdID0gXCJkb2N1bWVudFwiO1xuICAgIFJlc3BvbnNlVHlwZVtcIkpTT05cIl0gPSBcImpzb25cIjtcbiAgICBSZXNwb25zZVR5cGVbXCJSQVdcIl0gPSBcInJhd1wiO1xuICAgIFJlc3BvbnNlVHlwZVtcIlNUUkVBTVwiXSA9IFwic3RyZWFtXCI7XG4gICAgUmVzcG9uc2VUeXBlW1wiVEVYVFwiXSA9IFwidGV4dFwiO1xufSkoUmVzcG9uc2VUeXBlIHx8IChSZXNwb25zZVR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzcG9uc2VUeXBlLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBSZXNwb25zZVR5cGUgfSBmcm9tIFwiLi9SZXNwb25zZVR5cGVcIjtcbi8qKlxuICogQGVudW1cbiAqIEVudW0gZm9yIGRvY3VtZW50IHR5cGVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gVEVYVF9IVE1MIC0gVGhlIHRleHQvaHRtbCBjb250ZW50IHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBURVhUX1hNTCAtIFRoZSB0ZXh0L3htbCBjb250ZW50IHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBBUFBMSUNBVElPTl9YTUwgLSBUaGUgYXBwbGljYXRpb24veG1sIGNvbnRlbnQgdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IEFQUExJQ0FUSU9OX1hIVE1MIC0gVGhlIGFwcGxpY2F0aW9uL3hobWwreG1sIGNvbnRlbnQgdHlwZVxuICovXG5leHBvcnQgdmFyIERvY3VtZW50VHlwZTtcbihmdW5jdGlvbiAoRG9jdW1lbnRUeXBlKSB7XG4gICAgRG9jdW1lbnRUeXBlW1wiVEVYVF9IVE1MXCJdID0gXCJ0ZXh0L2h0bWxcIjtcbiAgICBEb2N1bWVudFR5cGVbXCJURVhUX1hNTFwiXSA9IFwidGV4dC94bWxcIjtcbiAgICBEb2N1bWVudFR5cGVbXCJBUFBMSUNBVElPTl9YTUxcIl0gPSBcImFwcGxpY2F0aW9uL3htbFwiO1xuICAgIERvY3VtZW50VHlwZVtcIkFQUExJQ0FUSU9OX1hIVE1MXCJdID0gXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIjtcbn0pKERvY3VtZW50VHlwZSB8fCAoRG9jdW1lbnRUeXBlID0ge30pKTtcbi8qKlxuICogQGVudW1cbiAqIEVudW0gZm9yIENvbnRlbnQgdHlwZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBURVhUX1BMQUlOIC0gVGhlIHRleHQvcGxhaW4gY29udGVudCB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gQVBQTElDQVRJT05fSlNPTiAtIFRoZSBhcHBsaWNhdGlvbi9qc29uIGNvbnRlbnQgdHlwZVxuICovXG52YXIgQ29udGVudFR5cGU7XG4oZnVuY3Rpb24gKENvbnRlbnRUeXBlKSB7XG4gICAgQ29udGVudFR5cGVbXCJURVhUX1BMQUlOXCJdID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgQ29udGVudFR5cGVbXCJBUFBMSUNBVElPTl9KU09OXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG59KShDb250ZW50VHlwZSB8fCAoQ29udGVudFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAZW51bVxuICogRW51bSBmb3IgQ29udGVudCB0eXBlIHJlZ2V4XG4gKiBAcHJvcGVydHkge3N0cmluZ30gRE9DVU1FTlQgLSBUaGUgcmVnZXggdG8gbWF0Y2ggZG9jdW1lbnQgY29udGVudCB0eXBlc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IElNQUdFIC0gVGhlIHJlZ2V4IHRvIG1hdGNoIGltYWdlIGNvbnRlbnQgdHlwZXNcbiAqL1xudmFyIENvbnRlbnRUeXBlUmVnZXhTdHI7XG4oZnVuY3Rpb24gKENvbnRlbnRUeXBlUmVnZXhTdHIpIHtcbiAgICBDb250ZW50VHlwZVJlZ2V4U3RyW1wiRE9DVU1FTlRcIl0gPSBcIl4odGV4dFxcXFwvKGh0bWx8eG1sKSl8KGFwcGxpY2F0aW9uXFxcXC8oeG1sfHhodG1sXFxcXCt4bWwpKSRcIjtcbiAgICBDb250ZW50VHlwZVJlZ2V4U3RyW1wiSU1BR0VcIl0gPSBcIl5pbWFnZVxcXFwvLitcIjtcbn0pKENvbnRlbnRUeXBlUmVnZXhTdHIgfHwgKENvbnRlbnRUeXBlUmVnZXhTdHIgPSB7fSkpO1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIGZvciBHcmFwaFJlc3BvbnNlSGFuZGxlclxuICovXG5leHBvcnQgY2xhc3MgR3JhcGhSZXNwb25zZUhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIFRvIHBhcnNlIERvY3VtZW50IHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmF3UmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtEb2N1bWVudFR5cGV9IHR5cGUgLSBUaGUgdHlwZSB0byB3aGljaCB0aGUgZG9jdW1lbnQgbmVlZHMgdG8gYmUgcGFyc2VkXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBkb2N1bWVudCBjb250ZW50XG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRG9jdW1lbnRSZXNwb25zZShyYXdSZXNwb25zZSwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIERPTVBhcnNlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByYXdSZXNwb25zZS50ZXh0KCkudGhlbigoeG1sU3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbFN0cmluZywgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHhtbERvYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmF3UmVzcG9uc2UuYm9keSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGFzeW5jXG4gICAgICogVG8gY29udmVydCB0aGUgbmF0aXZlIFJlc3BvbnNlIHRvIHJlc3BvbnNlIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByYXdSZXNwb25zZSAtIFRoZSByZXNwb25zZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1Jlc3BvbnNlVHlwZX0gW3Jlc3BvbnNlVHlwZV0gLSBUaGUgcmVzcG9uc2UgdHlwZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb252ZXJ0ZWQgcmVzcG9uc2UgY29udGVudFxuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0UmVzcG9uc2UocmF3UmVzcG9uc2UsIHJlc3BvbnNlVHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJhd1Jlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgLy8gTk8gQ09OVEVOVFxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZVZhbHVlO1xuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByYXdSZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZVR5cGUuQVJSQVlCVUZGRVI6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVmFsdWUgPSB5aWVsZCByYXdSZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlc3BvbnNlVHlwZS5CTE9COlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVZhbHVlID0geWllbGQgcmF3UmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlc3BvbnNlVHlwZS5ET0NVTUVOVDpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VWYWx1ZSA9IHlpZWxkIEdyYXBoUmVzcG9uc2VIYW5kbGVyLnBhcnNlRG9jdW1lbnRSZXNwb25zZShyYXdSZXNwb25zZSwgRG9jdW1lbnRUeXBlLlRFWFRfWE1MKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZVR5cGUuSlNPTjpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VWYWx1ZSA9IHlpZWxkIHJhd1Jlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZVR5cGUuU1RSRUFNOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVZhbHVlID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKHJhd1Jlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlc3BvbnNlVHlwZS5URVhUOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVZhbHVlID0geWllbGQgcmF3UmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gY29udGVudFR5cGUuc3BsaXQoXCI7XCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoQ29udGVudFR5cGVSZWdleFN0ci5ET0NVTUVOVCkudGVzdChtaW1lVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVZhbHVlID0geWllbGQgR3JhcGhSZXNwb25zZUhhbmRsZXIucGFyc2VEb2N1bWVudFJlc3BvbnNlKHJhd1Jlc3BvbnNlLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXcgUmVnRXhwKENvbnRlbnRUeXBlUmVnZXhTdHIuSU1BR0UpLnRlc3QobWltZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VWYWx1ZSA9IHJhd1Jlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1pbWVUeXBlID09PSBDb250ZW50VHlwZS5URVhUX1BMQUlOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VWYWx1ZSA9IHlpZWxkIHJhd1Jlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1pbWVUeXBlID09PSBDb250ZW50VHlwZS5BUFBMSUNBVElPTl9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VWYWx1ZSA9IHlpZWxkIHJhd1Jlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVmFsdWUgPSBQcm9taXNlLnJlc29sdmUocmF3UmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFJGQyBzcGVjaWZpY2F0aW9uIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTMuMS4xLjV9IHNheXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgQSBzZW5kZXIgdGhhdCBnZW5lcmF0ZXMgYSBtZXNzYWdlIGNvbnRhaW5pbmcgYSBwYXlsb2FkIGJvZHkgU0hPVUxEXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgZ2VuZXJhdGUgYSBDb250ZW50LVR5cGUgaGVhZGVyIGZpZWxkIGluIHRoYXQgbWVzc2FnZSB1bmxlc3MgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgaW50ZW5kZWQgbWVkaWEgdHlwZSBvZiB0aGUgZW5jbG9zZWQgcmVwcmVzZW50YXRpb24gaXMgdW5rbm93biB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICBzZW5kZXIuICBJZiBhIENvbnRlbnQtVHlwZSBoZWFkZXIgZmllbGQgaXMgbm90IHByZXNlbnQsIHRoZSByZWNpcGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICBNQVkgZWl0aGVyIGFzc3VtZSBhIG1lZGlhIHR5cGUgb2YgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICogIChbUkZDMjA0Nl0sIFNlY3Rpb24gNC41LjEpIG9yIGV4YW1pbmUgdGhlIGRhdGEgdG8gZGV0ZXJtaW5lIGl0cyB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICBTbyBhc3N1bWluZyBpdCBhcyBhIHN0cmVhbSB0eXBlIHNvIHJldHVybmluZyB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VWYWx1ZSA9IFByb21pc2UucmVzb2x2ZShyYXdSZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBUbyBnZXQgdGhlIHBhcnNlZCByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJhd1Jlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2VUeXBlfSBbcmVzcG9uc2VUeXBlXSAtIFRoZSByZXNwb25zZSB0eXBlIHZhbHVlXG4gICAgICogQHBhcmFtIHtHcmFwaFJlcXVlc3RDYWxsYmFja30gW2NhbGxiYWNrXSAtIFRoZSBncmFwaCByZXF1ZXN0IGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgVGhlIHBhcnNlZCByZXNwb25zZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXNwb25zZShyYXdSZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gUmVzcG9uc2VUeXBlLlJBVykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmF3UmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBHcmFwaFJlc3BvbnNlSGFuZGxlci5jb252ZXJ0UmVzcG9uc2UocmF3UmVzcG9uc2UsIHJlc3BvbnNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXR1cyBDb2RlIDJYWFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9UIE9LIFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhSZXNwb25zZUhhbmRsZXIuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBtb2R1bGUgUmFuZ2VcbiAqL1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIHJlcHJlc2VudGluZyBSYW5nZVxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgZm9yIGdpdmVuIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluVmFsID0gLTFdIC0gVGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhWYWwgPSAtMV0gLSBUaGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBhIFJhbmdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWluVmFsID0gLTEsIG1heFZhbCA9IC0xKSB7XG4gICAgICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWw7XG4gICAgICAgIHRoaXMubWF4VmFsdWUgPSBtYXhWYWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmFuZ2UuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHN1Y2Nlc3NmdWwgZmlsZSB1cGxvYWQgcmVzdWx0XG4gKi9cbmV4cG9ydCBjbGFzcyBVcGxvYWRSZXN1bHQge1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBHZXQgb2YgdGhlIGxvY2F0aW9uIHZhbHVlLlxuICAgICAqIExvY2F0aW9uIHZhbHVlIGlzIGxvb2tlZCB1cCBpbiB0aGUgcmVzcG9uc2UgaGVhZGVyXG4gICAgICovXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBTZXQgdGhlIGxvY2F0aW9uIHZhbHVlXG4gICAgICogTG9jYXRpb24gdmFsdWUgaXMgbG9va2VkIHVwIGluIHRoZSByZXNwb25zZSBoZWFkZXJcbiAgICAgKi9cbiAgICBzZXQgbG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEdldCBUaGUgcmVzcG9uc2UgYm9keSBmcm9tIHRoZSBjb21wbGV0ZWQgdXBsb2FkIHJlc3BvbnNlXG4gICAgICovXG4gICAgZ2V0IHJlc3BvbnNlQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlQm9keTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFNldCB0aGUgcmVzcG9uc2UgYm9keSBmcm9tIHRoZSBjb21wbGV0ZWQgdXBsb2FkIHJlc3BvbnNlXG4gICAgICovXG4gICAgc2V0IHJlc3BvbnNlQm9keShyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtyZXNwb25zZUJvZHl9IHJlc3BvbnNlYm9keSAtIFRoZSByZXNwb25zZSBib2R5IGZyb20gdGhlIGNvbXBsZXRlZCB1cGxvYWQgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge2xvY2F0aW9ufSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB2YWx1ZSBmcm9tIHRoZSBoZWFkZXJzIGZyb20gdGhlIGNvbXBsZXRlZCB1cGxvYWQgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZUJvZHksIGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlc3BvbnNlIGJvZHkgb3IgdGhlIGxvY2F0aW9uIHBhcmFtZXRlciBjYW4gYmUgdW5kZWZpbmVkLlxuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3Jlc3BvbnNlQm9keX0gcmVzcG9uc2VCb2R5IC0gVGhlIHJlc3BvbnNlIGJvZHkgZnJvbSB0aGUgY29tcGxldGVkIHVwbG9hZCByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7cmVzcG9uc2VIZWFkZXJzfSByZXNwb25zZUhlYWRlcnMgLSBUaGUgaGVhZGVycyBmcm9tIHRoZSBjb21wbGV0ZWQgdXBsb2FkIHJlc3BvbnNlXG4gICAgICovXG4gICAgc3RhdGljIENyZWF0ZVVwbG9hZFJlc3VsdChyZXNwb25zZUJvZHksIHJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFJlc3VsdChyZXNwb25zZUJvZHksIHJlc3BvbnNlSGVhZGVycy5nZXQoXCJsb2NhdGlvblwiKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXBsb2FkUmVzdWx0LmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBtb2R1bGUgTGFyZ2VGaWxlVXBsb2FkVGFza1xuICovXG5pbXBvcnQgeyBHcmFwaENsaWVudEVycm9yIH0gZnJvbSBcIi4uL0dyYXBoQ2xpZW50RXJyb3JcIjtcbmltcG9ydCB7IEdyYXBoUmVzcG9uc2VIYW5kbGVyIH0gZnJvbSBcIi4uL0dyYXBoUmVzcG9uc2VIYW5kbGVyXCI7XG5pbXBvcnQgeyBSZXNwb25zZVR5cGUgfSBmcm9tIFwiLi4vUmVzcG9uc2VUeXBlXCI7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gXCIuL0ZpbGVVcGxvYWRUYXNrL1JhbmdlXCI7XG5pbXBvcnQgeyBVcGxvYWRSZXN1bHQgfSBmcm9tIFwiLi9GaWxlVXBsb2FkVGFzay9VcGxvYWRSZXN1bHRcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgTGFyZ2VGaWxlVXBsb2FkVGFza1xuICovXG5leHBvcnQgY2xhc3MgTGFyZ2VGaWxlVXBsb2FkVGFzayB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBNYWtlcyByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gY3JlYXRlIGFuIHVwbG9hZCBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCAtIFRoZSBHcmFwaENsaWVudCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VXJsIC0gVGhlIFVSTCB0byBjcmVhdGUgdGhlIHVwbG9hZCBzZXNzaW9uXG4gICAgICogQHBhcmFtIHthbnl9IHBheWxvYWQgLSBUaGUgcGF5bG9hZCB0aGF0IG5lZWRzIHRvIGJlIHNlbnRcbiAgICAgKiBAcGFyYW0ge0tleVZhbHVlUGFpck9iamVjdFN0cmluZ051bWJlcn0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIHRoYXQgbmVlZHMgdG8gYmUgc2VudFxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gTGFyZ2VGaWxlVXBsb2FkU2Vzc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVVcGxvYWRTZXNzaW9uKGNsaWVudCwgcmVxdWVzdFVybCwgcGF5bG9hZCwgaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0geWllbGQgY2xpZW50XG4gICAgICAgICAgICAgICAgLmFwaShyZXF1ZXN0VXJsKVxuICAgICAgICAgICAgICAgIC5oZWFkZXJzKGhlYWRlcnMpXG4gICAgICAgICAgICAgICAgLnBvc3QocGF5bG9hZCk7XG4gICAgICAgICAgICBjb25zdCBsYXJnZUZpbGVVcGxvYWRTZXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHVybDogc2Vzc2lvbi51cGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgZXhwaXJ5OiBuZXcgRGF0ZShzZXNzaW9uLmV4cGlyYXRpb25EYXRlVGltZSksXG4gICAgICAgICAgICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBsYXJnZUZpbGVVcGxvYWRTZXNzaW9uO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENvbnN0cnVjdHMgYSBMYXJnZUZpbGVVcGxvYWRUYXNrXG4gICAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCAtIFRoZSBHcmFwaENsaWVudCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RmlsZU9iamVjdH0gZmlsZSAtIFRoZSBGaWxlT2JqZWN0IGhvbGRpbmcgZGV0YWlscyBvZiBhIGZpbGUgdGhhdCBuZWVkcyB0byBiZSB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSB7TGFyZ2VGaWxlVXBsb2FkU2Vzc2lvbn0gdXBsb2FkU2Vzc2lvbiAtIFRoZSB1cGxvYWQgc2Vzc2lvbiB0byB3aGljaCB0aGUgdXBsb2FkIGhhcyB0byBiZSBkb25lXG4gICAgICogQHBhcmFtIHtMYXJnZUZpbGVVcGxvYWRUYXNrT3B0aW9uc30gb3B0aW9ucyAtIFRoZSB1cGxvYWQgdGFzayBvcHRpb25zXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgTGFyZ2VGaWxlVXBsb2FkVGFza1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgZmlsZSwgdXBsb2FkU2Vzc2lvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBEZWZhdWx0IHZhbHVlIGZvciB0aGUgcmFuZ2VTaXplXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLkRFRkFVTFRfRklMRV9TSVpFID0gNSAqIDEwMjQgKiAxMDI0O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgaWYgKCFmaWxlLnNsaWNlRmlsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoQ2xpZW50RXJyb3IoXCJQbGVhc2UgcGFzcyB0aGUgRmlsZVVwbG9hZCBvYmplY3QsIFN0cmVhbVVwbG9hZCBvYmplY3Qgb3IgYW55IGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRmlsZU9iamVjdCBpbnRlcmZhY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIGlmICghb3B0aW9ucy5yYW5nZVNpemUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmFuZ2VTaXplID0gdGhpcy5ERUZBVUxUX0ZJTEVfU0laRTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVwbG9hZFNlc3Npb24gPSB1cGxvYWRTZXNzaW9uO1xuICAgICAgICB0aGlzLm5leHRSYW5nZSA9IG5ldyBSYW5nZSgwLCB0aGlzLm9wdGlvbnMucmFuZ2VTaXplIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUGFyc2VzIGdpdmVuIHJhbmdlIHN0cmluZyB0byB0aGUgUmFuZ2UgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByYW5nZXMgLSBUaGUgcmFuZ2VzIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIHJhbmdlIGluc3RhbmNlXG4gICAgICovXG4gICAgcGFyc2VSYW5nZShyYW5nZXMpIHtcbiAgICAgICAgY29uc3QgcmFuZ2VTdHIgPSByYW5nZXNbMF07XG4gICAgICAgIGlmICh0eXBlb2YgcmFuZ2VTdHIgPT09IFwidW5kZWZpbmVkXCIgfHwgcmFuZ2VTdHIgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFJhbmdlID0gcmFuZ2VTdHIuc3BsaXQoXCItXCIpO1xuICAgICAgICBjb25zdCBtaW5WYWwgPSBwYXJzZUludChmaXJzdFJhbmdlWzBdLCAxMCk7XG4gICAgICAgIGxldCBtYXhWYWwgPSBwYXJzZUludChmaXJzdFJhbmdlWzFdLCAxMCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obWF4VmFsKSkge1xuICAgICAgICAgICAgbWF4VmFsID0gdGhpcy5maWxlLnNpemUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UobWluVmFsLCBtYXhWYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFVwZGF0ZXMgdGhlIGV4cGlyYXRpb24gZGF0ZSBhbmQgdGhlIG5leHQgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge1VwbG9hZFN0YXR1c1Jlc3BvbnNlfSByZXNwb25zZSAtIFRoZSByZXNwb25zZSBvZiB0aGUgdXBsb2FkIHN0YXR1c1xuICAgICAqIEByZXR1cm5zIE5vdGhpbmdcbiAgICAgKi9cbiAgICB1cGRhdGVUYXNrU3RhdHVzKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMudXBsb2FkU2Vzc2lvbi5leHBpcnkgPSBuZXcgRGF0ZShyZXNwb25zZS5leHBpcmF0aW9uRGF0ZVRpbWUpO1xuICAgICAgICB0aGlzLm5leHRSYW5nZSA9IHRoaXMucGFyc2VSYW5nZShyZXNwb25zZS5uZXh0RXhwZWN0ZWRSYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogR2V0cyBuZXh0IHJhbmdlIHRoYXQgbmVlZHMgdG8gYmUgdXBsb2FkZWRcbiAgICAgKiBAcmV0dXJucyBUaGUgcmFuZ2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXROZXh0UmFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHRSYW5nZS5taW5WYWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5WYWwgPSB0aGlzLm5leHRSYW5nZS5taW5WYWx1ZTtcbiAgICAgICAgbGV0IG1heFZhbHVlID0gbWluVmFsICsgdGhpcy5vcHRpb25zLnJhbmdlU2l6ZSAtIDE7XG4gICAgICAgIGlmIChtYXhWYWx1ZSA+PSB0aGlzLmZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgbWF4VmFsdWUgPSB0aGlzLmZpbGUuc2l6ZSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShtaW5WYWwsIG1heFZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBtb3ZlZCBpbnRvIEZpbGVPYmplY3QgaW50ZXJmYWNlLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBTbGljZXMgdGhlIGZpbGUgY29udGVudCB0byB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtIFRoZSByYW5nZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzbGljZWQgQXJyYXlCdWZmZXIgb3IgQmxvYlxuICAgICAqL1xuICAgIHNsaWNlRmlsZShyYW5nZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgTGFyZ2VGaWxlVXBsb2FkVGFzay5zbGljZUZpbGUoKSBmdW5jdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCBtb3ZlZCBpbnRvIHRoZSBGaWxlT2JqZWN0IGludGVyZmFjZS5cIik7XG4gICAgICAgIGlmICh0aGlzLmZpbGUuY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IHRoaXMuZmlsZS5jb250ZW50IGluc3RhbmNlb2YgQmxvYiB8fCB0aGlzLmZpbGUuY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUuY29udGVudC5zbGljZShyYW5nZS5taW5WYWx1ZSwgcmFuZ2UubWF4VmFsdWUgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgR3JhcGhDbGllbnRFcnJvcihcIlRoZSBMYXJnZUZpbGVVcGxvYWRUYXNrLnNsaWNlRmlsZSgpIGZ1bmN0aW9uIGV4cGVjdHMgb25seSBCbG9iLCBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IGZpbGUgY29udGVudC4gUGxlYXNlIG5vdGUgdGhhdCB0aGUgc2xpY2VGaWxlKCkgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBVcGxvYWRzIGZpbGUgdG8gdGhlIHNlcnZlciBpbiBhIHNlcXVlbnRpYWwgb3JkZXIgYnkgc2xpY2luZyB0aGUgZmlsZVxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIHJlc29sdmVzIHRvIHVwbG9hZGVkIHJlc3BvbnNlXG4gICAgICovXG4gICAgdXBsb2FkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkRXZlbnRIYW5kbGVycyA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudXBsb2FkRXZlbnRIYW5kbGVycztcbiAgICAgICAgICAgIHdoaWxlICghdGhpcy51cGxvYWRTZXNzaW9uLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFJhbmdlID0gdGhpcy5nZXROZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFJhbmdlLm1heFZhbHVlID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJUYXNrIHdpdGggd2hpY2ggeW91IGFyZSB0cnlpbmcgdG8gdXBsb2FkIGlzIGFscmVhZHkgY29tcGxldGVkLCBQbGVhc2UgY2hlY2sgZm9yIHlvdXIgdXBsb2FkZWQgZmlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBcIkludmFsaWQgU2Vzc2lvblwiO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVTbGljZSA9IHlpZWxkIHRoaXMuZmlsZS5zbGljZUZpbGUobmV4dFJhbmdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdSZXNwb25zZSA9IHlpZWxkIHRoaXMudXBsb2FkU2xpY2VHZXRSYXdSZXNwb25zZShmaWxlU2xpY2UsIG5leHRSYW5nZSwgdGhpcy5maWxlLnNpemUpO1xuICAgICAgICAgICAgICAgIGlmICghcmF3UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoQ2xpZW50RXJyb3IoXCJTb21ldGhpbmcgd2VudCB3cm9uZyEgTGFyZ2UgZmlsZSB1cGxvYWQgc2xpY2UgcmVzcG9uc2UgaXMgbnVsbC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IHlpZWxkIEdyYXBoUmVzcG9uc2VIYW5kbGVyLmdldFJlc3BvbnNlKHJhd1Jlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAocmF3UmVzcG9uc2Uuc3RhdHVzID09PSAyMDEpIC0+IFRoaXMgY29uZGl0aW9uIGlzIGFwcGxpY2FibGUgZm9yIE9uZURyaXZlLCBQcmludERvY3VtZW50IGFuZCBPdXRsb29rIEFQSXMuXG4gICAgICAgICAgICAgICAgICogKHJhd1Jlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlQm9keS5pZCkgLT4gVGhpcyBhZGRpdGlvbmFsIGNvbmRpdGlvbiBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIE9uZURyaXZlIEFQSS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAocmF3UmVzcG9uc2Uuc3RhdHVzID09PSAyMDEgfHwgKHJhd1Jlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlQm9keS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRQcm9ncmVzcyh1cGxvYWRFdmVudEhhbmRsZXJzLCBuZXh0UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXBsb2FkUmVzdWx0LkNyZWF0ZVVwbG9hZFJlc3VsdChyZXNwb25zZUJvZHksIHJhd1Jlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBIYW5kbGluZyB0aGUgQVBJIGlzc3VlIHdoZXJlIHRoZSBjYXNlIG9mIE91dGxvb2sgdXBsb2FkIHJlc3BvbnNlIHByb3BlcnR5IC0nbmV4dEV4cGVjdGVkUmFuZ2VzJyAgaXMgbm90IHVuaWZvcm0uXG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdGdyYXBoL21zZ3JhcGgtc2RrLXNlcnZpY2Vpc3N1ZXMvaXNzdWVzLzM5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgICAgICAgICBleHBpcmF0aW9uRGF0ZVRpbWU6IHJlc3BvbnNlQm9keS5leHBpcmF0aW9uRGF0ZVRpbWUgfHwgcmVzcG9uc2VCb2R5LkV4cGlyYXRpb25EYXRlVGltZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dEV4cGVjdGVkUmFuZ2VzOiByZXNwb25zZUJvZHkuTmV4dEV4cGVjdGVkUmFuZ2VzIHx8IHJlc3BvbnNlQm9keS5uZXh0RXhwZWN0ZWRSYW5nZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRhc2tTdGF0dXMocmVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFByb2dyZXNzKHVwbG9hZEV2ZW50SGFuZGxlcnMsIG5leHRSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXBvcnRQcm9ncmVzcyh1cGxvYWRFdmVudEhhbmRsZXJzLCBuZXh0UmFuZ2UpIHtcbiAgICAgICAgaWYgKHVwbG9hZEV2ZW50SGFuZGxlcnMgJiYgdXBsb2FkRXZlbnRIYW5kbGVycy5wcm9ncmVzcykge1xuICAgICAgICAgICAgdXBsb2FkRXZlbnRIYW5kbGVycy5wcm9ncmVzcyhuZXh0UmFuZ2UsIHVwbG9hZEV2ZW50SGFuZGxlcnMuZXh0cmFDYWxsYmFja1BhcmFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogVXBsb2FkcyBnaXZlbiBzbGljZSB0byB0aGUgc2VydmVyXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlciB8IEJsb2IgfCBGaWxlfSBmaWxlU2xpY2UgLSBUaGUgZmlsZSBzbGljZVxuICAgICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gVGhlIHJhbmdlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsU2l6ZSAtIFRoZSB0b3RhbCBzaXplIG9mIGEgY29tcGxldGUgZmlsZVxuICAgICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBib2R5IG9mIHRoZSB1cGxvYWQgc2xpY2UgcmVzdWx0XG4gICAgICovXG4gICAgdXBsb2FkU2xpY2UoZmlsZVNsaWNlLCByYW5nZSwgdG90YWxTaXplKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jbGllbnRcbiAgICAgICAgICAgICAgICAuYXBpKHRoaXMudXBsb2FkU2Vzc2lvbi51cmwpXG4gICAgICAgICAgICAgICAgLmhlYWRlcnMoe1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogYCR7cmFuZ2UubWF4VmFsdWUgLSByYW5nZS5taW5WYWx1ZSArIDF9YCxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtUmFuZ2VcIjogYGJ5dGVzICR7cmFuZ2UubWluVmFsdWV9LSR7cmFuZ2UubWF4VmFsdWV9LyR7dG90YWxTaXplfWAsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnB1dChmaWxlU2xpY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFVwbG9hZHMgZ2l2ZW4gc2xpY2UgdG8gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSB7dW5rbm93bn0gZmlsZVNsaWNlIC0gVGhlIGZpbGUgc2xpY2VcbiAgICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtIFRoZSByYW5nZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbFNpemUgLSBUaGUgdG90YWwgc2l6ZSBvZiBhIGNvbXBsZXRlIGZpbGVcbiAgICAgKiBAcmV0dXJucyBUaGUgcmF3IHJlc3BvbnNlIG9mIHRoZSB1cGxvYWQgc2xpY2UgcmVzdWx0XG4gICAgICovXG4gICAgdXBsb2FkU2xpY2VHZXRSYXdSZXNwb25zZShmaWxlU2xpY2UsIHJhbmdlLCB0b3RhbFNpemUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudFxuICAgICAgICAgICAgICAgIC5hcGkodGhpcy51cGxvYWRTZXNzaW9uLnVybClcbiAgICAgICAgICAgICAgICAuaGVhZGVycyh7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBgJHtyYW5nZS5tYXhWYWx1ZSAtIHJhbmdlLm1pblZhbHVlICsgMX1gLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1SYW5nZVwiOiBgYnl0ZXMgJHtyYW5nZS5taW5WYWx1ZX0tJHtyYW5nZS5tYXhWYWx1ZX0vJHt0b3RhbFNpemV9YCxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVzcG9uc2VUeXBlKFJlc3BvbnNlVHlwZS5SQVcpXG4gICAgICAgICAgICAgICAgLnB1dChmaWxlU2xpY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIERlbGV0ZXMgdXBsb2FkIHNlc3Npb24gaW4gdGhlIHNlcnZlclxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIHJlc29sdmVzIHRvIGNhbmNlbGxlZCByZXNwb25zZVxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3BvbnNlID0geWllbGQgdGhpcy5jbGllbnRcbiAgICAgICAgICAgICAgICAuYXBpKHRoaXMudXBsb2FkU2Vzc2lvbi51cmwpXG4gICAgICAgICAgICAgICAgLnJlc3BvbnNlVHlwZShSZXNwb25zZVR5cGUuUkFXKVxuICAgICAgICAgICAgICAgIC5kZWxldGUoKTtcbiAgICAgICAgICAgIGlmIChjYW5jZWxSZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkU2Vzc2lvbi5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogR2V0cyBzdGF0dXMgZm9yIHRoZSB1cGxvYWQgc2Vzc2lvblxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIHJlc29sdmVzIHRvIHRoZSBzdGF0dXMgZW5xdWlyeSByZXNwb25zZVxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jbGllbnQuYXBpKHRoaXMudXBsb2FkU2Vzc2lvbi51cmwpLmdldCgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUYXNrU3RhdHVzKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBSZXN1bWVzIHVwbG9hZCBzZXNzaW9uIGFuZCBjb250aW51ZSB1cGxvYWRpbmcgdGhlIGZpbGUgZnJvbSB0aGUgbGFzdCBzZW50IHJhbmdlXG4gICAgICogQHJldHVybnMgVGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gdGhlIHVwbG9hZGVkIHJlc3BvbnNlXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXRTdGF0dXMoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnVwbG9hZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIEdldCB0aGUgdXBsb2FkIHNlc3Npb24gaW5mb3JtYXRpb25cbiAgICAgKiBAcmV0dXJucyBUaGUgbGFyZ2UgZmlsZSB1cGxvYWQgc2Vzc2lvblxuICAgICAqL1xuICAgIGdldFVwbG9hZFNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZFNlc3Npb247XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGFyZ2VGaWxlVXBsb2FkVGFzay5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmltcG9ydCB7IEdyYXBoQ2xpZW50RXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vR3JhcGhDbGllbnRFcnJvclwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIHVzZWQgZm9yIGNyZWF0aW5nIExhcmdlRmlsZVVwbG9hZFRhc2sgZmlsZW9iamVjdC5cbiAqIFRoaXMgY2xhc3MgYWNjZXB0cyBmaWxlcyBvZiB0eXBlIEFycmF5QnVmZmVyLCBCbG9iLCBVaW50OEFycmF5LlxuICovXG5leHBvcnQgY2xhc3MgRmlsZVVwbG9hZCB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXIgfCBCbG9iIHwgVWludDhBcnJheX0gY29udGVudCAtIFRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWRcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUgRmlsZVVwbG9hZCBjbGFzc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQsIG5hbWUsIHNpemUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgaWYgKCFjb250ZW50IHx8ICFuYW1lIHx8ICFzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhDbGllbnRFcnJvcihcIlBsZWFzZSBwcm92aWRlIHRoZSB1cGxvYWQgY29udGVudCwgbmFtZSBvZiB0aGUgZmlsZSBhbmQgc2l6ZSBvZiB0aGUgZmlsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogU2xpY2VzIHRoZSBmaWxlIGNvbnRlbnQgdG8gdGhlIGdpdmVuIHJhbmdlXG4gICAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgLSBUaGUgcmFuZ2UgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgc2xpY2VkIGZpbGUgcGFydFxuICAgICAqL1xuICAgIHNsaWNlRmlsZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNsaWNlKHJhbmdlLm1pblZhbHVlLCByYW5nZS5tYXhWYWx1ZSArIDEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGVVcGxvYWQuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBtb2R1bGUgT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrVXRpbFxuICovXG4vKipcbiAqIEBjb25zdGFudFxuICogRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHJhbmdlU2l6ZVxuICogUmVjb21tZW5kZWQgc2l6ZSBpcyBiZXR3ZWVuIDUgLSAxMCBNQiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9ncmFwaC9kb2NzL2FwaS1yZWZlcmVuY2UvdjEuMC9hcGkvZHJpdmVpdGVtX2NyZWF0ZXVwbG9hZHNlc3Npb24jYmVzdC1wcmFjdGljZXN9XG4gKi9cbmNvbnN0IERFRkFVTFRfRklMRV9TSVpFID0gNSAqIDEwMjQgKiAxMDI0O1xuLyoqXG4gKiBAY29uc3RhbnRcbiAqIFJvdW5kcyBvZmYgdGhlIGdpdmVuIHZhbHVlIHRvIGEgbXVsdGlwbGUgb2YgMzIwIEtCXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWVcbiAqIEByZXR1cm5zIFRoZSByb3VuZGVkIG9mZiB2YWx1ZVxuICovXG5jb25zdCByb3VuZFRvMzIwS0IgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPiAzMjAgKiAxMDI0KSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvICgzMjAgKiAxMDI0KSkgKiAzMjAgKiAxMDI0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEdldCB0aGUgdmFsaWQgcmFuZ2VTaXplIGZvciBhIGZpbGUgc2xpY2luZyAodmFsaWRpdHkgaXMgYmFzZWQgb24gdGhlIGNvbnN0cmFpbnMgbWVudGlvbmVkIGluIGhlcmVcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL2dyYXBoL2RvY3MvYXBpLXJlZmVyZW5jZS92MS4wL2FwaS9kcml2ZWl0ZW1fY3JlYXRldXBsb2Fkc2Vzc2lvbiN1cGxvYWQtYnl0ZXMtdG8tdGhlLXVwbG9hZC1zZXNzaW9ufSlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhbmdlU2l6ZSA9IERFRkFVTFRfRklMRV9TSVpFXSAtIFRoZSByYW5nZVNpemUgdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgdmFsaWQgcmFuZ2VTaXplXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRWYWxpZFJhbmdlU2l6ZSA9IChyYW5nZVNpemUgPSBERUZBVUxUX0ZJTEVfU0laRSkgPT4ge1xuICAgIGNvbnN0IHNpeHR5TUIgPSA2MCAqIDEwMjQgKiAxMDI0O1xuICAgIGlmIChyYW5nZVNpemUgPiBzaXh0eU1CKSB7XG4gICAgICAgIHJhbmdlU2l6ZSA9IHNpeHR5TUI7XG4gICAgfVxuICAgIHJldHVybiByb3VuZFRvMzIwS0IocmFuZ2VTaXplKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2tVdGlsLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBtb2R1bGUgT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrXG4gKi9cbmltcG9ydCB7IEdyYXBoQ2xpZW50RXJyb3IgfSBmcm9tIFwiLi4vR3JhcGhDbGllbnRFcnJvclwiO1xuaW1wb3J0IHsgRmlsZVVwbG9hZCB9IGZyb20gXCIuL0ZpbGVVcGxvYWRUYXNrL0ZpbGVPYmplY3RDbGFzc2VzL0ZpbGVVcGxvYWRcIjtcbmltcG9ydCB7IExhcmdlRmlsZVVwbG9hZFRhc2sgfSBmcm9tIFwiLi9MYXJnZUZpbGVVcGxvYWRUYXNrXCI7XG5pbXBvcnQgeyBnZXRWYWxpZFJhbmdlU2l6ZSB9IGZyb20gXCIuL09uZURyaXZlTGFyZ2VGaWxlVXBsb2FkVGFza1V0aWxcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrXG4gKi9cbmV4cG9ydCBjbGFzcyBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2sgZXh0ZW5kcyBMYXJnZUZpbGVVcGxvYWRUYXNrIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBDb25zdHJ1Y3RzIHRoZSBjcmVhdGUgc2Vzc2lvbiB1cmwgZm9yIE9uZWRyaXZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAgICAgKiBAcGFyYW0ge3BhdGh9IFtwYXRoID0gT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrLkRFRkFVTFRfVVBMT0FEX1BBVEhdIC0gVGhlIHBhdGggZm9yIHRoZSB1cGxvYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RydWN0ZWQgY3JlYXRlIHNlc3Npb24gdXJsXG4gICAgICovXG4gICAgc3RhdGljIGNvbnN0cnVjdENyZWF0ZVNlc3Npb25VcmwoZmlsZU5hbWUsIHBhdGggPSBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2suREVGQVVMVF9VUExPQURfUEFUSCkge1xuICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnRyaW0oKTtcbiAgICAgICAgcGF0aCA9IHBhdGgudHJpbSgpO1xuICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcGF0aCA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoWzBdICE9PSBcIi9cIikge1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBgJHtwYXRofS9gO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGNob29zZSB0byBlbmNvZGUgZWFjaCBjb21wb25lbnQgb2YgdGhlIGZpbGUgcGF0aCBzZXBhcmF0ZWx5IGJlY2F1c2Ugd2hlbiBlbmNvZGluZyBmdWxsIFVSSVxuICAgICAgICAvLyB3aXRoIGVuY29kZVVSSSwgc3BlY2lhbCBjaGFyYWN0ZXJzIGxpa2UgIyBvciAlIGluIHRoZSBmaWxlIG5hbWUgZG9lc24ndCBnZXQgZW5jb2RlZCBhcyBkZXNpcmVkXG4gICAgICAgIHJldHVybiBgL21lL2RyaXZlL3Jvb3Q6JHtwYXRoXG4gICAgICAgICAgICAuc3BsaXQoXCIvXCIpXG4gICAgICAgICAgICAubWFwKChwKSA9PiBlbmNvZGVVUklDb21wb25lbnQocCkpXG4gICAgICAgICAgICAuam9pbihcIi9cIil9JHtlbmNvZGVVUklDb21wb25lbnQoZmlsZU5hbWUpfTovY3JlYXRlVXBsb2FkU2Vzc2lvbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEdldCBmaWxlIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtCbG9iIHwgVWludDhBcnJheSB8IEZpbGV9IGZpbGUgLSBUaGUgZmlsZSBlbnRpdHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWUgLSBUaGUgZmlsZSBuYW1lXG4gICAgICogQHJldHVybnMge0ZpbGVJbmZvfSBUaGUgZmlsZSBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRGaWxlSW5mbyhmaWxlLCBmaWxlTmFtZSkge1xuICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgbGV0IHNpemU7XG4gICAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgY29udGVudCA9IG5ldyBGaWxlKFtmaWxlXSwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgc2l6ZSA9IGNvbnRlbnQuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgRmlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgY29udGVudCA9IGZpbGU7XG4gICAgICAgICAgICBzaXplID0gY29udGVudC5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBiID0gZmlsZTtcbiAgICAgICAgICAgIHNpemUgPSBiLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50ID0gYi5idWZmZXIuc2xpY2UoYi5ieXRlT2Zmc2V0LCBiLmJ5dGVPZmZzZXQgKyBiLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBDcmVhdGVzIGEgT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrXG4gICAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCAtIFRoZSBHcmFwaENsaWVudCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QmxvYiB8IFVpbnQ4QXJyYXkgfCBGaWxlfSBmaWxlIC0gRmlsZSByZXByZXNlbnRlZCBhcyBCbG9iLCBVaW50OEFycmF5IG9yIEZpbGVcbiAgICAgKiBAcGFyYW0ge09uZURyaXZlTGFyZ2VGaWxlVXBsb2FkT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB1cGxvYWQgdGFza1xuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlcyB0byBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2sgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNsaWVudCwgZmlsZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFjbGllbnQgfHwgIWZpbGUgfHwgIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhDbGllbnRFcnJvcihcIlBsZWFzZSBwcm92aWRlIHRoZSBHcmFwaCBjbGllbnQgaW5zdGFuY2UsIGZpbGUgb2JqZWN0IGFuZCBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZE9wdGlvbnMgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IG9wdGlvbnMuZmlsZU5hbWU7XG4gICAgICAgICAgICBjb25zdCBmaWxlSW5mbyA9IE9uZURyaXZlTGFyZ2VGaWxlVXBsb2FkVGFzay5nZXRGaWxlSW5mbyhmaWxlLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlT2JqID0gbmV3IEZpbGVVcGxvYWQoZmlsZUluZm8uY29udGVudCwgZmlsZU5hbWUsIGZpbGVJbmZvLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGFza1dpdGhGaWxlT2JqZWN0KGNsaWVudCwgZmlsZU9iaiwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhc3luY1xuICAgICAqIENyZWF0ZXMgYSBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2tcbiAgICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50IC0gVGhlIEdyYXBoQ2xpZW50IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGaWxlT2JqZWN0fSBmaWxlT2JqZWN0IC0gRmlsZU9iamVjdCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T25lRHJpdmVMYXJnZUZpbGVVcGxvYWRPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHVwbG9hZCB0YXNrXG4gICAgICogQHJldHVybnMgVGhlIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVzIHRvIE9uZURyaXZlTGFyZ2VGaWxlVXBsb2FkVGFzayBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVUYXNrV2l0aEZpbGVPYmplY3QoY2xpZW50LCBmaWxlT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudCB8fCAhZmlsZU9iamVjdCB8fCAhb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaENsaWVudEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgdGhlIEdyYXBoIGNsaWVudCBpbnN0YW5jZSwgRmlsZU9iamVjdCBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb24gYW5kIE9uZURyaXZlTGFyZ2VGaWxlVXBsb2FkT3B0aW9ucyB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBvcHRpb25zLnVwbG9hZFNlc3Npb25VUkwgPyBvcHRpb25zLnVwbG9hZFNlc3Npb25VUkwgOiBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2suY29uc3RydWN0Q3JlYXRlU2Vzc2lvblVybChvcHRpb25zLmZpbGVOYW1lLCBvcHRpb25zLnBhdGgpO1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkU2Vzc2lvblBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IG9wdGlvbnMuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgZmlsZURlc2NyaXB0aW9uOiBvcHRpb25zLmZpbGVEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBjb25mbGljdEJlaGF2aW9yOiBvcHRpb25zLmNvbmZsaWN0QmVoYXZpb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHlpZWxkIE9uZURyaXZlTGFyZ2VGaWxlVXBsb2FkVGFzay5jcmVhdGVVcGxvYWRTZXNzaW9uKGNsaWVudCwgcmVxdWVzdFVybCwgdXBsb2FkU2Vzc2lvblBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2VTaXplID0gZ2V0VmFsaWRSYW5nZVNpemUob3B0aW9ucy5yYW5nZVNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2soY2xpZW50LCBmaWxlT2JqZWN0LCBzZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgcmFuZ2VTaXplLFxuICAgICAgICAgICAgICAgIHVwbG9hZEV2ZW50SGFuZGxlcnM6IG9wdGlvbnMudXBsb2FkRXZlbnRIYW5kbGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBNYWtlcyByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gY3JlYXRlIGFuIHVwbG9hZCBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudCAtIFRoZSBHcmFwaENsaWVudCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VXJsIC0gVGhlIFVSTCB0byBjcmVhdGUgdGhlIHVwbG9hZCBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBheWxvYWRPcHRpb25zIC0gVGhlIHBheWxvYWQgb3B0aW9uLiBEZWZhdWx0IGNvbmZsaWN0QmVoYXZpb3IgaXMgJ3JlbmFtZSdcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIExhcmdlRmlsZVVwbG9hZFNlc3Npb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVXBsb2FkU2Vzc2lvbihjbGllbnQsIHJlcXVlc3RVcmwsIHBheWxvYWRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgY3JlYXRlVXBsb2FkU2Vzc2lvbjogeyBnZXQ6ICgpID0+IHN1cGVyLmNyZWF0ZVVwbG9hZFNlc3Npb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgICAgICAgICBcIkBtaWNyb3NvZnQuZ3JhcGguY29uZmxpY3RCZWhhdmlvclwiOiAocGF5bG9hZE9wdGlvbnMgPT09IG51bGwgfHwgcGF5bG9hZE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWRPcHRpb25zLmNvbmZsaWN0QmVoYXZpb3IpIHx8IFwicmVuYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWRPcHRpb25zID09PSBudWxsIHx8IHBheWxvYWRPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkT3B0aW9ucy5maWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHBheWxvYWRPcHRpb25zID09PSBudWxsIHx8IHBheWxvYWRPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkT3B0aW9ucy5maWxlRGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNyZWF0ZVVwbG9hZFNlc3Npb24uY2FsbCh0aGlzLCBjbGllbnQsIHJlcXVlc3RVcmwsIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENvbnN0cnVjdHMgYSBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2tcbiAgICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50IC0gVGhlIEdyYXBoQ2xpZW50IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGaWxlT2JqZWN0fSBmaWxlIC0gVGhlIEZpbGVPYmplY3QgaG9sZGluZyBkZXRhaWxzIG9mIGEgZmlsZSB0aGF0IG5lZWRzIHRvIGJlIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtMYXJnZUZpbGVVcGxvYWRTZXNzaW9ufSB1cGxvYWRTZXNzaW9uIC0gVGhlIHVwbG9hZCBzZXNzaW9uIHRvIHdoaWNoIHRoZSB1cGxvYWQgaGFzIHRvIGJlIGRvbmVcbiAgICAgKiBAcGFyYW0ge0xhcmdlRmlsZVVwbG9hZFRhc2tPcHRpb25zfSBvcHRpb25zIC0gVGhlIHVwbG9hZCB0YXNrIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBPbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2tcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIGZpbGUsIHVwbG9hZFNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY2xpZW50LCBmaWxlLCB1cGxvYWRTZXNzaW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIENvbW1pdHMgdXBsb2FkIHNlc3Npb24gdG8gZW5kIHVwbG9hZGluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VXJsIC0gVGhlIFVSTCB0byBjb21taXQgdGhlIHVwbG9hZCBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZsaWN0QmVoYXZpb3IgLSBDb25mbGljdCBiZWhhdmlvdXIgb3B0aW9uLiBEZWZhdWx0IGlzICdyZW5hbWUnXG4gICAgICogQHJldHVybnMgVGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gY29tbWl0dGVkIHJlc3BvbnNlXG4gICAgICovXG4gICAgY29tbWl0KHJlcXVlc3RVcmwsIGNvbmZsaWN0QmVoYXZpb3IgPSBcInJlbmFtZVwiKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIFwiQG1pY3Jvc29mdC5ncmFwaC5jb25mbGljdEJlaGF2aW9yXCI6IGNvbmZsaWN0QmVoYXZpb3IsXG4gICAgICAgICAgICAgICAgXCJAbWljcm9zb2Z0LmdyYXBoLnNvdXJjZVVybFwiOiB0aGlzLnVwbG9hZFNlc3Npb24udXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNsaWVudC5hcGkocmVxdWVzdFVybCkucHV0KHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKiBEZWZhdWx0IHBhdGggZm9yIHRoZSBmaWxlIGJlaW5nIHVwbG9hZGVkXG4gKi9cbk9uZURyaXZlTGFyZ2VGaWxlVXBsb2FkVGFzay5ERUZBVUxUX1VQTE9BRF9QQVRIID0gXCIvXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PbmVEcml2ZUxhcmdlRmlsZVVwbG9hZFRhc2suanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBHcmFwaENsaWVudEVycm9yIH0gZnJvbSBcIi4uLy4uLy4uL0dyYXBoQ2xpZW50RXJyb3JcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBGaWxlT2JqZWN0IGNsYXNzIGZvciBSZWFkYWJsZSBTdHJlYW0gdXBsb2FkXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1VcGxvYWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQsIG5hbWUsIHNpemUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgaWYgKCFjb250ZW50IHx8ICFuYW1lIHx8ICFzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JhcGhDbGllbnRFcnJvcihcIlBsZWFzZSBwcm92aWRlIHRoZSBSZWFkYWJsZSBTdHJlYW0gY29udGVudCwgbmFtZSBvZiB0aGUgZmlsZSBhbmQgc2l6ZSBvZiB0aGUgZmlsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogU2xpY2VzIHRoZSBmaWxlIGNvbnRlbnQgdG8gdGhlIGdpdmVuIHJhbmdlXG4gICAgICogQHBhcmFtIHtSYW5nZX0gcmFuZ2UgLSBUaGUgcmFuZ2UgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgc2xpY2VkIGZpbGUgcGFydFxuICAgICAqL1xuICAgIHNsaWNlRmlsZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlU2l6ZSA9IHJhbmdlLm1heFZhbHVlIC0gcmFuZ2UubWluVmFsdWUgKyAxO1xuICAgICAgICAgICAgLyogcmVhZGFibGUucmVhZGFibGUgSXMgdHJ1ZSBpZiBpdCBpcyBzYWZlIHRvIGNhbGwgcmVhZGFibGUucmVhZCgpLFxuICAgICAgICAgICAgICogd2hpY2ggbWVhbnMgdGhlIHN0cmVhbSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIG9yIGVtaXR0ZWQgJ2Vycm9yJyBvciAnZW5kJ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBidWZzID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzbGljZUZpbGUgcmVhZHMgdGhlIGZpcnN0IGByYW5nZVNpemVgIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICAgKiBUaGUgcHJldmlvdXNTbGljZSBwcm9wZXJ0eSBpcyB1c2VkIHRvIHNlZWsgdGhlIHJhbmdlIG9mIGJ5dGVzIGluIHRoZSBwcmV2aW91cyBzbGljZS5cbiAgICAgICAgICAgICAqIFN1cHBvc2UsIHRoZSBzbGljZUZpbGUgcmVhZHMgYnl0ZXMgZnJvbSBgMTAgLSAyMGAgZnJvbSB0aGUgc3RyZWFtIGJ1dCB0aGUgdXBsb2FkIG9mIHRoaXMgc2xpY2UgZmFpbHMuXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSB1c2VyIHJlc3VtZXMsIHRoZSBzdHJlYW0gd2lsbCBoYXZlIGJ5dGVzIGZyb20gcG9zaXRpb24gMjEuXG4gICAgICAgICAgICAgKiBUaGUgcHJldmlvdXNTbGljZS5SYW5nZSBpcyB1c2VkIHRvIGNvbXBhcmUgaWYgdGhlIHJlcXVlc3RlZCByYW5nZSBpcyBjYWNoZWQgaW4gdGhlIHByZXZpb3VzU2xpY2UgcHJvcGVydHkgb3IgcHJlc2VudCBpbiB0aGUgUmVhZGFibGUgU3RyZWFtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c1NsaWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLm1pblZhbHVlIDwgdGhpcy5wcmV2aW91c1NsaWNlLnJhbmdlLm1pblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHcmFwaENsaWVudEVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgdXBsb2FkaW5nIHRoZSBzdHJlYW0uIFBsZWFzZSByZXN0YXJ0IHRoZSBzdHJlYW0gdXBsb2FkIGZyb20gdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIGZpbGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UubWluVmFsdWUgPCB0aGlzLnByZXZpb3VzU2xpY2UucmFuZ2UubWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNSYW5nZU1pbiA9IHRoaXMucHJldmlvdXNTbGljZS5yYW5nZS5taW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNSYW5nZU1heCA9IHRoaXMucHJldmlvdXNTbGljZS5yYW5nZS5tYXhWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlcXVlc3RlZCByYW5nZSBpcyBzYW1lIGFzIHByZXZpb3VzbHkgc2xpY2VkIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5taW5WYWx1ZSA9PT0gcHJldmlvdXNSYW5nZU1pbiAmJiByYW5nZS5tYXhWYWx1ZSA9PT0gcHJldmlvdXNSYW5nZU1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNTbGljZS5maWxlU2xpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBmb2xsb3dpbmcgY2hlY2sgY29uc2lkZXJzIGEgcG9zc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICogb2YgYW4gdXBsb2FkIGZhaWxpbmcgYWZ0ZXIgc29tZSBvZiB0aGUgYnl0ZXMgb2YgdGhlIHByZXZpb3VzIHNsaWNlXG4gICAgICAgICAgICAgICAgICAgICAqIHdlcmUgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkLlxuICAgICAgICAgICAgICAgICAgICAgKiBFeGFtcGxlIC0gUHJldmlvdXMgc2xpY2UgcmFuZ2UgLSBgMTAgLSAyMGAuIEN1cnJlbnQgcmVxdWVzdGVkIHJhbmdlIGlzIGAxNSAtIDIwYC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5tYXhWYWx1ZSA9PT0gcHJldmlvdXNSYW5nZU1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNTbGljZS5maWxlU2xpY2Uuc2xpY2UocmFuZ2UubWluVmFsdWUsIHJhbmdlLm1heFZhbHVlICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIGFuIHVwbG9hZCBmYWlscyBhZnRlciBzb21lIG9mIHRoZSBieXRlcyBvZiB0aGUgcHJldmlvdXMgc2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICogd2VyZSBzdWNjZXNzZnVsbHkgdXBsb2FkZWQgYW5kIHRoZSBuZXcgUmFuZ2UuTWF4aW11bSBpcyBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIFJhbmdlLk1heGltdW1cbiAgICAgICAgICAgICAgICAgICAgICogRXhhbXBsZSAtIFByZXZpb3VzIHNsaWNlIHJhbmdlIC0gYDEwIC0gMjBgLiBDdXJyZW50IHJlcXVlc3RlZCByYW5nZSBpcyBgMTUgLSAyNWAsXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZW4gcmVhZCB0aGUgYnl0ZXMgZnJvbSBwb3NpdGlvbiAxNSB0byAyMCBmcm9tIHByZXZpb3VzU2xpY2UuZmlsZVNsaWNlIGFuZCByZWFkIGJ5dGVzIGZyb20gcG9zaXRpb24gMjEgdG8gMjUgZnJvbSB0aGUgUmVhZGFibGUgU3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBidWZzLnB1c2godGhpcy5wcmV2aW91c1NsaWNlLmZpbGVTbGljZS5zbGljZShyYW5nZS5taW5WYWx1ZSwgcHJldmlvdXNSYW5nZU1heCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VTaXplID0gcmFuZ2UubWF4VmFsdWUgLSBwcmV2aW91c1JhbmdlTWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQgJiYgdGhpcy5jb250ZW50LnJlYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5yZWFkYWJsZUxlbmd0aCA+PSByYW5nZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmcy5wdXNoKHRoaXMuY29udGVudC5yZWFkKHJhbmdlU2l6ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmcy5wdXNoKHlpZWxkIHRoaXMucmVhZE5CeXRlc0Zyb21TdHJlYW0ocmFuZ2VTaXplKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdyYXBoQ2xpZW50RXJyb3IoXCJTdHJlYW0gaXMgbm90IHJlYWRhYmxlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNsaWNlZENodW5rID0gQnVmZmVyLmNvbmNhdChidWZzKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTbGljZSA9IHsgZmlsZVNsaWNlOiBzbGljZWRDaHVuaywgcmFuZ2UgfTtcbiAgICAgICAgICAgIHJldHVybiBzbGljZWRDaHVuaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUmVhZHMgdGhlIHNwZWNpZmllZCBieXRlIHNpemUgZnJvbSB0aGUgc3RyZWFtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZSBvZiBieXRlcyB0byBiZSByZWFkXG4gICAgICogQHJldHVybnMgQnVmZmVyIHdpdGggdGhlIGdpdmVuIGxlbmd0aCBvZiBkYXRhLlxuICAgICAqL1xuICAgIHJlYWROQnl0ZXNGcm9tU3RyZWFtKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmRlciA9IHNpemU7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgR3JhcGhDbGllbnRFcnJvcihcIlN0cmVhbSBlbmRlZCBiZWZvcmUgcmVhZGluZyByZXF1aXJlZCByYW5nZSBzaXplXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiAoY2h1bmsgPSB0aGlzLmNvbnRlbnQucmVhZChzaXplKSkgY2FuIHJldHVybiBudWxsIGlmIHNpemUgb2Ygc3RyZWFtIGlzIGxlc3MgdGhhbiAnc2l6ZScgcGFyYW1ldGVyLlxuICAgICAgICAgICAgICAgICAqIFJlYWQgdGhlIHJlbWFpbmRlciBudW1iZXIgb2YgYnl0ZXMgZnJvbSB0aGUgc3RyZWFtIGl0ZXJhdGl2ZWx5IGFzIHRoZXkgYXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlbmd0aCA8IHNpemUgJiYgKGNodW5rID0gdGhpcy5jb250ZW50LnJlYWQocmVtYWluZGVyKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluZGVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKEJ1ZmZlci5jb25jYXQoY2h1bmtzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50IHx8ICF0aGlzLmNvbnRlbnQucmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgR3JhcGhDbGllbnRFcnJvcihcIkVycm9yIGVuY291bnRlcmVkIHdoaWxlIHJlYWRpbmcgdGhlIHN0cmVhbSBkdXJpbmcgdGhlIHVwbG9hZFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmVhbVVwbG9hZC5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIGZvciBQYWdlSXRlcmF0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VJdGVyYXRvciB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIGZvciBQYWdlSXRlcmF0b3JcbiAgICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50IC0gVGhlIGdyYXBoIGNsaWVudCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UGFnZUNvbGxlY3Rpb259IHBhZ2VDb2xsZWN0aW9uIC0gVGhlIHBhZ2UgY29sbGVjdGlvbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1BhZ2VJdGVyYXRvckNhbGxiYWNrfSBjYWxsQmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7R3JhcGhSZXF1ZXN0T3B0aW9uc30gcmVxdWVzdE9wdGlvbnMgLSBUaGUgcmVxdWVzdCBvcHRpb25zXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYSBQYWdlSXRlcmF0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHBhZ2VDb2xsZWN0aW9uLCBjYWxsYmFjaywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IHBhZ2VDb2xsZWN0aW9uLnZhbHVlO1xuICAgICAgICB0aGlzLm5leHRMaW5rID0gcGFnZUNvbGxlY3Rpb25bXCJAb2RhdGEubmV4dExpbmtcIl07XG4gICAgICAgIHRoaXMuZGVsdGFMaW5rID0gcGFnZUNvbGxlY3Rpb25bXCJAb2RhdGEuZGVsdGFMaW5rXCJdO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gcmVxdWVzdE9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIGNvbGxlY3Rpb24gYnkgZW5xdWV1aW5nIGVudHJpZXMgb25lIGJ5IG9uZSBhbmQga2lja2luZyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgZW5xdWV1ZWQgZW50cnlcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB0aGUgY29udGludWUgZmxhZyB0byBwcm9jZXNzIG5leHQgcGFnZVxuICAgICAqL1xuICAgIGl0ZXJhdGlvbkhlbHBlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkdmFuY2UgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoYWR2YW5jZSAmJiB0aGlzLmN1cnNvciA8IHRoaXMuY29sbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb25bdGhpcy5jdXJzb3JdO1xuICAgICAgICAgICAgYWR2YW5jZSA9IHRoaXMuY2FsbGJhY2soaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmN1cnNvcisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZHZhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhc3luY1xuICAgICAqIEhlbHBlciB0byBtYWtlIGEgZ2V0IHJlcXVlc3QgdG8gZmV0Y2ggbmV4dCBwYWdlIHdpdGggbmV4dExpbmsgdXJsIGFuZCB1cGRhdGUgdGhlIHBhZ2UgaXRlcmF0b3IgaW5zdGFuY2Ugd2l0aCB0aGUgcmV0dXJuZWQgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHJlc3BvbnNlIGRhdGEgd2l0aCBuZXh0IHBhZ2UgY29sbGVjdGlvblxuICAgICAqL1xuICAgIGZldGNoQW5kVXBkYXRlTmV4dFBhZ2VEYXRhKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGdyYXBoUmVxdWVzdCA9IHRoaXMuY2xpZW50LmFwaSh0aGlzLm5leHRMaW5rKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBncmFwaFJlcXVlc3QgPSBncmFwaFJlcXVlc3QuaGVhZGVycyh0aGlzLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0T3B0aW9ucy5taWRkbGV3YXJlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBncmFwaFJlcXVlc3QgPSBncmFwaFJlcXVlc3QubWlkZGxld2FyZU9wdGlvbnModGhpcy5yZXF1ZXN0T3B0aW9ucy5taWRkbGV3YXJlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3RPcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhSZXF1ZXN0ID0gZ3JhcGhSZXF1ZXN0Lm9wdGlvbnModGhpcy5yZXF1ZXN0T3B0aW9ucy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGdyYXBoUmVxdWVzdC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IHJlc3BvbnNlLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgICAgICAgICAgdGhpcy5uZXh0TGluayA9IHJlc3BvbnNlW1wiQG9kYXRhLm5leHRMaW5rXCJdO1xuICAgICAgICAgICAgdGhpcy5kZWx0YUxpbmsgPSByZXNwb25zZVtcIkBvZGF0YS5kZWx0YUxpbmtcIl07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogR2V0dGVyIHRvIGdldCB0aGUgZGVsdGFMaW5rIGluIHRoZSBjdXJyZW50IHJlc3BvbnNlXG4gICAgICogQHJldHVybnMgQSBkZWx0YUxpbmsgd2hpY2ggaXMgYmVpbmcgdXNlZCB0byBtYWtlIGRlbHRhIHJlcXVlc3RzIGluIGZ1dHVyZVxuICAgICAqL1xuICAgIGdldERlbHRhTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsdGFMaW5rO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgY29sbGVjdGlvbiBhbmQga2lja3MgY2FsbGJhY2sgZm9yIGVhY2ggaXRlbSBvbiBpdGVyYXRpb24uIEZldGNoZXMgbmV4dCBzZXQgb2YgZGF0YSB0aHJvdWdoIG5leHRMaW5rIGFuZCBpdGVyYXRlcyBvdmVyIGFnYWluXG4gICAgICogVGhpcyBoYXBwZW5zIHVudGlsIHRoZSBuZXh0TGluayBpcyBkcmFpbmVkIG91dCBvciB0aGUgdXNlciByZXNwb25kcyB3aXRoIGEgcmVkIGZsYWcgdG8gY29udGludWUgZnJvbSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG5vdGhpbmcgb24gY29tcGxldGlvbiBhbmQgdGhyb3dzIGVycm9yIGluY2FzZSBvZiBhbnkgZGlzY3JlcGFuY3kuXG4gICAgICovXG4gICAgaXRlcmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBhZHZhbmNlID0gdGhpcy5pdGVyYXRpb25IZWxwZXIoKTtcbiAgICAgICAgICAgIHdoaWxlIChhZHZhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dExpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmZldGNoQW5kVXBkYXRlTmV4dFBhZ2VEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UgPSB0aGlzLml0ZXJhdGlvbkhlbHBlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRMaW5rID09PSB1bmRlZmluZWQgJiYgdGhpcy5jdXJzb3IgPj0gdGhpcy5jb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFRvIHJlc3VtZSB0aGUgaXRlcmF0aW9uXG4gICAgICogTm90ZTogVGhpcyBpbnRlcm5hbGx5IGNhbGxzIHRoZSBpdGVyYXRlIG1ldGhvZCwgSXQncyBqdXN0IGZvciBtb3JlIHJlYWRhYmlsaXR5LlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG5vdGhpbmcgb24gY29tcGxldGlvbiBhbmQgdGhyb3dzIGVycm9yIGluY2FzZSBvZiBhbnkgZGlzY3JlcGFuY3lcbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVG8gZ2V0IHRoZSBjb21wbGV0ZW5lc3Mgc3RhdHVzIG9mIHRoZSBpdGVyYXRvclxuICAgICAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyB0aGUgY29tcGxldGVuZXNzXG4gICAgICovXG4gICAgaXNDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFnZUl0ZXJhdG9yLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBtb2R1bGUgQ3VzdG9tQXV0aGVudGljYXRpb25Qcm92aWRlclxuICovXG5pbXBvcnQgeyBHcmFwaENsaWVudEVycm9yIH0gZnJvbSBcIi4vR3JhcGhDbGllbnRFcnJvclwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIHJlcHJlc2VudGluZyBDdXN0b21BdXRoZW50aWNhdGlvblByb3ZpZGVyXG4gKiBAZXh0ZW5kcyBBdXRoZW50aWNhdGlvblByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBDdXN0b21BdXRoZW50aWNhdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDdXN0b21BdXRoZW50aWNhdGlvblByb3ZpZGVyXG4gICAgICogQHBhcmFtIHtBdXRoUHJvdmlkZXJDYWxsYmFja30gcHJvdmlkZXIgLSBBbiBhdXRoUHJvdmlkZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBDdXN0b21BdXRoZW50aWNhdGlvblByb3ZpZGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogVG8gZ2V0IHRoZSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFjY2VzcyB0b2tlblxuICAgICAqL1xuICAgIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyKChlcnJvciwgYWNjZXNzVG9rZW4pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5NZXNzYWdlID0gXCJBY2Nlc3MgdG9rZW4gaXMgdW5kZWZpbmVkIG9yIGVtcHR5LlxcXG5cdFx0XHRcdFx0XHRQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIHRva2VuLlxcXG5cdFx0XHRcdFx0XHRGb3IgbW9yZSBoZWxwIC0gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdGdyYXBoL21zZ3JhcGgtc2RrLWphdmFzY3JpcHQvYmxvYi9kZXYvZG9jcy9DdXN0b21BdXRoZW50aWNhdGlvblByb3ZpZGVyLm1kXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgR3JhcGhDbGllbnRFcnJvcihpbnZhbGlkVG9rZW5NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHlpZWxkIEdyYXBoQ2xpZW50RXJyb3Iuc2V0R3JhcGhDbGllbnRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DdXN0b21BdXRoZW50aWNhdGlvblByb3ZpZGVyLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiBAbW9kdWxlIEdyYXBoRXJyb3JcbiAqL1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIGZvciBHcmFwaEVycm9yXG4gKiBATk9URTogVGhpcyBpcyBOT1Qgd2hhdCBpcyByZXR1cm5lZCBmcm9tIHRoZSBHcmFwaFxuICogR3JhcGhFcnJvciBpcyBjcmVhdGVkIGZyb20gcGFyc2luZyBKU09OIGVycm9ycyByZXR1cm5lZCBmcm9tIHRoZSBncmFwaFxuICogU29tZSBmaWVsZHMgYXJlIHJlbmFtZWQgaWUsIFwicmVxdWVzdC1pZFwiID0+IHJlcXVlc3RJZCBzbyB5b3UgY2FuIHVzZSBkb3Qgbm90YXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR3JhcGhFcnJvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhdHVzQ29kZSA9IC0xXSAtIFRoZSBzdGF0dXMgY29kZSBvZiB0aGUgZXJyb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIHtFcnJvcn0gW2Jhc2VFcnJvcl0gLSBUaGUgYmFzZSBlcnJvclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIEdyYXBoRXJyb3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlID0gLTEsIG1lc3NhZ2UsIGJhc2VFcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlIHx8IChiYXNlRXJyb3IgJiYgYmFzZUVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvQnJlYWtpbmctQ2hhbmdlcyNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEdyYXBoRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gYmFzZUVycm9yID8gYmFzZUVycm9yLnN0YWNrIDogdGhpcy5zdGFjaztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaEVycm9yLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBtb2R1bGUgR3JhcGhFcnJvckhhbmRsZXJcbiAqL1xuaW1wb3J0IHsgR3JhcGhFcnJvciB9IGZyb20gXCIuL0dyYXBoRXJyb3JcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBDbGFzcyBmb3IgR3JhcGhFcnJvckhhbmRsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoRXJyb3JIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBQb3B1bGF0ZXMgdGhlIEdyYXBoRXJyb3IgaW5zdGFuY2Ugd2l0aCBFcnJvciBpbnN0YW5jZSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIFRoZSBlcnJvciByZXR1cm5lZCBieSBncmFwaCBzZXJ2aWNlIG9yIHNvbWUgbmF0aXZlIGVycm9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGF0dXNDb2RlXSAtIFRoZSBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyBUaGUgR3JhcGhFcnJvciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBjb25zdHJ1Y3RFcnJvcihlcnJvciwgc3RhdHVzQ29kZSwgcmF3UmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZ0Vycm9yID0gbmV3IEdyYXBoRXJyb3Ioc3RhdHVzQ29kZSwgXCJcIiwgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnRXJyb3IuY29kZSA9IGVycm9yLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ0Vycm9yLmJvZHkgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgICBnRXJyb3IuZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGdFcnJvci5oZWFkZXJzID0gcmF3UmVzcG9uc2UgPT09IG51bGwgfHwgcmF3UmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgIHJldHVybiBnRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFBvcHVsYXRlcyB0aGUgR3JhcGhFcnJvciBpbnN0YW5jZSBmcm9tIHRoZSBFcnJvciByZXR1cm5lZCBieSBncmFwaCBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtHcmFwaEFQSUVycm9yUmVzcG9uc2V9IGdyYXBoRXJyb3IgLSBUaGUgZXJyb3IgcG9zc2libHkgcmV0dXJuZWQgYnkgZ3JhcGggc2VydmljZSBvciBzb21lIG5hdGl2ZSBlcnJvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlIC0gVGhlIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIEdyYXBoRXJyb3IgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXJyb3IgZm9yIGh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS92MS4wL21lL2V2ZW50cz8kdG9wPTMmJHNlYXJjaD1mb29cbiAgICAgKiB7XG4gICAgICogICAgICBcImVycm9yXCI6IHtcbiAgICAgKiAgICAgICAgICBcImNvZGVcIjogXCJTZWFyY2hFdmVudHNcIixcbiAgICAgKiAgICAgICAgICBcIm1lc3NhZ2VcIjogXCJUaGUgcGFyYW1ldGVyICRzZWFyY2ggaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgb24gdGhlIEV2ZW50cyByZXNvdXJjZS5cIixcbiAgICAgKiAgICAgICAgICBcImlubmVyRXJyb3JcIjoge1xuICAgICAqICAgICAgICAgICAgICBcInJlcXVlc3QtaWRcIjogXCJiMzFjODNmZC05NDRjLTQ2NjMtYWE1MC01ZDljZWIzNjdlMTlcIixcbiAgICAgKiAgICAgICAgICAgICAgXCJkYXRlXCI6IFwiMjAxNi0xMS0xN1QxODozNzo0NVwiXG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgfVxuICAgICAqICB9XG4gICAgICovXG4gICAgc3RhdGljIGNvbnN0cnVjdEVycm9yRnJvbVJlc3BvbnNlKGdyYXBoRXJyb3IsIHN0YXR1c0NvZGUsIHJhd1Jlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZ3JhcGhFcnJvci5lcnJvcjtcbiAgICAgICAgY29uc3QgZ0Vycm9yID0gbmV3IEdyYXBoRXJyb3Ioc3RhdHVzQ29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGdFcnJvci5jb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgaWYgKGVycm9yLmlubmVyRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ0Vycm9yLnJlcXVlc3RJZCA9IGVycm9yLmlubmVyRXJyb3JbXCJyZXF1ZXN0LWlkXCJdO1xuICAgICAgICAgICAgZ0Vycm9yLmRhdGUgPSBuZXcgRGF0ZShlcnJvci5pbm5lckVycm9yLmRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGdFcnJvci5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgICAgICBnRXJyb3IuaGVhZGVycyA9IHJhd1Jlc3BvbnNlID09PSBudWxsIHx8IHJhd1Jlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICByZXR1cm4gZ0Vycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFRvIGdldCB0aGUgR3JhcGhFcnJvciBvYmplY3RcbiAgICAgKiBSZWZlcmVuY2UgLSBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9ncmFwaC9lcnJvcnNcbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycm9yID0gbnVsbF0gLSBUaGUgZXJyb3IgcmV0dXJuZWQgYnkgZ3JhcGggc2VydmljZSBvciBzb21lIG5hdGl2ZSBlcnJvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhdHVzQ29kZSA9IC0xXSAtIFRoZSBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge0dyYXBoUmVxdWVzdENhbGxiYWNrfSBbY2FsbGJhY2tdIC0gVGhlIGdyYXBoIHJlcXVlc3QgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBHcmFwaEVycm9yIGluc3RhbmNlXG4gICAgICovXG4gICAgc3RhdGljIGdldEVycm9yKGVycm9yID0gbnVsbCwgc3RhdHVzQ29kZSA9IC0xLCBjYWxsYmFjaywgcmF3UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBnRXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBnRXJyb3IgPSBHcmFwaEVycm9ySGFuZGxlci5jb25zdHJ1Y3RFcnJvckZyb21SZXNwb25zZShlcnJvciwgc3RhdHVzQ29kZSwgcmF3UmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGdFcnJvciA9IEdyYXBoRXJyb3JIYW5kbGVyLmNvbnN0cnVjdEVycm9yKGVycm9yLCBzdGF0dXNDb2RlLCByYXdSZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnRXJyb3IgPSBuZXcgR3JhcGhFcnJvcihzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICBnRXJyb3IuYm9keSA9IGVycm9yOyAvLyBpZiBhIGN1c3RvbSBlcnJvciBpcyBwYXNzZWQgd2hpY2ggaXMgbm90IGluc3RhbmNlIG9mIEVycm9yIG9iamVjdCBvciBhIGdyYXBoIEFQSSByZXNwb25zZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZ0Vycm9yLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoRXJyb3JIYW5kbGVyLmpzLm1hcCIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogU2VlIExpY2Vuc2UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG4vKipcbiAqIEBtb2R1bGUgR3JhcGhSZXF1ZXN0XG4gKi9cbmltcG9ydCB7IEdyYXBoQ2xpZW50RXJyb3IgfSBmcm9tIFwiLi9HcmFwaENsaWVudEVycm9yXCI7XG5pbXBvcnQgeyBHcmFwaEVycm9ySGFuZGxlciB9IGZyb20gXCIuL0dyYXBoRXJyb3JIYW5kbGVyXCI7XG5pbXBvcnQgeyBvRGF0YVF1ZXJ5TmFtZXMsIHNlcmlhbGl6ZUNvbnRlbnQsIHVybEpvaW4gfSBmcm9tIFwiLi9HcmFwaFJlcXVlc3RVdGlsXCI7XG5pbXBvcnQgeyBHcmFwaFJlc3BvbnNlSGFuZGxlciB9IGZyb20gXCIuL0dyYXBoUmVzcG9uc2VIYW5kbGVyXCI7XG5pbXBvcnQgeyBNaWRkbGV3YXJlQ29udHJvbCB9IGZyb20gXCIuL21pZGRsZXdhcmUvTWlkZGxld2FyZUNvbnRyb2xcIjtcbmltcG9ydCB7IFJlcXVlc3RNZXRob2QgfSBmcm9tIFwiLi9SZXF1ZXN0TWV0aG9kXCI7XG5pbXBvcnQgeyBSZXNwb25zZVR5cGUgfSBmcm9tIFwiLi9SZXNwb25zZVR5cGVcIjtcbi8qKlxuICogQGNsYXNzXG4gKiBBIENsYXNzIHJlcHJlc2VudGluZyBHcmFwaFJlcXVlc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoUmVxdWVzdCB7XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR3JhcGhSZXF1ZXN0XG4gICAgICogQHBhcmFtIHtIVFRQQ2xpZW50fSBodHRwQ2xpZW50IC0gVGhlIEhUVFBDbGllbnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0NsaWVudE9wdGlvbnN9IGNvbmZpZyAtIFRoZSBvcHRpb25zIGZvciBtYWtpbmcgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gQSBwYXRoIHN0cmluZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGh0dHBDbGllbnQsIGNvbmZpZywgcGF0aCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogUGFyc2VzIHRoZSBwYXRoIHN0cmluZyBhbmQgY3JlYXRlcyBVUkxDb21wb25lbnRzIG91dCBvZiBpdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSByZXF1ZXN0IHBhdGggc3RyaW5nXG4gICAgICAgICAqIEByZXR1cm5zIE5vdGhpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyc2VQYXRoID0gKHBhdGgpID0+IHtcbiAgICAgICAgICAgIC8vIFN0cmlwcyBvdXQgdGhlIGJhc2Ugb2YgdGhlIHVybCBpZiB0aGV5IHBhc3NlZCBpblxuICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihcImh0dHBzOi8vXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoXCJodHRwczovL1wiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRoZSBob3N0IGVuZHNcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRPZkhvc3RTdHJQb3MgPSBwYXRoLmluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRPZkhvc3RTdHJQb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIG91dCB0aGUgaG9zdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVybENvbXBvbmVudHMuaG9zdCA9IFwiaHR0cHM6Ly9cIiArIHBhdGguc3Vic3RyaW5nKDAsIGVuZE9mSG9zdFN0clBvcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBob3N0IGZyb20gcGF0aFxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoZW5kT2ZIb3N0U3RyUG9zICsgMSwgcGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZvbGxvd2luZyB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kT2ZWZXJzaW9uU3RyUG9zID0gcGF0aC5pbmRleE9mKFwiL1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kT2ZWZXJzaW9uU3RyUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBvdXQgdGhlIHZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLnZlcnNpb24gPSBwYXRoLnN1YnN0cmluZygwLCBlbmRPZlZlcnNpb25TdHJQb3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCB2ZXJzaW9uIGZyb20gcGF0aFxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoZW5kT2ZWZXJzaW9uU3RyUG9zICsgMSwgcGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0cmlwIG91dCBhbnkgbGVhZGluZyBcIi9cIlxuICAgICAgICAgICAgaWYgKHBhdGguY2hhckF0KDApID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5U3RyUG9zID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgICAgIGlmIChxdWVyeVN0clBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBxdWVyeSBzdHJpbmdcbiAgICAgICAgICAgICAgICB0aGlzLnVybENvbXBvbmVudHMucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVybENvbXBvbmVudHMucGF0aCA9IHBhdGguc3Vic3RyKDAsIHF1ZXJ5U3RyUG9zKTtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHF1ZXJ5IHN0cmluZyBpbnRvIG9EYXRhUXVlcnlQYXJhbXMgYW5kIG90aGVyVVJMUXVlcnlQYXJhbXNcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHBhdGguc3Vic3RyaW5nKHF1ZXJ5U3RyUG9zICsgMSwgcGF0aC5sZW5ndGgpLnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5UGFyYW0gb2YgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5UGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudXJsQ29tcG9uZW50cyA9IHtcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29uZmlnLmJhc2VVcmwsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmNvbmZpZy5kZWZhdWx0VmVyc2lvbixcbiAgICAgICAgICAgIG9EYXRhUXVlcnlQYXJhbXM6IHt9LFxuICAgICAgICAgICAgb3RoZXJVUkxRdWVyeVBhcmFtczoge30sXG4gICAgICAgICAgICBvdGhlclVSTFF1ZXJ5T3B0aW9uczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlT3B0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnBhcnNlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBBZGRzIHRoZSBxdWVyeSBwYXJhbWV0ZXIgYXMgY29tbWEgc2VwYXJhdGVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBUaGUgbmFtZSBvZiBhIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3BlcnR5VmFsdWUgLSBUaGUgdmFsZSBvZiBhIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtJQXJndW1lbnRzfSBhZGRpdGlvbmFsUHJvcGVydGllcyAtIFRoZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyBOb3RoaW5nXG4gICAgICovXG4gICAgYWRkQ3N2UXVlcnlQYXJhbWV0ZXIocHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlLCBhZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYWxyZWFkeSAkcHJvcGVydHlOYW1lIHZhbHVlIHRoZXJlLCBhcHBlbmQgYSBcIixcIlxuICAgICAgICB0aGlzLnVybENvbXBvbmVudHMub0RhdGFRdWVyeVBhcmFtc1twcm9wZXJ0eU5hbWVdID0gdGhpcy51cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXNbcHJvcGVydHlOYW1lXSA/IHRoaXMudXJsQ29tcG9uZW50cy5vRGF0YVF1ZXJ5UGFyYW1zW3Byb3BlcnR5TmFtZV0gKyBcIixcIiA6IFwiXCI7XG4gICAgICAgIGxldCBhbGxWYWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIHByb3BlcnR5VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFsbFZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvcGVydHlWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWxsVmFsdWVzLnB1c2gocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGxWYWx1ZXMgPSBhbGxWYWx1ZXMuY29uY2F0KHByb3BlcnR5VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXJsQ29tcG9uZW50cy5vRGF0YVF1ZXJ5UGFyYW1zW3Byb3BlcnR5TmFtZV0gKz0gYWxsVmFsdWVzLmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEJ1aWxkcyB0aGUgZnVsbCB1cmwgZnJvbSB0aGUgVVJMQ29tcG9uZW50cyB0byBtYWtlIGEgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIFRoZSBVUkwgc3RyaW5nIHRoYXQgaXMgcXVhbGlmaWVkIHRvIG1ha2UgYSByZXF1ZXN0IHRvIGdyYXBoIGVuZHBvaW50XG4gICAgICovXG4gICAgYnVpbGRGdWxsVXJsKCkge1xuICAgICAgICBjb25zdCB1cmwgPSB1cmxKb2luKFt0aGlzLnVybENvbXBvbmVudHMuaG9zdCwgdGhpcy51cmxDb21wb25lbnRzLnZlcnNpb24sIHRoaXMudXJsQ29tcG9uZW50cy5wYXRoXSkgKyB0aGlzLmNyZWF0ZVF1ZXJ5U3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5kZWJ1Z0xvZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBCdWlsZHMgdGhlIHF1ZXJ5IHN0cmluZyBmcm9tIHRoZSBVUkxDb21wb25lbnRzXG4gICAgICogQHJldHVybnMgVGhlIENvbnN0cnVjdGVkIHF1ZXJ5IHN0cmluZ1xuICAgICAqL1xuICAgIGNyZWF0ZVF1ZXJ5U3RyaW5nKCkge1xuICAgICAgICAvLyBDb21iaW5pbmcgcXVlcnkgcGFyYW1zIGZyb20gb0RhdGFRdWVyeVBhcmFtcyBhbmQgb3RoZXJVUkxRdWVyeVBhcmFtc1xuICAgICAgICBjb25zdCB1cmxDb21wb25lbnRzID0gdGhpcy51cmxDb21wb25lbnRzO1xuICAgICAgICBjb25zdCBxdWVyeSA9IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModXJsQ29tcG9uZW50cy5vRGF0YVF1ZXJ5UGFyYW1zKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gdXJsQ29tcG9uZW50cy5vRGF0YVF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeS5wdXNoKHByb3BlcnR5ICsgXCI9XCIgKyB1cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXNbcHJvcGVydHldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHVybENvbXBvbmVudHMub3RoZXJVUkxRdWVyeVBhcmFtcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHVybENvbXBvbmVudHMub3RoZXJVUkxRdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodXJsQ29tcG9uZW50cy5vdGhlclVSTFF1ZXJ5UGFyYW1zLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkucHVzaChwcm9wZXJ0eSArIFwiPVwiICsgdXJsQ29tcG9uZW50cy5vdGhlclVSTFF1ZXJ5UGFyYW1zW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cmxDb21wb25lbnRzLm90aGVyVVJMUXVlcnlPcHRpb25zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdHIgb2YgdXJsQ29tcG9uZW50cy5vdGhlclVSTFF1ZXJ5T3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnB1c2goc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnkubGVuZ3RoID4gMCA/IFwiP1wiICsgcXVlcnkuam9pbihcIiZcIikgOiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFBhcnNlcyB0aGUgcXVlcnkgcGFyYW1ldGVycyB0byBzZXQgdGhlIHVybENvbXBvbmVudHMgcHJvcGVydHkgb2YgdGhlIEdyYXBoUmVxdWVzdCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xLZXlWYWx1ZVBhaXJPYmplY3RTdHJpbmdOdW1iZXJ9IHF1ZXJ5RGljdGlvbmFyeU9yU3RyaW5nIC0gVGhlIHF1ZXJ5IHBhcmFtZXRlclxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoXG4gICAgICovXG4gICAgcGFyc2VRdWVyeVBhcmFtZXRlcihxdWVyeURpY3Rpb25hcnlPclN0cmluZykge1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5RGljdGlvbmFyeU9yU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocXVlcnlEaWN0aW9uYXJ5T3JTdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgIHF1ZXJ5RGljdGlvbmFyeU9yU3RyaW5nID0gcXVlcnlEaWN0aW9uYXJ5T3JTdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1ZXJ5RGljdGlvbmFyeU9yU3RyaW5nLmluZGV4T2YoXCImXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gcXVlcnlEaWN0aW9uYXJ5T3JTdHJpbmcuc3BsaXQoXCImXCIpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3RyIG9mIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VRdWVyeVBhcmFtZW50ZXJTdHJpbmcoc3RyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlUXVlcnlQYXJhbWVudGVyU3RyaW5nKHF1ZXJ5RGljdGlvbmFyeU9yU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWVyeURpY3Rpb25hcnlPclN0cmluZy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeURpY3Rpb25hcnlPclN0cmluZykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocXVlcnlEaWN0aW9uYXJ5T3JTdHJpbmcsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRVUkxDb21wb25lbnRzUXVlcnlQYXJhbWF0ZXIoa2V5LCBxdWVyeURpY3Rpb25hcnlPclN0cmluZ1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUGFyc2VzIHRoZSBxdWVyeSBwYXJhbWV0ZXIgb2Ygc3RyaW5nIHR5cGUgdG8gc2V0IHRoZSB1cmxDb21wb25lbnRzIHByb3BlcnR5IG9mIHRoZSBHcmFwaFJlcXVlc3Qgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5UGFyYW1ldGVyIC0gdGhlIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAgKiByZXR1cm5zIG5vdGhpbmdcbiAgICAgKi9cbiAgICBwYXJzZVF1ZXJ5UGFyYW1lbnRlclN0cmluZyhxdWVyeVBhcmFtZXRlcikge1xuICAgICAgICAvKiBUaGUgcXVlcnkga2V5LXZhbHVlIHBhaXIgbXVzdCBiZSBzcGxpdCBvbiB0aGUgZmlyc3QgZXF1YWxzIHNpZ24gdG8gYXZvaWQgZXJyb3JzIGluIHBhcnNpbmcgbmVzdGVkIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgIEV4YW1wbGUtPiBcIi9tZT8kZXhwYW5kPWhvbWUoJHNlbGVjdD1jaXR5KVwiICovXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRRdWVyeUtleVZhbHVlUGFpcihxdWVyeVBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZGaXJzdEVxdWFscyA9IHF1ZXJ5UGFyYW1ldGVyLmluZGV4T2YoXCI9XCIpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1LZXkgPSBxdWVyeVBhcmFtZXRlci5zdWJzdHJpbmcoMCwgaW5kZXhPZkZpcnN0RXF1YWxzKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSBxdWVyeVBhcmFtZXRlci5zdWJzdHJpbmcoaW5kZXhPZkZpcnN0RXF1YWxzICsgMSk7XG4gICAgICAgICAgICB0aGlzLnNldFVSTENvbXBvbmVudHNRdWVyeVBhcmFtYXRlcihwYXJhbUtleSwgcGFyYW1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBQdXNoIHZhbHVlcyB3aGljaCBhcmUgbm90IG9mIGtleS12YWx1ZSBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICBFeGFtcGxlLT4gSGFuZGxlIGFuIGludmFsaWQgaW5wdXQtPi5xdWVyeSh0ZXN0KSwgLnF1ZXJ5KCRzZWxlY3QoJHNlbGVjdD1uYW1lKSkgYW5kIGxldCB0aGUgR3JhcGggQVBJIHJlc3BvbmQgd2l0aCB0aGUgZXJyb3IgaW4gdGhlIFVSTCovXG4gICAgICAgICAgICB0aGlzLnVybENvbXBvbmVudHMub3RoZXJVUkxRdWVyeU9wdGlvbnMucHVzaChxdWVyeVBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXRzIHZhbHVlcyBpbnRvIHRoZSB1cmxDb21wb25lbnRzIHByb3BlcnR5IG9mIEdyYXBoUmVxdWVzdCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtS2V5IC0gdGhlIHF1ZXJ5IHBhcmFtZXRlciBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1WYWx1ZSAtIHRoZSBxdWVyeSBwYXJhbXRlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIG5vdGhpbmdcbiAgICAgKi9cbiAgICBzZXRVUkxDb21wb25lbnRzUXVlcnlQYXJhbWF0ZXIocGFyYW1LZXksIHBhcmFtVmFsdWUpIHtcbiAgICAgICAgaWYgKG9EYXRhUXVlcnlOYW1lcy5pbmRleE9mKHBhcmFtS2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMudXJsQ29tcG9uZW50cy5vRGF0YVF1ZXJ5UGFyYW1zW3BhcmFtS2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsdWVBcHBlbmRhYmxlID0gY3VycmVudFZhbHVlICYmIChwYXJhbUtleSA9PT0gXCIkZXhwYW5kXCIgfHwgcGFyYW1LZXkgPT09IFwiJHNlbGVjdFwiIHx8IHBhcmFtS2V5ID09PSBcIiRvcmRlcmJ5XCIpO1xuICAgICAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXNbcGFyYW1LZXldID0gaXNWYWx1ZUFwcGVuZGFibGUgPyBjdXJyZW50VmFsdWUgKyBcIixcIiArIHBhcmFtVmFsdWUgOiBwYXJhbVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLm90aGVyVVJMUXVlcnlQYXJhbXNbcGFyYW1LZXldID0gcGFyYW1WYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIENoZWNrIGlmIHRoZSBxdWVyeSBwYXJhbWV0ZXIgc3RyaW5nIGhhcyBhIHZhbGlkIGtleS12YWx1ZSBzdHJ1Y3R1cmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlTdHJpbmcgLSB0aGUgcXVlcnkgcGFyYW1ldGVyIHN0cmluZy4gRXhhbXBsZSAtPiBcIm5hbWU9dmFsdWVcIlxuICAgICAqICNyZXR1cm5zIHRydWUgaWYgdGhlIHF1ZXJ5IHN0cmluZyBoYXMgYSB2YWxpZCBrZXktdmFsdWUgc3RydWN0dXJlIGVsc2UgZmFsc2VcbiAgICAgKi9cbiAgICBpc1ZhbGlkUXVlcnlLZXlWYWx1ZVBhaXIocXVlcnlTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaW5kZXhvZkZpcnN0RXF1YWxzID0gcXVlcnlTdHJpbmcuaW5kZXhPZihcIj1cIik7XG4gICAgICAgIGlmIChpbmRleG9mRmlyc3RFcXVhbHMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhvZk9wZW5pbmdQYXJhbnRoZXNpcyA9IHF1ZXJ5U3RyaW5nLmluZGV4T2YoXCIoXCIpO1xuICAgICAgICBpZiAoaW5kZXhvZk9wZW5pbmdQYXJhbnRoZXNpcyAhPT0gLTEgJiYgcXVlcnlTdHJpbmcuaW5kZXhPZihcIihcIikgPCBpbmRleG9mRmlyc3RFcXVhbHMpIHtcbiAgICAgICAgICAgIC8vIEV4YW1wbGUgLT4gLnF1ZXJ5KCRzZWxlY3QoJGV4cGFuZD10cnVlKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogVXBkYXRlcyB0aGUgY3VzdG9tIGhlYWRlcnMgYW5kIG9wdGlvbnMgZm9yIGEgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7RmV0Y2hPcHRpb25zfSBvcHRpb25zIC0gVGhlIHJlcXVlc3Qgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBOb3RoaW5nXG4gICAgICovXG4gICAgdXBkYXRlUmVxdWVzdE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25zSGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5mZXRjaE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcuZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcuZmV0Y2hPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnLmZldGNoT3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc0hlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zSGVhZGVycywgdGhpcy5faGVhZGVycyk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnNIZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhc3luY1xuICAgICAqIEFkZHMgdGhlIGN1c3RvbSBoZWFkZXJzIGFuZCBvcHRpb25zIHRvIHRoZSByZXF1ZXN0IGFuZCBtYWtlcyB0aGUgSFRUUENsaWVudCBzZW5kIHJlcXVlc3QgY2FsbFxuICAgICAqIEBwYXJhbSB7UmVxdWVzdEluZm99IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB1cmwgc3RyaW5nIG9yIHRoZSBSZXF1ZXN0IG9iamVjdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7RmV0Y2hPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gbWFrZSBhIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge0dyYXBoUmVxdWVzdENhbGxiYWNrfSBbY2FsbGJhY2tdIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiByZXNwb25zZSB3aXRoIGFzeW5jIGNhbGxcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgY29udGVudFxuICAgICAqL1xuICAgIHNlbmQocmVxdWVzdCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHJhd1Jlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxld2FyZUNvbnRyb2wgPSBuZXcgTWlkZGxld2FyZUNvbnRyb2wodGhpcy5fbWlkZGxld2FyZU9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUhvc3RzID0gKF9hID0gdGhpcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXN0b21Ib3N0cztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHlpZWxkIHRoaXMuaHR0cENsaWVudC5zZW5kUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZXdhcmVDb250cm9sLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21Ib3N0cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByYXdSZXNwb25zZSA9IGNvbnRleHQucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBHcmFwaFJlc3BvbnNlSGFuZGxlci5nZXRSZXNwb25zZShyYXdSZXNwb25zZSwgdGhpcy5fcmVzcG9uc2VUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgR3JhcGhDbGllbnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1c0NvZGU7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSByYXdSZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGdFcnJvciA9IHlpZWxkIEdyYXBoRXJyb3JIYW5kbGVyLmdldEVycm9yKGVycm9yLCBzdGF0dXNDb2RlLCBjYWxsYmFjaywgcmF3UmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHRocm93IGdFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjb250ZW50LXR5cGUgaXMgcHJlc2VudCBpbiB0aGUgX2hlYWRlcnMgcHJvcGVydHkuIElmIG5vdCBwcmVzZW50LCBkZWZhdWx0cyB0aGUgY29udGVudC10eXBlIHRvIGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiBAcGFyYW0gbm9uZVxuICAgICAqIEByZXR1cm5zIG5vdGhpbmdcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJDb250ZW50VHlwZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2hlYWRlcnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlcktleSBvZiBoZWFkZXJLZXlzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyS2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCB0aGUgY29udGVudC10eXBlIHRvIGFwcGxpY2F0aW9uL2pzb24gaW4gY2FzZSB0aGUgY29udGVudC10eXBlIGlzIG5vdCBwcmVzZW50IGluIHRoZSBoZWFkZXJcbiAgICAgICAgdGhpcy5oZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogU2V0cyB0aGUgY3VzdG9tIGhlYWRlciBmb3IgYSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlcktleSAtIEEgaGVhZGVyIGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJWYWx1ZSAtIEEgaGVhZGVyIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGhcbiAgICAgKi9cbiAgICBoZWFkZXIoaGVhZGVyS2V5LCBoZWFkZXJWYWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWFkZXJzW2hlYWRlcktleV0gPSBoZWFkZXJWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBTZXRzIHRoZSBjdXN0b20gaGVhZGVycyBmb3IgYSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtLZXlWYWx1ZVBhaXJPYmplY3RTdHJpbmdOdW1iZXIgfCBIZWFkZXJzSW5pdH0gaGVhZGVycyAtIFRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICAgKiBAcmV0dXJucyBUaGUgc2FtZSBHcmFwaFJlcXVlc3QgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyBjYWxsZWQgd2l0aFxuICAgICAqL1xuICAgIGhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJzW2tleV0gPSBoZWFkZXJzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBTZXRzIHRoZSBvcHRpb24gZm9yIG1ha2luZyBhIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoXG4gICAgICovXG4gICAgb3B0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgbWFraW5nIGEgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBhbnkgfX0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGtleSB2YWx1ZSBwYWlyXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGhcbiAgICAgKi9cbiAgICBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogU2V0cyB0aGUgbWlkZGxld2FyZSBvcHRpb25zIGZvciBhIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge01pZGRsZXdhcmVPcHRpb25zW119IG9wdGlvbnMgLSBUaGUgYXJyYXkgb2YgbWlkZGxld2FyZSBvcHRpb25zXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGhcbiAgICAgKi9cbiAgICBtaWRkbGV3YXJlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX21pZGRsZXdhcmVPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBTZXRzIHRoZSBhcGkgZW5kcG9pbnQgdmVyc2lvbiBmb3IgYSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gLSBUaGUgdmVyc2lvbiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoXG4gICAgICovXG4gICAgdmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudXJsQ29tcG9uZW50cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBTZXRzIHRoZSBhcGkgZW5kcG9pbnQgdmVyc2lvbiBmb3IgYSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtSZXNwb25zZVR5cGV9IHJlc3BvbnNlVHlwZSAtIFRoZSByZXNwb25zZSB0eXBlIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGhcbiAgICAgKi9cbiAgICByZXNwb25zZVR5cGUocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUbyBhZGQgcHJvcGVydGllcyBmb3Igc2VsZWN0IE9EYXRhIFF1ZXJ5IHBhcmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3BlcnRpZXMgLSBUaGUgUHJvcGVydGllcyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoLCBhZnRlciBhZGRpbmcgdGhlIHByb3BlcnRpZXMgZm9yICRzZWxlY3QgcXVlcnlcbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEFjY2VwdHMgLnNlbGVjdChcImRpc3BsYXlOYW1lLGJpcnRoZGF5XCIpXG4gICAgICogICAgIGFuZCAuc2VsZWN0KFtcImRpc3BsYXlOYW1lXCIsIFwiYmlydGhkYXlcIl0pXG4gICAgICogICAgIGFuZCAuc2VsZWN0KFwiZGlzcGxheU5hbWVcIiwgXCJiaXJ0aGRheVwiKVxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5hZGRDc3ZRdWVyeVBhcmFtZXRlcihcIiRzZWxlY3RcIiwgcHJvcGVydGllcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUbyBhZGQgcHJvcGVydGllcyBmb3IgZXhwYW5kIE9EYXRhIFF1ZXJ5IHBhcmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3BlcnRpZXMgLSBUaGUgUHJvcGVydGllcyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoLCBhZnRlciBhZGRpbmcgdGhlIHByb3BlcnRpZXMgZm9yICRleHBhbmQgcXVlcnlcbiAgICAgKi9cbiAgICBleHBhbmQocHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmFkZENzdlF1ZXJ5UGFyYW1ldGVyKFwiJGV4cGFuZFwiLCBwcm9wZXJ0aWVzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIGFkZCBwcm9wZXJ0aWVzIGZvciBvcmRlcmJ5IE9EYXRhIFF1ZXJ5IHBhcmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3BlcnRpZXMgLSBUaGUgUHJvcGVydGllcyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoLCBhZnRlciBhZGRpbmcgdGhlIHByb3BlcnRpZXMgZm9yICRvcmRlcmJ5IHF1ZXJ5XG4gICAgICovXG4gICAgb3JkZXJieShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuYWRkQ3N2UXVlcnlQYXJhbWV0ZXIoXCIkb3JkZXJieVwiLCBwcm9wZXJ0aWVzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIGFkZCBxdWVyeSBzdHJpbmcgZm9yIGZpbHRlciBPRGF0YSBRdWVyeSBwYXJhbS4gVGhlIHJlcXVlc3QgVVJMIGFjY2VwdHMgb25seSBvbmUgJGZpbHRlciBPZGF0YSBRdWVyeSBvcHRpb24gYW5kIGl0cyB2YWx1ZSBpcyBzZXQgdG8gdGhlIG1vc3QgcmVjZW50bHkgcGFzc2VkIGZpbHRlciBxdWVyeSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlclN0ciAtIFRoZSBmaWx0ZXIgcXVlcnkgc3RyaW5nXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGgsIGFmdGVyIGFkZGluZyB0aGUgJGZpbHRlciBxdWVyeVxuICAgICAqL1xuICAgIGZpbHRlcihmaWx0ZXJTdHIpIHtcbiAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXMuJGZpbHRlciA9IGZpbHRlclN0cjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUbyBhZGQgY3JpdGVyaW9uIGZvciBzZWFyY2ggT0RhdGEgUXVlcnkgcGFyYW0uIFRoZSByZXF1ZXN0IFVSTCBhY2NlcHRzIG9ubHkgb25lICRzZWFyY2ggT2RhdGEgUXVlcnkgb3B0aW9uIGFuZCBpdHMgdmFsdWUgaXMgc2V0IHRvIHRoZSBtb3N0IHJlY2VudGx5IHBhc3NlZCBzZWFyY2ggY3JpdGVyaW9uIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoU3RyIC0gVGhlIHNlYXJjaCBjcml0ZXJpb24gc3RyaW5nXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGgsIGFmdGVyIGFkZGluZyB0aGUgJHNlYXJjaCBxdWVyeSBjcml0ZXJpYVxuICAgICAqL1xuICAgIHNlYXJjaChzZWFyY2hTdHIpIHtcbiAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXMuJHNlYXJjaCA9IHNlYXJjaFN0cjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBUbyBhZGQgbnVtYmVyIGZvciB0b3AgT0RhdGEgUXVlcnkgcGFyYW0uIFRoZSByZXF1ZXN0IFVSTCBhY2NlcHRzIG9ubHkgb25lICR0b3AgT2RhdGEgUXVlcnkgb3B0aW9uIGFuZCBpdHMgdmFsdWUgaXMgc2V0IHRvIHRoZSBtb3N0IHJlY2VudGx5IHBhc3NlZCBudW1iZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGgsIGFmdGVyIGFkZGluZyB0aGUgbnVtYmVyIGZvciAkdG9wIHF1ZXJ5XG4gICAgICovXG4gICAgdG9wKG4pIHtcbiAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXMuJHRvcCA9IG47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVG8gYWRkIG51bWJlciBmb3Igc2tpcCBPRGF0YSBRdWVyeSBwYXJhbS4gVGhlIHJlcXVlc3QgVVJMIGFjY2VwdHMgb25seSBvbmUgJHNraXAgT2RhdGEgUXVlcnkgb3B0aW9uIGFuZCBpdHMgdmFsdWUgaXMgc2V0IHRvIHRoZSBtb3N0IHJlY2VudGx5IHBhc3NlZCBudW1iZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBUaGUgbnVtYmVyIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIHNhbWUgR3JhcGhSZXF1ZXN0IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgY2FsbGVkIHdpdGgsIGFmdGVyIGFkZGluZyB0aGUgbnVtYmVyIGZvciB0aGUgJHNraXAgcXVlcnlcbiAgICAgKi9cbiAgICBza2lwKG4pIHtcbiAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXMuJHNraXAgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIGFkZCB0b2tlbiBzdHJpbmcgZm9yIHNraXBUb2tlbiBPRGF0YSBRdWVyeSBwYXJhbS4gVGhlIHJlcXVlc3QgVVJMIGFjY2VwdHMgb25seSBvbmUgJHNraXBUb2tlbiBPZGF0YSBRdWVyeSBvcHRpb24gYW5kIGl0cyB2YWx1ZSBpcyBzZXQgdG8gdGhlIG1vc3QgcmVjZW50bHkgcGFzc2VkIHRva2VuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIFRoZSB0b2tlbiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoLCBhZnRlciBhZGRpbmcgdGhlIHRva2VuIHN0cmluZyBmb3IgJHNraXBUb2tlbiBxdWVyeSBvcHRpb25cbiAgICAgKi9cbiAgICBza2lwVG9rZW4odG9rZW4pIHtcbiAgICAgICAgdGhpcy51cmxDb21wb25lbnRzLm9EYXRhUXVlcnlQYXJhbXMuJHNraXBUb2tlbiA9IHRva2VuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRvIGFkZCBib29sZWFuIGZvciBjb3VudCBPRGF0YSBRdWVyeSBwYXJhbS4gVGhlIFVSTCBhY2NlcHRzIG9ubHkgb25lICRjb3VudCBPZGF0YSBRdWVyeSBvcHRpb24gYW5kIGl0cyB2YWx1ZSBpcyBzZXQgdG8gdGhlIG1vc3QgcmVjZW50bHkgcGFzc2VkIGJvb2xlYW4gdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0NvdW50IC0gVGhlIGNvdW50IGJvb2xlYW5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2FtZSBHcmFwaFJlcXVlc3QgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyBjYWxsZWQgd2l0aCwgYWZ0ZXIgYWRkaW5nIHRoZSBib29sZWFuIHZhbHVlIGZvciB0aGUgJGNvdW50IHF1ZXJ5IG9wdGlvblxuICAgICAqL1xuICAgIGNvdW50KGlzQ291bnQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXJsQ29tcG9uZW50cy5vRGF0YVF1ZXJ5UGFyYW1zLiRjb3VudCA9IGlzQ291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBBcHBlbmRzIHF1ZXJ5IHN0cmluZyB0byB0aGUgdXJsQ29tcG9uZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd8S2V5VmFsdWVQYWlyT2JqZWN0U3RyaW5nTnVtYmVyfSBxdWVyeURpY3Rpb25hcnlPclN0cmluZyAtIFRoZSBxdWVyeSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzYW1lIEdyYXBoUmVxdWVzdCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIGNhbGxlZCB3aXRoLCBhZnRlciBhcHBlbmRpbmcgdGhlIHF1ZXJ5IHN0cmluZyB0byB0aGUgdXJsIGNvbXBvbmVudFxuICAgICAqL1xuICAgIC8qXG4gICAgICogQWNjZXB0cyAucXVlcnkoXCJkaXNwbGF5TmFtZT14eXpcIilcbiAgICAgKiAgICAgYW5kIC5zZWxlY3QoeyBuYW1lOiBcInZhbHVlXCIgfSlcbiAgICAgKi9cbiAgICBxdWVyeShxdWVyeURpY3Rpb25hcnlPclN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5RGljdGlvbmFyeU9yU3RyaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIE1ha2VzIGEgaHR0cCByZXF1ZXN0IHdpdGggR0VUIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7R3JhcGhSZXF1ZXN0Q2FsbGJhY2t9IFtjYWxsYmFja10gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIHJlc3BvbnNlIHdpdGggYXN5bmMgY2FsbFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBnZXQgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBnZXQoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRGdWxsVXJsKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5HRVQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmQodXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogTWFrZXMgYSBodHRwIHJlcXVlc3Qgd2l0aCBQT1NUIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7YW55fSBjb250ZW50IC0gVGhlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge0dyYXBoUmVxdWVzdENhbGxiYWNrfSBbY2FsbGJhY2tdIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiByZXNwb25zZSB3aXRoIGFzeW5jIGNhbGxcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcG9zdCByZXNwb25zZVxuICAgICAqL1xuICAgIHBvc3QoY29udGVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRGdWxsVXJsKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5QT1NULFxuICAgICAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gY29udGVudCAmJiBjb250ZW50LmNvbnN0cnVjdG9yICYmIGNvbnRlbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09IFwiRm9ybURhdGFcIikge1xuICAgICAgICAgICAgICAgIC8vIENvbnRlbnQtVHlwZSBoZWFkZXJzIHNob3VsZCBub3QgYmUgc3BlY2lmaWVkIGluIGNhc2UgdGhlIG9mIEZvcm1EYXRhIHR5cGUgY29udGVudFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJDb250ZW50VHlwZSgpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHRoaXMuX2hlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kKHVybCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIEFsaWFzIGZvciBQb3N0IHJlcXVlc3QgY2FsbFxuICAgICAqIEBwYXJhbSB7YW55fSBjb250ZW50IC0gVGhlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge0dyYXBoUmVxdWVzdENhbGxiYWNrfSBbY2FsbGJhY2tdIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiByZXNwb25zZSB3aXRoIGFzeW5jIGNhbGxcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcG9zdCByZXNwb25zZVxuICAgICAqL1xuICAgIGNyZWF0ZShjb250ZW50LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucG9zdChjb250ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogTWFrZXMgaHR0cCByZXF1ZXN0IHdpdGggUFVUIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7YW55fSBjb250ZW50IC0gVGhlIGNvbnRlbnQgdGhhdCBuZWVkcyB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge0dyYXBoUmVxdWVzdENhbGxiYWNrfSBbY2FsbGJhY2tdIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiByZXNwb25zZSB3aXRoIGFzeW5jIGNhbGxcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcHV0IHJlc3BvbnNlXG4gICAgICovXG4gICAgcHV0KGNvbnRlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkRnVsbFVybCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJDb250ZW50VHlwZSgpO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFJlcXVlc3RNZXRob2QuUFVULFxuICAgICAgICAgICAgICAgIGJvZHk6IHNlcmlhbGl6ZUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuc2VuZCh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBNYWtlcyBodHRwIHJlcXVlc3Qgd2l0aCBQQVRDSCBtZXRob2RcbiAgICAgKiBAcGFyYW0ge2FueX0gY29udGVudCAtIFRoZSBjb250ZW50IHRoYXQgbmVlZHMgdG8gYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtHcmFwaFJlcXVlc3RDYWxsYmFja30gW2NhbGxiYWNrXSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gcmVzcG9uc2Ugd2l0aCBhc3luYyBjYWxsXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBhdGNoIHJlc3BvbnNlXG4gICAgICovXG4gICAgcGF0Y2goY29udGVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRGdWxsVXJsKCk7XG4gICAgICAgICAgICB0aGlzLnNldEhlYWRlckNvbnRlbnRUeXBlKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5QQVRDSCxcbiAgICAgICAgICAgICAgICBib2R5OiBzZXJpYWxpemVDb250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNlbmQodXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogQWxpYXMgZm9yIFBBVENIIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge2FueX0gY29udGVudCAtIFRoZSBjb250ZW50IHRoYXQgbmVlZHMgdG8gYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtHcmFwaFJlcXVlc3RDYWxsYmFja30gW2NhbGxiYWNrXSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gcmVzcG9uc2Ugd2l0aCBhc3luYyBjYWxsXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBhdGNoIHJlc3BvbnNlXG4gICAgICovXG4gICAgdXBkYXRlKGNvbnRlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wYXRjaChjb250ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogTWFrZXMgaHR0cCByZXF1ZXN0IHdpdGggREVMRVRFIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7R3JhcGhSZXF1ZXN0Q2FsbGJhY2t9IFtjYWxsYmFja10gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIHJlc3BvbnNlIHdpdGggYXN5bmMgY2FsbFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZWxldGUgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBkZWxldGUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRGdWxsVXJsKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5ERUxFVEUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuc2VuZCh1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBBbGlhcyBmb3IgZGVsZXRlIHJlcXVlc3QgY2FsbFxuICAgICAqIEBwYXJhbSB7R3JhcGhSZXF1ZXN0Q2FsbGJhY2t9IFtjYWxsYmFja10gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIHJlc3BvbnNlIHdpdGggYXN5bmMgY2FsbFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZWxldGUgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBkZWwoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogTWFrZXMgYSBodHRwIHJlcXVlc3Qgd2l0aCBHRVQgbWV0aG9kIHRvIHJlYWQgcmVzcG9uc2UgYXMgYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtHcmFwaFJlcXVlc3RDYWxsYmFja30gW2NhbGxiYWNrXSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gcmVzcG9uc2Ugd2l0aCBhc3luYyBjYWxsXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGdldFN0cmVhbSByZXNwb25zZVxuICAgICAqL1xuICAgIGdldFN0cmVhbShjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZEZ1bGxVcmwoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kLkdFVCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZShSZXNwb25zZVR5cGUuU1RSRUFNKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNlbmQodXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGFzeW5jXG4gICAgICogTWFrZXMgYSBodHRwIHJlcXVlc3Qgd2l0aCBHRVQgbWV0aG9kIHRvIHJlYWQgcmVzcG9uc2UgYXMgYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHthbnl9IHN0cmVhbSAtIFRoZSBzdHJlYW0gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0dyYXBoUmVxdWVzdENhbGxiYWNrfSBbY2FsbGJhY2tdIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiByZXNwb25zZSB3aXRoIGFzeW5jIGNhbGxcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcHV0U3RyZWFtIHJlc3BvbnNlXG4gICAgICovXG4gICAgcHV0U3RyZWFtKHN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRGdWxsVXJsKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5QVVQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogc3RyZWFtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNlbmQodXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoUmVxdWVzdC5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiBAY2xhc3NcbiAqIENsYXNzIHJlcHJlc2VudGluZyBIVFRQQ2xpZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBIVFRQQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIEhUVFBDbGllbnRcbiAgICAgKiBAcGFyYW0gey4uLk1pZGRsZXdhcmV9IG1pZGRsZXdhcmUgLSBUaGUgZmlyc3QgbWlkZGxld2FyZSBvZiB0aGUgbWlkZGxld2FyZSBjaGFpbiBvciBhIHNlcXVlbmNlIG9mIGFsbCB0aGUgTWlkZGxld2FyZSBoYW5kbGVyc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgaWYgKCFtaWRkbGV3YXJlIHx8ICFtaWRkbGV3YXJlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkludmFsaWRNaWRkbGV3YXJlQ2hhaW5cIjtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBcIlBsZWFzZSBwcm92aWRlIGEgZGVmYXVsdCBtaWRkbGV3YXJlIGNoYWluIG9yIGN1c3RvbSBtaWRkbGV3YXJlIGNoYWluXCI7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogUHJvY2Vzc2VzIHRoZSBtaWRkbGV3YXJlIHBhcmFtZXRlciBwYXNzZWQgdG8gc2V0IHRoaXMubWlkZGxld2FyZSBwcm9wZXJ0eVxuICAgICAqIFRoZSBjYWxsaW5nIGZ1bmN0aW9uIHNob3VsZCB2YWxpZGF0ZSBpZiBtaWRkbGV3YXJlIGlzIG5vdCB1bmRlZmluZWQgb3Igbm90IGVtcHR5LlxuICAgICAqIEBwYXJhbSB7Li4uTWlkZGxld2FyZX0gbWlkZGxld2FyZSAtIFRoZSBtaWRkbGV3YXJlIHBhc3NlZFxuICAgICAqIEByZXR1cm5zIE5vdGhpbmdcbiAgICAgKi9cbiAgICBzZXRNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgaWYgKG1pZGRsZXdhcmUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZU1pZGRsZVdhcmVBcnJheShtaWRkbGV3YXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWlkZGxld2FyZSA9IG1pZGRsZXdhcmVbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBQcm9jZXNzZXMgdGhlIG1pZGRsZXdhcmUgYXJyYXkgdG8gY29uc3RydWN0IHRoZSBjaGFpblxuICAgICAqIGFuZCBzZXRzIHRoaXMubWlkZGxld2FyZSBwcm9wZXJ0eSB0byB0aGUgZmlyc3QgbWlkZGxld2FyZSBoYW5kbGVyIG9mIHRoZSBhcnJheVxuICAgICAqIFRoZSBjYWxsaW5nIGZ1bmN0aW9uIHNob3VsZCB2YWxpZGF0ZSBpZiBtaWRkbGV3YXJlIGlzIG5vdCB1bmRlZmluZWQgb3Igbm90IGVtcHR5XG4gICAgICogQHBhcmFtIHtNaWRkbGV3YXJlW119IG1pZGRsZXdhcmVBcnJheSAtIFRoZSBhcnJheSBvZiBtaWRkbGV3YXJlIGhhbmRsZXJzXG4gICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAqL1xuICAgIHBhcnNlTWlkZGxlV2FyZUFycmF5KG1pZGRsZXdhcmVBcnJheSkge1xuICAgICAgICBtaWRkbGV3YXJlQXJyYXkuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IG1pZGRsZXdhcmVBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXROZXh0KG1pZGRsZXdhcmVBcnJheVtpbmRleCArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZSA9IG1pZGRsZXdhcmVBcnJheVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBhc3luY1xuICAgICAqIFRvIHNlbmQgdGhlIHJlcXVlc3QgdGhyb3VnaCB0aGUgbWlkZGxld2FyZSBjaGFpblxuICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIGEgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBDb250ZXh0XG4gICAgICovXG4gICAgc2VuZFJlcXVlc3QoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LnJlcXVlc3QgPT09IFwic3RyaW5nXCIgJiYgY29udGV4dC5vcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkludmFsaWRSZXF1ZXN0T3B0aW9uc1wiO1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBcIlVuYWJsZSB0byBleGVjdXRlIHRoZSBtaWRkbGV3YXJlLCBQbGVhc2UgcHJvdmlkZSB2YWxpZCBvcHRpb25zIGZvciBhIHJlcXVlc3RcIjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMubWlkZGxld2FyZS5leGVjdXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUVFBDbGllbnQuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBtb2R1bGUgSFRUUENsaWVudEZhY3RvcnlcbiAqL1xuaW1wb3J0IHsgSFRUUENsaWVudCB9IGZyb20gXCIuL0hUVFBDbGllbnRcIjtcbmltcG9ydCB7IEF1dGhlbnRpY2F0aW9uSGFuZGxlciB9IGZyb20gXCIuL21pZGRsZXdhcmUvQXV0aGVudGljYXRpb25IYW5kbGVyXCI7XG5pbXBvcnQgeyBIVFRQTWVzc2FnZUhhbmRsZXIgfSBmcm9tIFwiLi9taWRkbGV3YXJlL0hUVFBNZXNzYWdlSGFuZGxlclwiO1xuaW1wb3J0IHsgUmVkaXJlY3RIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL21pZGRsZXdhcmUvb3B0aW9ucy9SZWRpcmVjdEhhbmRsZXJPcHRpb25zXCI7XG5pbXBvcnQgeyBSZXRyeUhhbmRsZXJPcHRpb25zIH0gZnJvbSBcIi4vbWlkZGxld2FyZS9vcHRpb25zL1JldHJ5SGFuZGxlck9wdGlvbnNcIjtcbmltcG9ydCB7IFJlZGlyZWN0SGFuZGxlciB9IGZyb20gXCIuL21pZGRsZXdhcmUvUmVkaXJlY3RIYW5kbGVyXCI7XG5pbXBvcnQgeyBSZXRyeUhhbmRsZXIgfSBmcm9tIFwiLi9taWRkbGV3YXJlL1JldHJ5SGFuZGxlclwiO1xuaW1wb3J0IHsgVGVsZW1ldHJ5SGFuZGxlciB9IGZyb20gXCIuL21pZGRsZXdhcmUvVGVsZW1ldHJ5SGFuZGxlclwiO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG8gY2hlY2sgd2hldGhlciB0aGUgZW52aXJvbm1lbnQgaXMgbm9kZSBvciBub3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVudmlyb25tZW50IGlzIG5vZGUgb3Igbm90XG4gKi9cbmNvbnN0IGlzTm9kZUVudmlyb25tZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiO1xufTtcbi8qKlxuICogQGNsYXNzXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgSFRUUENsaWVudEZhY3RvcnlcbiAqL1xuZXhwb3J0IGNsYXNzIEhUVFBDbGllbnRGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIENyZWF0ZXMgSFRUUENsaWVudCB3aXRoIGRlZmF1bHQgbWlkZGxld2FyZSBjaGFpblxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25Qcm92aWRlcn0gYXV0aFByb3ZpZGVyIC0gVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgQSBIVFRQQ2xpZW50IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVzZSBhcmUgdGhlIHRoaW5ncyB0aGF0IHdlIG5lZWQgdG8gcmVtZW1iZXIgd2hpbGUgZG9pbmcgbW9kaWZpY2F0aW9ucyBpbiB0aGUgYmVsb3cgZGVmYXVsdCBwaXBlbGluZS5cbiAgICAgKiBcdFx0KiBIVFRQTWVzc2FnZUhhbmRsZXIgc2hvdWxkIGJlIHRoZSBsYXN0IG9uZSBpbiB0aGUgbWlkZGxld2FyZSBwaXBlbGluZSwgYmVjYXVzZSB0aGlzIG1ha2VzIHRoZSBhY3R1YWwgbmV0d29yayBjYWxsIG9mIHRoZSByZXF1ZXN0XG4gICAgICogXHRcdCogVGVsZW1ldHJ5SGFuZGxlciBzaG91bGQgYmUgdGhlIG9uZSBwcmlvciB0byB0aGUgbGFzdCBtaWRkbGV3YXJlIGluIHRoZSBjaGFpbiwgYmVjYXVzZSB0aGlzIGlzIHRoZSBvbmUgd2hpY2ggYWN0dWFsbHkgY29sbGVjdHMgYW5kIGFwcGVuZHMgdGhlIHVzYWdlIGZsYWcgYW5kIHBsYWNpbmcgdGhpcyBoYW5kbGVyIFx0Klx0XHQgIGJlZm9yZSBtYWtpbmcgdGhlIGFjdHVhbCBuZXR3b3JrIGNhbGwgZW5zdXJlcyB0aGF0IHRoZSB1c2FnZSBvZiBhbGwgZmVhdHVyZXMgYXJlIHJlY29yZGVkIGluIHRoZSBmbGFnLlxuICAgICAqIFx0XHQqIFRoZSBiZXN0IHBsYWNlIGZvciBBdXRoZW50aWNhdGlvbkhhbmRsZXIgaXMgaW4gdGhlIHN0YXJ0aW5nIG9mIHRoZSBwaXBlbGluZSwgYmVjYXVzZSBldmVyeSBvdGhlciBoYW5kbGVyIG1pZ2h0IGhhdmUgdG8gd29yayBmb3IgbXVsdGlwbGUgdGltZXMgZm9yIGEgcmVxdWVzdCBidXQgdGhlIGF1dGggdG9rZW4gZm9yXG4gICAgICogXHRcdCAgdGhlbSB3aWxsIHJlbWFpbiBzYW1lLiBGb3IgZXhhbXBsZSwgUmV0cnkgYW5kIFJlZGlyZWN0IGhhbmRsZXJzIG1pZ2h0IGJlIHdvcmtpbmcgbXVsdGlwbGUgdGltZXMgZm9yIGEgcmVxdWVzdCBiYXNlZCBvbiB0aGUgcmVzcG9uc2UgYnV0IHRoZWlyIGF1dGggdG9rZW4gd291bGQgcmVtYWluIHNhbWUuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVdpdGhBdXRoZW50aWNhdGlvblByb3ZpZGVyKGF1dGhQcm92aWRlcikge1xuICAgICAgICBjb25zdCBhdXRoZW50aWNhdGlvbkhhbmRsZXIgPSBuZXcgQXV0aGVudGljYXRpb25IYW5kbGVyKGF1dGhQcm92aWRlcik7XG4gICAgICAgIGNvbnN0IHJldHJ5SGFuZGxlciA9IG5ldyBSZXRyeUhhbmRsZXIobmV3IFJldHJ5SGFuZGxlck9wdGlvbnMoKSk7XG4gICAgICAgIGNvbnN0IHRlbGVtZXRyeUhhbmRsZXIgPSBuZXcgVGVsZW1ldHJ5SGFuZGxlcigpO1xuICAgICAgICBjb25zdCBodHRwTWVzc2FnZUhhbmRsZXIgPSBuZXcgSFRUUE1lc3NhZ2VIYW5kbGVyKCk7XG4gICAgICAgIGF1dGhlbnRpY2F0aW9uSGFuZGxlci5zZXROZXh0KHJldHJ5SGFuZGxlcik7XG4gICAgICAgIGlmIChpc05vZGVFbnZpcm9ubWVudCgpKSB7XG4gICAgICAgICAgICBjb25zdCByZWRpcmVjdEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKG5ldyBSZWRpcmVjdEhhbmRsZXJPcHRpb25zKCkpO1xuICAgICAgICAgICAgcmV0cnlIYW5kbGVyLnNldE5leHQocmVkaXJlY3RIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlZGlyZWN0SGFuZGxlci5zZXROZXh0KHRlbGVtZXRyeUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0cnlIYW5kbGVyLnNldE5leHQodGVsZW1ldHJ5SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGVsZW1ldHJ5SGFuZGxlci5zZXROZXh0KGh0dHBNZXNzYWdlSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBIVFRQQ2xpZW50RmFjdG9yeS5jcmVhdGVXaXRoTWlkZGxld2FyZShhdXRoZW50aWNhdGlvbkhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIENyZWF0ZXMgYSBtaWRkbGV3YXJlIGNoYWluIHdpdGggdGhlIGdpdmVuIG9uZVxuICAgICAqIEBwcm9wZXJ0eSB7Li4uTWlkZGxld2FyZX0gbWlkZGxld2FyZSAtIFRoZSBmaXJzdCBtaWRkbGV3YXJlIG9mIHRoZSBtaWRkbGV3YXJlIGNoYWluIG9yIGEgc2VxdWVuY2Ugb2YgYWxsIHRoZSBNaWRkbGV3YXJlIGhhbmRsZXJzXG4gICAgICogQHJldHVybnMgQSBIVFRQQ2xpZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVdpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgLy8gTWlkZGxld2FyZSBzaG91bGQgbm90IGVtcHR5IG9yIHVuZGVmaW5lZC4gVGhpcyBpcyBjaGVjayBpcyBwcmVzZW50IGluIHRoZSBIVFRQQ2xpZW50IGNvbnN0cnVjdG9yLlxuICAgICAgICByZXR1cm4gbmV3IEhUVFBDbGllbnQoLi4ubWlkZGxld2FyZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRUUENsaWVudEZhY3RvcnkuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBjb25zdGFudFxuICogQGZ1bmN0aW9uXG4gKiBWYWxpZGF0ZXMgYXZhaWxhYmlsaXR5IG9mIFByb21pc2UgYW5kIGZldGNoIGluIGdsb2JhbCBjb250ZXh0XG4gKiBAcmV0dXJucyBUaGUgdHJ1ZSBpbiBjYXNlIHRoZSBQcm9taXNlIGFuZCBmZXRjaCBhdmFpbGFibGUsIG90aGVyd2lzZSB0aHJvd3MgZXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlUG9seUZpbGxpbmcgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBmZXRjaCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkxpYnJhcnkgY2Fubm90IGZ1bmN0aW9uIHdpdGhvdXQgUHJvbWlzZSBhbmQgZmV0Y2guIFNvLCBwbGVhc2UgcHJvdmlkZSBwb2x5ZmlsbCBmb3IgdGhlbS5cIik7XG4gICAgICAgIGVycm9yLm5hbWUgPSBcIlBvbHlGaWxsTm90QXZhaWxhYmxlXCI7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkxpYnJhcnkgY2Fubm90IGZ1bmN0aW9uIHdpdGhvdXQgUHJvbWlzZS4gU28sIHBsZWFzZSBwcm92aWRlIHBvbHlmaWxsIGZvciBpdC5cIik7XG4gICAgICAgIGVycm9yLm5hbWUgPSBcIlBvbHlGaWxsTm90QXZhaWxhYmxlXCI7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJMaWJyYXJ5IGNhbm5vdCBmdW5jdGlvbiB3aXRob3V0IGZldGNoLiBTbywgcGxlYXNlIHByb3ZpZGUgcG9seWZpbGwgZm9yIGl0LlwiKTtcbiAgICAgICAgZXJyb3IubmFtZSA9IFwiUG9seUZpbGxOb3RBdmFpbGFibGVcIjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhbGlkYXRlUG9seUZpbGxpbmcuanMubWFwIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBTZWUgTGljZW5zZSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIEBtb2R1bGUgQ2xpZW50XG4gKi9cbmltcG9ydCB7IEdSQVBIX0FQSV9WRVJTSU9OLCBHUkFQSF9CQVNFX1VSTCB9IGZyb20gXCIuL0NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQ3VzdG9tQXV0aGVudGljYXRpb25Qcm92aWRlciB9IGZyb20gXCIuL0N1c3RvbUF1dGhlbnRpY2F0aW9uUHJvdmlkZXJcIjtcbmltcG9ydCB7IEdyYXBoUmVxdWVzdCB9IGZyb20gXCIuL0dyYXBoUmVxdWVzdFwiO1xuaW1wb3J0IHsgSFRUUENsaWVudCB9IGZyb20gXCIuL0hUVFBDbGllbnRcIjtcbmltcG9ydCB7IEhUVFBDbGllbnRGYWN0b3J5IH0gZnJvbSBcIi4vSFRUUENsaWVudEZhY3RvcnlcIjtcbmltcG9ydCB7IHZhbGlkYXRlUG9seUZpbGxpbmcgfSBmcm9tIFwiLi9WYWxpZGF0ZVBvbHlGaWxsaW5nXCI7XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIFRvIGNyZWF0ZSBhIGNsaWVudCBpbnN0YW5jZSB3aXRoIG9wdGlvbnMgYW5kIGluaXRpYWxpemVzIHRoZSBkZWZhdWx0IG1pZGRsZXdhcmUgY2hhaW5cbiAgICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY2xpZW50IGluc3RhbmNlXG4gICAgICogQHJldHVybnMgVGhlIENsaWVudCBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50T3B0aW9ucyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBpKSkge1xuICAgICAgICAgICAgICAgIGNsaWVudE9wdGlvbnNbaV0gPSBpID09PSBcImF1dGhQcm92aWRlclwiID8gbmV3IEN1c3RvbUF1dGhlbnRpY2F0aW9uUHJvdmlkZXIob3B0aW9uc1tpXSkgOiBvcHRpb25zW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDbGllbnQuaW5pdFdpdGhNaWRkbGV3YXJlKGNsaWVudE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIFRvIGNyZWF0ZSBhIGNsaWVudCBpbnN0YW5jZSB3aXRoIHRoZSBDbGllbnQgT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Q2xpZW50T3B0aW9uc30gY2xpZW50T3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBmb3IgaW5pdGlhbGl6aW5nIHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJucyBUaGUgQ2xpZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgc3RhdGljIGluaXRXaXRoTWlkZGxld2FyZShjbGllbnRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50KGNsaWVudE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2xpZW50XG4gICAgICogQHBhcmFtIHtDbGllbnRPcHRpb25zfSBjbGllbnRPcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gaW5zdGFudGlhdGUgdGhlIGNsaWVudCBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnRPcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBBIG1lbWJlciB3aGljaCBzdG9yZXMgdGhlIENsaWVudCBpbnN0YW5jZSBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIGJhc2VVcmw6IEdSQVBIX0JBU0VfVVJMLFxuICAgICAgICAgICAgZGVidWdMb2dnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRlZmF1bHRWZXJzaW9uOiBHUkFQSF9BUElfVkVSU0lPTixcbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdGVQb2x5RmlsbGluZygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjbGllbnRPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNsaWVudE9wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1trZXldID0gY2xpZW50T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBodHRwQ2xpZW50O1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5hdXRoUHJvdmlkZXIgIT09IHVuZGVmaW5lZCAmJiBjbGllbnRPcHRpb25zLm1pZGRsZXdhcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkFtYmlndWl0eUluSW5pdGlhbGl6YXRpb25cIjtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBcIlVuYWJsZSB0byBDcmVhdGUgQ2xpZW50LCBQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgZm9yIGRlZmF1bHQgbWlkZGxld2FyZSBjaGFpbiBvciBjdXN0b20gbWlkZGxld2FyZSBjaGFpbiBub3QgYm90aFwiO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50T3B0aW9ucy5hdXRoUHJvdmlkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaHR0cENsaWVudCA9IEhUVFBDbGllbnRGYWN0b3J5LmNyZWF0ZVdpdGhBdXRoZW50aWNhdGlvblByb3ZpZGVyKGNsaWVudE9wdGlvbnMuYXV0aFByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnRPcHRpb25zLm1pZGRsZXdhcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaHR0cENsaWVudCA9IG5ldyBIVFRQQ2xpZW50KC4uLltdLmNvbmNhdChjbGllbnRPcHRpb25zLm1pZGRsZXdhcmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gXCJJbnZhbGlkTWlkZGxld2FyZUNoYWluXCI7XG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gXCJVbmFibGUgdG8gQ3JlYXRlIENsaWVudCwgUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIGZvciBkZWZhdWx0IG1pZGRsZXdhcmUgY2hhaW4gb3IgY3VzdG9tIG1pZGRsZXdhcmUgY2hhaW5cIjtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBFbnRyeSBwb2ludCB0byBtYWtlIHJlcXVlc3RzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCBzdHJpbmcgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgZ3JhcGggcmVxdWVzdCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFwaShwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhSZXF1ZXN0KHRoaXMuaHR0cENsaWVudCwgdGhpcy5jb25maWcsIHBhdGgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsaWVudC5qcy5tYXAiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIFNlZSBMaWNlbnNlIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdHJpcGxlLXNsYXNoLXJlZmVyZW5jZVxuLy8vIDxyZWZlcmVuY2UgcGF0aD0gXCIuLy4uL3NoaW1zLmQudHNcIiAvPlxuZXhwb3J0IHsgQmF0Y2hSZXF1ZXN0Q29udGVudCB9IGZyb20gXCIuL2NvbnRlbnQvQmF0Y2hSZXF1ZXN0Q29udGVudFwiO1xuZXhwb3J0IHsgQmF0Y2hSZXNwb25zZUNvbnRlbnQgfSBmcm9tIFwiLi9jb250ZW50L0JhdGNoUmVzcG9uc2VDb250ZW50XCI7XG5leHBvcnQgeyBBdXRoZW50aWNhdGlvbkhhbmRsZXIgfSBmcm9tIFwiLi9taWRkbGV3YXJlL0F1dGhlbnRpY2F0aW9uSGFuZGxlclwiO1xuZXhwb3J0IHsgSFRUUE1lc3NhZ2VIYW5kbGVyIH0gZnJvbSBcIi4vbWlkZGxld2FyZS9IVFRQTWVzc2FnZUhhbmRsZXJcIjtcbmV4cG9ydCB7IFJldHJ5SGFuZGxlciB9IGZyb20gXCIuL21pZGRsZXdhcmUvUmV0cnlIYW5kbGVyXCI7XG5leHBvcnQgeyBSZWRpcmVjdEhhbmRsZXIgfSBmcm9tIFwiLi9taWRkbGV3YXJlL1JlZGlyZWN0SGFuZGxlclwiO1xuZXhwb3J0IHsgVGVsZW1ldHJ5SGFuZGxlciB9IGZyb20gXCIuL21pZGRsZXdhcmUvVGVsZW1ldHJ5SGFuZGxlclwiO1xuZXhwb3J0IHsgTWlkZGxld2FyZUZhY3RvcnkgfSBmcm9tIFwiLi9taWRkbGV3YXJlL01pZGRsZXdhcmVGYWN0b3J5XCI7XG5leHBvcnQgeyBBdXRoZW50aWNhdGlvbkhhbmRsZXJPcHRpb25zIH0gZnJvbSBcIi4vbWlkZGxld2FyZS9vcHRpb25zL0F1dGhlbnRpY2F0aW9uSGFuZGxlck9wdGlvbnNcIjtcbmV4cG9ydCB7IFJldHJ5SGFuZGxlck9wdGlvbnMgfSBmcm9tIFwiLi9taWRkbGV3YXJlL29wdGlvbnMvUmV0cnlIYW5kbGVyT3B0aW9uc1wiO1xuZXhwb3J0IHsgUmVkaXJlY3RIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL21pZGRsZXdhcmUvb3B0aW9ucy9SZWRpcmVjdEhhbmRsZXJPcHRpb25zXCI7XG5leHBvcnQgeyBGZWF0dXJlVXNhZ2VGbGFnLCBUZWxlbWV0cnlIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL21pZGRsZXdhcmUvb3B0aW9ucy9UZWxlbWV0cnlIYW5kbGVyT3B0aW9uc1wiO1xuZXhwb3J0IHsgQ2hhb3NIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCIuL21pZGRsZXdhcmUvb3B0aW9ucy9DaGFvc0hhbmRsZXJPcHRpb25zXCI7XG5leHBvcnQgeyBDaGFvc1N0cmF0ZWd5IH0gZnJvbSBcIi4vbWlkZGxld2FyZS9vcHRpb25zL0NoYW9zU3RyYXRlZ3lcIjtcbmV4cG9ydCB7IENoYW9zSGFuZGxlciB9IGZyb20gXCIuL21pZGRsZXdhcmUvQ2hhb3NIYW5kbGVyXCI7XG5leHBvcnQgeyBMYXJnZUZpbGVVcGxvYWRUYXNrIH0gZnJvbSBcIi4vdGFza3MvTGFyZ2VGaWxlVXBsb2FkVGFza1wiO1xuZXhwb3J0IHsgT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrIH0gZnJvbSBcIi4vdGFza3MvT25lRHJpdmVMYXJnZUZpbGVVcGxvYWRUYXNrXCI7XG5leHBvcnQgeyBnZXRWYWxpZFJhbmdlU2l6ZSB9IGZyb20gXCIuL3Rhc2tzL09uZURyaXZlTGFyZ2VGaWxlVXBsb2FkVGFza1V0aWxcIjtcbmV4cG9ydCB7IFN0cmVhbVVwbG9hZCB9IGZyb20gXCIuL3Rhc2tzL0ZpbGVVcGxvYWRUYXNrL0ZpbGVPYmplY3RDbGFzc2VzL1N0cmVhbVVwbG9hZFwiO1xuZXhwb3J0IHsgRmlsZVVwbG9hZCB9IGZyb20gXCIuL3Rhc2tzL0ZpbGVVcGxvYWRUYXNrL0ZpbGVPYmplY3RDbGFzc2VzL0ZpbGVVcGxvYWRcIjtcbmV4cG9ydCB7IFVwbG9hZFJlc3VsdCB9IGZyb20gXCIuL3Rhc2tzL0ZpbGVVcGxvYWRUYXNrL1VwbG9hZFJlc3VsdFwiO1xuZXhwb3J0IHsgUmFuZ2UgfSBmcm9tIFwiLi90YXNrcy9GaWxlVXBsb2FkVGFzay9SYW5nZVwiO1xuZXhwb3J0IHsgUGFnZUl0ZXJhdG9yIH0gZnJvbSBcIi4vdGFza3MvUGFnZUl0ZXJhdG9yXCI7XG5leHBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9DbGllbnRcIjtcbmV4cG9ydCB7IEN1c3RvbUF1dGhlbnRpY2F0aW9uUHJvdmlkZXIgfSBmcm9tIFwiLi9DdXN0b21BdXRoZW50aWNhdGlvblByb3ZpZGVyXCI7XG5leHBvcnQgeyBHcmFwaEVycm9yIH0gZnJvbSBcIi4vR3JhcGhFcnJvclwiO1xuZXhwb3J0IHsgR3JhcGhDbGllbnRFcnJvciB9IGZyb20gXCIuL0dyYXBoQ2xpZW50RXJyb3JcIjtcbmV4cG9ydCB7IEdyYXBoUmVxdWVzdCB9IGZyb20gXCIuL0dyYXBoUmVxdWVzdFwiO1xuZXhwb3J0IHsgUmVzcG9uc2VUeXBlIH0gZnJvbSBcIi4vUmVzcG9uc2VUeXBlXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8703\n')},8789:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var Buffer = (__webpack_require__(2861).Buffer);\nvar crypto = __webpack_require__(6982);\nvar formatEcdsa = __webpack_require__(2010);\nvar util = __webpack_require__(9023);\n\nvar MSG_INVALID_ALGORITHM = '\"%s\" is not a valid algorithm.\\n  Supported algorithms are:\\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".'\nvar MSG_INVALID_SECRET = 'secret must be a string or buffer';\nvar MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';\nvar MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';\n\nvar supportsKeyObjects = typeof crypto.createPublicKey === 'function';\nif (supportsKeyObjects) {\n  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';\n  MSG_INVALID_SECRET += 'or a KeyObject';\n}\n\nfunction checkIsPublicKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.type !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.asymmetricKeyType !== 'string') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\n  }\n};\n\nfunction checkIsPrivateKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return;\n  }\n\n  if (typeof key === 'object') {\n    return;\n  }\n\n  throw typeError(MSG_INVALID_SIGNER_KEY);\n};\n\nfunction checkIsSecretKey(key) {\n  if (Buffer.isBuffer(key)) {\n    return;\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  if (!supportsKeyObjects) {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key !== 'object') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (key.type !== 'secret') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n\n  if (typeof key.export !== 'function') {\n    throw typeError(MSG_INVALID_SECRET);\n  }\n}\n\nfunction fromBase64(base64) {\n  return base64\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n\nfunction toBase64(base64url) {\n  base64url = base64url.toString();\n\n  var padding = 4 - base64url.length % 4;\n  if (padding !== 4) {\n    for (var i = 0; i < padding; ++i) {\n      base64url += '=';\n    }\n  }\n\n  return base64url\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n}\n\nfunction typeError(template) {\n  var args = [].slice.call(arguments, 1);\n  var errMsg = util.format.bind(util, template).apply(null, args);\n  return new TypeError(errMsg);\n}\n\nfunction bufferOrString(obj) {\n  return Buffer.isBuffer(obj) || typeof obj === 'string';\n}\n\nfunction normalizeInput(thing) {\n  if (!bufferOrString(thing))\n    thing = JSON.stringify(thing);\n  return thing;\n}\n\nfunction createHmacSigner(bits) {\n  return function sign(thing, secret) {\n    checkIsSecretKey(secret);\n    thing = normalizeInput(thing);\n    var hmac = crypto.createHmac('sha' + bits, secret);\n    var sig = (hmac.update(thing), hmac.digest('base64'))\n    return fromBase64(sig);\n  }\n}\n\nvar bufferEqual;\nvar timingSafeEqual = 'timingSafeEqual' in crypto ? function timingSafeEqual(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  return crypto.timingSafeEqual(a, b)\n} : function timingSafeEqual(a, b) {\n  if (!bufferEqual) {\n    bufferEqual = __webpack_require__(1045);\n  }\n\n  return bufferEqual(a, b)\n}\n\nfunction createHmacVerifier(bits) {\n  return function verify(thing, signature, secret) {\n    var computedSig = createHmacSigner(bits)(thing, secret);\n    return timingSafeEqual(Buffer.from(signature), Buffer.from(computedSig));\n  }\n}\n\nfunction createKeySigner(bits) {\n return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing);\n    // Even though we are specifying \"RSA\" here, this works with ECDSA\n    // keys as well.\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));\n    return fromBase64(sig);\n  }\n}\n\nfunction createKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify(publicKey, signature, 'base64');\n  }\n}\n\nfunction createPSSKeySigner(bits) {\n  return function sign(thing, privateKey) {\n    checkIsPrivateKey(privateKey);\n    thing = normalizeInput(thing);\n    var signer = crypto.createSign('RSA-SHA' + bits);\n    var sig = (signer.update(thing), signer.sign({\n      key: privateKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, 'base64'));\n    return fromBase64(sig);\n  }\n}\n\nfunction createPSSKeyVerifier(bits) {\n  return function verify(thing, signature, publicKey) {\n    checkIsPublicKey(publicKey);\n    thing = normalizeInput(thing);\n    signature = toBase64(signature);\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\n    verifier.update(thing);\n    return verifier.verify({\n      key: publicKey,\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n    }, signature, 'base64');\n  }\n}\n\nfunction createECDSASigner(bits) {\n  var inner = createKeySigner(bits);\n  return function sign() {\n    var signature = inner.apply(null, arguments);\n    signature = formatEcdsa.derToJose(signature, 'ES' + bits);\n    return signature;\n  };\n}\n\nfunction createECDSAVerifer(bits) {\n  var inner = createKeyVerifier(bits);\n  return function verify(thing, signature, publicKey) {\n    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');\n    var result = inner(thing, signature, publicKey);\n    return result;\n  };\n}\n\nfunction createNoneSigner() {\n  return function sign() {\n    return '';\n  }\n}\n\nfunction createNoneVerifier() {\n  return function verify(thing, signature) {\n    return signature === '';\n  }\n}\n\nmodule.exports = function jwa(algorithm) {\n  var signerFactories = {\n    hs: createHmacSigner,\n    rs: createKeySigner,\n    ps: createPSSKeySigner,\n    es: createECDSASigner,\n    none: createNoneSigner,\n  }\n  var verifierFactories = {\n    hs: createHmacVerifier,\n    rs: createKeyVerifier,\n    ps: createPSSKeyVerifier,\n    es: createECDSAVerifer,\n    none: createNoneVerifier,\n  }\n  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);\n  if (!match)\n    throw typeError(MSG_INVALID_ALGORITHM, algorithm);\n  var algo = (match[1] || match[3]).toLowerCase();\n  var bits = match[2];\n\n  return {\n    sign: signerFactories[algo](bits),\n    verify: verifierFactories[algo](bits),\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc4OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLGtDQUE2QjtBQUMxQyxhQUFhLG1CQUFPLENBQUMsSUFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyxJQUFxQjtBQUMvQyxXQUFXLG1CQUFPLENBQUMsSUFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsSUFBNEI7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2p3YS9pbmRleC5qcz83OWU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBmb3JtYXRFY2RzYSA9IHJlcXVpcmUoJ2VjZHNhLXNpZy1mb3JtYXR0ZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgTVNHX0lOVkFMSURfQUxHT1JJVEhNID0gJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCBhbGdvcml0aG0uXFxuICBTdXBwb3J0ZWQgYWxnb3JpdGhtcyBhcmU6XFxuICBcIkhTMjU2XCIsIFwiSFMzODRcIiwgXCJIUzUxMlwiLCBcIlJTMjU2XCIsIFwiUlMzODRcIiwgXCJSUzUxMlwiLCBcIlBTMjU2XCIsIFwiUFMzODRcIiwgXCJQUzUxMlwiLCBcIkVTMjU2XCIsIFwiRVMzODRcIiwgXCJFUzUxMlwiIGFuZCBcIm5vbmVcIi4nXG52YXIgTVNHX0lOVkFMSURfU0VDUkVUID0gJ3NlY3JldCBtdXN0IGJlIGEgc3RyaW5nIG9yIGJ1ZmZlcic7XG52YXIgTVNHX0lOVkFMSURfVkVSSUZJRVJfS0VZID0gJ2tleSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJztcbnZhciBNU0dfSU5WQUxJRF9TSUdORVJfS0VZID0gJ2tleSBtdXN0IGJlIGEgc3RyaW5nLCBhIGJ1ZmZlciBvciBhbiBvYmplY3QnO1xuXG52YXIgc3VwcG9ydHNLZXlPYmplY3RzID0gdHlwZW9mIGNyeXB0by5jcmVhdGVQdWJsaWNLZXkgPT09ICdmdW5jdGlvbic7XG5pZiAoc3VwcG9ydHNLZXlPYmplY3RzKSB7XG4gIE1TR19JTlZBTElEX1ZFUklGSUVSX0tFWSArPSAnIG9yIGEgS2V5T2JqZWN0JztcbiAgTVNHX0lOVkFMSURfU0VDUkVUICs9ICdvciBhIEtleU9iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQdWJsaWNLZXkoa2V5KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghc3VwcG9ydHNLZXlPYmplY3RzKSB7XG4gICAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1ZFUklGSUVSX0tFWSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfVkVSSUZJRVJfS0VZKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1ZFUklGSUVSX0tFWSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleS5hc3ltbWV0cmljS2V5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfVkVSSUZJRVJfS0VZKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5LmV4cG9ydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IHR5cGVFcnJvcihNU0dfSU5WQUxJRF9WRVJJRklFUl9LRVkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja0lzUHJpdmF0ZUtleShrZXkpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1NJR05FUl9LRVkpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tJc1NlY3JldEtleShrZXkpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIGlmICghc3VwcG9ydHNLZXlPYmplY3RzKSB7XG4gICAgdGhyb3cgdHlwZUVycm9yKE1TR19JTlZBTElEX1NFQ1JFVCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfU0VDUkVUKTtcbiAgfVxuXG4gIGlmIChrZXkudHlwZSAhPT0gJ3NlY3JldCcpIHtcbiAgICB0aHJvdyB0eXBlRXJyb3IoTVNHX0lOVkFMSURfU0VDUkVUKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5LmV4cG9ydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IHR5cGVFcnJvcihNU0dfSU5WQUxJRF9TRUNSRVQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gIHJldHVybiBiYXNlNjRcbiAgICAucmVwbGFjZSgvPS9nLCAnJylcbiAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5cbmZ1bmN0aW9uIHRvQmFzZTY0KGJhc2U2NHVybCkge1xuICBiYXNlNjR1cmwgPSBiYXNlNjR1cmwudG9TdHJpbmcoKTtcblxuICB2YXIgcGFkZGluZyA9IDQgLSBiYXNlNjR1cmwubGVuZ3RoICUgNDtcbiAgaWYgKHBhZGRpbmcgIT09IDQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGRpbmc7ICsraSkge1xuICAgICAgYmFzZTY0dXJsICs9ICc9JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTY0dXJsXG4gICAgLnJlcGxhY2UoL1xcLS9nLCAnKycpXG4gICAgLnJlcGxhY2UoL18vZywgJy8nKTtcbn1cblxuZnVuY3Rpb24gdHlwZUVycm9yKHRlbXBsYXRlKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgZXJyTXNnID0gdXRpbC5mb3JtYXQuYmluZCh1dGlsLCB0ZW1wbGF0ZSkuYXBwbHkobnVsbCwgYXJncyk7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGVyck1zZyk7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlck9yU3RyaW5nKG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0KHRoaW5nKSB7XG4gIGlmICghYnVmZmVyT3JTdHJpbmcodGhpbmcpKVxuICAgIHRoaW5nID0gSlNPTi5zdHJpbmdpZnkodGhpbmcpO1xuICByZXR1cm4gdGhpbmc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhtYWNTaWduZXIoYml0cykge1xuICByZXR1cm4gZnVuY3Rpb24gc2lnbih0aGluZywgc2VjcmV0KSB7XG4gICAgY2hlY2tJc1NlY3JldEtleShzZWNyZXQpO1xuICAgIHRoaW5nID0gbm9ybWFsaXplSW5wdXQodGhpbmcpO1xuICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYScgKyBiaXRzLCBzZWNyZXQpO1xuICAgIHZhciBzaWcgPSAoaG1hYy51cGRhdGUodGhpbmcpLCBobWFjLmRpZ2VzdCgnYmFzZTY0JykpXG4gICAgcmV0dXJuIGZyb21CYXNlNjQoc2lnKTtcbiAgfVxufVxuXG52YXIgYnVmZmVyRXF1YWw7XG52YXIgdGltaW5nU2FmZUVxdWFsID0gJ3RpbWluZ1NhZmVFcXVhbCcgaW4gY3J5cHRvID8gZnVuY3Rpb24gdGltaW5nU2FmZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by50aW1pbmdTYWZlRXF1YWwoYSwgYilcbn0gOiBmdW5jdGlvbiB0aW1pbmdTYWZlRXF1YWwoYSwgYikge1xuICBpZiAoIWJ1ZmZlckVxdWFsKSB7XG4gICAgYnVmZmVyRXF1YWwgPSByZXF1aXJlKCdidWZmZXItZXF1YWwtY29uc3RhbnQtdGltZScpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckVxdWFsKGEsIGIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhtYWNWZXJpZmllcihiaXRzKSB7XG4gIHJldHVybiBmdW5jdGlvbiB2ZXJpZnkodGhpbmcsIHNpZ25hdHVyZSwgc2VjcmV0KSB7XG4gICAgdmFyIGNvbXB1dGVkU2lnID0gY3JlYXRlSG1hY1NpZ25lcihiaXRzKSh0aGluZywgc2VjcmV0KTtcbiAgICByZXR1cm4gdGltaW5nU2FmZUVxdWFsKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSksIEJ1ZmZlci5mcm9tKGNvbXB1dGVkU2lnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5U2lnbmVyKGJpdHMpIHtcbiByZXR1cm4gZnVuY3Rpb24gc2lnbih0aGluZywgcHJpdmF0ZUtleSkge1xuICAgIGNoZWNrSXNQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgIHRoaW5nID0gbm9ybWFsaXplSW5wdXQodGhpbmcpO1xuICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGFyZSBzcGVjaWZ5aW5nIFwiUlNBXCIgaGVyZSwgdGhpcyB3b3JrcyB3aXRoIEVDRFNBXG4gICAgLy8ga2V5cyBhcyB3ZWxsLlxuICAgIHZhciBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbignUlNBLVNIQScgKyBiaXRzKTtcbiAgICB2YXIgc2lnID0gKHNpZ25lci51cGRhdGUodGhpbmcpLCBzaWduZXIuc2lnbihwcml2YXRlS2V5LCAnYmFzZTY0JykpO1xuICAgIHJldHVybiBmcm9tQmFzZTY0KHNpZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VmVyaWZpZXIoYml0cykge1xuICByZXR1cm4gZnVuY3Rpb24gdmVyaWZ5KHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIGNoZWNrSXNQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB0aGluZyA9IG5vcm1hbGl6ZUlucHV0KHRoaW5nKTtcbiAgICBzaWduYXR1cmUgPSB0b0Jhc2U2NChzaWduYXR1cmUpO1xuICAgIHZhciB2ZXJpZmllciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ1JTQS1TSEEnICsgYml0cyk7XG4gICAgdmVyaWZpZXIudXBkYXRlKHRoaW5nKTtcbiAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHB1YmxpY0tleSwgc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUFNTS2V5U2lnbmVyKGJpdHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNpZ24odGhpbmcsIHByaXZhdGVLZXkpIHtcbiAgICBjaGVja0lzUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICB0aGluZyA9IG5vcm1hbGl6ZUlucHV0KHRoaW5nKTtcbiAgICB2YXIgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24oJ1JTQS1TSEEnICsgYml0cyk7XG4gICAgdmFyIHNpZyA9IChzaWduZXIudXBkYXRlKHRoaW5nKSwgc2lnbmVyLnNpZ24oe1xuICAgICAga2V5OiBwcml2YXRlS2V5LFxuICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkcsXG4gICAgICBzYWx0TGVuZ3RoOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QU1NfU0FMVExFTl9ESUdFU1RcbiAgICB9LCAnYmFzZTY0JykpO1xuICAgIHJldHVybiBmcm9tQmFzZTY0KHNpZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUFNTS2V5VmVyaWZpZXIoYml0cykge1xuICByZXR1cm4gZnVuY3Rpb24gdmVyaWZ5KHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIGNoZWNrSXNQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB0aGluZyA9IG5vcm1hbGl6ZUlucHV0KHRoaW5nKTtcbiAgICBzaWduYXR1cmUgPSB0b0Jhc2U2NChzaWduYXR1cmUpO1xuICAgIHZhciB2ZXJpZmllciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoJ1JTQS1TSEEnICsgYml0cyk7XG4gICAgdmVyaWZpZXIudXBkYXRlKHRoaW5nKTtcbiAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHtcbiAgICAgIGtleTogcHVibGljS2V5LFxuICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkcsXG4gICAgICBzYWx0TGVuZ3RoOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QU1NfU0FMVExFTl9ESUdFU1RcbiAgICB9LCBzaWduYXR1cmUsICdiYXNlNjQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFQ0RTQVNpZ25lcihiaXRzKSB7XG4gIHZhciBpbm5lciA9IGNyZWF0ZUtleVNpZ25lcihiaXRzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IGlubmVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgc2lnbmF0dXJlID0gZm9ybWF0RWNkc2EuZGVyVG9Kb3NlKHNpZ25hdHVyZSwgJ0VTJyArIGJpdHMpO1xuICAgIHJldHVybiBzaWduYXR1cmU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVDRFNBVmVyaWZlcihiaXRzKSB7XG4gIHZhciBpbm5lciA9IGNyZWF0ZUtleVZlcmlmaWVyKGJpdHMpO1xuICByZXR1cm4gZnVuY3Rpb24gdmVyaWZ5KHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIHNpZ25hdHVyZSA9IGZvcm1hdEVjZHNhLmpvc2VUb0RlcihzaWduYXR1cmUsICdFUycgKyBiaXRzKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgdmFyIHJlc3VsdCA9IGlubmVyKHRoaW5nLCBzaWduYXR1cmUsIHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9uZVNpZ25lcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vbmVWZXJpZmllcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHZlcmlmeSh0aGluZywgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZSA9PT0gJyc7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBqd2EoYWxnb3JpdGhtKSB7XG4gIHZhciBzaWduZXJGYWN0b3JpZXMgPSB7XG4gICAgaHM6IGNyZWF0ZUhtYWNTaWduZXIsXG4gICAgcnM6IGNyZWF0ZUtleVNpZ25lcixcbiAgICBwczogY3JlYXRlUFNTS2V5U2lnbmVyLFxuICAgIGVzOiBjcmVhdGVFQ0RTQVNpZ25lcixcbiAgICBub25lOiBjcmVhdGVOb25lU2lnbmVyLFxuICB9XG4gIHZhciB2ZXJpZmllckZhY3RvcmllcyA9IHtcbiAgICBoczogY3JlYXRlSG1hY1ZlcmlmaWVyLFxuICAgIHJzOiBjcmVhdGVLZXlWZXJpZmllcixcbiAgICBwczogY3JlYXRlUFNTS2V5VmVyaWZpZXIsXG4gICAgZXM6IGNyZWF0ZUVDRFNBVmVyaWZlcixcbiAgICBub25lOiBjcmVhdGVOb25lVmVyaWZpZXIsXG4gIH1cbiAgdmFyIG1hdGNoID0gYWxnb3JpdGhtLm1hdGNoKC9eKFJTfFBTfEVTfEhTKSgyNTZ8Mzg0fDUxMikkfF4obm9uZSkkL2kpO1xuICBpZiAoIW1hdGNoKVxuICAgIHRocm93IHR5cGVFcnJvcihNU0dfSU5WQUxJRF9BTEdPUklUSE0sIGFsZ29yaXRobSk7XG4gIHZhciBhbGdvID0gKG1hdGNoWzFdIHx8IG1hdGNoWzNdKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYml0cyA9IG1hdGNoWzJdO1xuXG4gIHJldHVybiB7XG4gICAgc2lnbjogc2lnbmVyRmFjdG9yaWVzW2FsZ29dKGJpdHMpLFxuICAgIHZlcmlmeTogdmVyaWZpZXJGYWN0b3JpZXNbYWxnb10oYml0cyksXG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8789\n")},8794:module=>{"use strict";eval("\n\nclass LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc5NC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvbHJ1Y2FjaGUuanM/ZWRkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5tYXggPSAxMDAwXG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwKClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLm1hcC5nZXQoa2V5KVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUga2V5IGZyb20gdGhlIG1hcCBhbmQgYWRkIGl0IHRvIHRoZSBlbmRcbiAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpXG4gICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmRlbGV0ZShrZXkpXG4gIH1cblxuICBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBkZWxldGVkID0gdGhpcy5kZWxldGUoa2V5KVxuXG4gICAgaWYgKCFkZWxldGVkICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIGNhY2hlIGlzIGZ1bGwsIGRlbGV0ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCBpdGVtXG4gICAgICBpZiAodGhpcy5tYXAuc2l6ZSA+PSB0aGlzLm1heCkge1xuICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMubWFwLmtleXMoKS5uZXh0KCkudmFsdWVcbiAgICAgICAgdGhpcy5kZWxldGUoZmlyc3RLZXkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwLnNldChrZXksIHZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8794\n")},8798:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var iterate    = __webpack_require__(8051)\n  , initState  = __webpack_require__(9500)\n  , terminator = __webpack_require__(6276)\n  ;\n\n// Public API\nmodule.exports = parallel;\n\n/**\n * Runs iterator over provided array elements in parallel\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction parallel(list, iterator, callback)\n{\n  var state = initState(list);\n\n  while (state.index < (state['keyedList'] || list).length)\n  {\n    iterate(list, iterator, state, function(error, result)\n    {\n      if (error)\n      {\n        callback(error, result);\n        return;\n      }\n\n      // looks like it's the last one\n      if (Object.keys(state.jobs).length === 0)\n      {\n        callback(null, state.results);\n        return;\n      }\n    });\n\n    state.index++;\n  }\n\n  return terminator.bind(state, callback);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc5OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFrQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFxQjtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9wYXJhbGxlbC5qcz85MTVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpdGVyYXRlICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0ZS5qcycpXG4gICwgaW5pdFN0YXRlICA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLmpzJylcbiAgLCB0ZXJtaW5hdG9yID0gcmVxdWlyZSgnLi9saWIvdGVybWluYXRvci5qcycpXG4gIDtcblxuLy8gUHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBwYXJhbGxlbDtcblxuLyoqXG4gKiBSdW5zIGl0ZXJhdG9yIG92ZXIgcHJvdmlkZWQgYXJyYXkgZWxlbWVudHMgaW4gcGFyYWxsZWxcbiAqXG4gKiBAcGFyYW0gICB7YXJyYXl8b2JqZWN0fSBsaXN0IC0gYXJyYXkgb3Igb2JqZWN0IChuYW1lZCBsaXN0KSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBpdGVyYXRvciB0byBydW5cbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBpbnZva2VkIHdoZW4gYWxsIGVsZW1lbnRzIHByb2Nlc3NlZFxuICogQHJldHVybnMge2Z1bmN0aW9ufSAtIGpvYnMgdGVybWluYXRvclxuICovXG5mdW5jdGlvbiBwYXJhbGxlbChsaXN0LCBpdGVyYXRvciwgY2FsbGJhY2spXG57XG4gIHZhciBzdGF0ZSA9IGluaXRTdGF0ZShsaXN0KTtcblxuICB3aGlsZSAoc3RhdGUuaW5kZXggPCAoc3RhdGVbJ2tleWVkTGlzdCddIHx8IGxpc3QpLmxlbmd0aClcbiAge1xuICAgIGl0ZXJhdGUobGlzdCwgaXRlcmF0b3IsIHN0YXRlLCBmdW5jdGlvbihlcnJvciwgcmVzdWx0KVxuICAgIHtcbiAgICAgIGlmIChlcnJvcilcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbG9va3MgbGlrZSBpdCdzIHRoZSBsYXN0IG9uZVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlLmpvYnMpLmxlbmd0aCA9PT0gMClcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdGUucmVzdWx0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YXRlLmluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gdGVybWluYXRvci5iaW5kKHN0YXRlLCBjYWxsYmFjayk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8798\n")},8928:module=>{eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/**\n * Checks if `value` is an integer.\n *\n * **Note:** This method is based on\n * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n * @example\n *\n * _.isInteger(3);\n * // => true\n *\n * _.isInteger(Number.MIN_VALUE);\n * // => false\n *\n * _.isInteger(Infinity);\n * // => false\n *\n * _.isInteger('3');\n * // => false\n */\nfunction isInteger(value) {\n  return typeof value == 'number' && value == toInteger(value);\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = isInteger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkyOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNpbnRlZ2VyL2luZGV4LmpzPzRkYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNJbnRlZ2VyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW50ZWdlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8928\n")},8948:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*global module, process*/\nvar Buffer = (__webpack_require__(2861).Buffer);\nvar Stream = __webpack_require__(2203);\nvar util = __webpack_require__(9023);\n\nfunction DataStream(data) {\n  this.buffer = null;\n  this.writable = true;\n  this.readable = true;\n\n  // No input\n  if (!data) {\n    this.buffer = Buffer.alloc(0);\n    return this;\n  }\n\n  // Stream\n  if (typeof data.pipe === 'function') {\n    this.buffer = Buffer.alloc(0);\n    data.pipe(this);\n    return this;\n  }\n\n  // Buffer or String\n  // or Object (assumedly a passworded key)\n  if (data.length || typeof data === 'object') {\n    this.buffer = data;\n    this.writable = false;\n    process.nextTick(function () {\n      this.emit('end', data);\n      this.readable = false;\n      this.emit('close');\n    }.bind(this));\n    return this;\n  }\n\n  throw new TypeError('Unexpected data type ('+ typeof data + ')');\n}\nutil.inherits(DataStream, Stream);\n\nDataStream.prototype.write = function write(data) {\n  this.buffer = Buffer.concat([this.buffer, Buffer.from(data)]);\n  this.emit('data', data);\n};\n\nDataStream.prototype.end = function end(data) {\n  if (data)\n    this.write(data);\n  this.emit('end', data);\n  this.emit('close');\n  this.writable = false;\n  this.readable = false;\n};\n\nmodule.exports = DataStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsa0NBQTZCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxJQUFRO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxJQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2p3cy9saWIvZGF0YS1zdHJlYW0uanM/YTFjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MqL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIERhdGFTdHJlYW0oZGF0YSkge1xuICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBObyBpbnB1dFxuICBpZiAoIWRhdGEpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFN0cmVhbVxuICBpZiAodHlwZW9mIGRhdGEucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIGRhdGEucGlwZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEJ1ZmZlciBvciBTdHJpbmdcbiAgLy8gb3IgT2JqZWN0IChhc3N1bWVkbHkgYSBwYXNzd29yZGVkIGtleSlcbiAgaWYgKGRhdGEubGVuZ3RoIHx8IHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuYnVmZmVyID0gZGF0YTtcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVtaXQoJ2VuZCcsIGRhdGEpO1xuICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGRhdGEgdHlwZSAoJysgdHlwZW9mIGRhdGEgKyAnKScpO1xufVxudXRpbC5pbmhlcml0cyhEYXRhU3RyZWFtLCBTdHJlYW0pO1xuXG5EYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKGRhdGEpIHtcbiAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlciwgQnVmZmVyLmZyb20oZGF0YSldKTtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG59O1xuXG5EYXRhU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZGF0YSkge1xuICBpZiAoZGF0YSlcbiAgICB0aGlzLndyaXRlKGRhdGEpO1xuICB0aGlzLmVtaXQoJ2VuZCcsIGRhdGEpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8948\n")},8968:module=>{"use strict";eval("\n\n/** @type {import('./floor')} */\nmodule.exports = Math.floor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk2OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFtQjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9mbG9vci5qcz82NTkxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZmxvb3InKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mbG9vcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8968\n")},8980:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var JsonWebTokenError = __webpack_require__(1741);\n\nvar TokenExpiredError = function (message, expiredAt) {\n  JsonWebTokenError.call(this, message);\n  this.name = 'TokenExpiredError';\n  this.expiredAt = expiredAt;\n};\n\nTokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);\n\nTokenExpiredError.prototype.constructor = TokenExpiredError;\n\nmodule.exports = TokenExpiredError;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk4MC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFxQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2pzb253ZWJ0b2tlbi9saWIvVG9rZW5FeHBpcmVkRXJyb3IuanM/NmU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSnNvbldlYlRva2VuRXJyb3IgPSByZXF1aXJlKCcuL0pzb25XZWJUb2tlbkVycm9yJyk7XG5cbnZhciBUb2tlbkV4cGlyZWRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBleHBpcmVkQXQpIHtcbiAgSnNvbldlYlRva2VuRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgdGhpcy5uYW1lID0gJ1Rva2VuRXhwaXJlZEVycm9yJztcbiAgdGhpcy5leHBpcmVkQXQgPSBleHBpcmVkQXQ7XG59O1xuXG5Ub2tlbkV4cGlyZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEpzb25XZWJUb2tlbkVycm9yLnByb3RvdHlwZSk7XG5cblRva2VuRXhwaXJlZEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRva2VuRXhwaXJlZEVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuRXhwaXJlZEVycm9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8980\n")},9001:module=>{eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) ||\n      objectToString.call(value) != objectTag || isHostObject(value)) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nmodule.exports = isPlainObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAwMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNwbGFpbm9iamVjdC9pbmRleC5qcz9jZDkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxuICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT0gb2JqZWN0VGFnIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9001\n")},9023:n=>{"use strict";n.exports=require("util")},9092:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar hasSymbols = __webpack_require__(1333);\n\n/** @type {import('.')} */\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxJQUFtQjs7QUFFNUMsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcz8wN2E0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9092\n")},9278:n=>{"use strict";n.exports=require("net")},9290:module=>{"use strict";eval("\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI5MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFtQjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9yYW5nZS5qcz9kYzk5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmFuZ2UnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9290\n")},9353:module=>{"use strict";eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM1My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUEsaUZBQWlGLHNDQUFzQzs7QUFFdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzPzY4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG52YXIgY29uY2F0dHkgPSBmdW5jdGlvbiBjb25jYXR0eShhLCBiKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBhcnJbaiArIGEubGVuZ3RoXSA9IGJbal07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBzbGljeSA9IGZ1bmN0aW9uIHNsaWN5KGFyckxpa2UsIG9mZnNldCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0IHx8IDAsIGogPSAwOyBpIDwgYXJyTGlrZS5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICAgIGFycltqXSA9IGFyckxpa2VbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgam9pbnkgPSBmdW5jdGlvbiAoYXJyLCBqb2luZXIpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGFycltpXTtcbiAgICAgICAgaWYgKGkgKyAxIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyICs9IGpvaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5hcHBseSh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWN5KGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgKTtcblxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJnc1tpXSA9ICckJyArIGk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGpvaW55KGJvdW5kQXJncywgJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9353\n")},9383:module=>{"use strict";eval("\n\n/** @type {import('.')} */\nmodule.exports = Error;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM4My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGFBQWE7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvaW5kZXguanM/YTY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9383\n")},9500:module=>{eval("// API\nmodule.exports = state;\n\n/**\n * Creates initial state object\n * for iteration over list\n *\n * @param   {array|object} list - list to iterate over\n * @param   {function|null} sortMethod - function to use for keys sort,\n *                                     or `null` to keep them as is\n * @returns {object} - initial state object\n */\nfunction state(list, sortMethod)\n{\n  var isNamedList = !Array.isArray(list)\n    , initState =\n    {\n      index    : 0,\n      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,\n      jobs     : {},\n      results  : isNamedList ? {} : [],\n      size     : isNamedList ? Object.keys(list).length : list.length\n    }\n    ;\n\n  if (sortMethod)\n  {\n    // sort array keys based on it's values\n    // sort object's keys just on own merit\n    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)\n    {\n      return sortMethod(list[a], list[b]);\n    });\n  }\n\n  return initState;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUwMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi9zdGF0ZS5qcz80MTA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBzdGF0ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGluaXRpYWwgc3RhdGUgb2JqZWN0XG4gKiBmb3IgaXRlcmF0aW9uIG92ZXIgbGlzdFxuICpcbiAqIEBwYXJhbSAgIHthcnJheXxvYmplY3R9IGxpc3QgLSBsaXN0IHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtICAge2Z1bmN0aW9ufG51bGx9IHNvcnRNZXRob2QgLSBmdW5jdGlvbiB0byB1c2UgZm9yIGtleXMgc29ydCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGBudWxsYCB0byBrZWVwIHRoZW0gYXMgaXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gaW5pdGlhbCBzdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc3RhdGUobGlzdCwgc29ydE1ldGhvZClcbntcbiAgdmFyIGlzTmFtZWRMaXN0ID0gIUFycmF5LmlzQXJyYXkobGlzdClcbiAgICAsIGluaXRTdGF0ZSA9XG4gICAge1xuICAgICAgaW5kZXggICAgOiAwLFxuICAgICAga2V5ZWRMaXN0OiBpc05hbWVkTGlzdCB8fCBzb3J0TWV0aG9kID8gT2JqZWN0LmtleXMobGlzdCkgOiBudWxsLFxuICAgICAgam9icyAgICAgOiB7fSxcbiAgICAgIHJlc3VsdHMgIDogaXNOYW1lZExpc3QgPyB7fSA6IFtdLFxuICAgICAgc2l6ZSAgICAgOiBpc05hbWVkTGlzdCA/IE9iamVjdC5rZXlzKGxpc3QpLmxlbmd0aCA6IGxpc3QubGVuZ3RoXG4gICAgfVxuICAgIDtcblxuICBpZiAoc29ydE1ldGhvZClcbiAge1xuICAgIC8vIHNvcnQgYXJyYXkga2V5cyBiYXNlZCBvbiBpdCdzIHZhbHVlc1xuICAgIC8vIHNvcnQgb2JqZWN0J3Mga2V5cyBqdXN0IG9uIG93biBtZXJpdFxuICAgIGluaXRTdGF0ZS5rZXllZExpc3Quc29ydChpc05hbWVkTGlzdCA/IHNvcnRNZXRob2QgOiBmdW5jdGlvbihhLCBiKVxuICAgIHtcbiAgICAgIHJldHVybiBzb3J0TWV0aG9kKGxpc3RbYV0sIGxpc3RbYl0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGluaXRTdGF0ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9500\n")},9538:module=>{"use strict";eval("\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUzOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGlCQUFpQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9yZWYuanM/MTQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlZicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWZlcmVuY2VFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9538\n")},9589:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\n// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(9718)\nconst constants = __webpack_require__(6874)\nconst SemVer = __webpack_require__(3908)\nconst identifiers = __webpack_require__(1123)\nconst parse = __webpack_require__(144)\nconst valid = __webpack_require__(6953)\nconst clean = __webpack_require__(7414)\nconst inc = __webpack_require__(3007)\nconst diff = __webpack_require__(1832)\nconst major = __webpack_require__(2938)\nconst minor = __webpack_require__(6254)\nconst patch = __webpack_require__(4493)\nconst prerelease = __webpack_require__(1729)\nconst compare = __webpack_require__(560)\nconst rcompare = __webpack_require__(9970)\nconst compareLoose = __webpack_require__(1763)\nconst compareBuild = __webpack_require__(909)\nconst sort = __webpack_require__(3927)\nconst rsort = __webpack_require__(4277)\nconst gt = __webpack_require__(5580)\nconst lt = __webpack_require__(7059)\nconst eq = __webpack_require__(4641)\nconst neq = __webpack_require__(3999)\nconst gte = __webpack_require__(4089)\nconst lte = __webpack_require__(5200)\nconst cmp = __webpack_require__(2111)\nconst coerce = __webpack_require__(6170)\nconst Comparator = __webpack_require__(3904)\nconst Range = __webpack_require__(8311)\nconst satisfies = __webpack_require__(7638)\nconst toComparators = __webpack_require__(7631)\nconst maxSatisfying = __webpack_require__(9628)\nconst minSatisfying = __webpack_require__(270)\nconst minVersion = __webpack_require__(1261)\nconst validRange = __webpack_require__(3874)\nconst outside = __webpack_require__(7075)\nconst gtr = __webpack_require__(5571)\nconst ltr = __webpack_require__(5342)\nconst intersects = __webpack_require__(6780)\nconst simplifyRange = __webpack_require__(2525)\nconst subset = __webpack_require__(5032)\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU4OS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLElBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsSUFBc0I7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLElBQWtCO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLElBQXdCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyxHQUFtQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsSUFBbUI7QUFDekMsY0FBYyxtQkFBTyxDQUFDLElBQW1CO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxJQUFpQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsSUFBa0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLElBQW1CO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxJQUFtQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsSUFBbUI7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsSUFBd0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsR0FBcUI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsSUFBc0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsSUFBMkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsR0FBMkI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLElBQWtCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxJQUFtQjtBQUN6QyxXQUFXLG1CQUFPLENBQUMsSUFBZ0I7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLElBQWdCO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxJQUFnQjtBQUNuQyxZQUFZLG1CQUFPLENBQUMsSUFBaUI7QUFDckMsWUFBWSxtQkFBTyxDQUFDLElBQWlCO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxJQUFpQjtBQUNyQyxZQUFZLG1CQUFPLENBQUMsSUFBaUI7QUFDckMsZUFBZSxtQkFBTyxDQUFDLElBQW9CO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLElBQXNCO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyxJQUFpQjtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUF1QjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyxJQUF5QjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyxJQUF5QjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyxHQUF5QjtBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyxJQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyxJQUFnQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFrQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsSUFBYztBQUNsQyxZQUFZLG1CQUFPLENBQUMsSUFBYztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyxJQUFxQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyxJQUFtQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsSUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9pbmRleC5qcz9kZGMzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBpZGVudGlmaWVycyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpXG5jb25zdCB2YWxpZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJylcbmNvbnN0IGNsZWFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKVxuY29uc3QgaW5jID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJylcbmNvbnN0IGRpZmYgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJylcbmNvbnN0IG1ham9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKVxuY29uc3QgbWlub3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpXG5jb25zdCBwYXRjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJylcbmNvbnN0IHByZXJlbGVhc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JylcbmNvbnN0IHJzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGNvZXJjZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblZlcnNpb24gPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpXG5jb25zdCB2YWxpZFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKVxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKVxuY29uc3QgZ3RyID0gcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJylcbmNvbnN0IGx0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpXG5jb25zdCBpbnRlcnNlY3RzID0gcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpXG5jb25zdCBzaW1wbGlmeVJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKVxuY29uc3Qgc3Vic2V0ID0gcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0Jylcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZSxcbiAgdmFsaWQsXG4gIGNsZWFuLFxuICBpbmMsXG4gIGRpZmYsXG4gIG1ham9yLFxuICBtaW5vcixcbiAgcGF0Y2gsXG4gIHByZXJlbGVhc2UsXG4gIGNvbXBhcmUsXG4gIHJjb21wYXJlLFxuICBjb21wYXJlTG9vc2UsXG4gIGNvbXBhcmVCdWlsZCxcbiAgc29ydCxcbiAgcnNvcnQsXG4gIGd0LFxuICBsdCxcbiAgZXEsXG4gIG5lcSxcbiAgZ3RlLFxuICBsdGUsXG4gIGNtcCxcbiAgY29lcmNlLFxuICBDb21wYXJhdG9yLFxuICBSYW5nZSxcbiAgc2F0aXNmaWVzLFxuICB0b0NvbXBhcmF0b3JzLFxuICBtYXhTYXRpc2Z5aW5nLFxuICBtaW5TYXRpc2Z5aW5nLFxuICBtaW5WZXJzaW9uLFxuICB2YWxpZFJhbmdlLFxuICBvdXRzaWRlLFxuICBndHIsXG4gIGx0cixcbiAgaW50ZXJzZWN0cyxcbiAgc2ltcGxpZnlSYW5nZSxcbiAgc3Vic2V0LFxuICBTZW1WZXIsXG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogY29uc3RhbnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFJFTEVBU0VfVFlQRVM6IGNvbnN0YW50cy5SRUxFQVNFX1RZUEVTLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMucmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9589\n")},9605:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(453);\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasToStringTag = __webpack_require__(9092)();\nvar hasOwn = __webpack_require__(9957);\nvar $TypeError = __webpack_require__(9675);\n\nvar toStringTag = hasToStringTag ? Symbol.toStringTag : null;\n\n/** @type {import('.')} */\nmodule.exports = function setToStringTag(object, value) {\n\tvar overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;\n\tvar nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;\n\tif (\n\t\t(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')\n\t\t|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')\n\t) {\n\t\tthrow new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');\n\t}\n\tif (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {\n\t\tif ($defineProperty) {\n\t\t\t$defineProperty(object, toStringTag, {\n\t\t\t\tconfigurable: !nonConfigurable,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: value,\n\t\t\t\twritable: false\n\t\t\t});\n\t\t} else {\n\t\t\tobject[toStringTag] = value; // eslint-disable-line no-param-reassign\n\t\t}\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYwNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxHQUFlOztBQUUxQzs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQyxJQUF1QjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsSUFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxJQUFnQjs7QUFFekM7O0FBRUEsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvZXMtc2V0LXRvc3RyaW5ndGFnL2luZGV4LmpzPzk5OWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhc293bicpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xuXG52YXIgdG9TdHJpbmdUYWcgPSBoYXNUb1N0cmluZ1RhZyA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IG51bGw7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldFRvU3RyaW5nVGFnKG9iamVjdCwgdmFsdWUpIHtcblx0dmFyIG92ZXJyaWRlSWZTZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiAhIWFyZ3VtZW50c1syXSAmJiBhcmd1bWVudHNbMl0uZm9yY2U7XG5cdHZhciBub25Db25maWd1cmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiAhIWFyZ3VtZW50c1syXSAmJiBhcmd1bWVudHNbMl0ubm9uQ29uZmlndXJhYmxlO1xuXHRpZiAoXG5cdFx0KHR5cGVvZiBvdmVycmlkZUlmU2V0ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3ZlcnJpZGVJZlNldCAhPT0gJ2Jvb2xlYW4nKVxuXHRcdHx8ICh0eXBlb2Ygbm9uQ29uZmlndXJhYmxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygbm9uQ29uZmlndXJhYmxlICE9PSAnYm9vbGVhbicpXG5cdCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpZiBwcm92aWRlZCwgdGhlIGBvdmVycmlkZUlmU2V0YCBhbmQgYG5vbkNvbmZpZ3VyYWJsZWAgb3B0aW9ucyBtdXN0IGJlIGJvb2xlYW5zJyk7XG5cdH1cblx0aWYgKHRvU3RyaW5nVGFnICYmIChvdmVycmlkZUlmU2V0IHx8ICFoYXNPd24ob2JqZWN0LCB0b1N0cmluZ1RhZykpKSB7XG5cdFx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0JGRlZmluZVByb3BlcnR5KG9iamVjdCwgdG9TdHJpbmdUYWcsIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiAhbm9uQ29uZmlndXJhYmxlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvYmplY3RbdG9TdHJpbmdUYWddID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHR9XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9605\n")},9612:module=>{"use strict";eval("\n\n/** @type {import('.')} */\nmodule.exports = Object;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYxMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGFBQWE7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9lcy1vYmplY3QtYXRvbXMvaW5kZXguanM/YTI4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9612\n")},9628:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst SemVer = __webpack_require__(3908)\nconst Range = __webpack_require__(8311)\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYyOC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBbUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLElBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzPzc3OGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5cbmNvbnN0IG1heFNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtYXggPSBudWxsXG4gIGxldCBtYXhTViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdlxuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heFxufVxubW9kdWxlLmV4cG9ydHMgPSBtYXhTYXRpc2Z5aW5nXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9628\n")},9675:module=>{"use strict";eval("\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY3NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLGtCQUFrQjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy90eXBlLmpzPzBkMjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9675\n")},9718:(module,exports,__webpack_require__)=>{"use strict";eval("\n\nconst {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = __webpack_require__(6874)\nconst debug = __webpack_require__(7272)\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst safeSrc = exports.safeSrc = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  safeSrc[index] = safe\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n// Non-numberic identifiers include numberic identifiers but can be longer.\n// Therefore non-numberic identifiers must go first.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBbUI7QUFDL0QsOEJBQThCLGlCQUFpQixFQUFFLHdCQUF3Qjs7QUFFekU7QUFDQSxtQ0FBbUMsWUFBWSxPQUFPLGtCQUFrQjtBQUN4RSw4QkFBOEIsWUFBWSxPQUFPLGlCQUFpQjs7QUFFbEU7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxDQUFDLE9BQU8sa0JBQWtCLEdBQUcsbUJBQW1CO0FBQ2hELDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQzs7QUFFQSx5Q0FBeUMsd0JBQXdCO0FBQ2pFO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW50cmFwdWxzZWxpdGUvLi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzPzIyYzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfQlVJTERfTEVOR1RILFxuICBNQVhfTEVOR1RILFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fVxuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxuY29uc3QgcmUgPSBleHBvcnRzLnJlID0gW11cbmNvbnN0IHNhZmVSZSA9IGV4cG9ydHMuc2FmZVJlID0gW11cbmNvbnN0IHNyYyA9IGV4cG9ydHMuc3JjID0gW11cbmNvbnN0IHNhZmVTcmMgPSBleHBvcnRzLnNhZmVTcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgTEVUVEVSREFTSE5VTUJFUiA9ICdbYS16QS1aMC05LV0nXG5cbi8vIFJlcGxhY2Ugc29tZSBncmVlZHkgcmVnZXggdG9rZW5zIHRvIHByZXZlbnQgcmVnZXggZG9zIGlzc3Vlcy4gVGhlc2UgcmVnZXggYXJlXG4vLyB1c2VkIGludGVybmFsbHkgdmlhIHRoZSBzYWZlUmUgb2JqZWN0IHNpbmNlIGFsbCBpbnB1dHMgaW4gdGhpcyBsaWJyYXJ5IGdldFxuLy8gbm9ybWFsaXplZCBmaXJzdCB0byB0cmltIGFuZCBjb2xsYXBzZSBhbGwgZXh0cmEgd2hpdGVzcGFjZS4gVGhlIG9yaWdpbmFsXG4vLyByZWdleGVzIGFyZSBleHBvcnRlZCBmb3IgdXNlcmxhbmQgY29uc3VtcHRpb24gYW5kIGxvd2VyIGxldmVsIHVzYWdlLiBBXG4vLyBmdXR1cmUgYnJlYWtpbmcgY2hhbmdlIGNvdWxkIGV4cG9ydCB0aGUgc2FmZXIgcmVnZXggb25seSB3aXRoIGEgbm90ZSB0aGF0XG4vLyBhbGwgaW5wdXQgc2hvdWxkIGhhdmUgZXh0cmEgd2hpdGVzcGFjZSByZW1vdmVkLlxuY29uc3Qgc2FmZVJlZ2V4UmVwbGFjZW1lbnRzID0gW1xuICBbJ1xcXFxzJywgMV0sXG4gIFsnXFxcXGQnLCBNQVhfTEVOR1RIXSxcbiAgW0xFVFRFUkRBU0hOVU1CRVIsIE1BWF9TQUZFX0JVSUxEX0xFTkdUSF0sXG5dXG5cbmNvbnN0IG1ha2VTYWZlUmVnZXggPSAodmFsdWUpID0+IHtcbiAgZm9yIChjb25zdCBbdG9rZW4sIG1heF0gb2Ygc2FmZVJlZ2V4UmVwbGFjZW1lbnRzKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgLnNwbGl0KGAke3Rva2VufSpgKS5qb2luKGAke3Rva2VufXswLCR7bWF4fX1gKVxuICAgICAgLnNwbGl0KGAke3Rva2VufStgKS5qb2luKGAke3Rva2VufXsxLCR7bWF4fX1gKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG5jb25zdCBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgY29uc3Qgc2FmZSA9IG1ha2VTYWZlUmVnZXgodmFsdWUpXG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKG5hbWUsIGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICBzYWZlU3JjW2luZGV4XSA9IHNhZmVcbiAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpXG4gIHNhZmVSZVtpbmRleF0gPSBuZXcgUmVnRXhwKHNhZmUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxufVxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVInLCAnMHxbMS05XVxcXFxkKicpXG5jcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVJMT09TRScsICdcXFxcZCsnKVxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignTk9OTlVNRVJJQ0lERU5USUZJRVInLCBgXFxcXGQqW2EtekEtWi1dJHtMRVRURVJEQVNITlVNQkVSfSpgKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG4vLyBOb24tbnVtYmVyaWMgaWRlbnRpZmllcnMgaW5jbHVkZSBudW1iZXJpYyBpZGVudGlmaWVycyBidXQgY2FuIGJlIGxvbmdlci5cbi8vIFRoZXJlZm9yZSBub24tbnVtYmVyaWMgaWRlbnRpZmllcnMgbXVzdCBnbyBmaXJzdC5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgYCg/OiR7c3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdXG59fCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIGAoPzoke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFJywgYCg/Oi0oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKVxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUxPT1NFJywgYCg/Oi0/KCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV1cbn0oPzpcXFxcLiR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRElERU5USUZJRVInLCBgJHtMRVRURVJEQVNITlVNQkVSfStgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFUExBSU4nLCBgJHsnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnfSR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KWAgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2AgK1xuICAgICAgICAgICAgICBgKD86XFxcXC4oXFxcXGR7MSwke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSkpP2ApXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7c3JjW3QuQ09FUkNFUExBSU5dfSg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VGVUxMJywgc3JjW3QuQ09FUkNFUExBSU5dICtcbiAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT9gICtcbiAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuQlVJTERdfSk/YCArXG4gICAgICAgICAgICAgIGAoPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMJywgc3JjW3QuQ09FUkNFXSwgdHJ1ZSlcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVExGVUxMJywgc3JjW3QuQ09FUkNFRlVMTF0sIHRydWUpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5jcmVhdGVUb2tlbignTE9ORVRJTERFJywgJyg/On4+PyknKVxuXG5jcmVhdGVUb2tlbignVElMREVUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FVElMREVdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+J1xuXG5jcmVhdGVUb2tlbignVElMREUnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdUSUxERUxPT1NFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbmNyZWF0ZVRva2VuKCdMT05FQ0FSRVQnLCAnKD86XFxcXF4pJylcblxuY3JlYXRlVG9rZW4oJ0NBUkVUVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORUNBUkVUXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXidcblxuY3JlYXRlVG9rZW4oJ0NBUkVUJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignQ0FSRVRMT09TRScsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUkxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfSkkfF4kYClcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKigke3NyY1t0LkZVTExQTEFJTl19KSR8XiRgKVxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgYChcXFxccyopJHtzcmNbdC5HVExUXVxufVxcXFxzKigke3NyY1t0LkxPT1NFUExBSU5dfXwke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCwgdHJ1ZSlcbmV4cG9ydHMuY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFTE9PU0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5jcmVhdGVUb2tlbignU1RBUicsICcoPHw+KT89P1xcXFxzKlxcXFwqJylcbi8vID49MC4wLjAgaXMgbGlrZSBhIHN0YXJcbmNyZWF0ZVRva2VuKCdHVEUwJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiQnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9718\n")},9896:n=>{"use strict";n.exports=require("fs")},9910:(module,exports,__webpack_require__)=>{eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(6585);\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkxMC5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZixjQUFjO0FBQ2QsZUFBZTtBQUNmLDRDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSxhQUFhO0FBQ2YsRUFBRSxhQUFhOztBQUVmO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcz85NmZlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9910\n")},9957:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = __webpack_require__(6743);\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLElBQWU7O0FBRWxDLFdBQVcsYUFBYTtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VudHJhcHVsc2VsaXRlLy4vbm9kZV9tb2R1bGVzL2hhc293bi9pbmRleC5qcz85NjcxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciAkaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoY2FsbCwgJGhhc093bik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9957\n")},9970:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nconst compare = __webpack_require__(560)\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk3MC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbnRyYXB1bHNlbGl0ZS8uL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzP2EyMWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9970\n")}},__webpack_module_cache__={},leafPrototypes,getProto;function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var c=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](c,c.exports,__webpack_require__),c.exports}__webpack_require__.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(e,{a:e}),e},getProto=Object.getPrototypeOf?n=>Object.getPrototypeOf(n):n=>n.__proto__,__webpack_require__.t=function(n,e){if(1&e&&(n=this(n)),8&e)return n;if("object"==typeof n&&n){if(4&e&&n.__esModule)return n;if(16&e&&"function"==typeof n.then)return n}var c=Object.create(null);__webpack_require__.r(c);var t={};leafPrototypes=leafPrototypes||[null,getProto({}),getProto([]),getProto(getProto)];for(var I=2&e&&n;"object"==typeof I&&!~leafPrototypes.indexOf(I);I=getProto(I))Object.getOwnPropertyNames(I).forEach((e=>t[e]=()=>n[e]));return t.default=()=>n,__webpack_require__.d(c,t),c},__webpack_require__.d=(n,e)=>{for(var c in e)__webpack_require__.o(e,c)&&!__webpack_require__.o(n,c)&&Object.defineProperty(n,c,{enumerable:!0,get:e[c]})},__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(7140)})();