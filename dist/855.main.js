"use strict";exports.id=855,exports.ids=[855],exports.modules={4855:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MicrosoftDocsMCPClient: () => (/* binding */ MicrosoftDocsMCPClient)\n});\n\n;// ./src/mcp/clients/HttpStreamableMCPClient.ts\nclass HttpStreamableMCPClient {\n    constructor(serverConfig, authService) {\n        this.sessionId = null;\n        this.requestId = 1;\n        this.serverConfig = serverConfig;\n        this.authService = authService;\n        this.baseUrl = serverConfig.url || 'https://learn.microsoft.com/api/mcp';\n    }\n    /**\n     * Initialize the MCP client and perform handshake with the server\n     */\n    async initialize() {\n        try {\n            const initRequest = {\n                jsonrpc: '2.0',\n                id: this.getNextId(),\n                method: 'initialize',\n                params: {\n                    protocolVersion: '2024-11-05',\n                    capabilities: {\n                        tools: {},\n                        resources: {},\n                        sampling: {}\n                    },\n                    clientInfo: {\n                        name: 'EntraPulseLite',\n                        version: '1.0.0-beta.3'\n                    }\n                }\n            };\n            console.log('üîå Initializing HTTP Streamable MCP client for:', this.baseUrl);\n            const response = await this.sendRequest(initRequest);\n            if (response.error) {\n                throw new Error(`Initialization failed: ${response.error.message}`);\n            }\n            console.log('‚úÖ HTTP Streamable MCP client initialized successfully');\n        }\n        catch (error) {\n            console.error('‚ùå Failed to initialize HTTP Streamable MCP client:', error);\n            throw error;\n        }\n    }\n    /**\n     * List available tools from the MCP server\n     */\n    async listTools() {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'tools/list',\n            params: {}\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to list tools: ${response.error.message}`);\n        }\n        return response.result?.tools || [];\n    }\n    /**\n     * Call a tool on the MCP server\n     */\n    async callTool(toolName, arguments_) {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'tools/call',\n            params: {\n                name: toolName,\n                arguments: arguments_\n            }\n        };\n        console.log(`üîß HTTP Streamable MCP calling tool \"${toolName}\" with args:`, arguments_);\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Tool call failed: ${response.error.message}`);\n        }\n        console.log(`‚úÖ HTTP Streamable MCP tool \"${toolName}\" completed successfully`);\n        return response.result;\n    }\n    /**\n     * List available resources from the MCP server\n     */\n    async listResources() {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'resources/list',\n            params: {}\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to list resources: ${response.error.message}`);\n        }\n        return response.result?.resources || [];\n    }\n    /**\n     * Get the contents of a specific resource\n     */\n    async readResource(uri) {\n        const request = {\n            jsonrpc: '2.0',\n            id: this.getNextId(),\n            method: 'resources/read',\n            params: {\n                uri\n            }\n        };\n        const response = await this.sendRequest(request);\n        if (response.error) {\n            throw new Error(`Failed to read resource: ${response.error.message}`);\n        }\n        return response.result;\n    }\n    /**\n     * Send HTTP Streamable request to the MCP server\n     */\n    async sendRequest(request) {\n        try {\n            const headers = {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json, text/event-stream',\n                'User-Agent': 'MCP-Client/1.0.0-beta.1'\n            };\n            // Add session ID if we have one\n            if (this.sessionId) {\n                headers['Mcp-Session-Id'] = this.sessionId;\n            }\n            // Add authentication headers if needed\n            if (this.serverConfig.authConfig?.type !== 'none') {\n                try {\n                    const authHeaders = await this.authService.getAuthHeaders('microsoft-docs');\n                    Object.assign(headers, authHeaders);\n                }\n                catch (authError) {\n                    console.warn('Failed to get auth headers for Microsoft Docs MCP:', authError);\n                    // Continue without auth headers as Microsoft Docs MCP may not require authentication\n                }\n            }\n            console.log('üåê Sending HTTP Streamable MCP request:', {\n                url: this.baseUrl,\n                method: request.method,\n                id: request.id,\n                hasSessionId: !!this.sessionId,\n                headers: Object.keys(headers),\n                bodyPreview: JSON.stringify(request).substring(0, 200)\n            });\n            const response = await fetch(this.baseUrl, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify(request)\n            });\n            // Log response details for debugging\n            console.log('üì° Received response:', {\n                status: response.status,\n                statusText: response.statusText,\n                contentType: response.headers.get('Content-Type'),\n                hasSessionId: !!response.headers.get('Mcp-Session-Id')\n            });\n            // Check for session ID in response headers\n            const responseSessionId = response.headers.get('Mcp-Session-Id');\n            if (responseSessionId && !this.sessionId) {\n                this.sessionId = responseSessionId;\n                console.log('üìù Received session ID from server:', responseSessionId);\n            }\n            if (!response.ok) {\n                // For debugging 406 errors, try to get response body\n                let errorDetails = `HTTP ${response.status}: ${response.statusText}`;\n                try {\n                    const errorBody = await response.text();\n                    if (errorBody) {\n                        errorDetails += ` - Response: ${errorBody}`;\n                        console.log('‚ùå Error response body:', errorBody);\n                    }\n                }\n                catch (e) {\n                    console.log('‚ùå Could not read error response body');\n                }\n                throw new Error(errorDetails);\n            }\n            const contentType = response.headers.get('Content-Type') || '';\n            // Handle SSE stream response\n            if (contentType.includes('text/event-stream')) {\n                console.log('üì° Received SSE stream response, parsing...');\n                return await this.parseSSEResponse(response);\n            }\n            // Handle JSON response\n            const data = await response.json();\n            console.log('üì® Received JSON response:', {\n                hasResult: !!data.result,\n                hasError: !!data.error,\n                id: data.id\n            });\n            return data;\n        }\n        catch (error) {\n            console.error('‚ùå HTTP Streamable MCP request failed:', error);\n            throw new Error(`HTTP Streamable MCP request failed: ${error.message}`);\n        }\n    }\n    /**\n     * Parse Server-Sent Events response\n     */\n    async parseSSEResponse(response) {\n        const reader = response.body?.getReader();\n        if (!reader) {\n            throw new Error('No response body for SSE stream');\n        }\n        const decoder = new TextDecoder();\n        let buffer = '';\n        let lastResponse = null;\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || ''; // Keep incomplete line in buffer\n                for (const line of lines) {\n                    if (line.startsWith('data: ')) {\n                        const data = line.slice(6);\n                        if (data === '[DONE]') {\n                            return lastResponse || { jsonrpc: '2.0', id: 0, error: { code: -1, message: 'No response received' } };\n                        }\n                        try {\n                            const jsonData = JSON.parse(data);\n                            if (jsonData.jsonrpc) {\n                                lastResponse = jsonData;\n                            }\n                        }\n                        catch (parseError) {\n                            console.warn('Failed to parse SSE data:', data);\n                        }\n                    }\n                }\n            }\n            return lastResponse || { jsonrpc: '2.0', id: 0, error: { code: -1, message: 'No valid response received' } };\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    /**\n     * Get next request ID\n     */\n    getNextId() {\n        return this.requestId++;\n    }\n    /**\n     * Check if the server is healthy and responding\n     */\n    async healthCheck() {\n        try {\n            await this.listTools();\n            return true;\n        }\n        catch (error) {\n            console.error('HTTP Streamable MCP health check failed:', error);\n            return false;\n        }\n    }\n}\n\n;// ./src/mcp/clients/MicrosoftDocsMCPClient.ts\n\nclass MicrosoftDocsMCPClient {\n    constructor(serverConfig, authService) {\n        this.httpClient = new HttpStreamableMCPClient(serverConfig, authService);\n    }\n    /**\n     * Initialize the MCP client and perform handshake with the server\n     */\n    async initialize() {\n        return this.httpClient.initialize();\n    }\n    /**\n     * List available tools from Microsoft Docs MCP server\n     */\n    async listTools() {\n        return this.httpClient.listTools();\n    }\n    /**\n     * Call a tool on the Microsoft Docs MCP server\n     */\n    async callTool(toolName, arguments_) {\n        return this.httpClient.callTool(toolName, arguments_);\n    }\n    /**\n     * List available resources from Microsoft Docs MCP server\n     */\n    async listResources() {\n        return this.httpClient.listResources();\n    }\n    /**\n     * Get the contents of a specific resource\n     */\n    async readResource(uri) {\n        return this.httpClient.readResource(uri);\n    }\n    /**\n     * Check if the server is healthy and responding\n     */\n    async healthCheck() {\n        return this.httpClient.healthCheck();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9keW5hbWljZW5kcG9pbnRhc3Npc3RhbnQvLi9zcmMvbWNwL2NsaWVudHMvSHR0cFN0cmVhbWFibGVNQ1BDbGllbnQudHM/MDAwOSIsIndlYnBhY2s6Ly9keW5hbWljZW5kcG9pbnRhc3Npc3RhbnQvLi9zcmMvbWNwL2NsaWVudHMvTWljcm9zb2Z0RG9jc01DUENsaWVudC50cz8wMmVjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBIdHRwU3RyZWFtYWJsZU1DUENsaWVudCB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVyQ29uZmlnLCBhdXRoU2VydmljZSkge1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gMTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJDb25maWcgPSBzZXJ2ZXJDb25maWc7XG4gICAgICAgIHRoaXMuYXV0aFNlcnZpY2UgPSBhdXRoU2VydmljZTtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gc2VydmVyQ29uZmlnLnVybCB8fCAnaHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2FwaS9tY3AnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBNQ1AgY2xpZW50IGFuZCBwZXJmb3JtIGhhbmRzaGFrZSB3aXRoIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0TmV4dElkKCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnaW5pdGlhbGl6ZScsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogJzIwMjQtMTEtMDUnLFxuICAgICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGluZzoge31cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50SW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0VudHJhUHVsc2VMaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICcxLjAuMC1iZXRhLjMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflIwgSW5pdGlhbGl6aW5nIEhUVFAgU3RyZWFtYWJsZSBNQ1AgY2xpZW50IGZvcjonLCB0aGlzLmJhc2VVcmwpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KGluaXRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5pdGlhbGl6YXRpb24gZmFpbGVkOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEhUVFAgU3RyZWFtYWJsZSBNQ1AgY2xpZW50IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIEhUVFAgU3RyZWFtYWJsZSBNQ1AgY2xpZW50OicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIHRvb2xzIGZyb20gdGhlIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VG9vbHMoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldE5leHRJZCgpLFxuICAgICAgICAgICAgbWV0aG9kOiAndG9vbHMvbGlzdCcsXG4gICAgICAgICAgICBwYXJhbXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IHRvb2xzOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdD8udG9vbHMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYSB0b29sIG9uIHRoZSBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgY2FsbFRvb2wodG9vbE5hbWUsIGFyZ3VtZW50c18pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0TmV4dElkKCksXG4gICAgICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzX1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UpyBIVFRQIFN0cmVhbWFibGUgTUNQIGNhbGxpbmcgdG9vbCBcIiR7dG9vbE5hbWV9XCIgd2l0aCBhcmdzOmAsIGFyZ3VtZW50c18pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sIGNhbGwgZmFpbGVkOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYOKchSBIVFRQIFN0cmVhbWFibGUgTUNQIHRvb2wgXCIke3Rvb2xOYW1lfVwiIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhdmFpbGFibGUgcmVzb3VyY2VzIGZyb20gdGhlIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UmVzb3VyY2VzKCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogdGhpcy5nZXROZXh0SWQoKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ3Jlc291cmNlcy9saXN0JyxcbiAgICAgICAgICAgIHBhcmFtczoge31cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3QgcmVzb3VyY2VzOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdD8ucmVzb3VyY2VzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbnRlbnRzIG9mIGEgc3BlY2lmaWMgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBhc3luYyByZWFkUmVzb3VyY2UodXJpKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldE5leHRJZCgpLFxuICAgICAgICAgICAgbWV0aG9kOiAncmVzb3VyY2VzL3JlYWQnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgdXJpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkIHJlc291cmNlOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBIVFRQIFN0cmVhbWFibGUgcmVxdWVzdCB0byB0aGUgTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvZXZlbnQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNQ1AtQ2xpZW50LzEuMC4wLWJldGEuMSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBBZGQgc2Vzc2lvbiBJRCBpZiB3ZSBoYXZlIG9uZVxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snTWNwLVNlc3Npb24tSWQnXSA9IHRoaXMuc2Vzc2lvbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXJDb25maWcuYXV0aENvbmZpZz8udHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCB0aGlzLmF1dGhTZXJ2aWNlLmdldEF1dGhIZWFkZXJzKCdtaWNyb3NvZnQtZG9jcycpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIGF1dGhIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGF1dGhFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgYXV0aCBoZWFkZXJzIGZvciBNaWNyb3NvZnQgRG9jcyBNQ1A6JywgYXV0aEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aG91dCBhdXRoIGhlYWRlcnMgYXMgTWljcm9zb2Z0IERvY3MgTUNQIG1heSBub3QgcmVxdWlyZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn4yQIFNlbmRpbmcgSFRUUCBTdHJlYW1hYmxlIE1DUCByZXF1ZXN0OicsIHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuYmFzZVVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0LmlkLFxuICAgICAgICAgICAgICAgIGhhc1Nlc3Npb25JZDogISF0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3Qua2V5cyhoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBib2R5UHJldmlldzogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkuc3Vic3RyaW5nKDAsIDIwMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmJhc2VVcmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIExvZyByZXNwb25zZSBkZXRhaWxzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFJlY2VpdmVkIHJlc3BvbnNlOicsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyksXG4gICAgICAgICAgICAgICAgaGFzU2Vzc2lvbklkOiAhIXJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdNY3AtU2Vzc2lvbi1JZCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBzZXNzaW9uIElEIGluIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlU2Vzc2lvbklkID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ01jcC1TZXNzaW9uLUlkJyk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VTZXNzaW9uSWQgJiYgIXRoaXMuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSByZXNwb25zZVNlc3Npb25JZDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TnSBSZWNlaXZlZCBzZXNzaW9uIElEIGZyb20gc2VydmVyOicsIHJlc3BvbnNlU2Vzc2lvbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZGVidWdnaW5nIDQwNiBlcnJvcnMsIHRyeSB0byBnZXQgcmVzcG9uc2UgYm9keVxuICAgICAgICAgICAgICAgIGxldCBlcnJvckRldGFpbHMgPSBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzICs9IGAgLSBSZXNwb25zZTogJHtlcnJvckJvZHl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgRXJyb3IgcmVzcG9uc2UgYm9keTonLCBlcnJvckJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgQ291bGQgbm90IHJlYWQgZXJyb3IgcmVzcG9uc2UgYm9keScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEZXRhaWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpIHx8ICcnO1xuICAgICAgICAgICAgLy8gSGFuZGxlIFNTRSBzdHJlYW0gcmVzcG9uc2VcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygndGV4dC9ldmVudC1zdHJlYW0nKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFJlY2VpdmVkIFNTRSBzdHJlYW0gcmVzcG9uc2UsIHBhcnNpbmcuLi4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wYXJzZVNTRVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBKU09OIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6ggUmVjZWl2ZWQgSlNPTiByZXNwb25zZTonLCB7XG4gICAgICAgICAgICAgICAgaGFzUmVzdWx0OiAhIWRhdGEucmVzdWx0LFxuICAgICAgICAgICAgICAgIGhhc0Vycm9yOiAhIWRhdGEuZXJyb3IsXG4gICAgICAgICAgICAgICAgaWQ6IGRhdGEuaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgSFRUUCBTdHJlYW1hYmxlIE1DUCByZXF1ZXN0IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgU3RyZWFtYWJsZSBNQ1AgcmVxdWVzdCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBTZXJ2ZXItU2VudCBFdmVudHMgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZVNTRVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IGZvciBTU0Ugc3RyZWFtJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBsZXQgYnVmZmVyID0gJyc7XG4gICAgICAgIGxldCBsYXN0UmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJzsgLy8gS2VlcCBpbmNvbXBsZXRlIGxpbmUgaW4gYnVmZmVyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6ICcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzcG9uc2UgfHwgeyBqc29ucnBjOiAnMi4wJywgaWQ6IDAsIGVycm9yOiB7IGNvZGU6IC0xLCBtZXNzYWdlOiAnTm8gcmVzcG9uc2UgcmVjZWl2ZWQnIH0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uRGF0YS5qc29ucnBjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXNwb25zZSA9IGpzb25EYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgU1NFIGRhdGE6JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3BvbnNlIHx8IHsganNvbnJwYzogJzIuMCcsIGlkOiAwLCBlcnJvcjogeyBjb2RlOiAtMSwgbWVzc2FnZTogJ05vIHZhbGlkIHJlc3BvbnNlIHJlY2VpdmVkJyB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbmV4dCByZXF1ZXN0IElEXG4gICAgICovXG4gICAgZ2V0TmV4dElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SWQrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHNlcnZlciBpcyBoZWFsdGh5IGFuZCByZXNwb25kaW5nXG4gICAgICovXG4gICAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxpc3RUb29scygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdIVFRQIFN0cmVhbWFibGUgTUNQIGhlYWx0aCBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSHR0cFN0cmVhbWFibGVNQ1BDbGllbnQgfSBmcm9tICcuL0h0dHBTdHJlYW1hYmxlTUNQQ2xpZW50JztcbmV4cG9ydCBjbGFzcyBNaWNyb3NvZnREb2NzTUNQQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXJDb25maWcsIGF1dGhTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IG5ldyBIdHRwU3RyZWFtYWJsZU1DUENsaWVudChzZXJ2ZXJDb25maWcsIGF1dGhTZXJ2aWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgTUNQIGNsaWVudCBhbmQgcGVyZm9ybSBoYW5kc2hha2Ugd2l0aCB0aGUgc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIHRvb2xzIGZyb20gTWljcm9zb2Z0IERvY3MgTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RUb29scygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5saXN0VG9vbHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBhIHRvb2wgb24gdGhlIE1pY3Jvc29mdCBEb2NzIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBjYWxsVG9vbCh0b29sTmFtZSwgYXJndW1lbnRzXykge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LmNhbGxUb29sKHRvb2xOYW1lLCBhcmd1bWVudHNfKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhdmFpbGFibGUgcmVzb3VyY2VzIGZyb20gTWljcm9zb2Z0IERvY3MgTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RSZXNvdXJjZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQubGlzdFJlc291cmNlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbnRlbnRzIG9mIGEgc3BlY2lmaWMgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBhc3luYyByZWFkUmVzb3VyY2UodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQucmVhZFJlc291cmNlKHVyaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBzZXJ2ZXIgaXMgaGVhbHRoeSBhbmQgcmVzcG9uZGluZ1xuICAgICAqL1xuICAgIGFzeW5jIGhlYWx0aENoZWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LmhlYWx0aENoZWNrKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4855\n")}};